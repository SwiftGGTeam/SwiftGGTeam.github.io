<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftGG</title>
  
  <subtitle>走心的 Swift 翻译组</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swift.gg/"/>
  <updated>2018-06-25T03:44:11.535Z</updated>
  <id>https://swift.gg/</id>
  
  <author>
    <name>SwiftGG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift中的强制编译时报错</title>
    <link href="https://swift.gg/2018/06/25/forcing-compiler-errors-in-swift/"/>
    <id>https://swift.gg/2018/06/25/forcing-compiler-errors-in-swift/</id>
    <published>2018-06-25T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.535Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Erica Sadun，<a href="https://ericasadun.com/2018/04/18/forcing-compiler-errors-in-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-18<br>译者：<a href="http://wuqiuhao.github.io" target="_blank" rel="noopener">Hale</a>；校对：<a href="undefined">梁杰</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>得益于<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0196-diagnostic-directives.md" target="_blank" rel="noopener">SE-0196</a>，Swift 4.2 将引进 <code>#warning()</code> 和 <code>#error()</code> 两个编译指令。这两个指令允许你在编译期间合并诊断消息和抛出错误。下面这个例子来自已被确定接受的提议并且已经被实施。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#warning(<span class="string">"this is incomplete"</span>)</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> <span class="type">MY_BUILD_CONFIG</span> &amp;&amp; <span class="type">MY_OTHER_BUILD_CONFIG</span></span><br><span class="line">  #error(<span class="string">"MY_BUILD_CONFIG and MY_OTHER_BUILD_CONFIG cannot both be set"</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><code>#error</code>指令的例子使用条件编译标志（用-D选项设置）来检察编译是否产生了配置冲突。</p><p>我(原文作者)已经写了很多关于我不喜欢在Swift中使用蛇形命名法（THINGS_LIKE_THIS）的文章。但不可避免的，开发者们都喜欢使用蛇形命名法则来定义条件编译标志。无论是 <code>MY_BUILD_CONFIG</code>、<code>MY_OTHER_BUILD_CONFIG</code> 还是 <code>DEBUG</code>。虽然这是行业标准，但感觉这和Swift的美学存在冲突。</p><p>我也写过关于如何不显示使用 <code>DEBUG</code> 标志来<a href="https://ericasadun.com/2018/04/15/writing-swift-adventures-in-compiler-mods/" target="_blank" rel="noopener">检测调试条件的提议</a>。这边我附上了提议的链接，你们可以点击查看更多该提议的相关内容。</p><p>言归正传，Swift新近提出的 <code>#error</code> 和 <code>#warning</code> 指令，在当前的实践基础上有了很大进步。它们通常依赖于运行时的反馈而非编译时。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> !<span class="type">DEBUG</span></span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">"This code is incomplete. Please fix before release."</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>这个代码块中的缩进样式是 Swift 默认的，主要是为了避免条件编译块中出现轻微的<a href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming" target="_blank" rel="noopener">Pyramid of doom</a>)(金字塔厄运)。但如果把里面的代码缩进，在这个条件块的周围代码还是纵向增长的，主观上感觉有点丑。为了避免这种情况，一些编码人员采用内联方式，用最少的条件块和更简洁的方法强制编译时（而不是运行时）报错。</p><p>以下是我从 John Estropia 那发现的一个例子（他借鉴于他的同事）。他使用条件编译指令来设置 <code>TODO</code> 或 <code>FIXME</code> 等类型别名，然后在需要的地方使用它们。在 debug 环境时，编译能够通过而在 release 环境下编译就会报错：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span> </span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">typealias</span> <span class="type">TODO</span>&lt;<span class="type">T</span>&gt; = <span class="type">T</span></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Remove this later"</span>) <span class="keyword">as</span> <span class="type">TODO</span></span><br></pre></td></tr></table></figure><p>这个主意很棒。<code>TODO</code> 类型别名将支持 debug 过程中在想要注释的行末尾使用 <code>as TODO</code> ，在 release 编译环境下就会抛出异常。这确保了所有用 <code>TODO</code> 标注的点能够实现编译时反馈。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">error: <span class="type">ManyWays</span>.playground:<span class="number">5</span>:<span class="number">31</span>: error: use of undeclared type '<span class="type">TODO'</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Remove this later"</span>) <span class="keyword">as</span> <span class="type">TODO</span></span><br></pre></td></tr></table></figure><p>虽然不是很美观，但这很有效。它包含了关于代码调用的位置信息和你要发送的信息。如果我正在使用这个方法，我可能会创建一个 <code>todo</code> 方法，而不是直接使用上面的方法。在下面的例子中，我使用驼峰式命名使调用看起来更具有指令性，而不像标准的全局函数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">enum</span> <span class="title">IssueLevel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">    mildImportance,</span><br><span class="line">    moderateImportance,</span><br><span class="line">    highImportance,</span><br><span class="line">    criticalImportance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">ToDo</span><span class="params">(<span class="number">_</span> level: IssueLevel, <span class="number">_</span> string: String)</span></span> &#123;&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供编译错误、描述信息和优先级</span></span><br><span class="line"><span class="type">ToDo</span>(.highImportance, <span class="string">"Remove this later"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: ManyWays.playground:13:1: error: use of unresolved identifier 'ToDo'</span></span><br><span class="line"><span class="comment">// ToDo(.highImportance, "Remove this later")</span></span><br></pre></td></tr></table></figure><p>这种方式最大的好处就是从 debug 环境到 release 环境，只需通过 <code>#if</code> 进行判断。这种做法很诱人，只要确保全局都在需要标注的地方使用，然后在切换到 release 之前解决或移除所有的标注即可。</p><p>目前，Swift 不支持用 <code>#message</code> 指令来执行类似的任务。很多开发者将警告视为错误，他们无法在两者之间进行细微的区分。如果 <code>#warning</code> 被发布了，你就可以使用 <code>#warning</code> 实现类似“fix me”的反馈了。进一步改良的话，<code>#messageOrDie</code> （或者其他叫法，命名真的很难）可以在 debug build 时发送警告消息，在 release build 时报出错误，通过 <code>断言</code> 来判断申明是否发生。</p><p>Dave DeLong 为结构性项目语义提供了另一种方法。他介绍了一个 <code>Fatal</code> 类型为开发中一些比较常见的结果判断例如 <code>noImplemented</code>、<code>unreachable</code> 和 <code>mustOverride</code> 等提供<a href="https://forums.swift.org/t/introducing-namespacing-for-common-swift-error-scenarios/10773" target="_blank" rel="noopener">运行时线索</a>,它没有用“you need to remember to implement this”这样的提示，而是以运行时奔溃的形式，通过上报完整的位置和方法信息来解释。另一个检索被命名为 <code>silenceXcode()</code> 允许你添加你认为永远不会实现的一些方法，如果你使用了它也会报错。</p><p>Swift 仍有很大的空间来扩展这方面的支持。我不介意看到这两种方式都被添加到未来 Swift 的实现中。一种用于编译时（像 <code>#messageOrDie</code> ）另一种用于运行时（像 <code>Fatal</code> 命名空间的静态检索方法）</p><p>你们怎么看待这些？在 Swift 中还有哪些部分是元编程开发过程中（像宏）让你感到困惑的？我很想知道还有哪些已经确定发布的特性能够更好地支持开发。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了Swift4.2即将发布的
    
    </summary>
    
      <category term="iAchieved.it" scheme="https://swift.gg/categories/iAchieved-it/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>重新实现可选类型的隐式解包</title>
    <link href="https://swift.gg/2018/06/19/swift-org-blog-iuo/"/>
    <id>https://swift.gg/2018/06/19/swift-org-blog-iuo/</id>
    <published>2018-06-19T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.535Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mark Lacey，<a href="https://swift.org/blog/iuo/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-26<br>译者：<a href="undefined">灰s</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="undefined"> mmoaay</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>今年早些时候，Swift 编译器实现了一种新的可选类型隐式解包 (IUOs)，在最近的 Swift <a href="https://swift.org/download/#snapshots" target="_blank" rel="noopener">测试版本</a> 中开放使用。它实现了 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md" target="_blank" rel="noopener"> SE-0054 - Abolish ImplicitlyUnwrappedOptional Type</a>。对于 Swift 来说，这是一次重大的改变，消除了类型检测中的一些矛盾，并且阐明了处理这些值的规则，使语义保持一致且易于推理。更多信息可以阅读这条提案的 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md#motivation" target="_blank" rel="noopener">动机</a>。</p><p>主要变化是，当引用一个被声明为隐式解包可选的基础类型 <code>T</code> 时，在诊断信息中会打印 <code>T?</code>，而不是之前的 <code>T!</code>。你可能会遇到源代码兼容性问题，需要修改代码之后才能编译成功。</p><a id="more"></a><h2 id="隐式解包是声明的一部分"><a href="#隐式解包是声明的一部分" class="headerlink" title="隐式解包是声明的一部分"></a>隐式解包是声明的一部分</h2><p><em>可选类型的隐式解包</em> 在编译时会根据需要自动解包。要声明一个可选类型的隐式解包，需要将类型后面的 <code>?</code> 改成 <code>!</code>。  </p><p>在很多人的认知中，隐式解包的可选类型与常规可选类型并不属于同一个类别。在 Swift 3 中，它们也确实不一样：像 <code>var a: Int?</code>  这样的声明，会创建一个拥有 <code>Optional&lt;Int&gt;</code> 类型的 <code>a</code>；像 <code>var b: String!</code>  这样的声明，会创建一个拥有 <code>ImplicitlyUnwrappedOptional&lt;String&gt;</code> 类型的 <code>b</code> 。  </p><p>在 IUOs 的新模型中，你需要将 <code>!</code> 视为 <code>?</code> 的同义词，它只是在声明中添加一个标志让编译器知道被声明的值可以进行隐式解包。  </p><p>换句话说，对于 <code>String!</code> 的理解你可以认为是 “这个值拥有 <code>Optional&lt;String&gt;</code> 类型并且携带了信息说在需要的时候它可以被隐式的解包。”  </p><p>这种思维模型与新的实现相匹配。现在，任何地方你申明了 <code>T!</code> ，编译器都会将它看做 <code>T?</code> 类型，然后在申明的内部表示中添加一个标签使得类型检测器知道当需要的时候可以对它进行隐式解包。  </p><p>这一变化最明显的结果就是对于申明为 <code>T!</code> 的变量，你将看到关于 <code>T?</code> 的诊断而不是 <code>T!</code>。 在诊断中看到 <code>T?</code> 而不是 <code>T!</code> 可能需要一点时间去适应它，但是拥抱这一新的思维模型将会一直帮助你。</p><p><strong>为了便于理解，译者自己做了配图，展示新旧 Swift 的区别：</strong>  </p><p><img src="https://user-images.githubusercontent.com/13807250/40166397-082f067e-59f1-11e8-931a-3d3d0cb892eb.png" alt="old"><br><img src="https://user-images.githubusercontent.com/13807250/40166527-52d1029a-59f1-11e8-94f2-44d9dc1660ce.png" alt="new"></p><h2 id="源代码兼容性"><a href="#源代码兼容性" class="headerlink" title="源代码兼容性"></a>源代码兼容性</h2><h3 id="强制转换为-T"><a href="#强制转换为-T" class="headerlink" title="强制转换为 T!"></a>强制转换为 <code>T!</code></h3><p>按照 SE-0054 提案，<code>as T!</code> 这样的强制转换已经不再被允许。</p><p>在 Swift 4.1 中，这种形式的强制转换会显示一个弃用警告。多数情况下，使用 <code>as T?</code> 来替代 <code>as T!</code> 或者直接移除该强制转换即可编译成功。</p><p>如果这两种方法都不管用，新的实现中也有对应的特殊处理。具体来说，如果遇到 <code>x as T!</code>，编辑器首先会尝试 <code>x as T?</code>。如果失败，编辑器会用 <code>(x as T?)!</code> 来进行强制解包。</p><p>但是，这种形式的强制转换仍然不推荐使用，在将来的 Swift 版本中有可能会移除这种特殊处理。</p><h3 id="在类型中使用"><a href="#在类型中使用" class="headerlink" title="在类型中使用 !"></a>在类型中使用 <code>!</code></h3><p>强制转换为 <code>T!</code> 作为一个特例存在于一个更普遍的问题中：使用 <code>!</code> 作为类型的一部分。  </p><p>可以在下面三个地方使用 <code>!</code> 作为类型中的一部分：</p><pre><code>1. 属性声明2. 方法的参数类型声明3. 方法的返回值类型声明</code></pre><p>在其它地方使用 <code>!</code> 将被标记成一个错误。Swift 4.1 之前的版本就已经实现了这个检测，但是遗漏了一些情况：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn: (<span class="type">Int</span>!) -&gt; <span class="type">Int</span>! = ...   <span class="comment">// error: not a function declaration!</span></span><br></pre></td></tr></table></figure><p>这里 Swift 4.1 显示了弃用警告，但是仍然默认了隐式解包的行为。在近期测试版本的新实现中，编译器会将 <code>!</code> 视为 <code>?</code>，同时在诊断信息中告诉你发生了什么，以及这种用法会被废弃。  </p><p><strong>译者配图：</strong>  </p><p><img src="https://user-images.githubusercontent.com/13807250/40213466-2dd070ba-5a88-11e8-888a-0ca5066f4d36.png" alt="old-2"><br><img src="https://user-images.githubusercontent.com/13807250/40213471-336db9ba-5a88-11e8-9b8e-11287e1bfccd.png" alt="new-2"></p><h3 id="隐式解包可选类型的-map-方法"><a href="#隐式解包可选类型的-map-方法" class="headerlink" title="隐式解包可选类型的 map 方法"></a>隐式解包可选类型的 map 方法</h3><p>以前的代码是这样的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> values: [<span class="type">Any</span>]! = [<span class="type">C</span>()]</span><br><span class="line"><span class="keyword">let</span> transformed = values.<span class="built_in">map</span> &#123; $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">C</span> &#125;</span><br></pre></td></tr></table></figure><p>上面的代码会对 <code>values</code> 强制解包，然后对数组调用 <code>map(_:)</code> 方法。即使你在 <code>ImplicitlyUnwrappedOptional</code> 的扩展中定义了 <code>map(_:)</code> 方法也无法覆盖默认方法，因为它并不会像你想的那样，在 <code>ImplicitlyUnwrappedOptional</code> 中执行方法查找。  </p><p>在新的实现中，因为 <code>!</code> 和 <code>?</code> 是同义词，编译器会尝试使用 <code>Optional&lt;T&gt;</code> 中的 <code>map(_:)</code> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> transformed = values.<span class="built_in">map</span> &#123; $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">C</span> &#125; <span class="comment">// calls Optional.map; $0 has type [Any]</span></span><br></pre></td></tr></table></figure><p>并且显示： <code>warning: cast from &#39;[Any]&#39; to unrelated type &#39;C&#39; always fails</code>。  </p><p>这样从语义上就通过了类型检测，我们不需要对 <code>values</code> 进行强制解包。  </p><p>你可以使用可选链制造一个可选的数组来解决这个问题：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> transformed = values?.<span class="built_in">map</span> &#123; $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">C</span> &#125; <span class="comment">// transformed 的类型是 Optional&lt;[C]&gt;</span></span><br></pre></td></tr></table></figure><p>或者对 <code>values</code> 进行强制解包来得到一个数组：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> transformed = values!.<span class="built_in">map</span> &#123; $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">C</span> &#125; <span class="comment">// transformed has type [C]</span></span><br></pre></td></tr></table></figure><p>注意，大部分情况下你不需要修改代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values: [<span class="type">Int</span>]! = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> transformed = values.<span class="built_in">map</span> &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>它将继续按照老版本的方式工作，因为在这里将表达式看作 <code>Optional</code> 执行 <code>map(_:)</code> 方法无法进行类型检测。取而代之，我们会对 <code>values</code> 进行强制解包，并对返回的数组执行 <code>map(_:)</code> 方法。</p><h3 id="无法推断类型"><a href="#无法推断类型" class="headerlink" title="无法推断类型"></a>无法推断类型</h3><p>因为隐式解包可选不再是一个类型，所以不能被推断成一种类型或者类型的任何部分。</p><p>在下面的例子中，尽管右边的赋值包含一个被声明为隐式解包的值，左边类型推断仅表示这个值（或者返回值）是一个可选类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">Int</span>!</span><br><span class="line"><span class="keyword">let</span> y = x   <span class="comment">// y has type Int?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forcedResult</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>! &#123; ... &#125;</span><br><span class="line"><span class="keyword">let</span> getValue = forcedResult    <span class="comment">// getValue 的类型是 () -&gt; Int?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">id</span>&lt;T&gt;<span class="params">(<span class="number">_</span> value: T)</span></span> -&gt; <span class="type">T</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line"><span class="keyword">let</span> z = id(x)   <span class="comment">// z 的类型是 Int?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span>&lt;T&gt;<span class="params">(<span class="number">_</span> fn: <span class="params">()</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span> &#123; <span class="keyword">return</span> fn() &#125;</span><br><span class="line"><span class="keyword">let</span> w: <span class="type">Int</span> = apply(forcedResult)    <span class="comment">// 报错，因为 apply() 返回的是 Int?</span></span><br></pre></td></tr></table></figure><p>还有一些特殊的实例会遇到这个问题，比如 <code>AnyObject</code> 的查找操作，<code>try?</code> 和 <code>switch</code>。</p><h4 id="AnyObject-的查找操作"><a href="#AnyObject-的查找操作" class="headerlink" title="AnyObject 的查找操作"></a>AnyObject 的查找操作</h4><p><code>AnyObject</code> 的查找结果会被当作一个隐式解包的可选类型。如果你查找一个本身就被声明成隐式解包的属性，那么表达式现在就有两层隐式解包 ( <code>property</code> 被声明为 <code>UILabel!</code>)：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLabel</span><span class="params">(object: AnyObject)</span></span> -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> object.property <span class="comment">// forces both optionals, resulting in a UILabel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if let</code> 和 <code>guard let</code> 仅能解包一层可选属性。  </p><p>在下面的例子中，之前的 Swift 版本在经过 <code>if let</code> 进行一层解包之后，推测出 <code>label</code> 的属性为 <code>UILabel!</code>。在测试版本中 Swift 将推测出 <code>UILabel?</code> ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// label is inferred to be UILabel?</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> label = object.property &#123; </span><br><span class="line">   <span class="comment">// Error due to passing a UILabel? where a UILabel is expected</span></span><br><span class="line">  functionTakingLabel(label)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用一个明确的类型来修复这个问题：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Implicitly unwrap object.property due to explicit type.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> label: <span class="type">UILabel</span> = object.property &#123;</span><br><span class="line">  functionTakingLabel(label) <span class="comment">// okay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="try"><a href="#try" class="headerlink" title="try?"></a><code>try?</code></h4><p>类似的，<code>try?</code> 会添加一层可选性，所以当对一个返回值为隐式可选类型的方法使用 <code>try?</code> 时，你可能会发现现在需要更改代码来显式对两层可选性进行解包。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span>! &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x = <span class="keyword">try</span>? test() &#123;</span><br><span class="line">  <span class="keyword">let</span> y: <span class="type">Int</span> = x    <span class="comment">// error: x is an Int?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x: <span class="type">Int</span> = <span class="keyword">try</span>? test() &#123; <span class="comment">// explicitly typed as Int</span></span><br><span class="line">  <span class="keyword">let</span> y: <span class="type">Int</span> = x    <span class="comment">// okay, x is an Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x = <span class="keyword">try</span>? test(), <span class="keyword">let</span> y = x &#123; <span class="comment">// okay, x is Int?, y is Int</span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a><code>switch</code></h4><p>Swift 4.1 可以编译下面这样的代码，因为它将 <code>output</code> 作为隐式解包对待：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchExample</span><span class="params">(input: String!)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> input &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"okay"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fine"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> output:</span><br><span class="line">    <span class="keyword">return</span> output  <span class="comment">// 隐式解包可选值，返回 String</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，如果用下面这种方法实现这个例子，无法编译成功：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchExample</span><span class="params">(input: String!)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> output = input  <span class="comment">// output is inferred to be String?</span></span><br><span class="line">  <span class="keyword">switch</span> input &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"okay"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fine"</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> output  <span class="comment">// error: value of optional type 'String?' not unwrapped;</span></span><br><span class="line">                   <span class="comment">// did you mean to use '!' or '?'?</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在新的实现中，第一个例子中的 <code>output</code> 将被推断成没有隐式解包的 <code>String?</code> 类型。  </p><p>下面是一种修复方法，对值进行强制解包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> output:</span><br><span class="line">   <span class="keyword">return</span> output!</span><br></pre></td></tr></table></figure><p>另一种修复方法是对 non-nil 和 nil 进行显式的模式匹配：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchExample</span><span class="params">(input: String!)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> input &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"okay"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fine"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> output?: <span class="comment">// non-nil case</span></span><br><span class="line">    <span class="keyword">return</span> output   <span class="comment">// okay; output is a String</span></span><br><span class="line">  <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;empty&gt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用可选类型和隐式解包可选类型重载输入输出参数"><a href="#使用可选类型和隐式解包可选类型重载输入输出参数" class="headerlink" title="使用可选类型和隐式解包可选类型重载输入输出参数"></a>使用可选类型和隐式解包可选类型重载输入输出参数</h3><p>如果在 Swift 4.1 中尝试去重载一个函数并且 in-out 参数是隐式解包可选类型，会显示一个弃用警告</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someKindOfOptional</span><span class="params">(<span class="number">_</span>: <span class="keyword">inout</span> Int?)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Warning in Swift 4.1.  Error in new implementation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someKindOfOptional</span><span class="params">(<span class="number">_</span>: <span class="keyword">inout</span> Int!)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Swift 4.1 中，如果 in-out 参数是可选的，那可以直接传入一个隐式解包可选类型的值，反之亦然。这样就可以删除上面的第二个重载（假设两个函数实现完全一致）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someKindOfOptional</span><span class="params">(<span class="number">_</span>: <span class="keyword">inout</span> Int?)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span>! = <span class="number">1</span></span><br><span class="line">someKindOfOptional(&amp;i)   <span class="comment">// 完全没问题，i 的类型是 Optional&lt;Int&gt;</span></span><br></pre></td></tr></table></figure><p>在之后的新版本中，由于 <code>Int!</code> 与 <code>Int?</code> 是同义词，重载的可选性不再有意义。因此，和上面例子中类似的重载都会报错，并且第二个重载（声明为 <code>Int!</code>）必须被删除。</p><h3 id="ImplicitlyUnwrappedOptional-扩展"><a href="#ImplicitlyUnwrappedOptional-扩展" class="headerlink" title="ImplicitlyUnwrappedOptional 扩展"></a>ImplicitlyUnwrappedOptional 扩展</h3><p>现在 <code>ImplicitlyUnwrappedOptional&lt;T&gt;</code> 只是 <code>Optional&lt;T&gt;</code> 的别名，而且不能直接使用，所以尝试给它创建 <code>extension</code> 会编译失败：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1:11: error: 'ImplicitlyUnwrappedOptional' has been renamed to 'Optional'</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImplicitlyUnwrappedOptional</span> </span>&#123;</span><br></pre></td></tr></table></figure><h3 id="nil-桥接"><a href="#nil-桥接" class="headerlink" title="nil 桥接"></a>nil 桥接</h3><p>对 <code>nil</code> 类型的值进行桥接时不会报运行时错误，而是把 <code>nil</code> 桥接为 <code>NSNull</code> 。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>: <span class="title">NSObject</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iuoElement: <span class="type">C</span>! = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> array: [<span class="type">Any</span>] = [iuoElement <span class="keyword">as</span> <span class="type">Any</span>]</span><br><span class="line"><span class="keyword">let</span> ns = array <span class="keyword">as</span> <span class="type">NSArray</span></span><br><span class="line"><span class="keyword">let</span> element = ns[<span class="number">0</span>] <span class="comment">// Swift 4.1: Fatal error: Attempt to bridge</span></span><br><span class="line">                    <span class="comment">// an implicitly unwrapped optional containing nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = element <span class="keyword">as</span>? <span class="type">NSNull</span>, value == <span class="type">NSNull</span>() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"pass"</span>)     <span class="comment">// 新版本中会执行到这里</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"fail"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>隐式解包的可选类型已经被重新实现，它们不再是 <code>Optional&lt;T&gt;</code> 的特殊形式。因此，类型检测的一致性将会更好，编译器的特殊情况也会更少。删除这些特殊情况会减少处理声明时的错误数量。  </p><p>导入的 Object-C API 可能会返回隐式解包的值。你可能会发现在声明 <code>@IBOutlet</code> 属性（或者任何初始化之前不会使用的值）时使用隐式解包会更加方便。不过总体来说，隐式解包能不用最好别用，改用 <code>if let</code> 和 <code>guard let</code> 来显式解包。如果确定有值，就用 <code>!</code> 来显式强制解包。</p><h3 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h3><p>如果你对这篇文章有疑问或者想法，可以在 Swift 论坛中参与<a href="https://forums.swift.org/t/swift-org-blog-reimplementation-of-implicitly-unwrapped-optionals/12175" target="_blank" rel="noopener">相关讨论</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      重新实现隐式解包的原因，会碰到问题。
    
    </summary>
    
      <category term="swift.org" scheme="https://swift.gg/categories/swift-org/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 中内存释放的并发问题</title>
    <link href="https://swift.gg/2018/06/11/friday-qa-2015-05-29-concurrent-memory-deallocation-in-the-objective-c-runtime/"/>
    <id>https://swift.gg/2018/06/11/friday-qa-2015-05-29-concurrent-memory-deallocation-in-the-objective-c-runtime/</id>
    <published>2018-06-11T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.535Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-05-29-concurrent-memory-deallocation-in-the-objective-c-runtime.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-06-05<br>译者：<a href="https://github.com/YangGao1991" target="_blank" rel="noopener">阳仔</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Objective-C Runtime 是绝大多数 Mac 和 iOS 程序代码的核心。Runtime 的核心就是 <code>objc_msgSend</code> 函数，这个函数最关键的就是方法缓存。我在这篇文章中将会阐述一下，Apple 是如何在不影响性能的情况下，以线程安全的方式来重新分配缓存大小、释放方法缓存。</p><a id="more"></a><h3 id="消息传递的概念"><a href="#消息传递的概念" class="headerlink" title="消息传递的概念"></a>消息传递的概念</h3><p><code>objc_msgSend</code> 会查找被调用的方法的实现，然后去执行。从概念上讲，查找方法的过程如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IMP lookUp(id obj, SEL selector) &#123;</span><br><span class="line">    Class c = object_getClass(obj);</span><br><span class="line"></span><br><span class="line">    while(c) &#123;</span><br><span class="line">        for(int i = 0; i &lt; c-&gt;numMethods; i++) &#123;</span><br><span class="line">            Method m = c-&gt;methods[i];</span><br><span class="line">            if(m.selector == selector) &#123;</span><br><span class="line">                return m.imp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c = c-&gt;superclass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _objc_msgForward;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到源码的版权，一些变量名做了修改。如果你想看看真实的实现代码，可以查看 Objective-C runtime 的<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">开源代码</a>。</p><h3 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h3><p>绝大部分 Objective-C 的代码都用到了消息传递。如果每一次消息传递都需要进行一次完整查找的话，速度将会非常慢。</p><p>解决方法是建立方法的缓存。每个类持有一个哈希表，将方法名映射到方法的实现。这个哈希表需要尽可能地提高读取效率，<code>objc_msgSend</code> 函数使用精心构造的汇编代码来快速实现这个哈希表的查询。这样，在有缓存的情况下，一条消息的传递只需要几纳秒的时间。虽然每条消息第一次被传递的时候还是很慢，但这之后，就会变得很快。</p><p>我们所说的“缓存”，通常来说是指为了加快多次访问最近使用过的资源的速度，而开辟的一块有限大小的区域。例如，你可能会把从网络上下载的图片缓存起来，那么接下来的一段时间，如果再需要使用到这些图片的话，就不需要再去从网络下载了。尽管如此，你也不会希望缓存占用太多的内存空间。所以你可能会限制缓存图片的最大数量。当缓存的图片达到最大数量后，每次缓存新的图片，就会把最旧的那个从缓存中去掉。</p><p>这对于大部分问题来说是一个不错的做法，但它也可能导致性能上的损耗。比如，你设定图片缓存最多缓存 40 张图片，但在某种情况下，你的应用需要一直循环使用 41 张图片，这时你会发现缓存完全不起作用！</p><p>对于我们自己的应用，可以通过测试，调整缓存的大小来避免出现这种情况，但 Objective-C 的 runtime 并不能这样做。方法缓存对性能来说非常重要，并且每个方法的缓存占用的空间都很小，因此，runtime 并不会对缓存空间的大小进行限制，而是会在需要时随时扩大缓存空间，来缓存所有发送过的消息。</p><p>请注意，runtime 的方法缓存有时确实是会刷新的。比如当将新的代码加载到进程时，或者修改了一个类的方法列表时，可能会导致某些缓存的数据失效。这时，相应的旧的缓存数据就会被删除，并重新写入新的缓存数据。</p><h3 id="改变缓存大小，销毁，以及线程问题"><a href="#改变缓存大小，销毁，以及线程问题" class="headerlink" title="改变缓存大小，销毁，以及线程问题"></a>改变缓存大小，销毁，以及线程问题</h3><p>改变缓存大小，从概念上来说比较简单，比如这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *newCache = <span class="built_in">malloc</span>(newSize);</span><br><span class="line">copyEntries(newCache, class-&gt;cache);</span><br><span class="line"><span class="built_in">free</span>(class-&gt;cache);</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">newCache</span>;</span></span><br></pre></td></tr></table></figure><p>实际上，Objective-C runtime 在这个基础上又对代码进行了精简：旧的缓存数据并没有被复制到新的缓存空间中！毕竟，这只是一块缓存空间而已，并没有要求一定要保留其中的数据。在消息发送的时候，新的数据自然又会被缓存下来。因此，事实上，代码是这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(class-&gt;cache);</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br></pre></td></tr></table></figure><p>如果只讲单线程，需要做的就是这么多了，这篇文章到这也可以结束了。但是，Objective-C runtime 肯定要支持多线程操作，这就意味着所有的代码必须保证线程安全。每一个类的缓存数据都可能会被多个线程同时操作，因此，这里的代码必须谨慎处理，才能满足线程安全的条件。</p><p>像上面的写法自然不行。在释放了旧的缓存空间，并且还没有正确赋值新开辟的空间的这段“窗口时间”中，另一个线程就可能访问到非法的地址，这会导致其访问到垃圾数据。此外，如果那块内存没有进行映射的话，就会造成闪退。</p><p>我们如何解决这个问题？典型的做法是使用线程锁，就像这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lock(class-&gt;lock);</span><br><span class="line"><span class="built_in">free</span>(class-&gt;cache);</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line">unlock(class-&gt;lock);</span><br></pre></td></tr></table></figure><p>所有访问都必须由锁控制，包括读操作。这样就意味着，<code>objc_msgSend</code> 方法可能需要获取线程锁，访问缓存空间，然后释放锁。考虑到缓存的查找本身只会占用几纳秒的时间，每次获取、释放锁会增加很多时间的损耗，对性能的影响太大了。</p><p>我们也可以尝试用另外的方法去解决“窗口时间”，比如先分配和赋值新的内存空间，再销毁旧的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line"><span class="built_in">free</span>(oldCache);</span><br></pre></td></tr></table></figure><p>这也许有点用，但并没有解决问题。另一个线程也可能先获取到旧缓存的指针，然后在访问内存前被系统中断。然后，旧的缓存被销毁后，另外的线程又重新启动，这就导致了和前面一样的问题。</p><p>如果我们加一个延迟呢？比如说：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line">after(<span class="number">5</span> <span class="comment">/* seconds */</span>, ^&#123;</span><br><span class="line">    <span class="built_in">free</span>(oldCache);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这似乎是可行的，但还是可以想到一种情况，就是一个线程刚好被中断足够久，以至于五秒的延迟结束了才重新启动。虽然这样的情况及其罕见，但并不是毫无可能。</p><p>如果不是设置一个固定的延迟时间，而是确定等到“窗口时间”结束呢。我们可以给 <code>objc_msgSend</code> 函数增加一个计数器，就像这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gInMsgSend++;</span><br><span class="line">lookUpCache(class-&gt;cache);</span><br><span class="line">gInMsgSend--;</span><br></pre></td></tr></table></figure><p>正确的线程安全的做法需要对计数器使用原子性，以及使用内存屏障，来保证互相依赖的缓存的读取/存储正确进行。这里我们假设计数器已经满足这些条件。</p><p>有了计数器，重新分配缓存的代码就会像这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line"><span class="keyword">while</span>(gInMsgSend)</span><br><span class="line">    ; <span class="comment">// spin</span></span><br><span class="line"><span class="built_in">free</span>(oldCache);</span><br></pre></td></tr></table></figure><p>注意，我们并不需要阻塞 <code>objc_msgSend</code> 执行，就能让这段代码正确工作。在给缓存的指针重新赋值后，一旦某一时刻，确认没有方法在调用 <code>objc_msgSend</code> 了，就可以将旧的缓存空间释放。另一个线程有可能会在旧缓存空间被释放的时候调用 <code>objc_msgSend</code> ，但这个新的调用不会访问到旧的缓存的指针，因此是安全的。</p><p>然而，轮询操作效率较低，且不优雅。事实上，释放旧的缓存空间并不是十分要紧的一件事。内存能够正确释放当然是好的，但晚点再释放也没有什么大不了的。因此，我们可以不使用轮询，而是持有一份未释放的缓存的记录表。每次需要释放缓存时，就清空所有待释放的缓存：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line"></span><br><span class="line">append(gOldCachesList, oldCache);</span><br><span class="line"><span class="keyword">if</span>(!gInMsgSend) &#123;</span><br><span class="line">    <span class="keyword">for</span>(cache in gOldCachesList) &#123;</span><br><span class="line">        <span class="built_in">free</span>(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    gOldCachesList.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一条消息正在传递的话，那这里并不会立刻清空旧的缓存。但没关系，当下次时机来临时，比如消息传递结束或未来的某个时间点，这些过期的缓存都会被清空。</p><p>这个版本已经很接近 Objective-C runtime 的源码了。</p><h3 id="零消耗的标志位"><a href="#零消耗的标志位" class="headerlink" title="零消耗的标志位"></a>零消耗的标志位</h3><p>消息传递中的两部分存在着明显的不同。<code>objc_msgSend</code> 可能每秒钟需要运行数百万次，因此速度必须足够快，最好单次调用只消耗几纳秒的时间。然而，重新分配缓存却是个比较不频繁的操作，而且随着应用的持续运行，该操作也会变得越来越少。一旦应用达到一个稳定状态，不再加载新的代码，不再修改消息列表，这时缓存也就达到了它们所需的最大容量，再也不需要重新分配缓存了。在这之前，可能会发生成百上千次的缓存的重新分配，但相比于 <code>objc_msgSend</code> 来说，调用次数还是很少，因此对性能的要求也很低。</p><p>因此，应当尽可能少的去干预消息传递的过程，尽管这样会让缓存释放的过程变慢。如果在 <code>objc_msgSend</code> 阶段能减少一个 CPU 周期，那么即使每次缓存释放操作都会消耗一百万个 CPU 周期，那也能极大提高效率。</p><p>这么说来，哪怕设置一个全局的计数器，性能损耗的代价还是太高。那意味着 <code>objc_msgSend</code> 过程中需要增加两次内存访问，从而增加很多性能开销。而需要使用原子性以及内存屏障只会让这变得更糟。幸运的是，Objective-C runtime 能够将 <code>objc_msgSend</code> 的性能损耗降到零，代价是会让缓存释放的过程变得慢很多。</p><p>在上面的代码中，我们设置全局计数器的目的是追踪是否有线程处于消息传递的过程中。事实上，线程本身知道自己正在运行什么代码：程序计数器。这是一个记录当前指令的内存地址的 CPU 寄存器。我们可以用它来代替全局的计数器，来检查每个线程是否处于 <code>objc_msgSend</code> 当中。如果所有线程都不处于 <code>objc_msgSend</code> 中，那么旧的缓存就可以被安全释放。这种方法的实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ThreadsInMsgSend</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(thread in GetAllThreads()) &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> pc = thread.GetPC();</span><br><span class="line">        <span class="keyword">if</span>(pc &gt;= objc_msgSend_startAddress &amp;&amp; pc &lt;= objc_msgSend_endAddress) &#123;</span><br><span class="line">            <span class="keyword">return</span> YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line"></span><br><span class="line">append(gOldCachesList, oldCache);</span><br><span class="line"><span class="keyword">if</span>(!ThreadsInMsgSend()) &#123;</span><br><span class="line">    <span class="keyword">for</span>(cache in gOldCachesList) &#123;</span><br><span class="line">        <span class="built_in">free</span>(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    gOldCachesList.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objc_msgSend</code> 并不需要额外做任何事情，它可以不用考虑设置标志位，直接访问缓存：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lookUpCache(class-&gt;cache);</span><br></pre></td></tr></table></figure><p>缓存释放的代码效率很低，因为它需要检查进程中所有线程的状态。但这样 <code>objc_msgSend</code> 可以做到与单线程环境中同样高的效率，这是一个值得付出的代价。这就是 Apple 的 runtime 源码实现方式。</p><h3 id="真实代码"><a href="#真实代码" class="headerlink" title="真实代码"></a>真实代码</h3><p>具体的实现可以查看 runtime 源码 <a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-cache.mm" target="_blank" rel="noopener">objc-cache.mm</a> 中的 <code>_collecting_in_critical</code> 函数。</p><p>需要使用程序计数器的入口和出口位置被储存在全局变量中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OBJC_EXPORT <span class="keyword">uintptr_t</span> objc_entryPoints[];</span><br><span class="line">OBJC_EXPORT <span class="keyword">uintptr_t</span> objc_exitPoints[];</span><br></pre></td></tr></table></figure><p>事实上，<code>objc_msgSend</code> 有多种实现方式（比如返回 struct 类型），内部的 <code>cache_getImp</code> 也会直接访问缓存。这些都需要在缓存释放的时候被检查。</p><p><code>_collecting_in_critical</code> 函数没有入参，返回一个 <code>int</code> 类型，被当做一个布尔类型的标志位，指明是否有线程处于关键的函数中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _collecting_in_critical(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>我会跳过该函数中不重要的部分，只介绍最关键的部分。如果你想阅读完整代码，可以查看 <a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-cache.mm" target="_blank" rel="noopener">opensource.apple.com</a>。</p><p>获取线程信息的 API 处于 mach 层。<code>task_threads</code> 能够获取到指定任务（进程在 mach 中的表示）中的所有线程，这里用它来获取当前进程中的线程：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret = task_threads(mach_task_self(), &amp;threads, &amp;number);</span><br></pre></td></tr></table></figure><p>函数会在 <code>threads</code> 中保存 <code>thread_t</code> 数组，在 <code>number</code> 中保存线程的数量。然后会遍历所有线程：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; number; count++)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>获取一个线程的程序计数器是在另外一个单独的函数中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pc = _get_pc_for_thread (threads[count]);</span><br></pre></td></tr></table></figure><p>然后，程序会遍历所有的入口和出口，并逐个进行判断：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (region = <span class="number">0</span>; objc_entryPoints[region] != <span class="number">0</span>; region++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pc &gt;= objc_entryPoints[region]) &amp;&amp;</span><br><span class="line">            (pc &lt;= objc_exitPoints[region])) </span><br><span class="line">        &#123;</span><br><span class="line">            result = TRUE;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历结束后，将结果返回给调用者：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_get_pc_for_thread</code> 函数是怎么工作的呢？它只是简单地调用 <code>thread_get_state</code> 函数来获得目标线程的寄存器状态。之所以要放到一个单独的函数中，是因为寄存器状态的结构体是与具体架构相关的，不同架构都有不同的寄存器。也就是说，这个函数需要对每个支持的架构有一套单独的实现，尽管这些实现差别不大。下面是 x86-64 下的实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> _get_pc_for_thread(<span class="keyword">thread_t</span> thread)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">x86_thread_state64_t</span>            state;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = x86_THREAD_STATE64_COUNT;</span><br><span class="line">    <span class="keyword">kern_return_t</span> okay = thread_get_state (thread, x86_THREAD_STATE64, (<span class="keyword">thread_state_t</span>)&amp;state, &amp;count);</span><br><span class="line">    <span class="keyword">return</span> (okay == KERN_SUCCESS) ? state.__rip : PC_SENTINEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rip 是 x86-64 下程序计数器的寄存器名字。“R”代表“register”，“IP”代表“instruction pointer”。</p><p>上面所说的入口和出口的代码位置，与其函数一同定义在汇编文件中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.private_extern _objc_entryPoints</span><br><span class="line">_objc_entryPoints:</span><br><span class="line">    .quad   _cache_getImp</span><br><span class="line">    .quad   _objc_msgSend</span><br><span class="line">    .quad   _objc_msgSend_fpret</span><br><span class="line">    .quad   _objc_msgSend_fp2ret</span><br><span class="line">    .quad   _objc_msgSend_stret</span><br><span class="line">    .quad   _objc_msgSendSuper</span><br><span class="line">    .quad   _objc_msgSendSuper_stret</span><br><span class="line">    .quad   _objc_msgSendSuper2</span><br><span class="line">    .quad   _objc_msgSendSuper2_stret</span><br><span class="line">    .quad   <span class="number">0</span></span><br><span class="line"></span><br><span class="line">.private_extern _objc_exitPoints</span><br><span class="line">_objc_exitPoints:</span><br><span class="line">    .quad   LExit_cache_getImp</span><br><span class="line">    .quad   LExit_objc_msgSend</span><br><span class="line">    .quad   LExit_objc_msgSend_fpret</span><br><span class="line">    .quad   LExit_objc_msgSend_fp2ret</span><br><span class="line">    .quad   LExit_objc_msgSend_stret</span><br><span class="line">    .quad   LExit_objc_msgSendSuper</span><br><span class="line">    .quad   LExit_objc_msgSendSuper_stret</span><br><span class="line">    .quad   LExit_objc_msgSendSuper2</span><br><span class="line">    .quad   LExit_objc_msgSendSuper2_stret</span><br><span class="line">    .quad   <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>_collecting_in_critical</code> 的用法和上面我们假设的例子很相似。它在释放缓存之前被调用。事实上，runtime 有两种工作模式：一种是如果其他线程正在调用相关函数的话，就把垃圾内存的清理工作留到下一次调用；另一种是一直轮询，直到确认没有线程正在调用，然后再进行销毁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Synchronize collection with objc_msgSend and other cache readers</span></span><br><span class="line"><span class="keyword">if</span> (!collectALot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_collecting_in_critical ()) &#123;</span><br><span class="line">        <span class="comment">// objc_msgSend (or other cache reader) is currently looking in</span></span><br><span class="line">        <span class="comment">// the cache and might still be using some garbage.</span></span><br><span class="line">        <span class="keyword">if</span> (PrintCaches) &#123;</span><br><span class="line">            _objc_inform (<span class="string">"CACHES: not collecting; "</span></span><br><span class="line">                          <span class="string">"objc_msgSend in progress"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No excuses.</span></span><br><span class="line">    <span class="keyword">while</span> (_collecting_in_critical()) </span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free garbage here</span></span><br></pre></td></tr></table></figure><p>第一种将垃圾内存留到下一次调用时清理的模式，是在正常的重新分配缓存大小时采用；第二种始终清理垃圾内存的模式，是在需要刷新所有类的所有缓存时使用，因为这样往往会产生大量的垃圾内存。以我阅读代码来看，这种情况只会在开启一项日志调试功能时发生。日志调试会将所有的消息发送记录到文件中，消息缓存会影响这一日志，因此需要全部刷新。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>性能和线程安全经常会互相冲突。不同部分的代码对同一块内存的访问方式往往不同，也就允许我们以更加有效率的方式来实现线程安全。方式之一是用一个全局标志位或者计数器来指明对内存的改动操作是否安全。在 Objective-C runtime 中，Apple 更进一步，使用了各个线程的程序计数器来判断线程是否正在进行不安全的操作。这是一个很专业的案例，这种做法想要用到其他地方也不是很有用，但研究它的原理本身就是一件很有意思的事情。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-05-29-concurrent-memory-deallocation-in-the-objective-c-runtime.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2015-06-05&lt;br&gt;译者：&lt;a href=&quot;https://github.com/YangGao1991&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阳仔&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://weibo.com/1743643682/profile?topnav=1&amp;amp;wvr=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;liberalism&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Objective-C Runtime 是绝大多数 Mac 和 iOS 程序代码的核心。Runtime 的核心就是 &lt;code&gt;objc_msgSend&lt;/code&gt; 函数，这个函数最关键的就是方法缓存。我在这篇文章中将会阐述一下，Apple 是如何在不影响性能的情况下，以线程安全的方式来重新分配缓存大小、释放方法缓存。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的锁和线程安全</title>
    <link href="https://swift.gg/2018/06/07/friday-qa-2015-02-06-locks-thread-safety-and-swift/"/>
    <id>https://swift.gg/2018/06/07/friday-qa-2015-02-06-locks-thread-safety-and-swift/</id>
    <published>2018-06-07T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.535Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-02-06-locks-thread-safety-and-swift.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-02-06<br>译者：<a href="undefined">Lefe_x</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>在 Swift 中有个有趣的现象：它没有与线程相关的语法，也没有明确的互斥锁/锁（<code>mutexes/locks</code>）概念，甚至 Objective-C 中有的 <code>@synchronized</code> 和原子属性它都没有。幸运的是，苹果系统的 API 可以非常容易地应用到 Swift 中。今天，我会介绍这些 API 的用法以及从 Objective-C 过渡的一些问题，这些灵感都来源于 Cameron Pulsford。</p><a id="more"></a><h2 id="快速回顾一下锁"><a href="#快速回顾一下锁" class="headerlink" title="快速回顾一下锁"></a>快速回顾一下锁</h2><p>锁（<code>lock</code>）或者互斥锁（<code>mutex</code>）是一种结构，用来保证一段代码在同一时刻只有一个线程执行。它们通常被用来保证多线程访问同一可变数据结构时的数据一致性。主要有下面几种锁：</p><ul><li>阻塞锁（<code>Blocking locks</code>）：常见的表现形式是当前线程会进入休眠，直到被其他线程释放。</li><li>自旋锁（<code>Spinlocks</code>）：使用一个循环不断地检查锁是否被释放。如果等待情况很少话这种锁是非常高效的，相反，等待情况非常多的情况下会浪费 CPU 时间。</li><li>读写锁（<code>Reader/writer locks</code>）：允许多个读线程同时进入一段代码，但当写线程获取锁时，其他线程（包括读取器）只能等待。这是非常有用的，因为大多数数据结构读取时是线程安全的，但当其他线程边读边写时就不安全了。</li><li>递归锁（<code>Recursive locks</code>）：允许单个线程多次获取相同的锁。非递归锁被同一线程重复获取时可能会导致死锁、崩溃或其他错误行为。</li></ul><h2 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h2><p>苹果提供了一系列不同的锁 API，下面列出了其中一些： </p><ul><li><code>pthread_mutex_t</code></li><li><code>pthread_rwlock_t</code></li><li><code>dispatch_queue_t</code></li><li><code>NSOperationQueue</code> 当配置为 <code>serial</code> 时</li><li><code>NSLock</code></li><li><code>OSSpinLock</code></li></ul><p>除此之外，Objective-C 提供了 <code>@synchronized</code> 语法结构，它其实就是封装了 <code>pthread_mutex_t</code> 。与其他 API 不同的是，<code>@synchronized</code> 并未使用专门的锁对象，它可以将任意 Objective-C 对象视为锁。<code>@synchronized(someObject)</code> 区域会阻止其他 <code>@synchronized(someObject)</code> 区域访问同一对象指针。不同的 API 有不同的行为和能力： </p><ul><li><code>pthread_mutex_t</code> 是一个可选择性地配置为递归锁的阻塞锁；</li><li><code>pthread_rwlock_t</code> 是一个阻塞读写锁；</li><li><code>dispatch_queue_t</code> 可以用作阻塞锁，也可以通过使用 barrier block 配置一个同步队列作为读写锁，还支持异步执行加锁代码；</li><li><code>NSOperationQueue</code> 可以用作阻塞锁。与 <code>dispatch_queue_t</code> 一样，支持异步执行加锁代码。</li><li><code>NSLock</code> 是 Objective-C 类的阻塞锁，它的同伴类 <code>NSRecursiveLock</code> 是递归锁。</li><li><code>OSSpinLock</code> 顾名思义，是一个自旋锁。</li></ul><p>最后，<code>@synchronized</code> 是一个阻塞递归锁。</p><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>注意，<code>pthread_mutex_t</code>，<code>pthread_rwlock_t</code> 和 <code>OSSpinLock</code> 是值类型，而不是引用类型。这意味着如果你用 <code>=</code> 进行赋值操作，实际上会复制一个副本。这会造成严重的后果，因为这些类型无法复制！如果你不小心复制了它们中的任意一个，这个副本无法使用，如果使用可能会直接崩溃。这些类型的 <code>pthread</code> 函数会假定它们的内存地址与初始化时一样，因此如果将它们移动到其他地方就可能会出问题。<code>OSSpinLock</code> 不会崩溃，但复制操作会生成一个完全独立的锁，这不是你想要的。</p><p>如果使用这些类型，就必须注意不要去复制它们，无论是显式的使用 <code>=</code> 操作符还是隐式地操作。<br>例如，将它们嵌入到结构中或在闭包中捕获它们。</p><p>另外，由于锁本质上是可变对象，需要用 <code>var</code> 来声明它们。</p><p>其他锁都是是引用类型，它们可以随意传递，并且可以用 <code>let</code> 声明。 </p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>2015-02-10 更新：本节中所描述的问题已经以惊人的速度被淘汰。苹果昨天发布了 Xcode 6.3 beta 1，其中包括 Swift 1.2。在其他更改中，现在使用一个空的初始化器导入 C 结构，将所有字段设置为零。简而言之，你现在可以直接使用 <code>pthread_mutex_t()</code>，不需要下面提到的扩展。</p><p>pthread 类型很难在 swift 中使用。它们被定义为不透明的结构体中包含了一堆存储变量，例如：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">_opaque_pthread_mutex_t</span> </span>&#123;</span><br><span class="line">    long __sig;</span><br><span class="line">    char __opaque[__PTHREAD_MUTEX_SIZE__];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目的是声明它们，然后使用 init 函数对它们进行初始化，使用一个指针存储和填充。在 C 中，它看起来像： </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>这段代码可以正常的工作，只要你记得调用 <code>pthread_mutex_init</code>。然而，Swift 真的真的不喜欢未初始化的变量。与上面代码等效的 Swift 版本无法编译： </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex: pthread_mutex_t</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// error: address of variable 'mutex' taken before it is initialized</span></span><br></pre></td></tr></table></figure><p>Swift 需要变量在使用前初始化。<code>pthread_mutex_init</code> 不使用传入的变量的值，只是重写它，但是 Swift 不知道，因此它产生了一个错误。为了满足编译器，变量需要用某种东西初始化。在类型之后使用 <code>()</code>，但这样写仍然会报错：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex = pthread_mutex_t()</span><br><span class="line"><span class="comment">// error: missing argument for parameter '__sig' in call</span></span><br></pre></td></tr></table></figure><p>Swift 需要那些不透明字段的值。<code>__sig</code> 可以传入零，但是 <code>__opaque</code> 就有点烦人了。下面的结构体需要桥接到 swift 中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">_opaque_pthread_mutex_t</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> __sig: <span class="type">Int</span></span><br><span class="line">   <span class="keyword">var</span> __opaque: (<span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前没有简单的方法使用一堆 0 构建一个元组，只能像下面这样把所有的 0 都写出来：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex = pthread_mutex_t(__sig: <span class="number">0</span>,</span><br><span class="line">                             __opaque: (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>这么写太难看了，但我没找到好的方法。我能想到最好的做法就是把它写到一个扩展中，这样直接使用空的 <code>()</code> 就可以了。下面是我写的两个扩展： </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">pthread_mutex_t</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        __sig = <span class="number">0</span></span><br><span class="line">        __opaque = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">pthread_rwlock_t</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        __sig = <span class="number">0</span></span><br><span class="line">        __opaque = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过下面这种方式使用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex = pthread_mutex_t()</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h2 id="锁的封装"><a href="#锁的封装" class="headerlink" title="锁的封装"></a>锁的封装</h2><p>为了使这些不同的 API 更易于使用，我编写了一系列小型函数。我决定把 <code>with</code> 作为一个方便、简短、看起来像语法的名字，灵感来自 python 的 <code>with</code> 声明。Swift 函数重载允许不同类型使用相同的名称。基本形式如下所示：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(lock: SomeLockType, f: Void -&gt; Void)</span></span> &#123; ...</span><br></pre></td></tr></table></figure><p>然后在锁定的情况下执行函数 f。下面我们来实现这些类型。</p><p>对于值类型，它需要一个指向锁的指针，以便 lock/unlock 函数可以修改它。这个实现<code>pthread_mutex_t</code> 只是调用相应的 lock 和 unlock 函数，f 函数在两者之间调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(mutex: UnsafeMutablePointer&lt;pthread_mutex_t&gt;, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    pthread_mutex_lock(mutex)</span><br><span class="line">    f()</span><br><span class="line">    pthread_mutex_unlock(mutex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pthread_rwlock_t</code> 的实现几乎完全相同：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(rwlock: UnsafeMutablePointer&lt;pthread_rwlock_t&gt;, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    pthread_rwlock_rdlock(rwlock)</span><br><span class="line">    f()</span><br><span class="line">    pthread_rwlock_unlock(rwlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与读写锁做个对比，它们看起来很像：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with_write</span><span class="params">(rwlock: UnsafeMutablePointer&lt;pthread_rwlock_t&gt;, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    pthread_rwlock_wrlock(rwlock)</span><br><span class="line">    f()</span><br><span class="line">    pthread_rwlock_unlock(rwlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_queue_t</code> 更简单。它只需要封装 <code>dispatch_sync：</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(queue: dispatch_queue_t, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    dispatch_sync(queue, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个人想显摆自己很聪明，那么可以充分利用 Swift 的函数式特性简单的写出这样的代码：</p><p><code>let with = dispatch_sync</code></p><p>这种写法存在一些问题，最大的问题是它会和我们这里使用的基于类型的重载混淆。</p><p><code>NSOperationQueue</code> 在概念上是相似的，不过没有 <code>dispatch_sync</code> 可以用。我们需要创建一个操作（<code>operation</code>），将其添加到队列中，并显式等待它完成：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(opQ: NSOperationQueue, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> op = <span class="type">NSBlockOperation</span>(f)</span><br><span class="line">    opQ.addOperation(op)</span><br><span class="line">    op.waitUntilFinished()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>NSLock</code> 看起来像 <code>pthread</code> 版本，只是锁定调用有些不同：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(lock: NSLock, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    lock.lock()</span><br><span class="line">    f()</span><br><span class="line">    lock.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，<code>OSSpinLock</code> 的实现同样也是如此：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(spinlock: UnsafeMutablePointer&lt;OSSpinLock&gt;, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    <span class="type">OSSpinLockLock</span>(spinlock)</span><br><span class="line">    f()</span><br><span class="line">    <span class="type">OSSpinLockUnlock</span>(spinlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模仿-synchronized"><a href="#模仿-synchronized" class="headerlink" title="模仿 @synchronized"></a>模仿 <code>@synchronized</code></h3><p>有了上面的封装，模仿 <code>@synchronized</code> 的实现就变得很简单。给你的类添加一个属性，持有一个锁，然后使用 <code>with</code> 替代 <code>@synchronized</code> ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"com.example.myqueue"</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setEntryForKey</span><span class="params">(key: Key, entry: Entry)</span></span> &#123;</span><br><span class="line">    with(queue) &#123;</span><br><span class="line">        entries[key] = entry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 block 中获取数据比较麻烦。<code>@synchronized</code> 可以从内部 <code>return</code> ，但是 <code>with</code> 做不到。你必须使用一个 <code>var</code> 变量在 block 内部赋值给它：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entryForKey</span><span class="params">(key: Key)</span></span> -&gt; <span class="type">Entry</span>? &#123;</span><br><span class="line">    <span class="keyword">var</span> result: <span class="type">Entry</span>?</span><br><span class="line">    with(queue) &#123;</span><br><span class="line">        result = entries[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按理说可以将这段代码当做模板封装在一个通用函数中，但是它无法通过 Swift 编译器的类型推断，目前还没有找到解决方法。</p><h3 id="模拟原子属性"><a href="#模拟原子属性" class="headerlink" title="模拟原子属性"></a>模拟原子属性</h3><p>原子属性（<code>atomic</code>）并不常用。与其他代码属性不同，原子属性并不支持组合率。如果函数 f 不存在内存泄漏，函数 g 不存在内存泄漏，那么函数 h 只是调用 f 和 g 也不会存在内存泄漏。但是原子属性并不满足这个条件。举一个例子，假设你有一个定义成原子属性并且线程安全的 Account 类：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> checkingAccount = <span class="type">Account</span>(amount: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> savingsAccount = <span class="type">Account</span>(amount: <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>现在要把钱转到储蓄账户中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">checkingAccount.withDraw(<span class="number">100</span>)</span><br><span class="line">savingsAccount.deposit(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>在另一个线程中，统计并显示余额：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">"Your total balance is: <span class="subst">\(checkingAccount.amount + savingsAccount.amount)</span>"</span>)</span><br></pre></td></tr></table></figure><p>在某些情况下，这段代码会打印 0，而不是 100，尽管事实上这些 Account 对象本身是原子属性，并且用户确实有 100 的余额。所以，最好让整个子系统都满足原子性，而不是单个属性。</p><p>在极少数情况下，原子属性是有用的，因为它并不依赖其他特性，只需要线程安全即可。要在 Swift 中实现这一点，需要一个计算属性来完成锁定，用另一个常规属性保存值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"..."</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _myPropertyStorage: <span class="type">SomeType</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myProperty: <span class="type">SomeType</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result: <span class="type">SomeType</span>?</span><br><span class="line">        with(queue) &#123;</span><br><span class="line">            result = _myPropertyStorage</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        with(queue) &#123;</span><br><span class="line">            _myPropertyStorage = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何选择锁-API"><a href="#如何选择锁-API" class="headerlink" title="如何选择锁 API"></a>如何选择锁 API</h3><p><code>pthread</code> API 在 Swift 中不太好用，而且功能并不比其它 API 多。一般我比较喜欢在 C 和 Objective-C 中使用它们，因为它们又好用又高效。但是在 Swift 中，除非必要，我一般不会用。</p><p>一般来说不需要用读写锁，大多数情况下读写速度都非常快。读写锁带来的额外开销超过了并发读取带来的效率提升。</p><p>递归锁会发生死锁。多数情况下它们是有用的，但如果你发现自己需要获取一个已经在当前线程被锁住的锁，那最好重新设计代码，通常来说不会出现这种需求。</p><p>我的建议是，如果不知道该用什么，那就默认选择 <code>dispatch_queue_t</code> 。虽然用起来相对麻烦，但是不会产生太多问题。该 API 非常方便，并且确保你永远不会忘记调用 lock 和 unlock。它提供了许多有用的 API，如使用单个 <code>dispatch_async</code> 在后台执行被锁定的代码，或者设置定时器或其他作用于 queue 的事件源，以便它们自动执行锁定。你甚至可以用它作为 <code>NSNotificationCenter</code> 观察者，或者使用 <code>NSOperationQueue</code> 的属性 <code>underlyingQueue</code> 作为 <code>NSURLSession</code> 代理。</p><p><code>NSOperationQueue</code> 可能认为自己和 <code>dispatch_queue_t</code> 一样牛👃，但是实际上很少有场景需要使用它。这个 API 使用起来更麻烦，而且和其他 API 比没有什么优势，无非在某些情况下，它能自动进行操作的依赖关系管理，也就这点比较有用。</p><p><code>NSLock</code> 是一个简单的锁定类，易于使用且效率很高。如果需要显式锁定和解锁，那可以用它替代 <code>dispatch_queue_t</code> 。但在大多数情况下不需要使用它。</p><p><code>OSSpinLock</code> 对于经常使用锁定、竞争较少且锁定代码运行速度快的用户来说，是一个很好的选择。它的开销非常少，有助于提升性能。如果代码可能会在很长一段时间内保持锁定或竞争很多，那最好不要用这个 API，因为这会浪费 CPU 时间。通常来说，你可以先使用 <code>dispatch_queue_t</code> ，如果这块出现了性能问题，再考虑换成 <code>OSSpinLock</code> 。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Swift 语言层面并不支持线程同步，但是 Apple 的系统框架有很多好用的 API。<code>GCD</code> 和 <code>dispatch_queue_t</code> 非常好用，并且Swift 中的 API 也是如此。虽然 Swift 里没有 <code>@synchronized</code> 和原子属性，但我们有其他更好的选择。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-02-06-locks-thread-safety-and-swift.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2015-02-06&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;Lefe_x&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;，&lt;a href=&quot;https://weibo.com/1743643682/profile?topnav=1&amp;amp;wvr=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;liberalism&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在 Swift 中有个有趣的现象：它没有与线程相关的语法，也没有明确的互斥锁/锁（&lt;code&gt;mutexes/locks&lt;/code&gt;）概念，甚至 Objective-C 中有的 &lt;code&gt;@synchronized&lt;/code&gt; 和原子属性它都没有。幸运的是，苹果系统的 API 可以非常容易地应用到 Swift 中。今天，我会介绍这些 API 的用法以及从 Objective-C 过渡的一些问题，这些灵感都来源于 Cameron Pulsford。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 工具类：处理临时文件</title>
    <link href="https://swift.gg/2018/06/04/temp-file-helper/"/>
    <id>https://swift.gg/2018/06/04/temp-file-helper/</id>
    <published>2018-06-04T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.535Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2018/03/temp-file-helper/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-03-22<br>译者：<a href="http://daizi.me" target="_blank" rel="noopener">小袋子</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>我经常需要在某些操作中创建临时文件，每次都很繁琐：必须有合适的临时目录，确保文件名是唯一的，最后还不能忘记在操作完成之后删除文件。</p><p>实际上，“创建”是一个错误的说法，因为创建工作通常是由我使用的 API 负责的 — 而我只是提供了一个指向目的位置的 URL。举个例子，假设你的应用提供了一个分享 PDF 文件的功能。你需要创建一个 <a href="https://developer.apple.com/documentation/uikit/uigraphicspdfrenderer" target="_blank" rel="noopener"><code>UIGraphicsPDFRenderer</code></a>对象来生成 PDF，然后调用 <a href="https://developer.apple.com/documentation/uikit/uigraphicspdfrenderer/1649119-writepdf" target="_blank" rel="noopener"><code>writePDF</code></a> 方法并传入临时文件的 URL 生成 PDF 文件，最后在 iOS 分享列表（share sheet）中分享它。</p><p>为了使这个操作更加简便，我最近写了一个简单的 Swift 工具类。你可以这样使用：</p><a id="more"></a><p>1、选择一个文件名来初始化 <code>TemporaryFile</code> ：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tmp = <span class="keyword">try</span> <span class="type">TemporaryFile</span>(creatingTempDirectoryForFilename: <span class="string">"report.pdf"</span>)</span><br></pre></td></tr></table></figure></p><p>这样就新建了一个唯一的临时目录。正如我前面提到的，这是个空目录，<code>TemporaryFile</code> 并不会创建任何文件。更确切地说，它只是提供了一个可以安全创建很多文件的目录，并且不用担心命名冲突。</p><p>2、<code>TemporaryFile</code>有两个属性，<code>directoryURL</code> 是创建的临时目录 URL。<code>fileURL</code> 是目录中的文件 URL，即初始化时指定的文件名：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tmp.directoryURL.path)</span><br><span class="line"><span class="comment">// → /var/folders/v8/tft1q…/T/…-8DC6DD131DC1</span></span><br><span class="line"><span class="built_in">print</span>(tmp.fileURL.path)</span><br><span class="line"><span class="comment">// → /var/folders/v8/tft1q…/T/…-8DC6DD131DC1/report.pdf</span></span><br></pre></td></tr></table></figure><p>再次强调一下，该 URL 对应的文件暂时还不存在——你必须自己创建文件，通常来说可以把 URL 传入其他 API 来生成文件：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> renderer = <span class="type">UIGraphicsPDFRenderer</span>(...)</span><br><span class="line"><span class="keyword">try</span> renderer.writePDF(to: tmp.fileURL) &#123; context <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 编写代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在目录中创建不同名字的文件，但是 <code>TemporaryFile</code> 类型目前只能用来存储单一的文件 URL。如果能够支持多文件 URL 的存储，那就会更好用了。</p><p>3、创建文件后，<code>TemporaryFile</code> 的值被应用中使用该文件的对象所持有（例如，创建文件函数的调用者）。当该对象完成后并且不再需要该文件时，可以调用<code>DeleTeDirectory</code>方法删除临时目录，包括其中的所有文件：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如将 temp 文件传给 UIActivityController 用以分享</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 当你完成后, 调用 deleteDirectory</span></span><br><span class="line"><span class="keyword">try</span> tmp.deleteDirectory()</span><br></pre></td></tr></table></figure><p>我曾考虑到让这个步骤自动化 — 你可以创建 <code>TemporaryFile</code> 类，然后在 <code>deinitializer</code> 中调用 <code>deleteDirectory</code>。最后我放弃了，因为这种行为可能让类型的使用者感到困惑。如果能够添加一个初始化标志位来配置删除行为就好了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>以下是完整代码 (Swift 4.0):</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="comment">/// 临时目录中临时文件的包装（Wrapper）。目录是为文件而特别创建的，因此不再需要文件时，可以安全地删除该文件。</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 在你不再需要文件时，调用 `deleteDirectory`</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TemporaryFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> directoryURL: <span class="type">URL</span></span><br><span class="line">    <span class="keyword">let</span> fileURL: <span class="type">URL</span></span><br><span class="line">    <span class="comment">/// 删除临时目录和其中的所有文件。</span></span><br><span class="line">    <span class="keyword">let</span> deleteDirectory: () <span class="keyword">throws</span> -&gt; <span class="type">Void</span></span><br><span class="line"><span class="comment">/// 使用唯一的名字来创建临时目录，并且使用 `fileURL` 目录中名为 `filename` 的文件来初始化接收者。</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - 注意: 这里不会创建文件！</span></span><br><span class="line">    <span class="keyword">init</span>(creatingTempDirectoryForFilename filename: <span class="type">String</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (directory, deleteDirectory) = <span class="keyword">try</span> <span class="type">FileManager</span>.<span class="keyword">default</span></span><br><span class="line">            .urlForUniqueTemporaryDirectory()</span><br><span class="line">        <span class="keyword">self</span>.directoryURL = directory</span><br><span class="line">        <span class="keyword">self</span>.fileURL = directory.appendingPathComponent(filename)</span><br><span class="line">        <span class="keyword">self</span>.deleteDirectory = deleteDirectory</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FileManager</span> </span>&#123;</span><br><span class="line"><span class="comment">/// 创建一个有唯一名字的临时目录并返回 URL。</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - 返回：目录 URL 的 tuple 以及删除函数。</span></span><br><span class="line">    <span class="comment">///   完成后调用函数删除目录。</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - 注意: 在应用退出后，不应该存在依赖的临时目录。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">urlForUniqueTemporaryDirectory</span><span class="params">(preferredName: String? = <span class="literal">nil</span>)</span></span> <span class="keyword">throws</span></span><br><span class="line">        -&gt; (url: <span class="type">URL</span>, deleteDirectory: () <span class="keyword">throws</span> -&gt; <span class="type">Void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> basename = preferredName ?? <span class="type">UUID</span>().uuidString</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> createdSubdirectory: <span class="type">URL</span>? = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> subdirName = counter == <span class="number">0</span> ? basename : <span class="string">"<span class="subst">\(basename)</span>-<span class="subst">\(counter)</span>"</span></span><br><span class="line">                <span class="keyword">let</span> subdirectory = temporaryDirectory</span><br><span class="line">                    .appendingPathComponent(subdirName, isDirectory: <span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">try</span> createDirectory(at: subdirectory, withIntermediateDirectories: <span class="literal">false</span>)</span><br><span class="line">                createdSubdirectory = subdirectory</span><br><span class="line">            &#125; <span class="keyword">catch</span> <span class="type">CocoaError</span>.fileWriteFileExists &#123;</span><br><span class="line">                <span class="comment">// 捕捉到文件已存在的错误，并使用其他名字重试。</span></span><br><span class="line">                <span class="comment">// 其他错误传播到调用方。</span></span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> createdSubdirectory == <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> directory = createdSubdirectory!</span><br><span class="line">        <span class="keyword">let</span> deleteDirectory: () <span class="keyword">throws</span> -&gt; <span class="type">Void</span> = &#123;</span><br><span class="line">            <span class="keyword">try</span> <span class="keyword">self</span>.removeItem(at: directory)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (directory, deleteDirectory)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2018/03/temp-file-helper/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-03-22&lt;br&gt;译者：&lt;a href=&quot;http://daizi.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小袋子&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;我经常需要在某些操作中创建临时文件，每次都很繁琐：必须有合适的临时目录，确保文件名是唯一的，最后还不能忘记在操作完成之后删除文件。&lt;/p&gt;
&lt;p&gt;实际上，“创建”是一个错误的说法，因为创建工作通常是由我使用的 API 负责的 — 而我只是提供了一个指向目的位置的 URL。举个例子，假设你的应用提供了一个分享 PDF 文件的功能。你需要创建一个 &lt;a href=&quot;https://developer.apple.com/documentation/uikit/uigraphicspdfrenderer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;UIGraphicsPDFRenderer&lt;/code&gt;&lt;/a&gt;对象来生成 PDF，然后调用 &lt;a href=&quot;https://developer.apple.com/documentation/uikit/uigraphicspdfrenderer/1649119-writepdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;writePDF&lt;/code&gt;&lt;/a&gt; 方法并传入临时文件的 URL 生成 PDF 文件，最后在 iOS 分享列表（share sheet）中分享它。&lt;/p&gt;
&lt;p&gt;为了使这个操作更加简便，我最近写了一个简单的 Swift 工具类。你可以这样使用：&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的 Error Handling</title>
    <link href="https://swift.gg/2018/05/31/error-handling-swift/"/>
    <id>https://swift.gg/2018/05/31/error-handling-swift/</id>
    <published>2018-05-31T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.535Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Nick Hanan，<a href="http://www.codingexplorer.com/error-handling-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016/05/05<br>译者：<a href="undefined">TonyHan</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p><img src="http://www.codingexplorer.com/wp-content/uploads/2016/05/ErrorHandlingInSwiftTitle.png" alt=""></p><p>理想情况下，错误永远不会出现。我们所需的文件永远可以访问，网络永远可用并且稳定。不幸的是，现实并不理想，我们需要处理这种不理想的结果。幸运的是，Swift 团队在 Swift 2 中包含了一种很好的方式来处理与理想情况的偏差。Swift Error Handling 能够让我们快速而简便的告知编译器一个函数能否抛出错误，并且在抛出后以合适的方式去处理错误。</p><a id="more"></a><p>Objective-C 处理错误的方式与新的 Swift Error Handling 有一个主要区别。如果你之前在 Objective-C 中处理过 NSError，说实话，在处理可能抛出错误的方法时，你有没有过为其赋值为 “nil” 而不是 NSError 指针？是的，我也是这么认为。在 Objective-C 中，要正确的处理错误，你需要这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSError *err = nil;</span><br><span class="line">NSString *fileStuff = [[NSString alloc] initWithContentsOfFile:@&quot;someFile.txt&quot; encoding:NSUTF8StringEncoding error:&amp;err];</span><br></pre></td></tr></table></figure><p>上述代码所做的，是创建一个空的 NSError 对象，然后你可以用 ＆ 符号传入构造方法，＆ 符号用于辨识出传入的是变量地址。然后，如果有错误，方法或构造函数可以通过此地址找到对应的内存，将 NSError 赋值过去，然后退出函数。将可赋值的地址作为参数传入，是一种实现函数多返回值的手段。在 Swift 中这被转变成了方法原型中的 “inout” 关键字。</p><p>现在，如果有错误，你可以查看 “err” 变量，从而确认是什么错误，然后正确的处理错误。但是，如果不关心错误，可以不传错误指针（即 &amp;err）而直接传入 “nil”，然后任何 NSError 都会被忽略掉。</p><p>Swift 中新的错误处理的语法，使错误处理更加明确。函数会明确的标识出它们会抛出错误，你的程序需要对此很明确，同时要正确处理这些错误（或明确地忽略）。</p><h4 id="创建-Swift-错误"><a href="#创建-Swift-错误" class="headerlink" title="创建 Swift 错误"></a>创建 Swift 错误</h4><p>这可真是个奇怪的标题，什么是创建一个错误？事实上，我们是要创建一个能够表示程序中真实错误的实例。如果一切运行正常，或者文件甚至不存在，这当然没问题。如果存在，用户可能没有访问权限，或者文件因为未知原因损坏。我们需要为要访问这个文件的函数创建 Swift Error 并列出以下选项：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FileReadingError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FileNotFound</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">InsufficientPermission</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">FileCorrupted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，创建 Swift Error 的最简单方法是创建符合 ErrorType 协议的枚举。然后列出代表不同错误情况的选项。从技术来讲，任何对象都可以符合 ErrorType 协议，所以你可以使用一个结构体或一个类，但我觉得不应该这样做。枚举是更完美的方案，它能够列举出有限数目的错误名称。关联值的功能会让枚举更强大，比如说，你可以使用 InsufficientPermission，来显示出当前用户的权限等级。如果想了解更多关于枚举的内容，请查看这篇文章 <a href="http://www.codingexplorer.com/enumerations-swift/" target="_blank" rel="noopener">Enumerations in Swift</a>。</p><p>现在我们来创建一个能抛出错误的函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pretendToReadTestFile</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">NSData</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">FileReadingError</span>.<span class="type">FileNotFound</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，上述代码实际上什么也不会返回，只会自动抛出错误，但我们只是想了解如何实现抛出错误的机制，而并非真正实现一个访问文件并返回文件内容的函数。</p><p>首先，你必须将方法标记为能够抛出错误。要实现这个，只需要在在参数之后、用于表示返回类型的箭头 “ -&gt; “ 之前使用 “throws” 关键字即可。接下来要在函数内部实现抛出错误，只需要输入 “throw” 然后列出想要作为错误的选项。就是这么简单！</p><p>只需要在调用函数之前使用 “try” 关键字，便可以捕获函数的错误：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">try</span> pretendToReadTestFile()</span><br></pre></td></tr></table></figure><h4 id="处理-Swift-Errors"><a href="#处理-Swift-Errors" class="headerlink" title="处理 Swift Errors"></a>处理 Swift Errors</h4><p>主要有四种处理 Swift Errors 的方式：</p><h5 id="让其他人处理"><a href="#让其他人处理" class="headerlink" title="让其他人处理"></a>让其他人处理</h5><p>第一种方法就是不做处理，让其他人来处理。要实现这个特性，需要将函数标记为会抛出错误的函数。之后再调用此函数时则必须进行处理。最终需要有地方来正确处理错误，但不一定是调用抛出错误方法的地方。例如，如果有一个负责读写或其他文件管理操作的文件管理器对象，我们可能只想将错误抛给调用者而不是在其里面处理。</p><p>要实现上述特性，只需要用 “throws” 关键字标记函数即可。这仍然需要用 “try” 将调用功能函数的函数标记为可能抛出错误。如果需要存储抛出错误函数的返回值，只需要正常调用函数然后保存数据即可，但需要在等号和函数调用之间使用 “try” 关键字。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDataFromSomething</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">NSData</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span> pretendToReadTestFile()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="处理特定的-Swift-Errors"><a href="#处理特定的-Swift-Errors" class="headerlink" title="处理特定的 Swift Errors"></a>处理特定的 Swift Errors</h5><p>在其他语言中，这可能是最熟悉的用来处理异常的方法了。Swift Error 的处理方式与异常的处理有显著的不同，会更高效。抛出 Swift Error 更像是替代了返回语句，至少在使用方式上是这样：函数会返回相应的 Swift Error，而不是返回某个预期的返回值。</p><p>首先使用 “do” 语句将抛出错误的函数包裹起来，然后使用 “catch” 语句，有点像 Switch 的 “case” 语句，或者 if 语句的 else-if，来得到需要的 Swift Errors，如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> someData = <span class="keyword">try</span> pretendToReadTestFile()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">FileReadingError</span>.<span class="type">FileNotFound</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The file was not found."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码块 “do” 包含了调用抛出错误的函数的代码。如果出现错误，将会跳转到对应的 catch 语句，很像 switch case 语句。同时，如果考虑不到所有可能的错误情况，则需要类似 Switch 语句中 “default” 或 if 语句中 “else” 的选项，只用 “catch” 来处理其余所有的 Swift Error：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> someData = <span class="keyword">try</span> pretendToReadTestFile()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Something weird happened."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="抛出错误的函数返回可选类型"><a href="#抛出错误的函数返回可选类型" class="headerlink" title="抛出错误的函数返回可选类型"></a>抛出错误的函数返回可选类型</h5><p>如果只需要返回值或是否有返回值，而不关心是什么错误，听起来这有点像 Swift 的可选类型。这样的话，即便返回值不是可选的，也可以告诉编译器“如果有错误，我也并不关心，只需要将返回值设置为 nil”。可以在 “try” 关键字后面使用问号，如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleData = <span class="keyword">try</span>? pretendToReadTestFile()</span><br><span class="line"><span class="comment">//possibleData now contains "nil"</span></span><br></pre></td></tr></table></figure><p>根据实际需要来决定使用 do-catch 语句还是使用上述方式来处理指定的错误。如果的确不需要明确错误原因，或者错误原因很明显，那么使用 “try?” 将更合适。如果是网络调用，错误是由于无效的 URL、连接失败还是无法找到主机对于你的 App 的用户有意义么？对于有的 App 或许有意义，但也有的没有意义，上面那三种情况都意味着没有拿到数据。既然没有请求到数据，那么 “nil” 已经可以告知你的代码如何处理此种情况。</p><h5 id="确保编译器不会抛出-Error"><a href="#确保编译器不会抛出-Error" class="headerlink" title="确保编译器不会抛出 Error"></a>确保编译器不会抛出 Error</h5><p>如果有使用问号的版本，那么你可以猜到这个地方可能会有感叹号的版本（译者注：可选类型和强制解包）。如果使用 “try!”，更像是强制解包可选类型。你可以调用抛出错误的函数，但如果真的抛出错误，App 将会崩溃。如果你确认调用不会出问题，可以使用这种方式。Apple 的 iBook 解释了一种原因，即使用抛出错误的函数来访问 App 的 bundle 中的文件。既然资源来自 App，那它就应该存在，所以不会出现 “File Not Found” 或其他类似错误。如果真出现了错误，那么应该考虑下是不是有更严重的问题。</p><p>如果我们的函数总会抛出错误，那这种方式肯定会引发崩溃，以下仅仅展示了如何使用（顺便看下崩溃是什么样）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> definitelyNoData = <span class="keyword">try</span>! pretendToReadTestFile()</span><br><span class="line"><span class="comment">//Execution was interrupted, reason:  EXC_BAD_INSTRUCTION</span></span><br><span class="line"><span class="comment">//error: 'try!' expression unexpectedly raised an error: FileReadingError.FileNotFound</span></span><br></pre></td></tr></table></figure><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><blockquote><p>译者注:所有贴出的代码都在 Xcode 7.3.1 进行了测试。</p></blockquote><p>Swift Team 在 Swift 中实现了错误的处理，这点我感到很满意。表面上看这是一种相当常见的处理方式，但实际上，这更高效，并且与其表亲 “Exception Handling” 相比危害更小。不用使用调用栈，仅仅通过不同的返回值来告诉我们错误的性质。</p><p>我希望这篇文章对读者有所帮助。如果真的是这样，请毫不犹豫地在 Twitter 或其他社交媒体上分享这片文章，任何分享都可以。当然，如果有任何疑问，也请毫不犹豫地到联系<a href="http://www.codingexplorer.com/contact/" target="_blank" rel="noopener">页面联系</a>我，或者在 Twitter 上 <a href="https://twitter.com/CodingExplorer" target="_blank" rel="noopener">@CodingExplorer</a>，我会尽量提供帮助的。谢谢！</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://itunes.apple.com/us/book/swift-programming-language/id881256329?mt=11&amp;uo=4&amp;at=10lJ3x&amp;ct=blog-SwiftErrorHandling" target="_blank" rel="noopener">The Swift Programming Language – Apple Inc.</a></li></ul><blockquote><p>译者注：目前在中国大陆 iBooks 不可用。<br>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Xcode 7.3.1, Swift 2.2
    
    </summary>
    
      <category term="Coding Explorer Blog" scheme="https://swift.gg/categories/Coding-Explorer-Blog/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Core ML入门：构建一个简单的图像识别应用</title>
    <link href="https://swift.gg/2018/05/28/coreml-introduction/"/>
    <id>https://swift.gg/2018/05/28/coreml-introduction/</id>
    <published>2018-05-28T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.535Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sai Kambampati，<a href="http://www.appcoda.com/coreml-introduction/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-14<br>译者：<a href="http://hulizhen.me" target="_blank" rel="noopener">智多芯</a>；校对：<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>，<a href="https://lision.me/" target="_blank" rel="noopener">Lision</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Apple 公司在 WWDC 2017 发布了几个令开发者感到兴奋的框架和 API，而在这些新框架中最受欢迎的绝对非 <a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="noopener">Core ML</a> 莫属了。开发者可以通过 Core ML 框架将机器学习模型集成到应用程序中，该框架最大的优点是使用它并不需要开发者具备额外的神经网络或机器学习知识。Core ML 框架的另一个特点是，只要开发者将已经训练好的数据模型转换成了 Core ML 模型即可使用。为了演示，本文将直接使用 Apple 开发者网站上提供的一个 Core ML 模型。闲话少说，下面开始学习 Core ML。</p><blockquote><p>注：本文要求使用 Xcode 9 beta 编写代码，还需要一个安装了 iOS 11 beta 的设备（译者注：也可使用 iOS 模拟器）用于测试文中实现的功能。虽然 Xcode 9 beta 同时支持 Swift 3.2 和 4.0，但文中所有的代码都使用了 Swift 4.0 编写。</p></blockquote><a id="more"></a><h2 id="什么是-Core-ML"><a href="#什么是-Core-ML" class="headerlink" title="什么是 Core ML"></a>什么是 Core ML</h2><blockquote><p>Core ML 使得开发者能够将各种各样的机器学习模型集成到应用程序中。它除了支持超过 30 层类型的广泛深度学习，还支持如树集成、<a href="https://en.wikipedia.org/wiki/Support_vector_machine" target="_blank" rel="noopener">SVMs</a> 和广义线性模型等标准模型。Core ML 建立在像 Metal 和 Accelerate 这样的底层技术之上，因此它能够无缝地充分利用 CPU 和 GPU 以实现性能最大化。机器学习模型可直接运行在设备上，以至于数据被分析时不需要脱离设备。</p><p>- <a href="https://developer.apple.com/machine-learning/" target="_blank" rel="noopener">关于 Core ML 的 Apple 官方文档</a></p></blockquote><p>Core ML 是今年在 WWDC 上随着 iOS 11 发布的一个全新的机器学习框架。通过 Core ML，开发者可以直接将机器学习模型集成到应用程序中。那么什么是机器学习呢？简单地说，机器学习是赋予计算机学习能力的应用，而不需要明确地对它编程。一个训练好的模型就是结合机器学习算法对一些数据集进行训练的结果。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/trained-model.png" alt=""></p><p>作为一个应用程序开发者，我们主要关心的是如何将机器学习模型应用到应用程序中以实现更有意思的功能。幸运的是，Apple 提供的 Core ML 框架大大简化了将不同的机器学习模型集成到应用程序中的过程。这为开发者开发如图像识别、自然语言处理、文本预测等功能提供了非常多的可能性。</p><p>现在你可能想知道将这种类型的人工智能加入到应用程序中会不会很困难，这就是最有意思的部分了，实际上 Core ML 非常易用。在本文中，你将会看到只要 10 行代码就可以将 Core ML 集成到应用程序中。</p><p>很酷吧？下面开始吧！</p><h2 id="演示程序概览"><a href="#演示程序概览" class="headerlink" title="演示程序概览"></a>演示程序概览</h2><p>本文将要实现的程序十分简单。该程序让用户拍摄或者从相册中选择一张照片，然后机器学习算法将会尝试预测照片中的物体。虽然预测结果可能并不完美，但你将借此了解到如何将 Core ML 应用到应用程序上。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-app-demo.png" alt=""></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先，打开 Xcode 9 beta 并创建一个新项目。为该项目选择单视图应用程序（<code>Single View App</code>）模板，并确保使用的语言设置为 Swift。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/xcode9-new-proj.png" alt=""></p><h2 id="创建用户界面"><a href="#创建用户界面" class="headerlink" title="创建用户界面"></a>创建用户界面</h2><blockquote><p>如果你不想从头开始搭建 UI 界面，可以从<a href="https://github.com/appcoda/CoreMLDemo/raw/master/CoreMLDemoStarter.zip" target="_blank" rel="noopener">这里下载起始项目</a>并直接跳到 Core ML 部分。</p></blockquote><p>下面就开始吧！首先打开 <code>Main.storyboard</code>，并添加一些 UI 元素到视图中。选择 storyboard 中的视图控制器，然后依次点击 Xcode 菜单栏：<code>Editor-&gt; Embed In-&gt; Navigation Controller</code>。随后即可看到一个导航栏出现在视图上方。将该导航栏命名为 Core ML（或者任何你觉得合适的名字）。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/pic3.png" alt=""></p><p> 放到视图底端并对其缩放，使其两端刚好与视图两端重合。这样就搭建好了该应用的界面。</p><p>虽然本文没涉及到自动布局，但还是强烈建议使用。如果你没法做到自动布局，那就直接在 storyboard 中选择你将要运行的设备类型。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-storyboard.png" alt=""></p><h2 id="实现拍照和相册功能"><a href="#实现拍照和相册功能" class="headerlink" title="实现拍照和相册功能"></a>实现拍照和相册功能</h2><p>既然已经搭好了界面，接着就开始实现功能吧。本节将实现相册和拍照按钮的功能。在 <code>ViewController.swift</code> 中，先遵从 <code>UIImagePickerController</code> 所要求的 <code>UINavigationControllerDelegate</code> 协议。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UINavigationControllerDelegate</span></span></span><br></pre></td></tr></table></figure><p>然后为之前的 <code>UILabel</code> 和 <code>UIImageView</code> 新增两个 IBOutlet。为了简单起见，本文分别将 <code>UIImageView</code> 和 <code>UILabel</code> 命名为 <code>imageView</code> 和 <code>classifier</code>。代码如下所示：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> classifier: <span class="type">UILabel</span>!</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着还需要实现对应按钮被点击的响应动作，在 <code>ViewController</code> 中添加如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">camera</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="type">UIImagePickerController</span>.isSourceTypeAvailable(.camera) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cameraPicker = <span class="type">UIImagePickerController</span>()</span><br><span class="line">    cameraPicker.delegate = <span class="keyword">self</span></span><br><span class="line">    cameraPicker.sourceType = .camera</span><br><span class="line">    cameraPicker.allowsEditing = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    present(cameraPicker, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">openLibrary</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> picker = <span class="type">UIImagePickerController</span>()</span><br><span class="line">    picker.allowsEditing = <span class="literal">false</span></span><br><span class="line">    picker.delegate = <span class="keyword">self</span></span><br><span class="line">    picker.sourceType = .photoLibrary</span><br><span class="line">    present(picker, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码创建了一个 <code>UIImagePickerController</code> 类型的常量并确保用户无法修改已拍摄的照片（无论该照片是刚拍摄的或者从相册中选择的）。然后将 <code>delegate</code> 设置为 <code>self</code>，最后将 <code>UIImagePickerController</code> 展示给用户。</p><p>至此还未添加 <code>UIImagePickerControllerDelegate</code> 对应的方法到 <code>ViewController.swift</code> 中，因此 Xcode 将会有错误提示。这里通过 <code>extension</code> 的形式来实现该协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</span><br><span class="line">        dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码对用户取消选择照片的动作做了相应处理。到目前为止代码大致如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> classifier: <span class="type">UILabel</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">camera</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="type">UIImagePickerController</span>.isSourceTypeAvailable(.camera) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> cameraPicker = <span class="type">UIImagePickerController</span>()</span><br><span class="line">        cameraPicker.delegate = <span class="keyword">self</span></span><br><span class="line">        cameraPicker.sourceType = .camera</span><br><span class="line">        cameraPicker.allowsEditing = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        present(cameraPicker, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">openLibrary</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> picker = <span class="type">UIImagePickerController</span>()</span><br><span class="line">        picker.allowsEditing = <span class="literal">false</span></span><br><span class="line">        picker.delegate = <span class="keyword">self</span></span><br><span class="line">        picker.sourceType = .photoLibrary</span><br><span class="line">        present(picker, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</span><br><span class="line">        dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保你有回到 storyboard 并为所有的 IBOutlet 和 IBAction 都建立好了连接。</p><p>为了访问摄像头和相册，还有做一件事。打开 <code>Info.plist</code> 并添加两项：<em>Privacy - Camera Usage Description</em> 和 <em>Privacy – Photo Library Usage Description</em>。这是因为从 iOS 10 开始，访问摄像头和相册需要指明访问原因。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-plist-privacy.png" alt=""></p><p>接下来将开始本文的核心部分了。再声明一次，如果你不想从头搭建界面，你可以<a href="https://github.com/appcoda/CoreMLDemo/raw/master/CoreMLDemoStarter.zip" target="_blank" rel="noopener">从这里下载起始项目</a>。</p><h2 id="集成-Core-ML-数据模型"><a href="#集成-Core-ML-数据模型" class="headerlink" title="集成 Core ML 数据模型"></a>集成 Core ML 数据模型</h2><p>现在开始将 Core ML 数据模型集成到应用程序中。正如前文所提到的，要使 Core ML 能正常工作还需要提供一个训练好的模型。你可以使用自己训练的模型，但本文将使用 Apple 开发者网站上提供的已经训练好的模型。</p><p>在 Apple 开发者网站的 <a href="https://developer.apple.com/machine-learning/" target="_blank" rel="noopener">Machine Learning</a> 页面向下滚动到底部就可以看到 4 个已经训练好的 Core ML 模型。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-pretrained-model.png" alt=""></p><p>本教程将使用 <em>Inception v3</em> 模型，但你也可以尝试下其他三个。在下载了 <em>Inception v3</em> 模型后，将其添加到 Xcode 项目中，然后看看 Xcode 都显示了哪些信息。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-model-desc.png" alt=""></p><blockquote><p>备注：请确保该项目的 <code>Target Membersip</code> 被选中了，否则应用将无法访问到该文件。</p></blockquote><p>在上面的截图中，可以看出该数据模型的类型为神经网络分类器。其他需要注意的信息还有模型评估参数，它表示该模型的输入和输出参数。本文使用的模型需要输入一张 <code>299x299</code> 的图像，并输出最为可能的类型及其对应每个类型的概率。</p><p>该截图中的另一个重要信息是模型类（model class），它是机器学习模型（<code>Inceptionv3</code>）自动生成的可以直接在代码中使用的类。点击 <code>Inceptionv3</code> 右边的箭头就可以看到该类的源码。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/inceptionv3-class.png" alt=""></p><p>现在将该模型添加到代码中。打开 <code>ViewController.swift</code> 文件，在开头导入 Core ML 框架：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> CoreML</span><br></pre></td></tr></table></figure><p>接着，为 <code>Inceptionv3</code> 模型声明一个 <code>model</code> 变量，并在 <code>viewWillAppear()</code> 方法中初始化：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> model: <span class="type">Inceptionv3</span>!</span><br><span class="line"> </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">    model = <span class="type">Inceptionv3</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我知道你现在在想什么。</p><p>“为什么不早点对这个模型进行初始化？”</p><p>“在 <code>viewWillAppear</code> 方法中定义它的意义何在？”</p><p>亲爱的朋友，它的意义在于，当应用程序尝试识别图像中的物体时，速度会快得多。（译者注：直接在声明 <code>model</code> 变量时直接初始化似乎也没什么影响，读者可自行测试。）</p><p>现在回到 <code>Inceptionv3.mlmodel</code> ，该模型接受的唯一输入参数是一张尺寸为 <code>299x299</code> 的图像，所以接下来要处理的就是如何将一张图像转换成这种尺寸。</p><h2 id="转换图片"><a href="#转换图片" class="headerlink" title="转换图片"></a>转换图片</h2><p>在 <code>ViewController.swift</code> 的 extension 中，将代码更新成如下代码。它实现了 <code>imagePickerController(_:didFinishPickingMediaWithInfo)</code> 方法用于处理选中的图像：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</span><br><span class="line">        dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any])</span></span> &#123;</span><br><span class="line">        picker.dismiss(animated: <span class="literal">true</span>)</span><br><span class="line">        classifier.text = <span class="string">"Analyzing Image..."</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image = info[<span class="string">"UIImagePickerControllerOriginalImage"</span>] <span class="keyword">as</span>? <span class="type">UIImage</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="type">UIGraphicsBeginImageContextWithOptions</span>(<span class="type">CGSize</span>(width: <span class="number">299</span>, height: <span class="number">299</span>), <span class="literal">true</span>, <span class="number">2.0</span>)</span><br><span class="line">        image.draw(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">299</span>, height: <span class="number">299</span>))</span><br><span class="line">        <span class="keyword">let</span> newImage = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()!</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> attrs = [kCVPixelBufferCGImageCompatibilityKey: kCFBooleanTrue, kCVPixelBufferCGBitmapContextCompatibilityKey: kCFBooleanTrue] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">        <span class="keyword">var</span> pixelBuffer : <span class="type">CVPixelBuffer</span>?</span><br><span class="line">        <span class="keyword">let</span> status = <span class="type">CVPixelBufferCreate</span>(kCFAllocatorDefault, <span class="type">Int</span>(newImage.size.width), <span class="type">Int</span>(newImage.size.height), kCVPixelFormatType_32ARGB, attrs, &amp;pixelBuffer)</span><br><span class="line">        <span class="keyword">guard</span> (status == kCVReturnSuccess) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="type">CVPixelBufferLockBaseAddress</span>(pixelBuffer!, <span class="type">CVPixelBufferLockFlags</span>(rawValue: <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">let</span> pixelData = <span class="type">CVPixelBufferGetBaseAddress</span>(pixelBuffer!)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> rgbColorSpace = <span class="type">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">CGContext</span>(data: pixelData, width: <span class="type">Int</span>(newImage.size.width), height: <span class="type">Int</span>(newImage.size.height), bitsPerComponent: <span class="number">8</span>, bytesPerRow: <span class="type">CVPixelBufferGetBytesPerRow</span>(pixelBuffer!), space: rgbColorSpace, bitmapInfo: <span class="type">CGImageAlphaInfo</span>.noneSkipFirst.rawValue) <span class="comment">//3</span></span><br><span class="line">        </span><br><span class="line">        context?.translateBy(x: <span class="number">0</span>, y: newImage.size.height)</span><br><span class="line">        context?.scaleBy(x: <span class="number">1.0</span>, y: -<span class="number">1.0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">UIGraphicsPushContext</span>(context!)</span><br><span class="line">        newImage.draw(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: newImage.size.width, height: newImage.size.height))</span><br><span class="line">        <span class="type">UIGraphicsPopContext</span>()</span><br><span class="line">        <span class="type">CVPixelBufferUnlockBaseAddress</span>(pixelBuffer!, <span class="type">CVPixelBufferLockFlags</span>(rawValue: <span class="number">0</span>))</span><br><span class="line">        imageView.image = newImage</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>imagePickerController(_:didFinishPickingMediaWithInfo)</code> 函数中的代码解释如下：</p><ol><li>#7-11 行：该方法的前几行将选中的图像从 <code>info</code> 字典中（使用 <code>UIImagePickerControllerOriginalImage</code>键）取出。另外，一旦有图像被选中就 Dismiss <code>UIImagePickerController</code>。</li><li>#13-16 行：因为本文使用的模型只接受尺寸为 <code>299x299</code> 的图像，因此我们将选中的图像转换为一个正方形，然后将其赋值给另一个常量 <code>newImage</code>。</li><li>#18-23 行：将 <code>newImage</code> 转换为 <code>CVPixelBuffer</code>。对于不熟悉 <code>CVPixelBuffer</code> 的读者来说，它就是一个用来在内存中存放像素的图像缓冲区，详情可查阅<a href="https://developer.apple.com/documentation/corevideo/cvpixelbuffer-q2e" target="_blank" rel="noopener">这里</a>。</li><li>#31-32 行：将该图像的所有像素转换到独立于设备的 RGB 颜色空间。接着创建一个容纳所有像素数据的 <code>CGContext</code>，当需要渲染（或者改变）该上下文的一些基本属性时就可以很轻松的调用它。这也是我们这两行所做的事情——对图像进行平移和缩放。</li><li>#34-38 行：最后，将该图形上下文放入当前上下文中，渲染图像，从栈顶删除该上下文，再将 <code>imageView.image</code> 设置成 <code>newImage</code>。</li></ol><p>如果你现在无法理解以上的大部分代码也没关系，这只是一些超出本文范围的 <code>Core Image</code> 的高级代码片段而已。你只需要知道上面的代码将选中的图像转换成了数据模型能够接受的形式。我建议你能改动下代码中的数字并留意对应的结果，以更好地理解上面的代码。</p><h2 id="使用-Core-ML"><a href="#使用-Core-ML" class="headerlink" title="使用 Core ML"></a>使用 Core ML</h2><p>现在我们把注意力重新放回到 Core ML 上来。我们使用了 Inceptionv3 模型来实现对象识别。借助 Core ML，我们所需要做的只是添加几行代码。将以下代码段粘贴到 <code>imageView.image = newImage</code>  之后。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> prediction = <span class="keyword">try</span>? model.prediction(image: pixelBuffer!) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">classifier.text = <span class="string">"I think this is a <span class="subst">\(prediction.classLabel)</span>."</span></span><br></pre></td></tr></table></figure><p>这就完了！<code>Inceptionv3</code> 类自动生成了一个名为 <code>prediction(image:)</code> 的方法，可以用来预测给定图像中出现的物体。这里我们将调整后的图像以 <code>pixelBuffer</code> 作为参数传给了该方法。一旦 <code>String</code> 类型的预测结果返回了，就将 <code>classifier</code> 标签更新为识别出的物体名称。</p><p>是时候测试一下这个应用了。编译并在模拟器或者你的 iPhone（安装了 iOS 11 beta）上运行该应用，从相册选择或使用摄像头拍摄一张照片，该应用将识别出图像中有什么物体。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-successful-case.jpg" alt=""></p><p>在测试该应用的过程中，你可能会注意到它并不总能准确地做出预测。其实这并不是代码的问题，问题出在被训练过的模型上。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-failed-case.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望你已经懂得了如何将 Core ML 集成到你的应用中，本文仅仅是一篇入门教程而已。如果你对将训练好的 Caffe、Keras 或者 SciKit 模型转换成 Core ML 模型感兴趣的话，请 <a href="http://facebook.com/appcodamobile" target="_blank" rel="noopener">继续关注</a> 我们的下一篇 Core ML 系列教程。我将教你如何将一个模型转换为 Core ML 模型。</p><p>如果想参考本文的演示应用程序，请 <a href="https://github.com/appcoda/CoreMLDemo" target="_blank" rel="noopener">查看 GitHub 上的完整项目</a>。</p><p>关于 Core ML 框架的更详细信息，请参考 <a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="noopener">官方 Core ML 文档</a>。也可以参考 Apple 的 WWDC 2017 视频：</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2017/703/" target="_blank" rel="noopener">Introducing Core ML</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2017/710/" target="_blank" rel="noopener">Core ML in Depth</a></li></ul><p>关于 Core ML 如果你还有什么想说的，记得给我们留言哦！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Sai Kambampati，&lt;a href=&quot;http://www.appcoda.com/coreml-introduction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-06-14&lt;br&gt;译者：&lt;a href=&quot;http://hulizhen.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;智多芯&lt;/a&gt;；校对：&lt;a href=&quot;https://weibo.com/1743643682/profile?topnav=1&amp;amp;wvr=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;liberalism&lt;/a&gt;，&lt;a href=&quot;https://lision.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lision&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Apple 公司在 WWDC 2017 发布了几个令开发者感到兴奋的框架和 API，而在这些新框架中最受欢迎的绝对非 &lt;a href=&quot;https://developer.apple.com/documentation/coreml&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Core ML&lt;/a&gt; 莫属了。开发者可以通过 Core ML 框架将机器学习模型集成到应用程序中，该框架最大的优点是使用它并不需要开发者具备额外的神经网络或机器学习知识。Core ML 框架的另一个特点是，只要开发者将已经训练好的数据模型转换成了 Core ML 模型即可使用。为了演示，本文将直接使用 Apple 开发者网站上提供的一个 Core ML 模型。闲话少说，下面开始学习 Core ML。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：本文要求使用 Xcode 9 beta 编写代码，还需要一个安装了 iOS 11 beta 的设备（译者注：也可使用 iOS 模拟器）用于测试文中实现的功能。虽然 Xcode 9 beta 同时支持 Swift 3.2 和 4.0，但文中所有的代码都使用了 Swift 4.0 编写。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="AppCoda" scheme="https://swift.gg/categories/AppCoda/"/>
    
    
      <category term="机器学习" scheme="https://swift.gg/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>苹果的深度学习框架：BNNS 和 MPSCNN 的对比</title>
    <link href="https://swift.gg/2018/05/24/apple-deep-learning-bnns-versus-metal-cnn/"/>
    <id>https://swift.gg/2018/05/24/apple-deep-learning-bnns-versus-metal-cnn/</id>
    <published>2018-05-24T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.535Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：MATTHIJS HOLLEMANS，<a href="http://machinethink.net/blog/apple-deep-learning-bnns-versus-metal-cnn/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-02-07<br>译者：<a href="undefined">TonyHan</a>；校对：<a href="http://www.desgard.com/" target="_blank" rel="noopener">冬瓜</a>，<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>从 iOS 10 开始，苹果在 iOS 平台上引入了两个深度学习的框架：BNNS 和 MPSCNN。</p><ul><li><p>BNNS：全称为香蕉（bananas，译者注：此处开玩笑），Basic Neural Network Subroutines，是 <a href="https://developer.apple.com/reference/accelerate" target="_blank" rel="noopener">Accelerate  框架</a>的一部分。这个框架能够充分利用 CPU 的快速矢量指令，并提供一系列的数学函数。</p></li><li><p>MPSCNN 是 <a href="https://developer.apple.com/metal/" target="_blank" rel="noopener">Metal Performance Shaders</a> 的一部分。Metal Performance Shaders 是一个经过优化过的计算内核框架，并且可以运行在 GPU （而不是 CPU）上。</p></li></ul><p>所以，作为 iOS 开发者，有了两个用于做深度学习的框架，它们有很多类似的地方。</p><p>应该选择哪个呢？</p><p>在这篇文章中，我们将针对 BNNS 和 MPSCNN 进行对比来显示出这两者的差异。而且我们会对这两个 API 进行速度测试，来看下谁更快一些。</p><a id="more"></a><h2 id="为什么要优先使用-BNNS-或-MPSCNN-？"><a href="#为什么要优先使用-BNNS-或-MPSCNN-？" class="headerlink" title="为什么要优先使用 BNNS 或 MPSCNN ？"></a>为什么要优先使用 BNNS 或 MPSCNN ？</h2><p>我们首先讨论这两个框架的作用。</p><p>目前 BNNS 和 MPSCNN 在<strong>卷积神经网络</strong>领域中用于<strong>变分推断</strong>。</p><p>与类似的 <a href="https://tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a>（使用此方案可以通过构建一个计算图，从头开始建立你的神经网络）相比，BNNS 和 MPSCNN 提供更高级的 API，不需要担心你的数学。</p><p>这也有一个缺点：BNNS 和 MPSCNN 的功能远远少于其他框架，如 TensorFlow。它们更容易上手，但同时限制了所能做的深度学习的种类。</p><p>苹果的深度学习框架只是为了一个目的：通过网络层级<strong>尽可能快地传递数据</strong>。</p><h4 id="一切都与层级有关"><a href="#一切都与层级有关" class="headerlink" title="一切都与层级有关"></a>一切都与层级有关</h4><p>你可以将神经网络想象为数据流经的管道。管道中的不同阶段便是网络<strong>层级</strong>。这些层级以不同的方式转换你的数据。同时深度学习，我们可以使用多达 10 层甚至 100 层的神经网络。</p><p><img src="/img/articles/apple-deep-learning-bnns-versus-metal-cnn/Cat2Probability@2x.png1527128648.556878" alt="Cat2Probability"></p><p>层级有不同的种类。BNNS 和 MPSCNN 提供的有：卷积层（convolutional layer）、池化层（pooling layer）、全连接层（Fully Connected Layer）和规范化层（normalization layer）。</p><p>在 BNNS 和 MPSCNN 中，<strong>层级是主要的建构单元</strong>。你可以创建层级对象，将数据放入层级中，然后再从层级中读出结果。顺便说一句，BNNS 称它们为“过滤器”，而不是层级：数据以一种形式进入过滤器并以另一种形式从过滤器出来。</p><p>为了说明层级作为建构单元的思想，下面描述了数据如何通过一个简单的神经网络在 BNNS 中流动：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为中间结果和最终结果分配内存。</span></span><br><span class="line"><span class="keyword">var</span> tempBuffer1: [<span class="type">Float</span>] = . . .</span><br><span class="line"><span class="keyword">var</span> tempBuffer2: [<span class="type">Float</span>] = . . .</span><br><span class="line"><span class="keyword">var</span> results: [<span class="type">Float</span>] = . . .</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对输入的数据（比如说一张图片）应用第一层级。</span></span><br><span class="line"><span class="type">BNNSFilterApply</span>(convLayer, inputData, &amp;tempBuffer1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对第一层级的输出应用第二层级。</span></span><br><span class="line"><span class="type">BNNSFilterApply</span>(poolLayer, tempBuffer1, &amp;tempBuffer2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用第三和最后的层级。结果通常是概率分布。</span></span><br><span class="line"><span class="type">BNNSFilterApply</span>(fcLayer, tempBuffer2, &amp;results)</span><br></pre></td></tr></table></figure><p>要使用 BNNS 和 MPSCNN 构建神经网络，只需要设置层级并向它们发送数据。框架负责处理层级<em>内</em>发生的事情，但你需要做的是连接层级。</p><p>不幸的是，这可能有点无聊。例如，通过加载一个<a href="http://caffe.berkeleyvision.org/model_zoo.html" target="_blank" rel="noopener">提前训练好的 caffemodel 文件</a>来获取一个完整配置的“神经网络”是行不通的。你必须手写代码，仔细地创建层级并进行配置来复制出网络的设计。这样就很容易犯错。</p><h4 id="BNNS-和-MPSCNN-不做训练"><a href="#BNNS-和-MPSCNN-不做训练" class="headerlink" title="BNNS 和 MPSCNN 不做训练"></a>BNNS 和 MPSCNN 不做训练</h4><p>在你使用神经网络之前，你必须先<strong>训练</strong>它。训练需要大量的数据和耐心——至少几个小时，甚至几天或几周，取决于你可以投入多少计算能力。你肯定不想在手机上进行训练（这可能会使手机着火）。</p><p>当得到一个训练网络，便可以用来进行<strong>预测</strong>。这被称为“推断”。训练本应需要使用重型计算机，但在现代的手机上进行推断是完全可能的。</p><p>这正是 BNNS 和 MPSCNN 设计的目的。</p><h4 id="仅限卷积网络"><a href="#仅限卷积网络" class="headerlink" title="仅限卷积网络"></a>仅限卷积网络</h4><p>但是这两个 API 都有限制。目前，BNNS 和 MPSCNN 仅支持一种深度学习：卷积神经网络（CNN）。CNN 的主要应用场景是<strong>机器视觉</strong>任务。例如，你可以使用 CNN 来<a href="http://machinethink.net/blog/convolutional-neural-networks-on-the-iphone-with-vggnet/" target="_blank" rel="noopener">描述给定照片中的对象</a>。</p><p>虽然 CNN 很牛逼，但在 BNNS 或 MPSCNN 中无法支持其他深度学习架构（例如递归神经网络）。</p><p>然而，已经提供的建构单元（卷积层，池化层和全连接层）高效并且为构建更复杂的神经网络提供了<strong>良好的基础</strong>，即便你必须手工编写一些代码来填补 API 中的空白。</p><ul><li>备注：Metal Performance Shaders 框架还附带有用于在 GPU 上进行快速矩阵乘法的计算内核。同时，Accelerate 框架包含用于在 CPU 上执行相同操作的 BLAS 库。所以，即使 BNNS 或 MPSCNN 不包含你所需的深层学习架构的所有层级类型，你也可以借助这些矩阵例程来推出自己的层级类型。而且，如果有必要的话，你可以用 Metal Shading Language 编写你自己的 GPU 代码。</li></ul><h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><p>假如它们的功能一致，那为何 Apple 要给我们两个 API？</p><p>很简单：BNNS 运行在 CPU 上，MPSCNN 运行在 GPU 上。有时使用 CPU 速度更快，有时使用 GPU 更快。</p><ul><li>“等一下…难道 GPU 不是高度并行的计算怪物么？难道我们不应该一直在 GPU 上运行我们的深层神经网络吗？！”</li></ul><p>并没有。对于培训，你一定希望通过 GPU 来进行大规模并行计算（即使只是一个许多 GPU 的集群）但推论时，使用枯燥的旧的 2 或 4 核 CPU 可能会更快。</p><p>下面我将详细讨论的速度差异，但首先让我们来看看这两个 API 是有哪些不同。</p><ul><li>备注：Metal Performance Shaders 框架仅适用于 iOS 和 tvOS，不适用于 Mac。BNNS 也适用于 macOS 10.12 及更高版本。如果你想要保证 iOS 和 MacOS 之间的深度学习代码的可移植性，BNNS 是你唯一的选择（或使用第三方框架）。</li></ul><h4 id="它是-Swifty-的么"><a href="#它是-Swifty-的么" class="headerlink" title="它是 Swifty 的么?"></a>它是 Swifty 的么?</h4><p>BNNS 实际上是一个基于 C 的 API。如果你使用 Objective-C 是可以的，但 Swift 使用它有点麻烦。相反，MPSCNN 更兼容 Swift。</p><p>不过，你必须接受这些 API 比所谓的 UIKit 更低级的事实。Swift 并没有将所有的东西都抽象成简单的类型。你经常需要使用 Swift 的 <code>UnsafeRawPointer</code> 指针来处理原始字节。</p><p>Swift 也没有一个原生的 <strong>16 位浮点类型</strong>，但是 BNNS 和 MPSCNN 在使用这样的半精度浮点数时才是最高效的。你将不得不使用 Accelerate 框架在常规类型和半精度浮点数之间进行转换。</p><p>从理论上讲，当使用 MPSCNN 时，你不必自己编写任何 GPU 代码，但实际上我发现某些预处理步骤——如从每个图像像素中减去平均 RGB 值，使用 Metal Shading Language（基于 C++ 实现） 中的定制的计算内核是最容易实现的。</p><p>所以，即使你在 Swift 中使用这两个框架，也要准备好用这两个 API 来进行一些底层级别的 Hacking 行为。</p><h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p>随着数据在神经网络中从一层流向下一层，数据在每层都会以某种方式被转换。层级应用了激活函数，来作为此转换的一部分。没有这些激活函数，神经网络将无法学习非常有趣的事情。</p><p>激活函数有很多选择，BNNS 和 MPSCNN 都支持最常用的功能：</p><ul><li>修正线性单元（ReLU）和带泄漏修改线性单元（Leaky ReLU）</li><li>逻辑函数（logistic sigmoid）</li><li>双曲正切函数（<em>tanh</em>）和 扩展双曲正切函数（scaled <em>tanh</em>）</li><li>绝对值</li><li>恒等函数（the identity function），它传递数据而不改变数据</li><li>线性（只在 MPSCNN 上）</li></ul><p>你会认为这与 API 一样简单，但是奇怪的是，与 MPSCNN 相比，BNNS 有一个不同的定义这些激活函数的方式。</p><p>例如，BNNS 定义了两种类型，<code>BNNSActivationFunctionRectifiedLinear</code> 和 <code>BNNSActivationFunctionLeakyRectifiedLinear</code>，但在 MPSCNN 中，只有一种 <code>MPSCNNNeuronReLU</code> 类型，使用 <code>alpha</code> 参数来标记是否为带泄漏的修正线性单元（Leaky ReLU）。同样的还有双曲正切函数（tanh）和 扩展双曲正切函数（scaled tanh）。</p><p>可以肯定地说，MPSCNN 采用比 BNNS 更灵活和可定制的方法。整个 API 层面都是如此。</p><p>例如：MPSCNN 允许您通过继承 <code>MPSCNNNeuron</code> 并编写一些 GPU 代码来创建自己的激活函数。使用 BNNS 就无法实现，因为没有用于定制的激活函数的 API；只提供了枚举。如果你想要的激活函数不在列表中，那么使用 BNNS 就会掉进大坑。</p><ul><li><p>17年2月10号更新：以上内容有点误导，所以我应该澄清下。由于 BNNS 在 CPU 上运行，你可以简单地获取层级的输出并根据你的喜好进行修改。如果你需要一种特殊的激活函数，你可以在 Swift 中自己实现（最好使用 Accelerate 框架）并在进入下一层之前将其应用于上一层的输出。所以 BNNS 在这方面的能力不亚于 Metal。</p></li><li><p>17年6月29日更新：关于 <code>MPSCNNNeuron</code> 子类的澄清：如果你这样做，实际上并不能使用 <code>MPSCNNConvolution</code> 的子类。这是因为 MPS 在 GPU 内核中执行激活函数时使用了一个技巧，但这只适用于 Apple 自己的 MPSCNNNeuron 子类，不适用于你自己创建的任何子类。</p></li></ul><p>事实上，在 MPSCNN 中，<em>一切</em>都是 <code>MPSCNNKernel</code> 的一个子类。这意味着你可以单独使用一个激活函数，如 <code>MPSCNNNeuronLinear</code>，就像它是一个单独的层级一样。在预处理步骤中，这对以常量进行缩放数据是很有用的。（顺便说一句，BNNS 没有类似于“线性”的激活函数。）</p><ul><li>备注：在我看来，感觉就像 BNNS 和 MPSCNN 是由 Apple 内部不同的团体创建的。它们有非常相似的功能，但它们的 API 之间有一些奇怪的差异。我不在 Apple 公司工作，所以我不知道这些差异存在的原因。也许是出于技术或性能的原因。但是你应该知道 BNNS 和 MPSCNN 不是“热插拔”的。如果你想要知道在 CPU 或 GPU 上进行推理时哪种方法最快，你将不得不实现两次深度学习网络。</li></ul><h4 id="层级类型"><a href="#层级类型" class="headerlink" title="层级类型"></a>层级类型</h4><p>我之前提到深层神经网络是由不同类型的层级组成的：</p><ul><li>卷积（Convolutional）</li><li>池化（Pooling），最大值和平均值</li><li>完全连接（Fully-connected）</li></ul><p>BNNS 和 MPSCNN 都实现了这三种层级类型，但是每种 API 的实现方式都有细微差别。</p><p>例如，BNNS 可以在池化层中使用激活函数，但是 MPSCNN 不行。但是，在 MPSCNN 中，你可以将激活函数添加到池化层后面作为单独的一层，所以最终这两个 API 能实现相同的功能，但是它们实现的路径不同。</p><p>在 MPSCNN 中，完全连接层被视为卷积的一个特例，而在 BNNS 中，它被实现为矩阵向量乘法。实践中并不会有差别，但是这表明这两个框架采取了不同的方法来解决同样的问题。</p><p>我觉得对于开发者来说，<strong>MPSCNN 使用起来更方便</strong>。</p><p>当对图像使用卷积时，除非添加“填充”像素，否则输出图像会缩小一些。使用 MPSCNN，就不必担心这一点：你只需告诉它，希望输入和输出图像有多大。使用 BNNS 你就必须自己计算填充量。像这样的细节让 MPSCNN 成为更易用的 API。</p><p>除了基础层级，MPSCNN 还提供以下层级：</p><ul><li>归一化（特征归一化、跨通道归一化（弱化）、局部对比度归一化）</li><li>Softmax，也称为归一化指数函数</li><li>对数 Softmax，即使用 Softmax 函数并配合 log 似然代价函数</li><li>激活函数层</li></ul><p>这些额外的层级类型无法在 BNNS 中找到。</p><p>对于规范化层来说，这可能不是什么大问题，因为我觉得它们并不常见，但 softmax 是大多数卷积网络在某些时候需要做的事情（通常在最后）。</p><p>softmax 函数将神经网络的输出转化为概率分布：“我 95％ 肯定这张照片是一只猫，但只有 5％ 确定它是一只 <code>Pokémon</code> 。”</p><p>在 BNNS 中没有提供 softmax 是有点奇怪的。在 Accelerate 框架中使用 vDSP 函数来写代码实现并不难，但是也不是很方便。</p><h4 id="学习参数"><a href="#学习参数" class="headerlink" title="学习参数"></a>学习参数</h4><p>训练神经网络时，训练过程会调整一组数字来表示网络正在学习什么。这些数字被称为<strong>学习参数</strong>。</p><p>学习参数由所谓的权重和偏差值组成，这些值只是一些浮点数。当你向神经网络发送数据时，各层级实际上将你的数据乘以这些权重，添加偏差值，然后再应用激活函数。</p><p>创建层级时，需要为每个层级指定权重和偏差值。这两个 API 只需要一个原始指针指向浮点值的缓冲区。需要由你来确保这些数字以正确的方式组织。如果这里操作错误，神经网络将会输出垃圾数据。</p><p>你可能猜到了：BNNS 和 MPSCNN 为权重使用不同的内存分配。😅</p><p>对于 MPSCNN 权重数组看起来像这样：</p><p><code>weights[ outputChannel ][ kernelY ][ kernelX ][ inputChannel ]</code></p><p>但是对于 BNNS 来说，顺序是不同的：</p><p><code>weights[ outputChannel ][ inputChannel ][ kernelY ][ kernelX ]</code></p><p>我认为 MPSCNN 将输入通道放在最后的原因是，这样可以很好地映射到存储数据的 <code>MTLTexture</code>s 中的 RGBA 像素。但是对于 BNNS 所使用的 CPU 矢量指令，将输入通道视为单独的内存块会更高效。</p><p>这种差异对于开发者来说不是一个大问题，但是当你导入训练好的模型时你需要<strong>知道权重的内存分配</strong>。</p><p>备注：你可能需要编写一个转换脚本来导出培训工具中的数据，例如 TensorFlow 或 Caffe，并将其转换为 BNNS 或 MPSCNN 预期的格式。这两个 API 都不能读取这些工具所保存的模型，它们只接受原始的浮点值的缓冲数据。</p><p>MPSCNN 总是复制权重和偏差值，并将它们作为 16 位浮点内部存储。由于你必须将它们作为单精度浮点数提供，因此这有效地将你的学习参数的精度减半。</p><p>BNNS 在这里比较开放一些：它可以让你选择你想要存储学习参数的格式，也可以让你选择不复制。</p><p>将权重加载到网络中仅仅在创建网络时的 App 启动时起到重要作用。但是，如果你有大量的权重，你仍然需要认真对待。我的 <a href="http://machinethink.net/blog/convolutional-neural-networks-on-the-iphone-with-vggnet/" target="_blank" rel="noopener">VGGNet implementation</a> 不能在 iPhone 6 上工作，因为 App 试图一次性将所有权重加载到 MPSCNN 时导致内存不足。（可以先创建大的层级，然后是再创建较小的层级。）</p><h4 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h4><p>一旦你创建了所有的层级对象，你终于可以开始使用神经网络进行推断啦！</p><p>正如你所看到的，BNNS 或 MPSCNN 都没有真正的“神经网络”的概念，他们只能看到每个层级。你需要逐个将数据放入这些层级中的每一层。</p><p>作为神经网络的用户，你关心的数据是进入第一层（例如一张图片）的输入和从最后一层出来的输出（这张图片是猫的概率）。其他在各层之间传递的数据，只是临时的中间结果。</p><p>那么你需要输入什么格式的数据？</p><p>MPSCNN 要求将所有数据放置在一个特殊的 <code>MPSImage</code> 对象内，这个对象实际上是 2D 纹理的集合。如果你正在使用图片，这会非常有意义 - 但是如果你的数据不是图片，则需要将其转换为 Metal 纹理。这会消耗 CPU 的性能。（你可以使用 Accelerate 框架来解决这个问题。）</p><p>备注：iOS 设备使用统一的内存模型，这意味着 CPU 和 GPU 访问相同的 RAM 芯片。与桌面计算机或服务器上的情况不同，你不需要将数据复制到 GPU。所以至少你的 iOS App 不会有这些性能消耗。</p><p>另一方面，BNNS 只需要一个指向浮点值缓冲区的指针。不需要将数据加载到特定对象中。所以这似乎比使用纹理更快…是么？</p><p>这样有一个重要的限制：在 BNNS 中，不同“通道”中的输入不能交错。</p><p>如果你的输入是图片，那么它有三个通道：一个用于红色像素，一个用于绿色像素，另一个用于蓝色像素。问题是像 PNG 或 JPEG 这样的图像文件会作为交错的 RGBA 值被加载到内存中。BNNS 并不会接受这种情况。</p><p><img src="/img/articles/apple-deep-learning-bnns-versus-metal-cnn/InterleavedPlanar@2x.png1527128648.7662659" alt=""></p><p>目前没有办法告诉 BNNS 使用红色像素值作为通道 0，绿色像素值作为通道 1，蓝色值作为通道 2，并跳过 alpha 通道。相反，你将不得不重新排列像素数据，以便输入缓冲区的首先包含所有 R 值，然后是所有 G 值，然后是所有 B 值。</p><p>我们若采取这种预处理，就会占用宝贵的计算时间。其次，也许这些限制允许 BNNS 在其层级如何执行其的计算方面做一定的优化，从而使整个事情是个净增益。但这谁也不知道。</p><p>在任何情况下，如果您使用 BNNS 处理图像（CNNs主要的用途）那么你可能需要对输入数据进行一些调整以获得正确的格式。</p><p>还有<strong>数据类型</strong>的问题。</p><p>BNNS 和 MPSCNN 都允许你将输入数据指定为浮点值（16 位和 32 位）或整数（8、16 或 32 位）。你想将浮点数据作为网络的输入，你可能无法选择输入数据的格式。</p><p>通常，当你加载 PNG 或 JPEG 图像，或者从手机相机中取出静止图像时，会得到一个 8Bit 纹理，该纹理使用无符号的 8 位整数作为像素的 RGBA 值。使用 MPSCNN 这是没有问题的：纹理会自动转换为浮点值。</p><p>用 BNNS 你可以指定 <code>Int8</code> 作为图像的数据类型，但是我实践后发现是行不通的。其实也许是因为我没有投入大量的时间来研究它。由于我要重新修改输入图像的通道，于是顺便就轻松地将像素数据转换为浮点数。</p><p>备注：即使 BNNS 允许你指定整数作为数据和权重的数据类型，它在内部也会将其转换为浮点数据，进行计算，然后将结果转换为整数。为了获得最好的速度，你可能想要跳过这个转换步骤，并且总是直接处理浮点数据，即使它们占用了 2 到 4 倍的内存。</p><h4 id="临时数据"><a href="#临时数据" class="headerlink" title="临时数据"></a>临时数据</h4><p>在 BNNS 和 MPSCNN 中，每个层级都需要处理。你将数据放入一个层级，并从一个层级中获取数据。</p><p>深层网络将会有很多层级。我们只关心最后一层的输出，而不关心所有其他层的输出。但是我们仍然需要将这些中间结果存储在某个地方，即使它们只用了一小会儿。</p><p>MPSCNN 对此有一个特殊的对象，<code>MPSTemporaryImage</code>。它就像一个 <code>MPSImage</code>，但只能使用一次。写入一次数据，读取一次数据。之后，它的内存将被回收。（如果您熟悉 Metal，它们是使用 Metal 的资源堆来实现的。）</p><p>你应该尽可能地使用 <code>MPSTemporaryImage</code>，因为这样可以避免大量的内存分配和释放。</p><p>使用 BNNS 的话就得靠自己。你需要自己管理临时数据缓冲区。幸运的是，它非常简单：您可以分配一个或两个大数组，然后在这些层级之间重复使用它们。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>你可能想要在后台线程中构建网络层级。加载学习参数的所有数据可能需要几秒钟的时间。</p><p>在后台线程上执行推断也是一个好主意。</p><p>使用足够深的神经网络，推断可能需要 0.1 到 0.5 秒之间的时间，这样的延迟对于用户是很明显的。</p><p>使用 MPSCNN 创建一个命令队列和一个命令缓冲区，然后通知所有层级编码到命令缓冲区中，最后将工作提交给 GPU。GPU 完成后，会通过回调通知你。</p><p>每项工作的编码都可以在后台线程中进行，你不需要做任何事情来进行同步。</p><p>备注：在实时情况下（例如，将摄像机的实时视频帧提供给神经网络时），你希望 GPU 保持繁忙状态，并且避免 CPU 和 GPU 相互等待的情况。当 GPU 仍在处理前一帧时，CPU 应该已经编码了下一个视频帧。你需要使用 <code>MPSImage</code> 对象数组，并通过信号量保证对它们的同步访问——但说实话，如果现在的移动设备能够实时地进行深度学习，我会感到非常惊讶。</p><p>BNNS 在 CPU 上工作，所以你可以在后台线程中开始工作，然后阻塞，直到 BNNS 完成。</p><p>最好让 BNNS 弄清楚如何在可用的 CPU 内核上分割工作，但是有一个配置选项告诉 BNNS 有多少线程可以用来执行计算。（MPSCNN 不需要这个，它将使用尽可能多的 GPU 线程。）</p><p>备注：你不应该在多个线程之间共享 MPSCNN 对象或 BNNS 对象。它们可以在单个后台线程中使用，但不能同时在使用多个线程中使用。</p><h2 id="速度问题"><a href="#速度问题" class="headerlink" title="速度问题"></a>速度问题</h2><p>决定是否使用 BNNS 或 MPSCNN 是基于一个权衡：<strong>CPU 数据更快还是 GPU 更快？</strong></p><p>并非所有数据都适合 GPU 处理。图像或视频是非常合适的，但像时间序列数据可能不适合。</p><p>将数据加载到 GPU 中是需要花费的，因为你需要将其封装到 <code>MTLTexture</code> 对象中。一旦 GPU 完成，读取结果就需要再次从纹理对象中获取。</p><p>使用基于 CPU 的 BNNS，便不会有这些开销，但是你也无法利用 GPU 的大规模并行性来进行计算。</p><p>在实践中，开发人员可能会<strong>尝试两种方法，看看哪一个更快</strong>。但是，如上所示，由于 BNNS 和 MPSCNN 具有不同的 API，因此需要编写两次代码。</p><p>因为我很好奇，所以我决定分别使用 BNNS 和 MPSCNN 建立一个非常基本的卷积神经网络来测量哪一个更快。</p><p>我的神经网络设计大概是这样（点击图片放大）：</p><p><img src="/img/articles/apple-deep-learning-bnns-versus-metal-cnn/ConvNet@2x.png1527128648.814062" alt="The convolutional neural network used for the speed test"></p><p>这种网络设计可以用来分类图像。网络采用 256×256 的 RGB 图像（无 alpha 通道）作为输入，并产生一个具有 100 个 <code>浮点值</code> 的数组。输出会表示出 100 多种可能类别的对象的概率分布。</p><p>实际上，神经网络需要有更多的层级才能真正有用。它最后也本该有一个 softmax 层，但是因为 BNNS 没有使用 softmax 函数，所以我把它去掉了。</p><p>我实际上并没有训练这个神经网络来学习任何有用的东西，而是用合理的随机值进行初始化。这是一个没有用的神经网络。然而，它确实允许我们比较在 BNNS 和 MPSCNN 中建立相同的神经网络所需要的内容，以及每个网络运行有多快。</p><p>如果你想一起实践，<a href="https://github.com/hollance/BNNS-vs-MPSCNN" target="_blank" rel="noopener">这是 GitHub 上的代码</a>。在 Xcode 中打开这个项目，并在至少有一个 A8 处理器的 iOS 10 兼容设备上运行它（它不能在模拟器上运行）。</p><p><img src="/img/articles/apple-deep-learning-bnns-versus-metal-cnn/Screenshot@2x.png1527128648.8787365" alt="The speed test app"></p><p>点击按钮后，App 冻结几秒钟，同时在每个神经网络上执行 100 个独立的推断。该 App 显示了创建网络需要多长时间（并不是很有趣），以及需要多长时间才能完成 100 次重复的推断。</p><p>该 App 还打印出每个网络计算的结果。由于网络并没有进行训练，因此这些数字什么意义都没有，仅仅是用于调试目的。我想确保两个网络实际上计算的事情相同，从而保证测试是公平的。</p><p>答案中的小差异是由于浮点四舍五入（由于 Metal 在内部使用的 16 位浮点数，我们只得到 3 位小数的精度），而且也可能是由于每个框架具体执行计算的差异而产生的。但结果足够接近。</p><h4 id="App-的工作原理"><a href="#App-的工作原理" class="headerlink" title="App 的工作原理"></a>App 的工作原理</h4><p>这个 App 创建的神经网络具有 2 个卷积层、1 个 max-pooling 层，1 个 average-pooling 层和 1 个全连接层。然后，它会测量向网络发送 100 次相同图像需要多长时间。</p><p>与此有关的主要源文件是 <strong>BNNSTest.swift</strong> 和 <strong>MetalTest.swift</strong>。</p><p>你猜对了，<code>BNNSTest</code> 类使用 BNNS 功能创建神经网络。以下是创建第一个卷积层所需的一小段代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">inputImgDesc = <span class="type">BNNSImageStackDescriptor</span>(width: <span class="number">256</span>, height: <span class="number">256</span>, channels: <span class="number">3</span>, </span><br><span class="line">                   row_stride: <span class="number">256</span>, image_stride: <span class="number">256</span>*<span class="number">256</span>, </span><br><span class="line">                   data_type: dataType, data_scale: <span class="number">0</span>, data_bias: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">conv1imgDesc = <span class="type">BNNSImageStackDescriptor</span>(width: <span class="number">256</span>, height: <span class="number">256</span>, channels: <span class="number">16</span>, </span><br><span class="line">                   row_stride: <span class="number">256</span>, image_stride: <span class="number">256</span>*<span class="number">256</span>, </span><br><span class="line">                   data_type: dataType, data_scale: <span class="number">0</span>, data_bias: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> relu = <span class="type">BNNSActivation</span>(function: <span class="type">BNNSActivationFunctionRectifiedLinear</span>, </span><br><span class="line">                          alpha: <span class="number">0</span>, beta: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> conv1weightsData = <span class="type">BNNSLayerData</span>(data: conv1weights, data_type: dataType, </span><br><span class="line">                           data_scale: <span class="number">0</span>, data_bias: <span class="number">0</span>, data_table: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> conv1biasData = <span class="type">BNNSLayerData</span>(data: conv1bias, data_type: dataType, </span><br><span class="line">                        data_scale: <span class="number">0</span>, data_bias: <span class="number">0</span>, data_table: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> conv1desc = <span class="type">BNNSConvolutionLayerParameters</span>(x_stride: <span class="number">1</span>, y_stride: <span class="number">1</span>, </span><br><span class="line">                    x_padding: <span class="number">2</span>, y_padding: <span class="number">2</span>, k_width: <span class="number">5</span>, k_height: <span class="number">5</span>, </span><br><span class="line">                    in_channels: <span class="number">3</span>, out_channels: <span class="number">16</span>, </span><br><span class="line">                    weights: conv1weightsData, bias: conv1biasData, </span><br><span class="line">                    activation: relu)</span><br><span class="line"></span><br><span class="line">conv1 = <span class="type">BNNSFilterCreateConvolutionLayer</span>(&amp;inputImgDesc, &amp;conv1imgDesc, </span><br><span class="line">                                         &amp;conv1desc, &amp;filterParams)</span><br></pre></td></tr></table></figure><p>使用 BNNS，你需要创建大量“描述符”助手来描述你将要使用的数据以及层级的属性和权重。其他层级也会重复此操作。现在你可以明白为什么我之前说这个会很无聊。</p><p><code>MetalTest</code> 类使用 <code>MPSCNN</code>做同样的事情：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">conv1imgDesc = <span class="type">MPSImageDescriptor</span>(channelFormat: channelFormat, width: <span class="number">256</span>, </span><br><span class="line">                                  height: <span class="number">256</span>, featureChannels: <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> relu = <span class="type">MPSCNNNeuronReLU</span>(device: device, a: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> conv1desc = <span class="type">MPSCNNConvolutionDescriptor</span>(kernelWidth: <span class="number">5</span>, kernelHeight: <span class="number">5</span>, </span><br><span class="line">                    inputFeatureChannels: <span class="number">3</span>, outputFeatureChannels: <span class="number">16</span>, </span><br><span class="line">                    neuronFilter: relu)</span><br><span class="line"></span><br><span class="line">conv1 = <span class="type">MPSCNNConvolution</span>(device: device, convolutionDescriptor: conv1desc, </span><br><span class="line">            kernelWeights: conv1weights, biasTerms: conv1bias, flags: .<span class="keyword">none</span>)</span><br></pre></td></tr></table></figure><p>在这里你也可以创建各种描述符对象，但代码会短一些。</p><p>你已经看到如何使用 BNNS 进行推断：你在每个层级调用一次 <code>BNNSFilterApply()</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">BNNSFilterApply</span>(conv1, imagePointer, &amp;temp1) != <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"BNNSFilterApply failed on layer conv1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="type">BNNSFilterApply</span>(pool1, temp1, &amp;temp2) != <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"BNNSFilterApply failed on layer pool1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="type">BNNSFilterApply</span>(conv2, temp2, &amp;temp1) != <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"BNNSFilterApply failed on layer conv2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="type">BNNSFilterApply</span>(pool2, temp1, &amp;temp2) != <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"BNNSFilterApply failed on layer pool2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="type">BNNSFilterApply</span>(fc3, temp2, &amp;results) != <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"BNNSFilterApply failed on layer fc3"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>imagePointer</code> 指向一个<code>浮点值</code>的 Swift 数组。同样，<code>temp1</code> 和 <code>temp2</code> 是普通的 <code>Swift</code> <code>浮点值</code>数组。我们不断重复使用这些数组来存储中间结果。网络的最终输出会写入 <code>[Float]</code> 类型的 <code>results</code> 中。一旦网络完成计算，我们可以立即读取这个数组的结果，并在我们 App 的其他地方使用它们。</p><p>使用 MPSCNN 的过程是非常相似的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> commandBuffer = commandQueue.makeCommandBuffer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> conv1img = <span class="type">MPSTemporaryImage</span>(commandBuffer: commandBuffer, </span><br><span class="line">                                 imageDescriptor: conv1imgDesc)</span><br><span class="line">conv1.encode(commandBuffer: commandBuffer, sourceImage: inputImage, </span><br><span class="line">             destinationImage: conv1img)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pool1img = <span class="type">MPSTemporaryImage</span>(commandBuffer: commandBuffer, </span><br><span class="line">                                 imageDescriptor: pool1imgDesc)</span><br><span class="line">pool1.encode(commandBuffer: commandBuffer, sourceImage: conv1img, </span><br><span class="line">             destinationImage: pool1img)</span><br><span class="line">. . . </span><br><span class="line"></span><br><span class="line">fc3.encode(commandBuffer: commandBuffer, sourceImage: pool2img, </span><br><span class="line">           destinationImage: outputImage)</span><br><span class="line"></span><br><span class="line">commandBuffer.commit()</span><br></pre></td></tr></table></figure><p>你创建一个 <code>MPSTemporaryImage</code> 对象来保存当前层级的结果，然后通知层级对其自身使用 <code>encode()</code> 并添加到 Metal 的命令缓冲区。这些 <code>MPSTemporaryImage</code> 对象跟我们在 <code>BNNS</code> 代码中使用的 <code>temp1</code> 和 <code>temp2</code> 的是等价的。MPSCNN 在后台管理自己的存储。</p><p><code>inputImage</code> 和 <code>outputImage</code> 分别是网络的输入和输出，因此保存在持久化的 <code>MPSImage</code> 对象中。</p><p>请注意，除非你在命令缓冲区上调用 <code>commit()</code>，否则 GPU 将不会执行任何操作。使用 BNNS，每次调用 <code>BNNSFilterApply()</code> 便会立即开始处理。但是 MPSCNN 中的 <code>layer.encode(...)</code> 只是创建了 GPU 命令，不会马上执行它们。在调用 <code>commit()</code> 之后，GPU 才开始处理数据，而 CPU 可以自由地处理更多东西。</p><p>我们真正想要的是神经网络的输出是一个<code>浮点值</code>的数组。BNNS 已经可以处理普通的 Swift 数组，所以在此我们不需要做任何特别的事情。但是对于 MPSCNN，我们需要将输出的 <code>MPSImage</code> 对象的纹理转换成我们可以在 Swift 中使用的东西。在 App 的 <strong><code>MPSImage + Floats.swift</code></strong> 文件中包含一些辅助代码。</p><p>备注：如果你使用 BNNS 的 16 位浮点数（你很可能会这样做），那么在某些时候你需要转换回 32 位浮点数。在演示的 App 中，这是在最后一个层级之前做的，而不是之后，因为完全连接层无法处理 16 位浮点数。</p><h4 id="测试指标"><a href="#测试指标" class="headerlink" title="测试指标"></a>测试指标</h4><p>我想对 BNNS 和 MPSCNN 中创建的完全相同的神经网络的运行时间进行公平的比较。</p><p>我没有测试将输入数据转换为正确格式所需的时间。如果输入的数据是图像，并且使用 MPSCNN，你可以将其加载到纹理中，然后就不用管了。但是 BNNS 不行：你需要首先在内存中重新排列图像数据，这可能会非常费时。</p><p>然而，这实际上取决于你使用的是什么神经网络，这就是为什么我不想测量它。但是在我们的速度测试中，它确实给 BNNS 带来了轻微的优势，因为对于 BNNS 来说，获得正确形式的输入数据比较慢。</p><p>对于输出数据，我测量了将其转换回 Swift 数组所需的时间。在这里，MPSCNN 比较慢，而 BNNS 根本没有成本（如果使用 32 位浮点数的话）。所以这也有利于 BNNS。</p><p>然而，我认为在这种情况下的测量中包含转换是公平的，因为转换网络输出是你几乎总要做的事情。这是将 GPU 用于通用计算工作的一个缺点，因此降低了使用 GPU 所带来的性能收益。</p><p>对于一个公平的测试，我想在 MPSCNN 和 BNNS 中使用 16 位浮点数。MPSCNN 在内部总是将权重存储为 <code>float16</code> 类型，所以为了保持公正，我们也应该让 BNNS 使用 16 位浮点数。缺点是 Swift 没有“半浮点”类型，所以我们即使在使用 BNNS 时，总是需要用“真实的” 32 位浮点数来回转换。</p><p>备注：在 <strong>ViewController.swift</strong> 文件中有几个选项可以让你改变所测试的东西。特别是，它允许你更改学习参数的数据类型以及层级用来用于执行计算的数据类型。还有一个选项可以增大网络，这会增加所需的计算的数量，因为最初的网络很小，不一定代表真实的深度学习架构。</p><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>你准备好了吗？</p><p>对于基本的 5 层卷积网络，在我的 iPhone 6s 上，使用 16 位浮点数，BNNS 比 MPSCNN 快大约 25％。</p><p>所以这是CPU的胜利。</p><p>然而，如果我们在每一层中通过提供更多的处理通道（改变 App 中的<code>乘数值</code>）来使网络更庞大，MPSCNN 将轻松超越 BNNS。</p><p>当使用 32 位浮点数时，MPSCNN 也比 BNNS 更快。（可能是因为 MPSCNN 在内部总是使用 16 位浮点数，但 BNNS 现在有两倍的工作量。）</p><p>作为一个全面的指导方针，如果发送到网络的推断需要做<strong>超过3亿次的浮点运算</strong>，那么最好切换到 MPSCNN。</p><p>我以下面的方式来到这个数字：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number of flops per layer = 2 × kernelWidth   × kernelHeight   ×</span><br><span class="line">                                inputChannels × outputChannels ×</span><br><span class="line">                                outputWidth   × outputHeight</span><br></pre></td></tr></table></figure><p>然后我为每一层添加了触发器，并试验了网络的大小，来验证 MPSCNN 变得比 BNNS 更快的临界点。</p><p>警告：这是一个超级不科学的实验，我的计算可能会失败。但是，如果你为深层网络做了一个后台计算，并且发现它需要 1 Gflops（每秒10亿次的浮点运算数）或更多，那么很明显 BNNS 就不行了。</p><p>但请注意，这取决于许多因素：</p><ul><li><p>设备类型。我只在iPhone 6s上测试过。在较慢的 iPhone 6 或较快的 iPhone 7 上，性能可能会有所不同。</p></li><li><p>你的数据。正如我所指出的，MPSCNN 可以轻松地将图像加载到纹理中，但对于 BNNS ，你需要首先完全重新排列像素数据。你需要执行的预处理会对性能产生影响。</p></li><li><p>同样，为了在 Swift 中使用而对网络输出的数据进行的任何转换，都可能会减慢处理过程。</p></li><li><p>内存带宽。在我的 <a href="http://machinethink.net/blog/convolutional-neural-networks-on-the-iphone-with-vggnet/" target="_blank" rel="noopener">VGGNet 实现</a>中，学习参数占用大约 260 MB 的 RAM。对于每个推断，神经网络不仅需要做大量的计算，还需要访问数百万个存储单元。随时都可能遇到带宽的瓶颈。</p></li></ul><p>我试图尽可能公平地进行测试，但是由于这两个框架中的错误和其他怪异行为，使得过程并不完美。</p><p>例如，BNNS 全连接层不能接受 16 位浮点数，所以我必须先将数据转换回 32 位浮点数。由于完全连接层执行了大量的计算，如果支持这些半精度浮点数，BNNS 可能会更快。MPSCNN 的一些层级也有自己的怪异之处（详见<a href="https://github.com/hollance/BNNS-vs-MPSCNN" target="_blank" rel="noopener">源代码</a>）。</p><p>备注：我没有测试批处理。这两个 API 都可以一次处理多个输入图像。这只会增加一次性向网络发送的数据量。然而，GPU 可能在这方面有优势，因为批处理可能会更好地使用 GPU 带宽。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以应该使用哪个 API ？这要结合实际情况。</p><p>这两个 API 功能都有限，而且仍然有一些不足之处。对于较小的网络，BNNS 速度较快，但较大的网络速度较慢。BNNS 的功能也较少，你必须自己编写更多的代码。总的来说，BNNS API 比 MPSCNN 更丑陋一点，可能是因为它是一个 C API 被导入到 Swift 中。</p><p>但是，BNNS 与 MPSCNN 相比有一个优势：它也能运行在 macOS 上。</p><p>提示：<strong>使用16位浮点数</strong>。尽管 16 位浮点数不是 Swift 的本地类型，但它们能使 BNNS 执行得更高效，即使这意味着您必须将常规数组转换为 16 位浮点数，然后再返回。</p><p>就个人而言，我可能会坚持 MPSCNN 。它更加灵活，你可以将它与 Metal Performance Shaders 的快速矩阵乘法程序和自己的计算内核结合使用。</p><p><strong>最重要的是你的 App 运行得有多快，以及推断的效果如何。</strong></p><p>如果你的项目紧急，需要快点，请使用 MPSCNN。但是如果你能腾出时间，那最好用这两种 API 来分别实现你的神经网络，通过对比来达到最佳速度。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      在这篇文章中，我们将针对 BNNS 和 MPSCNN 进行对比来显示出这两者的差异
    
    </summary>
    
      <category term="machinethink" scheme="https://swift.gg/categories/machinethink/"/>
    
    
      <category term="深度学习" scheme="https://swift.gg/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift 的可选型枚举</title>
    <link href="https://swift.gg/2018/05/17/enums-and-optionals/"/>
    <id>https://swift.gg/2018/05/17/enums-and-optionals/</id>
    <published>2018-05-17T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2018/04/enums-and-optionals/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-11<br>译者：<a href="https://weibo.com/u/1771329710" target="_blank" rel="noopener">ennisk</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>去年我写了一篇关于<a href="http://khanlou.com/2017/03/that-one-optional-property/" target="_blank" rel="noopener">在类中添加普通可选型属性使扩展功能变得更简单</a>的文章，但是从长远来看会对代码库造成一定的损害，本文接上一篇内容。</p><p>假设你正在设计 App 中的认证流程，而且知道这个流程不是简单的线性执行代码，所以想写一些测试代码。</p><a id="more"></a><p>首先列举出流程中的每一步：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AuthFlowStep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> collectUsernameAndPassword</span><br><span class="line">    <span class="keyword">case</span> findFriends</span><br><span class="line">    <span class="keyword">case</span> uploadAvatar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将所有复杂的逻辑放入到一个函数中，该函数接收当前步骤和当前状态，返回流程中的下一个步骤。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepAfter</span><span class="params">(<span class="number">_</span> currentStep: AuthFlowStep, context: UserState)</span></span> -&gt; <span class="type">AuthFlowStep</span></span><br></pre></td></tr></table></figure><p>这应该很容易测试，到目前为止一切正常。</p><p>但是，在认真思考逻辑之后，你会发现有时候不能返回 <code>AuthFlowStep</code> 。一旦用户提交了所有认证需要的数据，你就需要想个办法表示流程已经结束了。在这个函数中，你需要返回一个特殊值。所以要怎么做呢？很简单，把返回类型改为可选值即可：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepAfter</span><span class="params">(<span class="number">_</span> currentStep: AuthFlowStep, context: UserState)</span></span> -&gt; <span class="type">AuthFlowStep</span>?</span><br></pre></td></tr></table></figure><p>这个方法可以解决问题，你可以在 <a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener">coordinator</a> 中调用这个函数，继续实现你的功能：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finished</span><span class="params">(flowStep: AuthFlowStep, state: UserState, from vc: SomeViewController)</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> nextState = stepAfter(flowStep, context: state)</span><br></pre></td></tr></table></figure><p>由于 <code>nextState</code> 是可选值，所以最直接的想法就是用 <code>guard</code> 方法把它变成非可选值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> nextState = stepAfter(flowStep, context: state) <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">self</span>.parentCoordinator.authFlowFinished(on: <span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">switch</span> nextState &#123;</span><br><span class="line">  <span class="keyword">case</span> .collectUsernameAndPassword:</span><br><span class="line"><span class="comment">//build and present next view controller</span></span><br></pre></td></tr></table></figure><p>但是我总觉得这里的写法有点问题。阅读 <a href="http://alisoftware.github.io/swift/pattern-matching/2016/04/24/pattern-matching-3/#syntactic-sugar-on-optionals" target="_blank" rel="noopener">Olivier 的模式匹配指南</a> 之后，我发现可以在 <code>switch</code> 语句中同时处理可选值和枚举值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finished</span><span class="params">(flowStep: AuthFlowStep, state: UserState, from viewController: SomeViewController)</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> nextState = stepAfter(flowStep, context: state) <span class="comment">// Optional&lt;AuthFlowStep&gt;</span></span><br><span class="line"><span class="keyword">switch</span> nextState &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">self</span>.parentCoordinator.authFlowFinished(on: <span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">case</span> .collectUsernameAndPassword?:</span><br><span class="line"><span class="comment">//build and present next view controller</span></span><br></pre></td></tr></table></figure><p>代码里的那个问号可以匹配枚举的可选值。这种写法确实更好，但还是有点不对劲。既然我已经用了 <code>switch</code>，为什么还要做解包操作？<code>nil</code> 在这个上下文中又代表着什么？</p><p>如果你认真读过这篇文章的标题，或许已经猜到了我下面要做什么。我们先来看看可选值的定义。在底层代码中，它和 <code>AuthFlowState</code> 一样是个枚举：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">case</span> some(<span class="type">Wrapped</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把枚举转换成可选类型时，实际上只是向枚举中添加了一个新值。既然我们能直接控制 <code>AuthFlowStep</code>，直接给它添加一个新值就能实现同样的效果。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AuthFlowStep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> collectUsernameAndPassword</span><br><span class="line">    <span class="keyword">case</span> findFriends</span><br><span class="line">    <span class="keyword">case</span> uploadAvatar</span><br><span class="line">    <span class="keyword">case</span> finished</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以从函数返回值类型中删掉 <code>?</code> 了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepAfter</span><span class="params">(<span class="number">_</span> currentStep: AuthFlowStep, context: UserState)</span></span> -&gt; <span class="type">AuthFlowStep</span></span><br></pre></td></tr></table></figure><p>我们的 <code>switch</code> 语句现在可以直接处理所有步骤，不需要对 <code>nil</code> 做特殊处理。</p><p>为什么这样更好？有几个原因：</p><p>首先，现在 <code>nil</code> 对应的情况有了具体的名字。以前，使用该函数的用户可能不清楚函数返回 <code>nil</code> 意味着什么。他们要么去阅读文档求助，要么直接阅读函数代码，分析什么时候会返回 <code>nil</code> 。</p><p>第二，简单才是王道，不需要先用 <code>guard</code> 解包再用 <code>switch</code> 判断，也不需要用 <code>swtich</code> 语句处理两层枚举，一层枚举更容易处理。</p><p>最后，代码更加健壮。<code>return nil</code> 应该留给真正异常情况。下一个开发者可能需要在某些特殊情况发生时退出函数，他想都没想就写了个 <code>return nil</code>。这时 <code>nil</code> 就具备了两种含义，你的代码无法正确处理。</p><p>当你把特殊情况添加到枚举中时，需要想好到底使用什么名字。你有很多选择，挑一个最合适的：<code>.unknow</code>，<code>.none</code>，<code>.finished</code>，<code>.initial</code>，<code>.notFound</code>，<code>.default</code>，<code>.nothing</code>，<code>.unspecified</code> 等等（需要注意，如果你有一个 case 匹配的是 <code>.none</code>，并且匹配的值是可选值，那么 <code>Option.none</code> 和 <code>YourEnum.none</code> 都会引起歧义，所以不要在匹配可选值的时候使用 <code>.none</code> 去表示你自己的状态）。</p><p>这篇文章介绍的是流程状态，但我觉得这种模式也同样适用其他情况 — 如果你想把一个枚举改成可选值，最好先停下来想一想，是否可以给枚举加一个新值来表示特殊情况。</p><p>感谢 <a href="https://irace.me/" target="_blank" rel="noopener">Bryan Irace</a> 提出的反馈和示例代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2018/04/enums-and-optionals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-04-11&lt;br&gt;译者：&lt;a href=&quot;https://weibo.com/u/1771329710&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ennisk&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;去年我写了一篇关于&lt;a href=&quot;http://khanlou.com/2017/03/that-one-optional-property/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在类中添加普通可选型属性使扩展功能变得更简单&lt;/a&gt;的文章，但是从长远来看会对代码库造成一定的损害，本文接上一篇内容。&lt;/p&gt;
&lt;p&gt;假设你正在设计 App 中的认证流程，而且知道这个流程不是简单的线性执行代码，所以想写一些测试代码。&lt;/p&gt;
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>使非法状态不可表示</title>
    <link href="https://swift.gg/2018/05/14/making-illegal-states-unrepresentable/"/>
    <id>https://swift.gg/2018/05/14/making-illegal-states-unrepresentable/</id>
    <published>2018-05-14T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2018/03/making-illegal-states-unrepresentable/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-03-27<br>译者：<a href="http://daizi.me" target="_blank" rel="noopener">小袋子</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><blockquote><p>你知道 <code>URLSession</code> 能同时返回响应和错误吗？</p></blockquote><p><a href="https://oleb.net/blog/2015/07/swift-type-system/" target="_blank" rel="noopener">我之前介绍过</a>，Swift 强类型系统的一个主要优点是天生具备编译器强制遵循的文档规范。</p><h2 id="类型是编译器强制遵循的文档规范"><a href="#类型是编译器强制遵循的文档规范" class="headerlink" title="类型是编译器强制遵循的文档规范"></a>类型是编译器强制遵循的文档规范</h2><p>类型为函数的行为设立了一种“界限”，因此一个易用的 API 应该精心选择输入输出类型。</p><a id="more"></a><p>仔细思考以下 Swift 函数声明：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> / <span class="params">(dividend: Int, divisor: Int)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>在不阅读任何函数实现的情况下，你就可以推断出这应该是<a href="http://mathworld.wolfram.com/IntegerDivision.html" target="_blank" rel="noopener">整型除法</a>，因为返回的类型不可能是小数。相较之下，如果函数的返回类型是既可以表示整型，也可以表示浮点型数值的 <a href="https://developer.apple.com/documentation/foundation/nsnumber" target="_blank" rel="noopener"><code>NSNumber</code></a>，那你就只能祈祷开发者自觉遵循文档只返回整数。</p><p>随着类型系统的表现越来越好，这种使用类型来记录函数行为的技巧变得越来越有用。如果 <code>Swift</code> 有一个<a href="#quote1"><code>NonZeroInt</code> 类型</a>代表 “除了 <code>0</code> 之外的整型” ，那么除法函数可能就会变成下面这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> / <span class="params">(dividend: Int, divisor: NonZeroInt)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>类型检查不允许传入的除数为 <code>0</code> ，因此你不用关心函数如何处理除数为 <code>0</code> 的错误。函数会中断吗？会返回一个没有意义的值吗？如果你用的是上一种定义，就必须在文档里单独说明特殊情况的处理方式。</p><h2 id="使非法状态成为不可能"><a href="#使非法状态成为不可能" class="headerlink" title="使非法状态成为不可能"></a>使非法状态成为不可能</h2><p>我们可以把这个观点转换为一条通用规则：<strong>使用类型让你的程序无法表现非法状态</strong>。</p><p>如果你想学习更多相关知识，可以看看 Brandon Williams 和 Stephen Celis 的最新视频系列 <a href="https://www.pointfree.co/" target="_blank" rel="noopener">Point-Free</a>。他们讲了很多这方面的知识和相关话题，前八集真的特别棒，我强烈推荐大家去订阅，你会学到很多东西。</p><p>在<a href="https://www.pointfree.co/episodes/ep4-algebraic-data-types" target="_blank" rel="noopener">第四集</a>关于代数数据类型（<a href="https://en.wikipedia.org/wiki/Algebraic_data_type" target="_blank" rel="noopener">algebraic data types</a>）的视频中，Brandon 和 Stephen 讨论了如何组合 <code>enums</code> 和 <code>structs</code>（或者 <code>tuples</code>）来精确表示期望状态的类型，并且让所有非法状态无法表示。在视频的最后，他们用 Apple 的 <a href="https://developer.apple.com/documentation/foundation/urlsession" target="_blank" rel="noopener">URLSession</a> API 作为反面教材进行介绍，因为这个 API 没有使用最合适的类型，这就引出了本文的子标题——“你知道 URLSession 能同时返回响应和错误吗？”。</p><h2 id="URLSession"><a href="#URLSession" class="headerlink" title="URLSession"></a>URLSession</h2><p>Swift 的类型系统比 Objective-C 更富有表现力。然而，很多 Apple 自己的 API 也没有利用这个优势，可能是因为没空更新老旧的 API，或者是为了维持 Objective-C 的兼容性。</p><p>在 iOS 中发起一个<a href="https://developer.apple.com/documentation/foundation/urlsession/1410330-datatask" target="_blank" rel="noopener">网络请求</a>的通用方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLSession</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dataTask</span><span class="params">(with url: URL,</span></span></span><br><span class="line"><span class="function"><span class="params">        completionHandler: @escaping <span class="params">(Data?, URLResponse?, Error?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">        -&gt; <span class="type">URLSessionDataTask</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调函数的参数是三个可选值：<a href="https://developer.apple.com/documentation/foundation/data" target="_blank" rel="noopener"><code>Data?</code></a>，<a href="https://developer.apple.com/documentation/foundation/urlresponse" target="_blank" rel="noopener"><code>URLResponse?</code></a> 和 <a href="https://developer.apple.com/documentation/swift/error" target="_blank" rel="noopener"><code>Error?</code></a>。这将产生 <code>2 × 2 × 2 = 8</code> 种<a href="#quote2">可能的状态</a>，但是其中有多少种是合法的呢？</p><p>引述 <a href="https://www.pointfree.co/episodes/ep4-algebraic-data-types" target="_blank" rel="noopener">Brandon 和 Stephen</a> 的观点：“这里有很多状态毫无意义”。有些组合很明显没有意义，另外我们基本可以确定，这三个值不可能全为 <code>nil</code> 或全为非 <code>nil</code>。</p><h2 id="响应和错误能够同时非-nil"><a href="#响应和错误能够同时非-nil" class="headerlink" title="响应和错误能够同时非 nil"></a>响应和错误能够同时非 <code>nil</code></h2><p>其他状态就很棘手了，在这里 Brandon 和 Stephen 犯了一点小错误：他们认为 API 要么返回一个有效的 <code>Data</code> 和 <code>URLResponse</code>，要么返回一个 <code>Error</code>。毕竟接口不可能同时返回一个非 <code>nil</code> 的响应和错误。看起来很有道理，对不对？</p><p>但事实上这是错误的。<code>URLResponse</code> 封装了服务器的 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html" target="_blank" rel="noopener">HTTP 响应头部</a>，只要接收到一个有效的响应头部， <code>URLSession</code> API 就会一直给你提供这个值，无论后续的阶段请求是否出错（例如取消和超时)。因而 API 的完成处理中有可能包含一个有效的 <code>URLResponse</code> 和非 <code>nil</code> 的错误值（但是没有 <code>Data</code>）。</p><p>如果你对 <code>URLSession</code> 代理（delegate）API 比较熟悉的话，应该不会太惊讶，因为代理方法就是分成 <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/1410027-urlsession" target="_blank" rel="noopener"><code>didReceiveResponse</code></a> 和 <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/1411528-urlsession" target="_blank" rel="noopener"><code>didReceiveData</code></a>。实际上，<a href="https://developer.apple.com/documentation/foundation/urlsession/1410330-datatask" target="_blank" rel="noopener"><code>dataTask​(with:​completionHandler:)</code>的文档</a>也提到了这个问题：</p><blockquote><p>如果收到服务器的响应，那么<strong>无论请求成功或失败</strong>，响应参数都会有值。</p></blockquote><p>不过，我敢打赌 Cocoa 开发人员普遍对此抱有误解。仅仅在过去的四周，我就看到<a href="https://davedelong.com/blog/2018/03/02/apple-networking-feedback/" target="_blank" rel="noopener">两</a>篇<a href="https://ruiper.es/2018/03/03/ras-s2e1/" target="_blank" rel="noopener">文章</a>的作者犯了同样的错误（至少没有领悟其中的真谛）。</p><p>说真的，我很喜欢这个充满讽刺意味的事实：Brandon 和 Stephen 试图指出由于类型问题导致的 API 缺陷，但在指出错误的同时，这个类型问题又让他们犯了另一个错误。如果原始 API 使用了更好的类型，那么这两个错误就都能避免，这反而证明了他们的观点：一个有更加严格类型的 API 能够避免错误使用。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>如果你想自己体验一下 <code>URLSession</code> 的功能，你可以复制以下代码到 Swift playground：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> PlaygroundSupport</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果返回 404，把 URL 换成随便一个大文件</span></span><br><span class="line"><span class="keyword">let</span> bigFile = <span class="type">URL</span>(string: <span class="string">"https://speed.hetzner.de/1GB.bin"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: bigFile) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"data:"</span>, data <span class="keyword">as</span> <span class="type">Any</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"response:"</span>, response <span class="keyword">as</span> <span class="type">Any</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error:"</span>, error <span class="keyword">as</span> <span class="type">Any</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task.resume()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过几秒之后取消下载</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">3</span>) &#123;</span><br><span class="line">    task.cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">PlaygroundPage</span>.current.needsIndefiniteExecution = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这段代码首先下载一个大文件，然后在几秒后取消。最后，完成的处理中返回了一个非 <code>nil</code> 的响应和错误。</p><p>（这里假设指定的时间间隔内，能够获取到服务器响应的头部，但不能完成下载。如果你的网速非常慢或者非常变态，请自行调整这个时间参数）</p><h2 id="正确的类型应该是什么？"><a href="#正确的类型应该是什么？" class="headerlink" title="正确的类型应该是什么？"></a>正确的类型应该是什么？</h2><p>Brandon 和 Stephen 随后在 <a href="https://www.pointfree.co/episodes/ep9-algebraic-data-types-exponents" target="_blank" rel="noopener">Point-Free 的第九集视频</a>中发布了他们对问题的跟进。他们认为“正确”的参数类型应该是：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(<span class="type">URLResponse</span>?, <span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">Error</span>&gt;)</span><br></pre></td></tr></table></figure><p>我不同意，因为如果有数据，就一定有响应，不可能只有数据没有响应。我认为应该是这样的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Result</span>&lt;(<span class="type">Data</span>, <span class="type">URLResponse</span>), (<span class="type">Error</span>, <span class="type">URLResponse</span>?)&gt;</span><br></pre></td></tr></table></figure><p>解读：你将要么得到数据和响应（后者肯定不是 <code>nil</code>），要么得到一个错误和一个可选类型的响应。不可否认，我的建议与一般的 <code>Result</code> 类型定义相悖，因为它将失败参数约束为不能符合 <code>Error</code> 的 <a href="https://developer.apple.com/documentation/swift/error" target="_blank" rel="noopener">Error</a> 协议—<code>(Error, URLResponse?)</code>。目前 <a href="https://forums.swift.org/t/adding-result-to-the-standard-library/6932/58" target="_blank" rel="noopener">Swift 论坛正在讨论</a> <code>Error</code> 约束是否有必要。</p><h2 id="Result-类型"><a href="#Result-类型" class="headerlink" title="Result 类型"></a><code>Result</code> 类型</h2><p>由于 <code>URLResponse</code> 参数的非直观行为，<code>URLSession</code> 的API 显得特别棘手。但是 Apple 几乎所有的基于回调的异步 API 都有相同的问题，它们所提供的类型使得非法状态可以表示。</p><p>如何解决这个问题呢？</p><p>Swift 的通用方案是定义一个 <a href="https://github.com/antitypical/Result/blob/03fba33a0a8b75492480b9b2e458e88651525a2a/Result/Result.swift" target="_blank" rel="noopener">Result 类型</a>—一个可以代表通用成功值或错误的枚举。最近，又有人试图将 <a href="https://forums.swift.org/t/adding-result-to-the-standard-library/6932/20" target="_blank" rel="noopener">Result 添加到标准库</a>。</p><p>如果 Swift 5 添加了 <code>Result</code>（大胆假设），Apple 可能（更大胆的假设）会自动导入类似这样 <code>completionHandler: (A?, Error?) -&gt; Void as (Result&lt;A&gt;) -&gt; Void</code> 的 Cocoa API，将四个可表现的状态转为两个。在那之前（如果真的会发生的话），我建议你还是先自己<a href="https://oleb.net/blog/2017/01/result-init-helper/" target="_blank" rel="noopener">实现转换</a>。</p><p>长远来看，Swift 终有一天能从语言层面正确支持异步 API。社区和 Swift 团队可能会提出新的解决方案，<a href="https://gist.github.com/lattner/429b9070918248274f25b714dcfc7619#conversion-of-imported-objective-c-apis" target="_blank" rel="noopener">把现有的 Cocoa API 移植到新系统中</a>，就像把 Objective-C 的 <code>NSError **</code> 参数作为抛出（throwing）函数引入 Swift 一样。不过不要太过期待，Swift 6 之前肯定实现不了。</p><hr><p><span id="quote1"><br>1、你可以自己定义一个 <code>NonZeroInt</code> 类型，但是没有办法告诉编译器“如果有人尝试用零去初始化这个类型，就引发一个错误”。你必须依赖运行时检查。</span></p><p>不过，引入这样的类型通常是个不错的想法，因为类型的用户可以在初始化之后依赖于所声明的不变性。我还没有在其他地方看到一个 <code>NonZeroInt</code> 类型，保证类型为非空集合的自定义类型更受欢迎。<br></p><p><span id="quote2"><br>2、我只是把“<code>nil</code>”或“非<code>nil</code>”作为可能的状态。显然，非 <code>nil</code> 数据值可以具有无数种可能的状态，并且对于其他两个参数也是如此。但是这些状态对我们来说并不好玩。<br></span></p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2018/03/making-illegal-states-unrepresentable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-03-27&lt;br&gt;译者：&lt;a href=&quot;http://daizi.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小袋子&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;blockquote&gt;
&lt;p&gt;你知道 &lt;code&gt;URLSession&lt;/code&gt; 能同时返回响应和错误吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://oleb.net/blog/2015/07/swift-type-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我之前介绍过&lt;/a&gt;，Swift 强类型系统的一个主要优点是天生具备编译器强制遵循的文档规范。&lt;/p&gt;
&lt;h2 id=&quot;类型是编译器强制遵循的文档规范&quot;&gt;&lt;a href=&quot;#类型是编译器强制遵循的文档规范&quot; class=&quot;headerlink&quot; title=&quot;类型是编译器强制遵循的文档规范&quot;&gt;&lt;/a&gt;类型是编译器强制遵循的文档规范&lt;/h2&gt;&lt;p&gt;类型为函数的行为设立了一种“界限”，因此一个易用的 API 应该精心选择输入输出类型。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Elm Native UI in Production</title>
    <link href="https://swift.gg/2018/05/10/elm-native-ui-in-production/"/>
    <id>https://swift.gg/2018/05/10/elm-native-ui-in-production/</id>
    <published>2018-05-10T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Josh Steiner，<a href="https://robots.thoughtbot.com/elm-native-ui-in-production" target="_blank" rel="noopener">原文链接</a>，原文日期：2016-03-01<br>译者：<a href="http://muhlenxi.com/" target="_blank" rel="noopener">muhlenXi</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="http://www.jianshu.com/users/9efd08855d3a/" target="_blank" rel="noopener">aaaron7</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>在 11 月份，thoughtbot 发布了一个叫 <a href="https://purpletrainapp.com/" target="_blank" rel="noopener">Purple Train</a> 的 APP ，该 APP 是用 <a href="https://thoughtbot.com/services/react" target="_blank" rel="noopener">React Native</a> 实现的， <code>React Native</code> 一直被用于快速构建跨平台的 APP 。由于 <code>Reactive Natice</code> 对传统移动开发的许多改进，使我们更加喜欢它，比如声明性 API、更快的开发周期、对 Web 开发和设计师来说更友好和跨平台等。但是 <code>React Native</code> 并不是对每个 APP 都非常合适，它虽然适合大多数的 APP ，但仍然有一个主要的缺陷：<code>JavaScript</code> 。</p><p><code>JavaScript</code> 作为一门语言它一直在改进，它有一个显著优点就是无所不在，然而，它也以 <a href="https://www.destroyallsoftware.com/talks/wat" target="_blank" rel="noopener">奇怪的行为</a> 和弱类型系统（读作 <code>aggressive type coercion</code> ）而闻名。</p><a id="more"></a><h3 id="Elm-Native-UI"><a href="#Elm-Native-UI" class="headerlink" title="Elm Native UI"></a>Elm Native UI</h3><p>开始说 <a href="https://github.com/ohanhi/elm-native-ui" target="_blank" rel="noopener">Elm Native UI</a> - 一个提供 <code>React Native</code> 组件编译功能的 <code>Elm</code> 库。如果你听过 <code>Elm</code> ，你可能知道 <a href="http://elm-lang.org/blog/compiler-errors-for-humans" target="_blank" rel="noopener">amazing error message</a> 和听说 <a href="https://www.pivotaltracker.com/blog/Elm-pivotal-tracker/" target="_blank" rel="noopener">zero runtime errors</a> 的主张。<code>Elm</code> 的安全性来自于它的 <code>pure function（纯函数）</code> 和强大的静态类型，这也使得 <code>Elm</code> 的代码更容易验证。</p><p>在发布 <code>Purple Train</code> 的 <code>React Native</code> 版本的时候，我们偶然发现了 <code>Elm Native UI</code> 。它在 GitHUb 的 repo 中清楚的声明了，“不要用于生产环境中”，但我想要把它加入测试，我从一些简单 feature 开始，不断拓宽边界。该 APP 很快就接近 <code>React Native APP</code> 相同的特点。在 12 月份，虽然库不成熟，但是它的开发环境是极其出色的，于是我们决定创建一个 Purple Train 的试验版本，在我们完成剩下的功能后将第一个 <code>Elm Native UI APP</code> 发布到生产环境中。</p><h3 id="React-vs-Elm"><a href="#React-vs-Elm" class="headerlink" title="React vs Elm"></a>React vs Elm</h3><p>用 <code>React</code> 和 <code>Elm</code> 开发的差异是很明显的，在 <code>React</code> 中，当开发一个功能时，你必须充分考虑每一步，如果你忘记了某一步，很少的提示会告诉你你错过什么并且 <code>React</code> 需要花一些时间来追踪和考虑如何将这些部分连接起来。</p><p>在 <code>Elm</code> 中，你可以根据编译器友好的错误提示来持续做一些简单的改变直到程序调通。你不需要担心在功能开发中途离开，因为当你回来的时候，编译器会提醒你接下来做什么。此外，你可以简单快速的在整个代码库中进行全面更改但是却没有任何程序崩溃。用 <code>Elm</code> 编程就如同和一个厉害的 robot 一起编程一样。 </p><p><code>React</code> 取决于开发者不要犯错误，尽管有像 <code>eslint</code> 这样的静态分析工具可以帮助您，但是对于像 <code>JavaScript</code> 这样的动态语言的帮助是有限的，当你犯错误时，在开发模式下，你可能会看到用 “Red Screens of Death” 显示的运行时错误。</p><p><img src="/img/articles/elm-native-ui-in-production/UMpL2QIqQFutYXmAJikX_react-native-red-screen-of-death.png1525918443.8166037" alt=""></p><p>Elm 另一方面依赖编译器来捕获 bug，我很高兴的说，在 <code>Purple Train</code> 运行期间，我没有碰到一个 Red Screen of Death<sup>[1]</sup>。</p><h3 id="Not-Ready-for-Prime-Time"><a href="#Not-Ready-for-Prime-Time" class="headerlink" title="Not Ready for Prime Time"></a>Not Ready for Prime Time</h3><p>尽管到目前为止 <code>Elm Native UI</code> 的体验非常棒，但是 <code>Elm Native UI</code> 至今还没有为大多数生产环境的 APP 做好准备。它仍然缺少关键功能，如图片绑定和简单的设定过程 - 当前过程实现这些仍然颇具挑战。目前 thoughtbot 在为 <code>Elm Native UI</code> 在一些重要方面的应用而努力。如果你还有疑问，你可以访问 <a href="http://elmlang.herokuapp.com/" target="_blank" rel="noopener">elmlang Slack</a>  的 <code>#elm-native-ui</code> 频道。</p><hr><p>1、这并不完全正确。我遇到了 Red Screens of Death ，是当我为 <code>Elm Native UI</code> 库开发新功能时，而不是为 <code>Purple Train</code> 写新功能的时候。假定 <code>Elm Native UI</code> 中的 <code>JavaScript</code> 是没有 bug ，我希望这对于其他 APP 也是这样。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Josh Steiner，&lt;a href=&quot;https://robots.thoughtbot.com/elm-native-ui-in-production&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-03-01&lt;br&gt;译者：&lt;a href=&quot;http://muhlenxi.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;muhlenXi&lt;/a&gt;；校对：&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/9efd08855d3a/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;aaaron7&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在 11 月份，thoughtbot 发布了一个叫 &lt;a href=&quot;https://purpletrainapp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Purple Train&lt;/a&gt; 的 APP ，该 APP 是用 &lt;a href=&quot;https://thoughtbot.com/services/react&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React Native&lt;/a&gt; 实现的， &lt;code&gt;React Native&lt;/code&gt; 一直被用于快速构建跨平台的 APP 。由于 &lt;code&gt;Reactive Natice&lt;/code&gt; 对传统移动开发的许多改进，使我们更加喜欢它，比如声明性 API、更快的开发周期、对 Web 开发和设计师来说更友好和跨平台等。但是 &lt;code&gt;React Native&lt;/code&gt; 并不是对每个 APP 都非常合适，它虽然适合大多数的 APP ，但仍然有一个主要的缺陷：&lt;code&gt;JavaScript&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt; 作为一门语言它一直在改进，它有一个显著优点就是无所不在，然而，它也以 &lt;a href=&quot;https://www.destroyallsoftware.com/talks/wat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;奇怪的行为&lt;/a&gt; 和弱类型系统（读作 &lt;code&gt;aggressive type coercion&lt;/code&gt; ）而闻名。&lt;/p&gt;
    
    </summary>
    
      <category term="Thoughtbot" scheme="https://swift.gg/categories/Thoughtbot/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>抛弃视图控制器，做自己的控制器</title>
    <link href="https://swift.gg/2018/05/02/just-controllers/"/>
    <id>https://swift.gg/2018/05/02/just-controllers/</id>
    <published>2018-05-02T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2018/02/just-controllers/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-02-21<br>译者：<a href="https://weibo.com/u/5029986118" target="_blank" rel="noopener">东莞大唐和尚</a>；校对：<a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefex</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>苹果官方文档中提到过 MVC 的软件设计模式。不过，苹果介绍的并不是本质意义上的 MVC 。<a href="http://khanlou.com/2014/03/model-view-whatever/" target="_blank" rel="noopener">关于这一点我之前也有写过一篇文章</a>，MVC 是为 Smalltalk 语言设计的一种设计模式。在 Smalltalk 语言里，MVC 的三个组件：模型（model）、视图（view）和控制器（controller）之间都可以相互通信。这就意味着要么视图知道自己持有的模型是如何实现的，要么模型知道自己是如何在视图中被应用的。</p><p>我们写 iOS 软件的时候，通常会把可以直接通信的视图和模型称之为“反模式”（PS：不推荐这么做）。我们所谓的 MVC 更准确的说其实是“模型-视图-适配器（Model - View - Adapter）”。我们说的“视图控制器”其实只是模型和视图中间沟通的一个桥梁。笼统来讲，我觉得这是对正统MVC一个不错的改良——不是把视图和模型绑在一起，而是通过一个适配器把模型和视图联系起来，这个方法不错。然而，不得不说，在我工作中涉及到的大部分系统中，模型和视图都是分开的。</p><p>以上就是为什么 iOS 开发里会有视图控制器的原因：用来连接模型和视图。但是这种模式的编码会产生一些问题：有一些代码看起来既不属于模型，也不属于视图，所以我们就把这些代码放到了视图控制器里，最后视图控制器变得超级臃肿。关于这个问题，我在博客里面讨论过<a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener">很多次</a>，但这次我想说的不是这个问题。</p><a id="more"></a><hr><p>我私下里听到过很多关于 <code>UIViewController</code> 的谈论。我认为 <code>UIViewController</code> 这个基本类写的不是很好，这一点你用 UIKit 用得越久就越能感觉到。听说 <code>UIViewController</code> 这个基本类型有 1 万到 2 万行代码（那是几年前了，现在可能已经超过两万行了）。</p><p>当我们需要把 <code>UIView</code> 和一个模型联系起来的时候，我们通常会把视图控制器分成一个个小的视图控制器组件，然后再组装到一起。</p><p>但是，这样做太小题大做了。一个小地方没处理好，就会出现很多 bug，而且这样的 bug 很难修复，也没有什么提示。然后，当你终于找到 bug 的时候，发现通常都是 <code>didMove</code> 或者 <code>willMove</code> 的调用顺序不对导致的。其实，出现 <code>didMove</code> 和 <code>willMove</code> 的时候就已经说明这些组件一些内部状态需要清理了。</p><p>这样的情况我自己就遇到过两次。第一次是我把视图控制器放在了 <code>tableView</code> 的 <code>cell</code> 里。出现的 bug 就是，table view 里面的一些内容总会莫名其妙地消失。然后过了好几个月，我才意识到我对 table view cells 的生命周期理解有误。</p><p>在我改正了一些对 <code>-addChildViewController</code> 的调用之后，程序就正常运行了。</p><p>这件事让我看到了一个很大的问题：视图控制器的视图并不是一个普普通通的视图，而是一个视图控制器的视图。它有自己一些特性。</p><p>回过头去看，一切都很明显。<code>UIViewController</code> 怎么知道什么时候该去调用 <code>viewDidLayoutSubviews</code>? 肯定是 <code>view</code> 向它发送了请求，这就意味着视图控制器对视图是有一些依赖的。</p><p>第二次是最近碰到的，这次的问题出现在我把一个视图控制器的视图作为 <code>text field</code> 的 <code>inputAccessoryView</code> 时。当时我在实现一个通信软件（类似  iMessage）里 <code>textField</code> 贴在屏幕底部的功能，整个过程十分挫败。我花了整整一天时间都没搞定，最后还是把这个视图转换成了一个普通的视图。</p><hr><p>所以，我们通常想 <code>UIViewController</code> 应该做的是哪些事情呢？</p><ul><li>承载视图</li><li>把模型和视图联系起来</li></ul><p>那 <code>UIViewController</code> 还做了哪些我们并不十分在意的事呢？</p><ul><li>为子视图控制器提供存储</li><li>把外观和过渡动画推送给子视图控制器</li><li>可以在类似 <code>UINavigationController</code> 的容器中显示</li><li>内存过低通知</li><li>处理状态栏</li><li>保存状态、恢复状态</li></ul><p>知道了这些，在一些特殊情况下，需要我们做一个替代视图控制器的东西时，我们就知道了哪些东西是我们并不需要的。我喜欢这样，因为这样可以快速地解决问题，同时也符合我“自己的事情自己做”的性格。</p><p>还有一个问题，这个东西怎么命名呢？我觉得命名成一个视图控制器不太好，很容易被误解为一个 <code>UIViewController</code>的子类。或者，我们就叫它 <code>Controller</code>？我觉得可以（<a href="http://khanlou.com/2014/11/a-controller-by-any-other-name/" target="_blank" rel="noopener">尽管我之前可能有其他观点</a>），因为它的作用就是 iOS MVC 设计框架中控制器的作用（把视图和模型联系起来），但是还有其他一些备选：<code>Binder</code>（粘合）, <code>Binding</code>（捆绑）, <code>Pair</code>（配对）, <code>Mediator</code>（中介）, <code>Concierge</code>（前台）。</p><p>这个做法还有一个好处是，<strong>特别好写</strong>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DestinationTextFieldController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> destination: <span class="type">Destination</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">DestinationTextFieldControllerDelegate</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> textField = <span class="type">UITextField</span>().configure(&#123;</span><br><span class="line">        $<span class="number">0</span>.autocorrectionType = .no</span><br><span class="line">        $<span class="number">0</span>.clearButtonMode = .always</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可能不用 <code>UIViewController</code> 的子类，然后写这样一个东西，会有人喊，“异教徒！烧死他！”。但是，当 <code>UIViewController</code> 没有把自己该做的事情做好的时候，我们就应该抛弃它。</p><p>现在大家已经知道怎么给自己的新对象加新功能了。在我的这个例子中，控制器成了 <code>textField</code> 的代理，文字变化时发出事件（以及域元数据 domain metadta），同时提供更新视图（这个例子中是<code>textField</code>）的接口。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DestinationTextFieldController</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> isActive: <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.textField.isFirstResponder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(with destination: Destination)</span></span> &#123;</span><br><span class="line"><span class="keyword">self</span>.destination = destination</span><br><span class="line">configureView()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">configureView</span><span class="params">()</span></span> &#123;</span><br><span class="line">textField.text = destination.descriptionForDisplay</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种新的控制器你还需要做其他几件事：</p><ul><li>你得新建一个实例变量来存储数据</li><li>你得负责一些触发事件——因为它不是一个视图控制器，没有 <code>-viewDidAppear</code></li><li>因为新的控制器已经不在 <code>UIKit</code> 框架里面了，所以其他一些 <code>UIKit</code> 的特性（<a href="https://developer.apple.com/documentation/uikit/uitraitcollection" target="_blank" rel="noopener">UITraitCollection</a>, <a href="https://developer.apple.com/documentation/uikit/uiview/positioning_content_relative_to_the_safe_area" target="_blank" rel="noopener">safe area insets</a>，或者<a href="https://developer.apple.com/documentation/uikit/uiresponder" target="_blank" rel="noopener">UIResponder</a>）都不能再使用了。而需要你自己实现。</li></ul><p>使用这个对象不是很难，不过你还是需要写明它的数据存储方式， 防止它的内存被回收。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span>, <span class="title">DestinationTextFieldControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> destinationViewController = <span class="type">DestinationTextFieldController</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">destinationViewController.delegate = <span class="keyword">self</span></span><br><span class="line">view.addSubview(destinationViewController.view)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//handle any delegate methods</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>话说回来，即使你使用我说的这个方法，其他大部分的视图应该还会是视图控制器和 <code>UIViewController</code> 的子类。不过，在某些特殊的情况下，整合一个视图控制器会耗费你过多的精力，这时候采用这种方法，就可以避免再次被 <code>UIKit</code> 折磨。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2018/02/just-controllers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-02-21&lt;br&gt;译者：&lt;a href=&quot;https://weibo.com/u/5029986118&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;东莞大唐和尚&lt;/a&gt;；校对：&lt;a href=&quot;https://weibo.com/u/5953150140&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lefex&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;苹果官方文档中提到过 MVC 的软件设计模式。不过，苹果介绍的并不是本质意义上的 MVC 。&lt;a href=&quot;http://khanlou.com/2014/03/model-view-whatever/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于这一点我之前也有写过一篇文章&lt;/a&gt;，MVC 是为 Smalltalk 语言设计的一种设计模式。在 Smalltalk 语言里，MVC 的三个组件：模型（model）、视图（view）和控制器（controller）之间都可以相互通信。这就意味着要么视图知道自己持有的模型是如何实现的，要么模型知道自己是如何在视图中被应用的。&lt;/p&gt;
&lt;p&gt;我们写 iOS 软件的时候，通常会把可以直接通信的视图和模型称之为“反模式”（PS：不推荐这么做）。我们所谓的 MVC 更准确的说其实是“模型-视图-适配器（Model - View - Adapter）”。我们说的“视图控制器”其实只是模型和视图中间沟通的一个桥梁。笼统来讲，我觉得这是对正统MVC一个不错的改良——不是把视图和模型绑在一起，而是通过一个适配器把模型和视图联系起来，这个方法不错。然而，不得不说，在我工作中涉及到的大部分系统中，模型和视图都是分开的。&lt;/p&gt;
&lt;p&gt;以上就是为什么 iOS 开发里会有视图控制器的原因：用来连接模型和视图。但是这种模式的编码会产生一些问题：有一些代码看起来既不属于模型，也不属于视图，所以我们就把这些代码放到了视图控制器里，最后视图控制器变得超级臃肿。关于这个问题，我在博客里面讨论过&lt;a href=&quot;http://khanlou.com/2015/10/coordinators-redux/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;很多次&lt;/a&gt;，但这次我想说的不是这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="khanlou.com" scheme="https://swift.gg/categories/khanlou-com/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程：基本概念</title>
    <link href="https://swift.gg/2018/05/02/swift-functional-programming-basic-concepts/"/>
    <id>https://swift.gg/2018/05/02/swift-functional-programming-basic-concepts/</id>
    <published>2018-05-02T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andyy Hope，<a href="https://medium.com/swift-programming/swift-functional-programming-basic-concepts-a6b0c3937d56" target="_blank" rel="noopener">原文链接</a>，原文日期：2016-05-18<br>译者：<a href="http://muhlenxi.com/" target="_blank" rel="noopener">muhlenXi</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="https://lision.me/" target="_blank" rel="noopener">Lision</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>通常情况下，人们在学习了函数式编程（Function Programming 即 FP）之后就根本停不下来对它的修改，甚至到了一种如果 FP 不是特别酷的话就会烦躁的地步。回忆一下 1999 年经典非主流电影 Fight Club 最著名的情景，完全颠覆了人们的头脑。</p><blockquote><p><strong>函数式编程俱乐部的条例：</strong><br>1.永远不要停止函数式编程。<br>2.永远不要停止函数式编程！</p></blockquote><a id="more"></a><p>一些人对函数式编程很热心，就像对 Crossfit 一样热情，但是与 Crossfit不一样的是，函数式编程没有 73.5% 的机会去损害并且影响到你的工作，事实上它提高了你编写的代码的安全性，可读性和价值。</p><p>Swift 绝不是类似 Haskell 这种纯粹的函数式编程语言，而是一种把其他语言的部分精华紧密结合起来的多范式编程语言。</p><p>在第一部分，我们将会了解函数式编程的比较简单的概念和阐述如何用 Swift 编写函数式代码。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这是很容易理解的，不变性的意思就是一个值只要被设定，以后就不能再被改变。在 Swift 中，我们通过 <code>let</code> 关键字来创建一个不可变的值。</p><p>不变性的原因是因为它允许开发者编写线程安全的代码。在我们使用的过程中，我们可以完全确定应用中的其他线程是不能改变它的值的。</p><h3 id="值的类型"><a href="#值的类型" class="headerlink" title="值的类型"></a>值的类型</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CGRect</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>当我们用值代替引用来传递变量的值时，我们创建的代码是安全的。<code>struct</code> 类型在 Swift 标准库中使用得最多，比如：<code>Array</code>, <code>Dictionary</code>, <code>Int</code>, <code>Bool</code> 等等都是 <code>struct</code> 。</p><p>这些数据结构比引用安全的原因是因为当我们通过传递值来设置对象时，实际传递的是值的拷贝。我们可以通过下面的代码来理解这个概念：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="type">CGRect</span>.zero</span><br><span class="line"><span class="keyword">var</span> square = box.size</span><br><span class="line"></span><br><span class="line">box.size.height = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// square: width: 0,height: 0</span></span><br><span class="line"><span class="comment">// box.size: width: 0,height: 10</span></span><br></pre></td></tr></table></figure><p>如果将 <code>CGRect</code> 和 <code>CGSize</code> 的值类型改为引用类型，当我们改变 <code>box</code> 的 <code>height</code> 时候，<code>square</code> 的 <code>height</code> 也将会发生改变。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">box.size.height = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// square: width: 0,height: 10</span></span><br><span class="line"><span class="comment">// box.size: width: 0,height: 10</span></span><br></pre></td></tr></table></figure><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的返回值取仅决于输入值，没有任何可见副作用。它只做了一件事就是对输入的值进行计算并返回，没有其他的。</p><p>即使我们在 <code>sum()</code> 函数中放入一个 <code>log</code> 语句，这也会把该函数变成非纯函数，这在编写代码时非常具有传染性。</p><p>所以基本上编写纯函数的思想消除了副作用代码产生的全部机会，这些副作用代码可能会增加我们的 <code>bug</code> ，当然，也包括上文提到的 <code>log</code> 。</p><h3 id="一等函数"><a href="#一等函数" class="headerlink" title="一等函数"></a>一等函数</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hi!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeting = sayHello</span><br><span class="line"></span><br><span class="line">greeting()</span><br><span class="line"></span><br><span class="line"><span class="comment">// prints: Hi!</span></span><br></pre></td></tr></table></figure><p>在 Swift 的创作过程中，Swift 作者们决定将所有他们能想到的每件东西都视为一等公民，当函数是一等公民时，这个意思就是我们可以把一个函数赋值给一个变量，就跟我们使用 <code>Int</code> 或者 <code>String</code> 一样。</p><p>这就允许我们编写的函数可以被别的函数当做参数传递或者作为结果来返回，所以我们可以在代码中进行函数的传递。</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>因为把函数视为一等公民，那也就意味着我们能够创建高阶函数，一个函数被认定为高阶函数，它必须至少满足以下提到的两个特征的一种：</p><ul><li>使用函数作为参数</li><li>返回值是函数</li></ul><p>举个例子来说明一下，我们创建一个接受函数作为参数的高阶函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inside</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Yo!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inside's structure</span></span><br><span class="line"><span class="comment">// () -&gt; Void</span></span><br></pre></td></tr></table></figure><p>我们创建一个叫 <code>inside</code> 的无参返回值为空的函数，即返回值的类型为 <code>Void</code> ，在函数的下面，我描述了函数的结构，这对我们理解高阶函数将会很重要。当我们将一个函数作为参数来传递时，编译器将会分析和验证该函数的兼容性。现在，让我们来看一个函数接受另一个函数作为参数的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outside</span><span class="params">(inner:<span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">inner()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，<code>outside</code> 函数接受一个参数，并且这个参数是一个函数，如果你查看 <code>inner</code> 这个参数的类型，你将会发现，这和上面的 <code>inside</code> 函数的返回类型是一致的。因为这两个函数的参数类型是一样的，所以我们能够将 <code>inside</code> 赋值给 <code>inner</code> 且编译器不会发出警告或报错。</p><p>最后，我们在 <code>outside</code> 函数的内部调用参数 <code>inner</code> ，它会转而去调用 <code>inside</code> 函数内部的 <code>print()</code> 函数:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">outside(inside)</span><br><span class="line"><span class="comment">// prints: Yo!</span></span><br></pre></td></tr></table></figure><h2 id="高级概念"><a href="#高级概念" class="headerlink" title="高级概念"></a>高级概念</h2><h3 id="响应链、合成和柯里化"><a href="#响应链、合成和柯里化" class="headerlink" title="响应链、合成和柯里化"></a>响应链、合成和柯里化</h3><p>我们仅仅接触到了 Swift 函数式编程的表面，在我后续的发表文章中，将会包含许多新的内容，包括一些更高级的概念，比如上面小标题提到的第三个部分(即高级概念)，它们有些复杂，在稍后的文章中将会有详细介绍，希望现在你能对 Swift 是如何进行函数式编程的基础部分能有深入理解，然后用来使你的代码更加健壮、安全和多功能。</p><p>我想要正式的欢迎你加入函数式编程的俱乐部。在等待后续文章期间希望你能熟记练习规则 <code>1</code> 和 <code>2</code> 。</p><p>本文中的<a href="https://github.com/andyyhope/Blog_FunctionalProgramming_BasicConcepts" target="_blank" rel="noopener">示例代码</a>在 GitHub 上可以下载。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Andyy Hope，&lt;a href=&quot;https://medium.com/swift-programming/swift-functional-programming-basic-concepts-a6b0c3937d56&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-05-18&lt;br&gt;译者：&lt;a href=&quot;http://muhlenxi.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;muhlenXi&lt;/a&gt;；校对：&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;，&lt;a href=&quot;https://lision.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lision&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;通常情况下，人们在学习了函数式编程（Function Programming 即 FP）之后就根本停不下来对它的修改，甚至到了一种如果 FP 不是特别酷的话就会烦躁的地步。回忆一下 1999 年经典非主流电影 Fight Club 最著名的情景，完全颠覆了人们的头脑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;函数式编程俱乐部的条例：&lt;/strong&gt;&lt;br&gt;1.永远不要停止函数式编程。&lt;br&gt;2.永远不要停止函数式编程！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="medium.com" scheme="https://swift.gg/categories/medium-com/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>Swift 服务端开发指南</title>
    <link href="https://swift.gg/2018/04/24/server-side-commands/"/>
    <id>https://swift.gg/2018/04/24/server-side-commands/</id>
    <published>2018-04-24T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2017/06/server-side-commands" target="_blank" rel="noopener">原文链接</a>，原文日期：2017/6/21<br>译者：<a href="http://weibo.com/277195544" target="_blank" rel="noopener">Cwift</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>在服务端使用 Swift 时，大多数路由框架都会把路由同一个指定的闭包关联起来。比如我们在编写 <a href="http://beacon.party" target="_blank" rel="noopener">Beacon</a>  时使用的 <a href="https://vapor.codes" target="_blank" rel="noopener">Vapor</a> 框架。你可以在该框架主页的测试示例中看到如下的代码：</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vapor</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> droplet = <span class="keyword">try</span> <span class="type">Droplet</span>()</span><br><span class="line"></span><br><span class="line">droplet.<span class="keyword">get</span>(<span class="string">"hello"</span>) &#123; req <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, world."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> droplet.run()</span><br></pre></td></tr></table></figure><p>当你运行这段代码时，访问 <code>localhost:8080/hello</code> 会展示文本 <code>Hello, world.</code> 。</p><p>有时候，你想要向 <code>API</code> 的调用者返回一个特殊的 <code>HTTP</code> 代码，提示执行了一个特殊的操作。示例如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">droplet.post(<span class="string">"devices"</span>, handler: &#123; request <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span> apnsToken: <span class="type">String</span> = <span class="keyword">try</span> request.niceJSON.fetch(<span class="string">"apnsToken"</span>)</span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">try</span> request.session.ensureUser()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> device = <span class="keyword">try</span> <span class="type">Device</span>(apnsToken: apnsToken, userID: user.id.unwrap())</span><br><span class="line"><span class="keyword">try</span> device.save()</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">try</span> device.makeJSON()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（我打算在之后的博客中详细介绍 <code>niceJSON</code> 的用法，不过现在请忽略它。）</p><p>这是个非常好的请求，和 <code>Beacon</code> 中的代码很像。不过有一个问题：当你返回类似字符串的对象（本文的第一个示例）或者 <code>JSON</code>（本文的第二个示例）时，Vapor 会返回 <code>200</code> 的状态码。但是这是一个 <code>POST</code> 请求并且创建了一个新的 <code>Device</code> 资源，所以应该返回 <code>201 Created</code> 的 <code>HTTP</code> 状态码。所以你需要创建一个完整的 <code>Response</code> 对象：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="type">Response</span>(status: .created)</span><br><span class="line">response.json = <span class="keyword">try</span> device.makeJSON()</span><br><span class="line"><span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>对每个创建型的请求重复执行这样的操作很烦人。</p><p>最后一点，端点（endpoints）通常会有副作用。特别是使用 Rails 编写的应用，管理和测试这些端点是非常困难的，在 Rails 社区中已经出现了许多有关的讨论了。如果注册需要发送注册邮件，那么如何布置 “桩代码” （stub）以便测试剩余的代码？这是很难做到的，如果所有逻辑都在一个复杂的函数中执行，更是难上加难。在 <code>Beacon</code> 中没有任何发送邮件的功能，但是我们的确有很多推送通知。监管这些推送的副作用是很重要的。</p><p>一般来说，在每个路由中使用一个闭包的风格，已经应用在 <code>Flask</code>、<code>Sinatra</code> 和 <code>Express</code> 之类的框架中了。它们都是非常好的示例，不过真实的项目往往具有复杂的端点，依旧是把所有逻辑放在一个复杂的方法中。</p><p>进一步说，Rails 风格的控制器模块很庞大，而与每个端点匹配的相关方法都使用控制器作为命名空间，这使得控制器彼此之间具有边界攻击性。我觉得我们可以做的比以上两种模式（使用闭包的风格和 Rails 风格）更好。（如果你想了解 Ruby 服务器架构，我已经从 <a href="https://github.com/trailblazer/trailblazer" target="_blank" rel="noopener">Trailblazer</a> 项目中总结了一些经验。）</p><p>最基本的一点是我想要一个更好的抽象来响应传入的请求。为此，我使用了一个称之为 <code>Command</code> 的对象来封装端点需要做的工作。</p><p><code>Command</code> 模式的起始部分是一个协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(request: <span class="type">Request</span>, droplet: <span class="type">Droplet</span>) <span class="keyword">throws</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> status: <span class="type">Status</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">JSON</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Command</span>: <span class="title">ResponseRepresentable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeResponse</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Response</span> &#123;</span><br><span class="line"><span class="keyword">let</span> response = <span class="type">Response</span>(status: <span class="keyword">self</span>.status)</span><br><span class="line">response.json = <span class="keyword">try</span> execute()</span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是 <code>Command</code> 协议的基础外壳，后面会向其中添加更多的代码。从协议的基础部分可以了解如何使用这种模式。下面来使用新模式重写“注册设备”这个端点。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">droplet.post(<span class="string">"devices"</span>, handler: &#123; request <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">RegisterDeviceCommand</span>(request: request, droplet: droplet)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为该命令遵守了 <code>ResponseRepresentable</code>，所以 Vapor 接受它作为路由的 <code>handler</code> 闭包的有效返回值。 它将自动调用 <code>Command</code> 的 <code>makeResponse()</code> 方法并且为 API 的调用者返回一个 <code>Response</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterDeviceCommand</span>: <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apnsToken: <span class="type">String</span></span><br><span class="line"><span class="keyword">let</span> user: <span class="type">User</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(request: <span class="type">Request</span>, droplet: <span class="type">Droplet</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line"><span class="keyword">self</span>.apnsToken = <span class="keyword">try</span> request.niceJSON.fetch(<span class="string">"apnsToken"</span>)</span><br><span class="line"><span class="keyword">self</span>.user = <span class="keyword">try</span> request.session.ensureUser()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> status = <span class="type">Status</span>.created</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">JSON</span> &#123;</span><br><span class="line"><span class="keyword">var</span> device = <span class="keyword">try</span> <span class="type">Device</span>(apnsToken: apnsToken, userID: user.id.unwrap())</span><br><span class="line"><span class="keyword">try</span> device.save()</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">try</span> device.makeJSON()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是该模式的一些优点：</p><ol><li>在服务端使用诸如 Swift 这样的新语言的主要吸引力是可以使用新的特性，比如用可选型（更针对性地说，是为了解决以前的缺陷）来保障一个请求成功完成。因为 <code>apnsToken</code> 和 <code>user</code> 的类型是非可选型的，所以如果 <code>init</code> 方法在结束时没有初始化所有的属性，则文件无法通过编译。</li><li>状态码的使用方式很友好。</li><li>初始化与执行分离。你可以编写一个测试，检查对象的初始化过程（例如，从请求中提取属性），该测试与检查实际的 <code>save()</code> 方法的测试是分离的。</li><li>至于副作用，该模式可以轻松地把不同的 <code>Command</code> 放置到自己的文件中。</li></ol><p>可以向 <code>Command</code> 中添加两个更重要的组件。首先是验证。添加 <code>func validate() throws</code> 到 <code>Command</code> 协议中，编写一个默认的空实现。他也会被添加到 <code>makeResponse()</code> 方法中，在 <code>execute()</code> 方法之前执行：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeResponse</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Response</span> &#123;</span><br><span class="line"><span class="keyword">let</span> response = <span class="type">Response</span>(status: <span class="keyword">self</span>.status)</span><br><span class="line"><span class="keyword">try</span> validate()</span><br><span class="line">response.json = <span class="keyword">try</span> execute()</span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>validate()</code> 方法的典型样式可能如下所示（来自 Beacon 的 <code>AttendEventCommand</code>）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">validate</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line"><span class="keyword">if</span> attendees.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.userID == user.id &#125;) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">ValidationError</span>(message: <span class="string">"You can't join an event you've already joined."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> attendees.<span class="built_in">count</span> &gt;= event.attendanceLimit &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">ValidationError</span>(message: <span class="string">"This event is at capacity."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> user.id == event.organizer.id &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">ValidationError</span>(message: <span class="string">"You can't join an event you're organizing."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码易于阅读，保持所有验证本地化并且非常易于测试。虽然你可以构造你自己的 <code>Request</code> 和 <code>Droplet</code> 对象，然后把它们传入 <code>Command</code> 的指定构造器，但是你完全没必要这么做。因为每个 <code>Command</code> 都是你自己的对象，所以你可以编写一个接受完备的诸如 <code>User</code> 和 <code>Event</code> 这类对象的构造器，你不需要手动构造 <code>Request</code> 对象进行测试，除非你有测试 <code>Command</code> 构造过程的特殊需求。</p><p>Command 需要的最后一个组件是执行副作用的功能。副作用很简单：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">SideEffect</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">()</span></span> <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在 <code>Command</code> 协议中增加了一个属性，该属性列出了 Command 执行之后需要执行的 <code>SideEffect</code> 对象。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sideEffects: [<span class="type">SideEffect</span>] &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>最后，副作用被添加到了 <code>makeResponse()</code> 方法中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeResponse</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Response</span> &#123;</span><br><span class="line"><span class="keyword">let</span> response = <span class="type">Response</span>(status: <span class="keyword">self</span>.status)</span><br><span class="line"><span class="keyword">try</span> validate()</span><br><span class="line">response.json = <span class="keyword">try</span> execute()</span><br><span class="line"><span class="keyword">try</span> sideEffects.forEach(&#123; <span class="keyword">try</span> $<span class="number">0</span>.perform() &#125;)</span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（在代码的未来版本中，副作用可能会以异步的方式执行，即不会阻止向用户发送响应的过程，不过目前只能同步执行。）将副作用与 <code>Command</code> 的其余部分分离的主要原因是便于测试。你可以创建 <code>Command</code> 并且执行，而不必隔离副作用，因为副作用永远不会被执行。</p><p><code>Command</code> 模式是一个简单的抽象，但它是可测试且正确的，坦白地说，它使用起来令人很愉悦。你可以在这个 <a href="https://gist.github.com/khanlou/133c3cf65d434ec2e66a28a519df3372" target="_blank" rel="noopener">gist</a> 中找到协议的完整定义。我不会因为 Vapor 没有包含这类的抽象而打击它：和其他服务端的框架一样，Vapor 设计简单，你可以根据个人喜好对它进行抽象。 </p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2017/06/server-side-commands&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017/6/21&lt;br&gt;译者：&lt;a href=&quot;http://weibo.com/277195544&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cwift&lt;/a&gt;；校对：&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在服务端使用 Swift 时，大多数路由框架都会把路由同一个指定的闭包关联起来。比如我们在编写 &lt;a href=&quot;http://beacon.party&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Beacon&lt;/a&gt;  时使用的 &lt;a href=&quot;https://vapor.codes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vapor&lt;/a&gt; 框架。你可以在该框架主页的测试示例中看到如下的代码：&lt;/p&gt;
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="Swift 跨平台" scheme="https://swift.gg/tags/Swift-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Swift 服务端错误处理</title>
    <link href="https://swift.gg/2018/04/23/errors-on-the-server/"/>
    <id>https://swift.gg/2018/04/23/errors-on-the-server/</id>
    <published>2018-04-23T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2017/07/errors-on-the-server" target="_blank" rel="noopener">原文链接</a>，原文日期：2017/07/06<br>译者：<a href="http://weibo.com/277195544" target="_blank" rel="noopener">Cwift</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Swift 的 Promise 可以让代码变得简单、正确并具有良好的语义。Swift 的错误处理系统也不例外，正确使用它可以大大提高服务器端代码质量。我们的应用 <a href="https://beacon.party" target="_blank" rel="noopener">Beacon</a> 使用 <a href="https://vapor.codes" target="_blank" rel="noopener">Vapor</a> 构建 API。Vapor 提供了许多构建 API 的基本组件，但更重要的是，它提供了扩展功能，你可以自己添加错误处理。</p><a id="more"></a><p>错误处理的核心是给每个函数基本都标上 <code>throws</code>。你随时可以抛出错误，这个错误会一路冒泡传递上去，一路通过你的路由处理函数和所有中间件。</p><p>Vapor 通常会加载一个 HTML 错误页来显示错误。因为 Beacon 的服务端组件是 JSON API，所以我们需要用中间件将 <code>AbortError</code>（Vapor 的错误类型，包括消息内容和一个状态码）转换为可用的 JSON。这个中间件的模板非常简单，所以我没怎么写注释：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONErrorMiddleware</span>: <span class="title">Middleware</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">respond</span><span class="params">(to request: Request, chainingTo next: Responder)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Response</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">try</span> next.respond(to: request)</span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">AbortError</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> response = <span class="type">Response</span>(status: error.status)</span><br><span class="line">            response.json = <span class="keyword">try</span> <span class="type">JSON</span>(node: [</span><br><span class="line">                <span class="string">"error"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"message"</span>: error.message,</span><br><span class="line">                <span class="string">"code"</span>: error.code,</span><br><span class="line">                <span class="string">"metadata"</span>: error.metadata,</span><br><span class="line">            ])</span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Vapor 1.5 中，你可以把中间件添加到 <code>droplet</code> 中来激活它，<code>droplet</code> 对象就是你的应用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">droplet.middleware.append(<span class="type">JSONErrorMiddleware</span>())</span><br></pre></td></tr></table></figure><p>现在我们已经可以显示错误，接下来我们看看如何优化错误信息。大多数时候，当服务器发生错误时，会使用 nil 作为失败时的返回值，表示没取到想要获取的值。所以我们首先来添加一个 <code>unwrap()</code> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NilError</span>: <span class="title">Error</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">unwrap</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> result = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NilError</span>() &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个请求的返回值为 nil 但是你不想直接返回它，就可以用这个函数让请求直接失败。假设你想使用 <code>id</code> 查找某个 <code>Event</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="type">Event</span>.<span class="built_in">find</span>(id)</span><br></pre></td></tr></table></figure><p>不出所料，<code>event</code> 的类型是 <code>Optional&lt;Event&gt;</code>。因为调用 find 方法时给定的 ID 在数据库中可能不存在，所以它返回了一个可选值。有时候我们不需要空值。例如，在 Beacon 中，如果你尝试参加某个活动，该活动为空并不是正常流程。为了应对这种情况，我用 unwrap() 处理返回值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="type">Event</span>.<span class="built_in">find</span>(id).unwrap()</span><br></pre></td></tr></table></figure><p>现在 <code>event</code> 的类型是 <code>Event</code>，如果活动不存在，函数会直接结束并把错误传递到上面提到的 <code>JSONErrorMiddleware</code>，返回给用户会看到 JSON 格式的错误信息。</p><p><code>unwrap()</code> 的问题是丢失了上下文。到底什么类型获取失败了？如果是在 Ruby 或者 Java 中，我们至少有一个堆栈跟踪器，可以了解到是哪些函数调用报错。可惜在 Swift 里我们没有这种东西。我们最多只能捕获这个错误解包发生的文件和行数。我已经在 <a href="https://github.com/login/oauth/authorize?client_id=7e0a3cd836d3e544dbd9&amp;redirect_uri=https%3A%2F%2Fgist.github.com%2Fauth%2Fgithub%2Fcallback%3Freturn_to%3Dhttps%253A%252F%252Fgist.github.com%252Fkhanlou%252Fe4b5db71a6a18903d8a78edd04068780&amp;response_type=code&amp;state=7847690730bf2d71212c928a94096750c72943aa61610c1614398d52b9a1d383" target="_blank" rel="noopener">这个版本的 <code>NilError</code></a> 中实现了这个功能。</p><p>此外，由于没有上下文，Vapor 没法判断状态代码。你应该注意到了 <code>JSONErrorMiddleware</code> 仅仅遵守了 <code>AbortError</code> 协议。那么其他类型的错误呢？它们被封装在符合 <code>AbortError</code> 协议的对象中，但是状态码被预设为 <code>500</code>，这不是我们想要的。虽然 <code>unwrap()</code> 非常适合快速获取内容。但是一旦你的客户端需要返回正确的状态码以及有用的错误信息，这个方法就不再适用了。为此，我们将探讨如何为该项目构建自定义错误类型。</p><h2 id="缺少资源"><a href="#缺少资源" class="headerlink" title="缺少资源"></a>缺少资源</h2><p>先来解决对象丢失的问题。如果我们的 ID 来自一个 URL 中的参数，这个请求应该返回 <code>404</code>。在 Swift 中构建一个错误信息很简单：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ModelNotFoundError</span>: <span class="title">AbortError</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> status = <span class="type">Status</span>.notFound</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> code: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status.statusCode</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">T</span>&gt;(type: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.message = <span class="string">"<span class="subst">\(typeName)</span> could not be found."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后续的示例中，我会省略 <code>code</code> 这个计算属性，因为它的作用仅仅是转发 <code>status</code> 的 <code>statusCode</code>。</p><p>定义好 <code>ModelNotFoundError</code> 之后，我们可以加上 <code>guard</code> 和 <code>throw</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> event = <span class="type">Event</span>.<span class="built_in">find</span>(id) <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">ModelNotFoundError</span>(type: <span class="type">Event</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是每次获取对象都需要写这些的代码，真的很烦。为了解决这个问题，我在 <code>Entity</code> 的扩展中封装了这段代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">findOr404</span><span class="params">(<span class="number">_</span> id: Node)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> result = <span class="keyword">self</span>.<span class="built_in">find</span>(id) <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">ModelNotFoundError</span>(type: <span class="type">Self</span>.<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的代码好多了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="keyword">try</span> <span class="type">Event</span>.findOr404(id)</span><br></pre></td></tr></table></figure><p>在服务端使用原生的错误，可以提升正确性（基于状态码和准确的消息）以及更严密的表达性。</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>我们的 API 和其他类型的访问需要验证用户身份，以便他们可以执行某些操作。为了简洁地执行该过程，我们使用中间件从用户请求中获取认证的 token，并且把该信息保存在请求对象中。（Vapor 在每个 <code>Request</code> 中包含了一个名为 <code>storage</code> 的便捷字典，你可以把自定义的信息保存在其中。）（此外，Vapor 包含了一些身份验证和 session 处理的组件。相比弄清楚 Vapor 的源码，自己实现一个更简单。）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(user: <span class="type">User</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.user = user</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> user: <span class="type">User</span>?</span><br><span class="line">    </span><br><span class="line">@discardableResult</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">ensureUser</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line"><span class="keyword">return</span> user.unwrap()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个请求都需要提供如上所示的 <code>Session</code> 对象。如果你想确保用户已通过身份验证（并且希望与该用户通信），可以调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currentUser = <span class="keyword">try</span> request.session.ensureUser()</span><br></pre></td></tr></table></figure><p>这段代码和之前的代码有相同的问题。如果用户没有正确的授权，用户会看到 <code>500</code> 的错误和一个有关 <code>nil</code> 对象的没有任何意义的错误描述，而不是 <code>401</code> 未授权的状态码和可读的错误信息。我们需要自定义另一个错误。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AuthorizationError</span>: <span class="title">AbortError</span> </span>&#123;</span><br><span class="line"><span class="keyword">let</span> status = <span class="type">Status</span>.unauthorized</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">"Invalid credentials."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 Vapor 已经实现了对这种错误的处理：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Abort</span>.custom(status: .unauthorized, message: <span class="string">"Invalid credentials."</span>)</span><br><span class="line"> ``` </span><br><span class="line"></span><br><span class="line">我使用了自定义的错误类型，原因后面会解释。</span><br><span class="line"></span><br><span class="line">现在 `ensureUser` 函数变成了这样：</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">@discardableResult</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">ensureUser</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> user = user <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">AuthorizationError</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误的-JSON-格式"><a href="#错误的-JSON-格式" class="headerlink" title="错误的 JSON 格式"></a>错误的 JSON 格式</h2><p>Vapor 对 JSON 的处理难以令人满意。假设你想从一个 JSON 中取出 <code>title</code> 键所保存的字符串内容。看看这些问号：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title = request.json?[<span class="string">"title"</span>]?.string</span><br></pre></td></tr></table></figure><p>当然，在调用链的末尾，<code>title</code> 是一个 <code>Optional&lt;String&gt;</code>。即便在末尾添加一个 <code>unwrap()</code> 也不能解决问题：因为根据 Swift 的可选链优先级规则，它只会解包可选链的最后一个元素：<code>.string</code>。我们可以通过两种方式解决这个问题。第一种是将整个表达式包裹在括号中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title = <span class="keyword">try</span> (request.json?[<span class="string">"title"</span>]?.string).unwrap()</span><br></pre></td></tr></table></figure><p>或者在每一步解包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title = <span class="keyword">try</span> request.json.unwrap()[<span class="string">"title"</span>].unwrap().string.unwrap()</span><br></pre></td></tr></table></figure><p>不必多言，这很可怕。每个展开都代表了不同的错误：第一个解包表示 <code>Content-Type</code> 中缺失了<code>application/json</code>（或者格式不正确），第二个表示 key 不存在，第三个表示 key 对应的类型不符合期望。所有的这些信息都被 <code>unwrap()</code> 丢弃了。理想情况下，我们的 API 会为每种错误提供不同的错误信息。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">JSONError</span>: <span class="title">AbortError</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status: <span class="type">Status</span> &#123;</span><br><span class="line"><span class="keyword">return</span> .badRequest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> jsonMissing</span><br><span class="line"><span class="keyword">case</span> missingKey(keyName: <span class="type">String</span>)</span><br><span class="line"><span class="keyword">case</span> typeMismatch(keyName: <span class="type">String</span>, expectedType: <span class="type">String</span>, actualType: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些 <code>case</code> 代表了上述的三种错误。我们需要根据情况添加一个函数来生成消息，这就是我们需要的全部功能。更完善的错误信息有助于客户端调试常见的错误（比如缺少 <code>Content-Type</code> ）。</p><p>这些错误，和 <code>NiceJSON</code> 组合起来（希望把这个对象作为一个单独的文章），就是下面的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title: <span class="type">String</span> = <span class="keyword">try</span> request.niceJSON.fetch(<span class="string">"title"</span>)</span><br></pre></td></tr></table></figure><p>可读性高了许多。<code>title</code> 通常也是一个具有预设类型的实例变量（<a href="http://khanlou.com/2017/06/server-side-commands/" target="_blank" rel="noopener">这篇文章</a>中有提到），所以类型推断所需的 <code>: String</code> 也可以省略。</p><p>编写代码的“正确方式”应该同时是编写代码的“最佳实践”，你不必在有价值的错误消息或者类型安全性以及简单的易于阅读的代码之间做出痛苦的折衷。</p><h2 id="外部可见的错误"><a href="#外部可见的错误" class="headerlink" title="外部可见的错误"></a>外部可见的错误</h2><p>默认情况下，Vapor 包含一个指向 <code>AbortError</code> 的错误。然而，许多（绝大多数！）情况下用户不应该从错误中看到实现的细节。例如，PostgreSQL 适配器的错误显示你所连接的数据库以及表结构的详细信息。甚至 <code>NilError</code>包含了错误的文件和行数，它显示了服务器是基于 Swift 搭建的，因此容易受到针对 Swift 的攻击。</p><p>为了隐藏一些错误信息，我创建了一个新的协议。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ExternallyVisibleError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> status: <span class="type">Status</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> externalMessage: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>ExternallyVisibleError</code> 没有遵守 <code>AbortError</code>。一旦你让 <code>AbortError</code> 对象遵守该协议，就必须提供额外的属性：<code>externalMessage</code>，它是用户看到的内容。</p><p>我们需要对 <code>JSONErrorMiddleware</code> 进行快速地修改，以便在非 <code>ExternallyVisibleError</code> 类型的错误中隐藏错误信息：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">respond</span><span class="params">(to request: Request, chainingTo next: Responder)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Response</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> next.respond(to: request)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">ExternallyVisibleError</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> response = <span class="type">Response</span>(status: error.status)</span><br><span class="line">        response.json = <span class="keyword">try</span> <span class="type">JSON</span>(node: [</span><br><span class="line">            <span class="string">"error"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"message"</span>: error.externalMessage,</span><br><span class="line">            <span class="string">"code"</span>: error.status.statusCode,</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">AbortError</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> response = <span class="type">Response</span>(status: error.status)</span><br><span class="line">        response.json = <span class="keyword">try</span> <span class="type">JSON</span>(node: [</span><br><span class="line">            <span class="string">"error"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"There was an error processing this request."</span>,</span><br><span class="line">            <span class="string">"code"</span>: error.code,</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我还添加了一些代码，只要不是 <code>.production</code> 环境，就把 <code>AbortError</code> 传递下去。</p><p>Swift 的错误类型是一个强大的工具，可以存储附加的数据、元数据和类型。Vapor 内置类型的一些简单扩展能帮助你写出更好的代码。对于我来说，Swift 的亮点就是简洁、表现力和错误处理能力，客户端和服务端应该达成这种默契。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      如何在服务端中更 Swifty 使用错误处理
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="Swift 跨平台" scheme="https://swift.gg/tags/Swift-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Twitter iOS 教程</title>
    <link href="https://swift.gg/2018/04/15/twitter-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2018/04/15/twitter-ios-tutorial-ios10/</id>
    <published>2018-04-15T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:11.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/twitter-ios-tutorial-ios10" target="_blank" rel="noopener">原文链接</a>，原文日期：2017/03/14<br>译者：<a href="https://imiem.github.io" target="_blank" rel="noopener">imiem</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://www.jianshu.com/u/2d46948e84e3" target="_blank" rel="noopener">mmoaay</a></p></blockquote><!--此处开始正文--><p>Social Framework 使在 App 中使用社交分享成为可能。本教程中我们将从图库中选取一张图片，然后在 Twitter 中分享一个带图片的推文。本教程使用 Xcode 8.2.1 和 iOS 10.2。</p><a id="more"></a><p>打开 Xcode，创建一个 Single View Application。<br><img src="/img/articles/twitter-ios-tutorial-ios10/single-view-xcode-templateformat=750w1523791017.6382737" alt=""></p><p>Product Name 命名为 <strong>IOS10TwitterTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier。Language 选择 Swift, 并确保 Devices 只选择了 iPhone。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=750w1523791017.6963322" alt=""></p><p>转到 Storyboard，拖拽一个 Image View 到主页面上。选中 Image View 跳转到属性选项卡。在 View 部分使用 “Aspect Fit” 模式。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.7377508" alt=""></p><p>这种模式会使图片自适应 Image View。下一步，在页面的 Image View 下方添加两个 Button 按钮。title 分别设为 “Choose Image” 和 “Tweet”。</p><p>选中 Image View，点击 Storyboard 右下角 Auto Layout 的 Pin 按钮，填写下方的值，点击 Add 4 Constraints 按钮。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.786322" alt=""></p><p>按住 Cmd 键选中 “Choose Image” 和 “Tweet” 按钮。点击 Storyboard 右下角的 Align 按钮然后选择 “Horizontally in Container”。点击 “Add 2 Constraints” 按钮添加约束。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.8271823" alt=""></p><p>选中 “Choose Image” 按钮，点击 Storyboard 右下方的 Auto Layout 的 Pin 按钮，选中左边的线，点击 Add 1 Constraint 按钮添加约束。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.870292" alt=""></p><p>选中 “Tweet” 按钮，点击 Storyboard 右下方的 Auto Layout 的 Pin 按钮，选中右边的线，点击 Add 1 Constraint 按钮添加约束。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.91299" alt=""></p><p>Storyboard 看起来应如下图：</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.956209" alt=""></p><p>点击 Assistant Editor，确保 ViewController.swift 文件内容可见。接着选中 Image View ，按住 Ctrl 键鼠标左键拖拽一条线到  ViewController 类中，创建如下 Outlet 。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.964874" alt=""></p><p>同上，选中 Choose Image 按钮，按住 Ctrl 键拖拽到 ViewController 类中，创建如下 Action。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791018.0067496" alt=""></p><p>选中 Tweet 按钮，按住 Ctrl 键拖拽到 ViewController 类中，创建如下 Action。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791018.0520294" alt=""></p><p>要想使用 Social framework，首先要将其导入到工程中。添加如下代码到 ViewController.swift 文件中。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Social</span><br></pre></td></tr></table></figure><p>ViewController 访问图库需要遵循 UINavigtionControllerDelegate 和 UiImagePickerControllerDelegate 协议。将声明 ViewController 的代码改为：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UINavigationControllerDelegate</span>, <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>在类中添加如下属性</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pickerController: <span class="type">UIImagePickerController</span> = <span class="type">UIImagePickerController</span>()</span><br></pre></td></tr></table></figure><p>下一步，实现 chooseImagePressed 方法</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">chooseImagePressed</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    pickerController.delegate = <span class="keyword">self</span></span><br><span class="line">    pickerController.sourceType = <span class="type">UIImagePickerControllerSourceType</span>.photoLibrary</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">self</span>.present(pickerController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将 View Controller 设为代理，同时设置图库的 sourceType。</li><li>呈现图片选择视图控制器。</li></ol><p>下一步，实现 tweetButtonPressed 方法来创建分享页。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">tweetButtonPressed</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">SLComposeViewController</span>.isAvailable(forServiceType: <span class="type">SLServiceTypeTwitter</span>) &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">let</span> tweetSheet = <span class="type">SLComposeViewController</span>(forServiceType: <span class="type">SLServiceTypeTwitter</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> tweetSheet = tweetSheet &#123;</span><br><span class="line">            tweetSheet.setInitialText(<span class="string">"Look at this nice picture!"</span>)</span><br><span class="line">            tweetSheet.add(imageView.image)</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">self</span>.present(tweetSheet, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下这个方法</p><ol><li>检查这个设备上是否有 twitter 账户。</li><li>创建 SLComposeViewController 对象，该对象用于显示推文界面和全部的功能。</li><li>在推文发布页面添加初始化文本和选中的图片。</li><li>显示推文发布页面。</li><li>如果没有 twitter 账户，在控制台打印一条信息。</li></ol><p>最后，实现 <code>imagePickerController:didFinishPickingMediaWithInfo</code> 方法。这里指定图库中的照片到 image view 上。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any])</span></span> &#123;</span><br><span class="line">    imageView.image = info[<span class="type">UIImagePickerControllerOriginalImage</span>] <span class="keyword">as</span>? <span class="type">UIImage</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">self</span>.dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想获得图库权限，必须要在 Info.plist 中添加一个键值（key）。打开 Info.plist 点击 + 添加如下键值。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=750w1523791018.0618207" alt=""></p><p>正常运行前，需要在 iOS 模拟器的设置中创建 Twitter 账号。</p><p>构建和运行工程。这个应用会请求访问图库的权限，点击允许。下一步，点击 “Choose Image”  按钮在图库中选择一张图片。下一步，点击 “Tweet” 按钮创建和发布推文。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=500w1523791018.070653" alt=""></p><p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="noopener">github</a> 上下载 IOS10TwitterTutorial 教程的源代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Arthur Knopper，&lt;a href=&quot;https://www.ioscreator.com/tutorials/twitter-ios-tutorial-ios10&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017/03/14&lt;br&gt;译者：&lt;a href=&quot;https://imiem.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;imiem&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;http://www.jianshu.com/u/2d46948e84e3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mmoaay&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Social Framework 使在 App 中使用社交分享成为可能。本教程中我们将从图库中选取一张图片，然后在 Twitter 中分享一个带图片的推文。本教程使用 Xcode 8.2.1 和 iOS 10.2。&lt;/p&gt;
    
    </summary>
    
      <category term="Arthur Knopper" scheme="https://swift.gg/categories/Arthur-Knopper/"/>
    
    
  </entry>
  
  <entry>
    <title>在 Xcode9 中自定义文件头部注释和其他文本宏</title>
    <link href="https://swift.gg/2017/12/10/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/"/>
    <id>https://swift.gg/2017/12/10/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/</id>
    <published>2017-12-10T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:08.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2017/07/xcode-9-text-macros/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017/07/24<br>译者：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>；校对：<a href="http://www.jianshu.com/users/9c51a213b02e/latest_articles" target="_blank" rel="noopener">Joy</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>我一直<a href="https://twitter.com/olebegemann/status/845263246949011457" target="_blank" rel="noopener">不喜欢 Xcode 默认给新文件头部添加的注释</a>。在我看来，从注释里得到的绝大多数信息要么和文件本身没有关系，要么通过版本控制，你能得到更详尽的信息。此外，当文件和项目更名的时候，这些注释会立刻显得过时。</p><a id="more"></a><p><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/11.png1512891714.217959" alt=""></p><p>因此，在我个人的项目里，我创建新文件后，第一件要做的事情就是删除这些注释。</p><p>这个习惯一直持续到不久前，直到 Xcode9 允许使用一个 plist 文件来自定义文件头部注释和其他被称作文本宏的东西。这部分内容在 Xcode 的<a href="https://help.apple.com/xcode/mac/9.0/index.html" target="_blank" rel="noopener">帮助文档</a>中的<a href="https://help.apple.com/xcode/mac/9.0/index.html?localePath=en.lproj#/dev91a7a31fc" target="_blank" rel="noopener">自定义文本宏</a>这一页中有详尽的描述：</p><p><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-help-customize-text-macros.png1512892169.760428" alt=""></p><ol><li><strong>首先，创建一个叫做 <code>IDETemplateMacros.plist</code> 的 plist 文件</strong></li><li><p><strong>当你想自定义一个文本宏时，就向 plist 的字典中添加一个新的键。</strong>例如，当你想修改默认的文件头部注释时，就给 plist 文件中添加一个新条目，条目的键为 <code>FILEHEADER</code>。</p><p> <img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-plist-editor-IDETemplateMacros-plist.png1512892705.4828758" alt="在 Xcode 的 plist 编辑器中编辑`IDETemplateMacros.plist`文件"></p><blockquote><p>Xcode 的 plist 编辑器只会展示一行，不过你可以用 Option + Return 添加新行。</p></blockquote><p> 如果你想知道都有哪些文本宏可以使用，你可以查看<a href="#1">下方的文本宏参考</a>。你也可以在某个宏的值中使用其他宏，只要用下划线（译者注：三个下划线）包裹起来那个宏就可以了，比如：<code>___DATE___</code>。一些文本宏也可以用一种<code>:modifier</code>语法来进行进一步的自定义。通过查看<a href="#2">下方的文本宏格式参考</a>你可以得知更多细节。</p></li><li><p><strong>然后你可以把 plist 文件放到这么几个地方。放置的位置决定了自定义的文本宏会在什么范围内生效</strong>：</p><ul><li>使用该工程 (project) 的某个特定用户创建新文件时生效：<code>&lt;ProjectName&gt;.xcodeproj/xcuserdata/[username].xcuserdatad/IDETemplateMacros.plist</code></li><li>使用该工程的所有人创建新文件时生效：<code>&lt;ProjectName&gt;.xcodeproj/xcshareddata/IDETemplateMacros.plist</code></li><li>使用该工作空间 (workspace) 的某个特定用户创建新文件时生效：<code>&lt;WorkspaceName&gt;.xcworkspace/xcuserdata/[username].xcuserdatad/IDETemplateMacros.plist</code></li><li>使用该工作空间的所有人创建新文件时生效：<code>&lt;WorkspaceName&gt;.xcworkspace/xcshareddata/IDETemplateMacros.plist</code> </li><li>使用 Xcode 创建的所有新文件都生效：<code>~/Library/Developer/Xcode/UserData/IDETemplateMacros.plist</code></li></ul></li></ol><p>当你创建一个新文件时，新文件的头部看起来像是这样：<br>​<br><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-new-file-after-customizing-text-macros.png1512892705.61613" alt="在自定义了`FILEHEADRE`文本宏后创建爱你的新文件"><br>​    </p><blockquote><p>注意，对于<code>FILEHEADER</code>宏，目前的 Xcode(Xcode9 beta3) 只会自动给第一行添加注释标记（一个不带空格的<code>//</code>），剩下的行并不会自动添加注释标记。你需要手动在带有宏的文本中添加注释标记。我不确定对 Xcode 来说这是一个 feature 还是一个 bug（对我来说现在看起来这是一个 bug）</p><p>因此，即便你在 plist 文件中把 <code>FILEHEADER</code> 设置成空字符串，也没法让文件头部的注释完全消失，新文件的开头会是一个空的注释行。我希望这个 bug 可以在未来的版本中解决掉。我已经给苹果官方提交了这个 bug（rdar://33451838）</p></blockquote><blockquote><p>译者注：<br>rdar 指的苹果内部的 bug 追踪系统，一般开发者可以在 <a href="https://bugreport.apple.com/" target="_blank" rel="noopener">https://bugreport.apple.com/</a> 上提交 bug，当然你只能看到自己提交的 bug，高冷的苹果不会展示出来总共有多少人提交了 bug，所以有人建立了 <a href="https://openradar.appspot.com/" target="_blank" rel="noopener">https://openradar.appspot.com/</a> 这个网站呼吁大家在提交 bug 后也在这里提交一次，方便开发者们知道都有哪些问题被提交了。更多详情可以参见这个<a href="https://forums.developer.apple.com/thread/8796" target="_blank" rel="noopener">论坛帖子</a></p></blockquote><hr><h2 id="1">文本宏索引</h2><p>这里是所有可以在 Xcode9 中使用的文本宏，我把他们从 <a href="https://help.apple.com/xcode/mac/9.0/index.html?localePath=en.lproj#/dev7fe737ce0" target="_blank" rel="noopener">Xcode 的帮助页面</a>中一字不差的复制过来了。</p><p><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-help-text-macros-reference.png1512892705.665681" alt=""></p><blockquote><h5 id="DATE"><a href="#DATE" class="headerlink" title="DATE"></a>DATE</h5><p>当前的日期。</p><h5 id="DEFAULTTOOLCHAINSWIFTVERSION"><a href="#DEFAULTTOOLCHAINSWIFTVERSION" class="headerlink" title="DEFAULTTOOLCHAINSWIFTVERSION"></a>DEFAULTTOOLCHAINSWIFTVERSION</h5><p>当前工具链所使用的 Swift 的版本。</p><h5 id="FILEBASENAME"><a href="#FILEBASENAME" class="headerlink" title="FILEBASENAME"></a>FILEBASENAME</h5><p>不带扩展名的当前文件的名称。</p><h5 id="FILEBASENAMEASIDENTIFIER"><a href="#FILEBASENAMEASIDENTIFIER" class="headerlink" title="FILEBASENAMEASIDENTIFIER"></a>FILEBASENAMEASIDENTIFIER</h5><p>以 C 标识符编码的当前文件名称。（译者注：C 标识符只允许使用数字、字母和下划线，使用这个宏会把其他的字符自动替换成下划线）</p><h5 id="FILEHEADER"><a href="#FILEHEADER" class="headerlink" title="FILEHEADER"></a>FILEHEADER</h5><p>每个文本文件头部的文本。</p><h5 id="FILENAME"><a href="#FILENAME" class="headerlink" title="FILENAME"></a>FILENAME</h5><p>当前文件的完整名称。</p><h5 id="FULLUSERNAME"><a href="#FULLUSERNAME" class="headerlink" title="FULLUSERNAME"></a>FULLUSERNAME</h5><p>当前系统用户的全名。</p><h5 id="NSHUMANREADABLECOPYRIGHTPLIST"><a href="#NSHUMANREADABLECOPYRIGHTPLIST" class="headerlink" title="NSHUMANREADABLECOPYRIGHTPLIST"></a>NSHUMANREADABLECOPYRIGHTPLIST</h5><p>macOS 应用类型的 target 中，Info.plist 文件设置的版权信息条目的值（译者注：也就是这个宏最终会被替换成在 Info.plist 中 NSHumanReadableCopyright 这一项保存的字符串）。这个条目对应的一个合法的示例值为：</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &lt;key&gt;NSHumanReadableCopyright&lt;/key&gt;</span><br><span class="line">&gt; &lt;string&gt;Copyright © 2017 Apple, Inc. All rights reserved.&lt;/string&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注意值里头有一次换行<br><strong>ORGANIZATIONNAME</strong><br> Provisioning profile 文件中使用的团队所在的公司名称。<br><strong>PACKAGENAME</strong><br>当前 scheme 所设置的包名。<br><strong>PACKAGENAMEASIDENTIFIER</strong><br>当前 scheme 所设置的包名，以 C 标识符的形式编码。<br><strong>PRODUCTNAME</strong><br>当前 scheme 设置的应用名称。<br><strong>PROJECTNAME</strong><br>当前工程的名称。<br><strong>RUNNINGMACOSVERSION</strong><br>macOS 系统的版本。<br><strong>TARGETNAME</strong><br>当前 target 的名称。<br><strong>TIME</strong><br>当前的时间<br><strong>USERNAME</strong><br>当前 macOS 用户的登录名。<br><strong>UUID</strong><br>使用这个宏的时候，会返回一个唯一 ID。当这个宏第一次被使用时，Xcode 会创建一个 ID。你可以通过使用修饰符来创建多个唯一的 ID。每个修饰符都会得到一个针对这个修饰符唯一的 ID。</p><p>例如，<code>UUID:firstPurpose</code>这个宏和修饰符的组合在第一次使用的时候，它会创建并返回一个唯一的 ID。接下来其他使用 <code>UUID:firstPurpose</code>的地方都会返回这个 ID。使用 <code>UUID:secondPurpose</code> 后会产生并返回一个新的 ID，这个 ID 对于<code>UUID:secondPurpose</code>来说是唯一的，并且这个 ID 不同于前一个 ID。<br><strong>WORKSPACENAME</strong><br>当前 workspace 的名称。如果 workspace 中只有一个 project，那么这个宏的值便是当前打开的 project 的名称。<br><strong>YEAR</strong><br>四位数字格式的当前年数。</p></blockquote><hr><h2 id="2">文本宏格式索引</h2><p><em>以下内容都是从 Xcode 帮助页面中的<a href="https://help.apple.com/xcode/mac/9.0/index.html?localePath=en.lproj#/devc8a500cb9" target="_blank" rel="noopener">文本宏格式参考</a>拷贝过来的</em></p><p><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-help-text-macro-format-reference.png1512892705.816728" alt=""></p><blockquote><p>一个文本宏的值可以包含任何合法的 unicode 字符。同时一个文本宏的值也可以包含其他的文本宏。</p></blockquote><blockquote><h5 id="引入其他文本宏"><a href="#引入其他文本宏" class="headerlink" title="引入其他文本宏"></a>引入其他文本宏</h5><p>要想引入其他文本宏，在想要添加的文本宏之前和之后添加下划线(__):</p></blockquote><blockquote><p><code>___&lt;MacroName&gt;___</code></p><h5 id="编辑文本宏表达式"><a href="#编辑文本宏表达式" class="headerlink" title="编辑文本宏表达式"></a>编辑文本宏表达式</h5><p>通过添加一个或者多个修饰符，你可以修改文本宏的最终值。针对那些可以添加修饰符的文本宏，可以在宏的最后添加修饰符，宏和修饰符之间用分号(:)分隔。多个修饰符之间可以用逗号(,)分隔。</p></blockquote><blockquote><p><code>&lt;MACRO&gt;:&lt;modifier&gt;[,&lt;modifier&gt;]…</code></p><p>例如，下面的这段宏会删除掉<code>FILENAME</code>宏中的扩展名：</p></blockquote><blockquote><p><code>FILENAME:deletingPathExtension</code></p><p>为了使编辑后的宏符合 C 标识符的规范，可以在宏之后再添加一个 identifier 修饰符：</p><p><code>FILENAME:deletingPathExtension,identifier</code></p><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><h5 id="bundleIdentifier"><a href="#bundleIdentifier" class="headerlink" title="bundleIdentifier"></a>bundleIdentifier</h5><p>用一个连字符(-)替换所有不符合 bundle 标识的字符。</p><h5 id="deletingLastPathComponent"><a href="#deletingLastPathComponent" class="headerlink" title="deletingLastPathComponent"></a>deletingLastPathComponent</h5><p>从字符串中删除最后一个路径组件 (path component)。（译者注：根据<a href="https://en.wikipedia.org/wiki/Path_(computing" target="_blank" rel="noopener">维基百科</a>)的解释，一个路径是由多个路径组件组成的，路径组件之间使用斜线”/“、反斜线”\“或者句点”.“来分隔）</p><h5 id="deletingPathExtension"><a href="#deletingPathExtension" class="headerlink" title="deletingPathExtension"></a>deletingPathExtension</h5><p>从字符串中删除所有的扩展名。</p><h5 id="deletingTrailingDot"><a href="#deletingTrailingDot" class="headerlink" title="deletingTrailingDot"></a>deletingTrailingDot</h5><p>删除所有句子末尾的句点 (.)。</p><h5 id="identifier"><a href="#identifier" class="headerlink" title="identifier"></a>identifier</h5><p>用下划线(_)代替所有不符合 C 标识符编码的字符。</p><h5 id="lastPathComponent"><a href="#lastPathComponent" class="headerlink" title="lastPathComponent"></a>lastPathComponent</h5><p>仅返回字符最后一个路径组件。</p><h5 id="pathExtension"><a href="#pathExtension" class="headerlink" title="pathExtension"></a>pathExtension</h5><p>返回字符的扩展名。</p><h5 id="rfc1034Identifier"><a href="#rfc1034Identifier" class="headerlink" title="rfc1034Identifier"></a>rfc1034Identifier</h5><p>用连字符(-)替换所有不符合 rfc1034 标识符规范的字符。（译者注：rfc1034 是定义域名的规范，详情参见<a href="https://www.ietf.org/rfc/rfc1034.txt" target="_blank" rel="noopener">这里</a>）</p><h5 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h5><p>将一些特殊的 xml 字符用其转义字符替换。比如，小于号 (&lt;) 会被 &amp;lt 替换;</p></blockquote><hr><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2017/07/xcode-9-text-macros/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017/07/24&lt;br&gt;译者：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/9c51a213b02e/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Joy&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;我一直&lt;a href=&quot;https://twitter.com/olebegemann/status/845263246949011457&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不喜欢 Xcode 默认给新文件头部添加的注释&lt;/a&gt;。在我看来，从注释里得到的绝大多数信息要么和文件本身没有关系，要么通过版本控制，你能得到更详尽的信息。此外，当文件和项目更名的时候，这些注释会立刻显得过时。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Xcode" scheme="https://swift.gg/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Core NFC 指南 - iOS 设备中的 NFC</title>
    <link href="https://swift.gg/2017/09/25/core-nfc-tutorial-for-nfc-on-ios-devices/"/>
    <id>https://swift.gg/2017/09/25/core-nfc-tutorial-for-nfc-on-ios-devices/</id>
    <published>2017-09-25T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:08.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jameson Quave，<a href="http://jamesonquave.com/blog/core-nfc-tutorial-for-nfc-on-ios-devices/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-06<br>译者：<a href="http://www.desgard.com/" target="_blank" rel="noopener">冬瓜</a>；校对：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>在 iOS 11 发布后，开发者们首次可以在 iPhone7 或者更高的设备上调用 NFC 读取相关的接口。这些接口可以用于传递身份信息或者是用于实现类似门禁、地铁闸机这种功能的数据交换应用。</p><p>在 iOS 11 中，这项技术被称作 Core NFC，下面我将在教程中使用 Swift 4 来讨论如何使用它。</p><p><img src="/img/articles/core-nfc-tutorial-for-nfc-on-ios-devices/nfc2.pngzoom=2&amp;w=5841512890761.307122" alt=""></p><a id="more"></a><iframe width="560" height="315" src="https://www.youtube.com/embed/SD6Rm4cGyko" frameborder="0" allowfullscreen></iframe><p>由于 Core NFC 目前权限为只读状态，非接触式支付功能是不被开放的，但是仍旧有一些能够使用 Core NFC 读取能力的<del>使用</del>场景。下面我们来讲述一下。</p><p>使用 NFC 的第一步是在 Apple Developer Center 中通过 App ID 来启用它。创建一个新的 App ID，并启用 “NFC Tag Reading” 这个功能。</p><p><img src="/img/articles/core-nfc-tutorial-for-nfc-on-ios-devices/entitlement.pngzoom=2&amp;w=5841512890761.528886" alt=""></p><p>这之后，我建议专门为这个 App ID 创建一个 development/distribution provisioning profile 文件，这样当你尝试构建 App 的时候，NFC 读取功能将会自动加入。</p><p>接下来，你需要在 Xcode 项目中的 projectName.entitlements 中为的工程添加授权。你需要右键点击该文件并选择”Open As Source Code”，显示如图所示：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.developer.nfc.readersession.formats<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>NDEF<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果没有 entitlements 文件，可以在项目中手动创建并把他加到工程的 build settings 中。在 “Build Settings” 下点击 “Coding Signing Entitlements” 选项并加入 entitlements 文件的相对路径。本例中是 “CoreNFC-Tutorial/CoreNFC-Tutorial.entitlements” ，因为我的工程文件在 “CoreNFC-Tutorial” 子目录下。</p><p>然后，需要为 Xcode 项目增加 usage string。打开 Info.plist 文件，增加 “Privacy - NFC Scan Usage Description” 这个键值。当用户使用 NFC 时，这个键值填写的内容会作为通知消息展示给用户，所以我们最好写一些有用的信息，比如可以填写 “NFC is needed to unlock doors.”。</p><p>接下来，在代码中引入 <code>CoreNFC</code> 模块。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> CoreNFC</span><br></pre></td></tr></table></figure><p>备注：Core NFC 在 iOS 的模拟器上不可用， 即便是导入模块也会编译失败。因此 Core NFC 相关代码只能真机调试。</p><p>这里我创建了一个 <code>NFCHelper.swift</code> 文件，并将所有 NFC 相关的 API 调用封装成一个 NFCHelper 类。在 <code>init</code> 方法中我创建了一个会话 ，Core NFC 需要使用 <code>NFCNDEFReaderSession</code> 这个 class 来监听 NFC 设备，从而完成通信。（注意 <code>NFCReaderSession</code> 是一个抽象类，不能直接使用）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NFCHelper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> session =</span><br><span class="line">      <span class="type">NFCNDEFReaderSession</span>(delegate: <span class="keyword">self</span>,</span><br><span class="line">                           queue: <span class="literal">nil</span>,</span><br><span class="line">                           invalidateAfterFirstRead: <span class="literal">true</span>)</span><br><span class="line">    session.begin()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中我们创建了一个会话，并且为 <code>Dispatch Queue</code> 这个参数传递了一个 nil 值。这样可以使得 <code>NFCNDEFReaderSession</code> 自动创建一个串行 Dispatch Queue。</p><p>创建会话的时候，我们也要为 <code>NFCDEFReaderSession</code> 设置代理对象。这里我使用 <code>NFCHelper</code> class 来作为代理，所以我们需要遵守 <code>NFCNDEFReaderSessionDelegate</code> 协议。这个协议是基于 <code>NSObjectProtocol</code> 协议的，所以我们需要继承 <code>NSObject</code>（译者注：NSObject 协议在 Swift 中的名称为 NSObjectProtocol）。<code>NFCNDEFReaderSessionDelegate</code> 有两个必须实现的代理方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didInvalidateWithError error: Error)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage])</span></span></span><br></pre></td></tr></table></figure><p>当 NFC 的会话获取到验证错误，或是 NFC 的感应被触发时，这两个回调方法就会被调用。我们对回调信息的处理方式取决于我们 App 的使用场景，但是所有能够获取到的信息都可以通过 <code>didDetectNDEFs</code> 回调方法中的 <code>messages</code> 变量得到。在一开始，你可以通过遍历并打印 <code>messages</code> 中的元素来了解这些信息的内容。每个元素均是 <code>NFCDEFPayload</code> 对象，并且每一个对象都会包括 <code>identifier</code>、<code>payload</code>、<code>type</code> 和 <code>typeNameFormat</code> 这些属性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage])</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Did detect NDEFs."</span>)</span><br><span class="line">  <span class="comment">// 遍历 messages 数组中所有元素</span></span><br><span class="line">  <span class="keyword">for</span> message <span class="keyword">in</span> messages &#123;</span><br><span class="line">    <span class="keyword">for</span> record <span class="keyword">in</span> message.records &#123;</span><br><span class="line">      <span class="built_in">print</span>(record.identifier)</span><br><span class="line">      <span class="built_in">print</span>(record.payload)</span><br><span class="line">      <span class="built_in">print</span>(record.type)</span><br><span class="line">      <span class="built_in">print</span>(record.typeNameFormat)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们了解了这些属性的含义之后，就可以将其集成在前端 App 中，这里我针对我的应用创建了一个专门的回调方法，你应该也会做类似的事情，这里我增加了一个回调的属性，便于我的前端页面用这个属性来做进一步的展示：</p><p>当我从 NFC 获得一个有效信号或是一个错误的时候，会调用这个回调：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NFCHelper</span>: <span class="title">NSObject</span>, <span class="title">NFCNDEFReaderSessionDelegate</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> onNFCResult: ((<span class="type">Bool</span>, <span class="type">String</span>) -&gt; ())?</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我还实现了把创建会话的方法封装到了一个新的方法中，这样我就可以通过 <code>ViewController</code> 中的一个 button 点击触发来创建一个新的会话。关于 <code>NFCHelper.swift</code> 的最终代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  NFCHelper.swift</span></span><br><span class="line"><span class="comment">//  CoreNFC-Tutorial</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Jameson Quave on 6/6/17.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 Jameson Quave. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CoreNFC</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NFCHelper</span>: <span class="title">NSObject</span>, <span class="title">NFCNDEFReaderSessionDelegate</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> onNFCResult: ((<span class="type">Bool</span>, <span class="type">String</span>) -&gt; ())?</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">restartSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> session =</span><br><span class="line">    <span class="type">NFCNDEFReaderSession</span>(delegate: <span class="keyword">self</span>,</span><br><span class="line">                       queue: <span class="literal">nil</span>,</span><br><span class="line">                       invalidateAfterFirstRead: <span class="literal">true</span>)</span><br><span class="line">    session.begin()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// MARK: NFCNDEFReaderSessionDelegate</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didInvalidateWithError error: Error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> onNFCResult = onNFCResult <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    onNFCResult(<span class="literal">false</span>, error.localizedDescription)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage])</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> onNFCResult = onNFCResult <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> message <span class="keyword">in</span> messages &#123;</span><br><span class="line">      <span class="keyword">for</span> record <span class="keyword">in</span> message.records &#123;</span><br><span class="line">        <span class="keyword">if</span>(record.payload.<span class="built_in">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">let</span> payloadString = <span class="type">String</span>.<span class="keyword">init</span>(data: record.payload, encoding: .utf8) &#123;</span><br><span class="line">              onNFCResult(<span class="literal">true</span>, payloadString)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我还搭建了一个简易的 UI 视图来展示这个类的用法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  CoreNFC-Tutorial</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Jameson Quave on 6/6/17.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 Jameson Quave. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helper: <span class="type">NFCHelper</span>?</span><br><span class="line">  <span class="keyword">var</span> payloadLabel: <span class="type">UILabel</span>!</span><br><span class="line">  <span class="keyword">var</span> payloadText = <span class="string">""</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    <span class="comment">// 增加检测按钮</span></span><br><span class="line">    <span class="keyword">let</span> button = <span class="type">UIButton</span>(type: .system)</span><br><span class="line">    button.setTitle(<span class="string">"Read NFC"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">    button.titleLabel?.font = <span class="type">UIFont</span>(name: <span class="string">"Helvetica"</span>, size: <span class="number">28.0</span>)</span><br><span class="line">    button.isEnabled = <span class="literal">true</span></span><br><span class="line">    button.addTarget(<span class="keyword">self</span>, action: #selector(didTapReadNFC), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">    button.frame = <span class="type">CGRect</span>(x: <span class="number">60</span>, y: <span class="number">200</span>, width: <span class="keyword">self</span>.view.bounds.width - <span class="number">120</span>, height: <span class="number">80</span>)</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(button)</span><br><span class="line">    <span class="comment">// 添加一个 Label 来显示状态</span></span><br><span class="line">    payloadLabel = <span class="type">UILabel</span>(frame: button.frame.offsetBy(dx: <span class="number">0</span>, dy: <span class="number">220</span>))</span><br><span class="line">    payloadLabel.text = <span class="string">"Press Read to see payload data."</span></span><br><span class="line">    payloadLabel.numberOfLines = <span class="number">100</span></span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(payloadLabel)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当 NFCHelper 已经处理过或者通信失败时调用</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">onNFCResult</span><span class="params">(success: Bool, message: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> success &#123;</span><br><span class="line">      payloadText = <span class="string">"<span class="subst">\(payloadText)</span>\n<span class="subst">\(message)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      payloadText = <span class="string">"<span class="subst">\(payloadText)</span>\n<span class="subst">\(message)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在主线程中更新 UI </span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">      <span class="keyword">self</span>.payloadLabel.text = <span class="keyword">self</span>.payloadText</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当用户点击 NFC 读取按钮时调用</span></span><br><span class="line">  <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">didTapReadNFC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> helper == <span class="literal">nil</span> &#123;</span><br><span class="line">      helper = <span class="type">NFCHelper</span>()</span><br><span class="line">      helper?.onNFCResult = <span class="keyword">self</span>.onNFCResult(success:message:)</span><br><span class="line">    &#125;</span><br><span class="line">    payloadText = <span class="string">""</span></span><br><span class="line">    helper?.restartSession()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了以上的基本框架，你就可以结合你具体的需求来为你的 APP 添砖加瓦了。无论是识别客人身份、检测 Amiibo 状态（译者注：<a href="https://zh.wikipedia.org/wiki/Amiibo" target="_blank" rel="noopener">Amiibo</a> 是任天堂推出的基于 NFC 的玩偶），甚至是完成支付，Apple 推出的 Core NFC API 终于为这些新设备提供了完成各类 NFC 功能的可能性。如果你在开发任何集成了 NFC 功能的产品，欢迎发邮件到<a href="jquave@gmail.com">jquave@gmail.com</a>和我交流。</p><p><a href="https://github.com/jquave/TagReader" target="_blank" rel="noopener">完整源码</a></p><p><a href="https://www.youtube.com/watch?v=SD6Rm4cGyko&amp;feature=youtu.be" target="_blank" rel="noopener">视频教程</a></p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Jameson Quave，&lt;a href=&quot;http://jamesonquave.com/blog/core-nfc-tutorial-for-nfc-on-ios-devices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-06-06&lt;br&gt;译者：&lt;a href=&quot;http://www.desgard.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;冬瓜&lt;/a&gt;；校对：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在 iOS 11 发布后，开发者们首次可以在 iPhone7 或者更高的设备上调用 NFC 读取相关的接口。这些接口可以用于传递身份信息或者是用于实现类似门禁、地铁闸机这种功能的数据交换应用。&lt;/p&gt;
&lt;p&gt;在 iOS 11 中，这项技术被称作 Core NFC，下面我将在教程中使用 Swift 4 来讨论如何使用它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/articles/core-nfc-tutorial-for-nfc-on-ios-devices/nfc2.pngzoom=2&amp;amp;w=5841512890761.307122&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Jameson Quave" scheme="https://swift.gg/categories/Jameson-Quave/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>升级 CMake 使 Swift 的构建过程更加愉悦</title>
    <link href="https://swift.gg/2017/09/20/swift-option-sets/"/>
    <id>https://swift.gg/2017/09/20/swift-option-sets/</id>
    <published>2017-09-20T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:08.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Joe，<a href="http://dev.iachieved.it/iachievedit/upgrading-cmake-for-a-happier-swift-build/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016/06/30<br>译者：<a href="undefined">EyreFree</a>；校对：<a href="http://chengway.in/" target="_blank" rel="noopener">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p><img src="/img/articles/swift-option-sets/swift-og-1.png1512890761.873188" alt=""></p><p>开源 Swift 已经有一些更新来利用新版本的 <a href="https://cmake.org/" target="_blank" rel="noopener">CMake</a> <strong>在 Linux 上构建 Swift</strong>。需要指出的是，Ubuntu 14.04 (2.8.12.2) 自带的默认版 cmake 不再胜任这项工作。</p><p>让我们把 Ubuntu 14.04 的 CMake 升级到 3.4.3，<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160627/002299.html" target="_blank" rel="noopener">开发者表示</a>该版本可以满足需求。</p><p>当通过源代码安装软件时，通常会有一个构建区在 <code>/usr/local/src</code> 和一个存档区（所以可以跟踪我构建的版本）在 <code>/usr/local/archive</code>：</p><p>使用 root 账户或者用 sudo 方式执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd /usr/local/archive</span></span><br><span class="line"><span class="comment"># wget https://cmake.org/files/v3.4/cmake-3.4.3.tar.gz</span></span><br><span class="line"><span class="comment"># cd ../src/</span></span><br><span class="line"><span class="comment"># tar -xzvf ../archive/cmake-3.4.3.tar.gz</span></span><br></pre></td></tr></table></figure><p>接下来，进行配置并且构建：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd cmake-3.4.3</span></span><br><span class="line"><span class="comment"># ./configure --prefix=/usr/local</span></span><br><span class="line">...</span><br><span class="line">CMake has bootstrapped.  Now run make.</span><br><span class="line"><span class="comment"># make</span></span><br></pre></td></tr></table></figure><p>最后，<code>make install</code> 会将 cmake 和它的关联设置安装到 <code>/usr/local</code> 目录下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make install</span></span><br><span class="line"><span class="comment"># which cmake</span></span><br><span class="line"><span class="comment"># cmake --version</span></span><br><span class="line">cmake version 3.4.3</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br></pre></td></tr></table></figure><p>以上就是全部过程。构建愉快！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：Joe，&lt;a href=&quot;http://dev.iachieved.it/iachievedit/upgrading-cmake-for-a-happier-swift-build/&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="iAchieved.it" scheme="https://swift.gg/categories/iAchieved-it/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>从零构建 Dispatch Queue</title>
    <link href="https://swift.gg/2017/09/07/friday-qa-2015-09-04-lets-build-dispatch_queue/"/>
    <id>https://swift.gg/2017/09/07/friday-qa-2015-09-04-lets-build-dispatch_queue/</id>
    <published>2017-09-07T00:00:00.000Z</published>
    <updated>2018-06-25T03:44:08.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-09-04-lets-build-dispatch_queue.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-09-04<br>译者：<a href="http://hulizhen.me" target="_blank" rel="noopener">智多芯</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="noopener">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Grand Central Dispatch 是 Apple 公司最近几年推出的重量级 API 之一。在本次“从零构建”系列文章中，我们将探索一个由 Rob Rix 建议的主题：从零构建一个具备基本功能的 Dispatch Queue。</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>分发队列（Dispatch Queue）是一个保存了多个基于全局线程池的任务（译者注：其实就是一系列的代码块）的队列。提交到队列的任务通常会被放到一个后台线程异步执行。为了使整个系统运作得更高效，所有的线程共享一个后台线程池。</p><p>这就是下面将要实现的 API 核心功能。为了简单起见，本文会略去很多 GCD 提供的额外功能。例如，全局线程池中的线程数量会随着任务总量和系统的 CPU 使用率进行动态调整。在已有一堆耗 CPU 的任务在运行的情形下，如果此时再提交一个任务，GCD 不会再为该任务创建新的线程。因为此时 CPU 已经满负荷运行了，再创建新的线程只会导致系统更低效。下面我会直接将线程数量硬编码在代码中。同样，其他的额外功能，如目标队列和并行队列屏障，也会一并略过。</p><p>本文会把重点放在实现分发队列的核心功能上：基于一个共享的全局线程池实现串行/并行及同步/异步派发任务。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>和往常一样，本文中的代码可在 GitHub 上获取：</p><p><a href="https://github.com/mikeash/MADispatchQueue" target="_blank" rel="noopener">https://github.com/mikeash/MADispatchQueue</a></p><p>可以边读本文边敲代码，也可以自己探索。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>GCD 提供的是一系列的 C 语言 API。虽然在最近发布的 OS 上 Apple 已经将 GCD 对象转成了 Objective-C 对象，但 API 还是保持着纯 C 语言接口（还新增了对 Block 支持）。这对底层 API 来说其实是好事，提供的接口也十分简洁。但本文将采用 Objective-C 语言来实现。</p><p>本文实现的 Objective-C 类叫做 <code>MADispatchQueue</code>，它只提供了四个方法：</p><ol><li>一个获取共享的全局队列的方法。GCD 有多个不同优先级的全局队列，但为了简单起见，我们只有一个全局队列。</li><li>一个构造器，可通过它创建并行或串行队列。</li><li>一个异步派发方法。</li><li>一个同步派发方法。</li></ol><p>接口的声明如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MADispatchQueue : NSObject</span><br><span class="line"></span><br><span class="line">+ (MADispatchQueue *)globalQueue;</span><br><span class="line"></span><br><span class="line">- (id)initSerial: (BOOL)serial;</span><br><span class="line"></span><br><span class="line">- (void)dispatchAsync: (dispatch_block_t)block;</span><br><span class="line">- (void)dispatchSync: (dispatch_block_t)block;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>本文的目标就是实现这些方法的功能。</p><h3 id="线程池接口"><a href="#线程池接口" class="headerlink" title="线程池接口"></a>线程池接口</h3><p>用来支撑分发队列的线程池有着相对简洁的接口，该线程池负责执行被提交的作业。分发队列负责在合适的时机将已入队的作业提交到线程池。</p><p>线程池只有一个简单的任务：提交作业并执行。因此，它就只有一个方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MAThreadPool : NSObject</span><br><span class="line"></span><br><span class="line">- (void)addBlock: (dispatch_block_t)block;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>因为这是整个线程池的核心，所以接下来先把它实现了。</p><h3 id="线程池实现"><a href="#线程池实现" class="headerlink" title="线程池实现"></a>线程池实现</h3><p>首先看下实例变量。线程池可能会被外部或内部的多个线程同时访问，因此必须保证其线程安全。虽然 GCD 尽可能地使用了快速原子操作以保证线程安全，但本文还是采用古老的锁方案。除了保证读写操作互斥外，该锁还要支持 <code>wait</code> 和 <code>signal</code> 操作，因此使用了 <code>NSCondition</code>，而不是原生的 <code>NSLock</code>。如果你不熟悉 <code>NSCondition</code> 也没关系，实际上它只是把锁和一个条件变量封装在一起而已：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSCondition *_lock;</span><br></pre></td></tr></table></figure><p>为了确定何时启动新的线程，需要知道当前线程池中有多少线程，有多少线程正在运行，线程池最多支持多少线程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSUInteger _threadCount;</span><br><span class="line">NSUInteger _activeThreadCount;</span><br><span class="line">NSUInteger _threadCountLimit;</span><br></pre></td></tr></table></figure><p>最后是一个保存了多个代码块的数组。这里使用了 <code>NSMutableArray</code> 来实现队列，通过追加新的代码块到末尾来实现入队操作，通过删除开头的代码块来实现出队操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *_blocks;</span><br></pre></td></tr></table></figure><p>初始化方法很简单，只是初始化锁、代码块数组，最后将线程数的最大值设置成 123（随机选择的数目）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    if((self = [super init])) &#123;</span><br><span class="line">        _lock = [[NSCondition alloc] init];</span><br><span class="line">        _blocks = [[NSMutableArray alloc] init];</span><br><span class="line">        _threadCountLimit = 128;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程中主要是一个无限循环。当代码块数组为空时，线程进入休眠并等待。一旦数组不为空，该代码块立即出队并开始执行。代码块执行开始后，当前活跃线程数加一；代码块执行完成后，当前活跃线程数减一：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)workerThreadLoop: (id)ignore &#123;</span><br></pre></td></tr></table></figure><p>在进入循环之前先加锁，至于为什么这么做，请继续往下看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock lock];</span><br></pre></td></tr></table></figure><p>接着进入无限循环：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (1) &#123;</span><br></pre></td></tr></table></figure><p>如果队列为空，则等待：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while ([_blocks count] == 0) &#123;</span><br><span class="line">   [_lock wait];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的是，上面代码是在一个循环中，而不仅仅只是一个 <code>if</code> 语句。这么做是因为<a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">假性唤醒</a>。简单地说，即使没有发送<code>signal</code>信号，<code>wait</code> 也可能提前返回。为了让代码产生预期的行为，<code>wait</code> 返回时每次都要检查代码块的数量。</p><p>一旦有了可用代码块，立即出队：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_block_t block = [_blocks firstObject];</span><br><span class="line">[_blocks removeObjectAtIndex: 0];</span><br></pre></td></tr></table></figure><p>将当前活跃线程数加一，表明当前线程正忙：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_activeThreadCount++;</span><br></pre></td></tr></table></figure><p>现在是时候开始执行代码块了。但在此之前需要先解锁，否则就无法并发执行代码，并且所有试图对该锁加锁的线程都会导致死锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock unlock];</span><br></pre></td></tr></table></figure><p>安全地解锁并立即执行代码块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block();</span><br></pre></td></tr></table></figure><p>当该代码块执行完后，将当前活跃线程数减一。在这样做之前需要先加锁以避免竞争条件。到这里循环也就结束了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        [_lock lock];</span><br><span class="line">        _activeThreadCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在应该明白为什么进入上面这个循环之前先加锁了。循环中的最后一步是将当前活跃线程数减一，进入循环的第一步是检查队列中的代码块数量，而这两个操作都需要先加锁。通过在循环外加锁，后续的迭代只需要加一次锁即可。而不需要加锁、解锁，又马上加锁。</p><p>现在来看看 <code>addBlock</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addBlock: (dispatch_block_t)block &#123;</span><br></pre></td></tr></table></figure><p>这个方法中的所有操作都需要加锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock lock];</span><br></pre></td></tr></table></figure><p>第一件事就是将传入的代码块添加到队列中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_blocks addObject: block];</span><br></pre></td></tr></table></figure><p>如果目前有空闲的工作线程可以执行该代码块，那么就没什么需要做的了。如果没有空闲线程去处理这个还未被执行的代码块，并且工作线程总数还没超出限制，那就新建一个线程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSUInteger idleThreads = _threadCount - _activeThreadCount;</span><br><span class="line">   if([_blocks count] &gt; idleThreads &amp;&amp; _threadCount &lt; _threadCountLimit) &#123;</span><br><span class="line">   [NSThread detachNewThreadSelector: @selector(workerThreadLoop:)</span><br><span class="line">                                toTarget: self</span><br><span class="line">                              withObject: nil];</span><br><span class="line">       _threadCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>现在有了空闲的工作线程可以执行代码块了。但 <code>workerThreadLoop</code> 中的循环可能由于 <code>wait</code> 操作而处于休眠状态，因此执行一下 <code>signal</code> 操作唤醒它：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock signal];</span><br></pre></td></tr></table></figure><p>最后解锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面实现的线程池能够创建预定数目的工作线程以便执行新入队的代码块。接下来就利用这个线程池去实现分发队列 <code>Dispatch Queue</code>。</p><h3 id="分发队列的实现"><a href="#分发队列的实现" class="headerlink" title="分发队列的实现"></a>分发队列的实现</h3><p>和线程池相同的是，分发队列同样需要一个锁。而不同的是，它并不需要 <code>wait</code> 和 <code>signal</code>操作，只需要最基本的互斥锁 <code>NSLock</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLock *_lock;</span><br></pre></td></tr></table></figure><p>类似线程池，分发队列使用 <code>NSMutableArray</code> 维护了一个队列用于保存还未被执行的代码块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *_pendingBlocks;</span><br></pre></td></tr></table></figure><p><code>Dispatch Queue</code> 需要知道自己是串行还是并行队列。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL _serial;</span><br></pre></td></tr></table></figure><p>如果是串行队列，它还需要跟踪线程池中是否有代码块正在执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL _serialRunning;</span><br></pre></td></tr></table></figure><p>并行队列则不管是否有代码块正在运行都不影响，因此不需要跟踪该状态。</p><p>和共享的线程池一样，将全局队列保存在一个全局变量中，二者都在 <code>+initialize</code> 方法中创建：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static MADispatchQueue *gGlobalQueue;</span><br><span class="line">static MAThreadPool *gThreadPool;</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    if(self == [MADispatchQueue class]) &#123;</span><br><span class="line">        gGlobalQueue = [[MADispatchQueue alloc] initSerial: NO];</span><br><span class="line">        gThreadPool = [[MAThreadPool alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>+initialize</code> 方法已经确保了全局队列会被创建，因此 <code>+globalQueue</code> 方法可直接返回 <code>gGlobalQueue</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (MADispatchQueue *)globalQueue &#123;</span><br><span class="line">    return gGlobalQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里本来是可以直接用 <code>dispatch_once</code> 方法的，但这么做会有种使用了 GCD API 来作弊的感觉，说好的要从零构建的，虽然这并不是我们要实现的 API。</p><p>初始化方法包括分配锁、创建代码块队列（译者注：还未被执行的代码块），还要设置 <code>_serial</code> 变量：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)initSerial: (BOOL)serial &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _lock = [[NSLock alloc] init];</span><br><span class="line">        _pendingBlocks = [[NSMutableArray alloc] init];</span><br><span class="line">        _serial = serial;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在讲其余的公开 API 之前，还有一个底层方法需要实现。这个方法会在线程池中将 <code>_pendingBlocks</code> 队列中的一个代码块取出并执行，接着还很有可能（串行队列的情况下）会调用自身在线程池中执行另一个代码块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)dispatchOneBlock &#123;</span><br></pre></td></tr></table></figure><p>该方法唯一的职责就是在线程池中执行代码块，所以把自身的功能代码块添加到线程池中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[gThreadPool addBlock: ^&#123;</span><br></pre></td></tr></table></figure><p>接着从队列中取出队列头部的代码块。当然了，这个操作也需要加锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock lock];</span><br><span class="line">      dispatch_block_t block = [_pendingBlocks firstObject];</span><br><span class="line">      [_pendingBlocks removeObjectAtIndex: 0];</span><br><span class="line">      [_lock unlock];</span><br></pre></td></tr></table></figure><p>在解锁后，上面取出的代码块就可以安全地在后台线程执行（译者注：在前文线程池的实现中可以看出，每个添加到线程池中的代码块都会在独立的后台线程中执行）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block();</span><br></pre></td></tr></table></figure><p>如果队列是并行的，那么到这里就结束了。如果是串行的话，还需要下面的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(_serial) &#123;</span><br></pre></td></tr></table></figure><p>在串行队列上，新增的代码块需要等到前一个代码块执行完后才能执行。每当一个代码块执行完后，<code>dispatchOneBlock</code> 会检查当前队列是否还有代码块未执行。如果有的话，它会调用自身以便最后可以执行到该代码块。如果没有，将队列的运行状态设置回 <code>NO</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            [_lock lock];</span><br><span class="line">            if([_pendingBlocks count] &gt; 0) &#123;</span><br><span class="line">                [self dispatchOneBlock];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                _serialRunning = NO;</span><br><span class="line">            &#125;</span><br><span class="line">            [_lock unlock];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面这个方法之后，实现 <code>dispatchAsync</code> 就相对简单了。将代码块添加到队列中，然后根据情况（是否为串行队列）设置队列的运行状态并调用 <code>dispatchOneBlock</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)dispatchAsync: (dispatch_block_t)block &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    [_pendingBlocks addObject: block];</span><br></pre></td></tr></table></figure><p>如果是串行队列且当前空闲，就将队列运行状态设置为 <code>YES</code> 并调用 <code>dispatchOneBlock</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(_serial &amp;&amp; !_serialRunning) &#123;</span><br><span class="line">    _serialRunning = YES;</span><br><span class="line">    [self dispatchOneBlock];</span><br></pre></td></tr></table></figure><p>如果是并行队列，就无条件直接执行。这样保证了即使其他代码块正在执行，新增的代码块也能尽快执行，毕竟并行队列是允许多个代码块同时运行的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125; else if (!_serial) &#123;</span><br><span class="line">       [self dispatchOneBlock];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果串行队列已经在执行代码块了，就没什么需要做的了，已经在执行的 <code>dispatchOneBlock</code>最后会执行到新增的代码块的。最后解锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来轮到 <code>dispatchSync</code> 了。与 GCD 的实现不同，本文直接使用 <code>dispatchAsync</code> 派发代码块，并等到代码执行完后再返回（译者注：这就是同步的效果）。</p><p>为了实现这个目的，这里使用到了一个本地条件变量 <code>NSCondition</code>，还有一个 <code>done</code> 变量用于表示代码块是否执行完毕：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)dispatchSync: (dispatch_block_t)block &#123;</span><br><span class="line">   NSCondition *condition = [[NSCondition alloc] init];</span><br><span class="line">   __block BOOL done = NO;</span><br></pre></td></tr></table></figure><p>接着异步派发代码块。这里执行了通过函数参数传进来的代码块，然后设置 <code>done</code> 为 <code>YES</code>并唤醒 <code>condition</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self dispatchAsync: ^&#123;</span><br><span class="line">    block();</span><br><span class="line">    [condition lock];</span><br><span class="line">    done = YES;</span><br><span class="line">    [condition signal];</span><br><span class="line">    [condition unlock];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>在条件变量 <code>condition</code> 上等待 <code>done</code> 被设置成 <code>YES</code>，然后返回：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    [condition lock];</span><br><span class="line">    while (!done) &#123;</span><br><span class="line">        [condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    [condition unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就成功地运行了代码块，这也是 <code>MADispatchQueue</code> 所需要的最后一个 API 。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>可以通过一个保存代码块的队列和动态创建和销毁线程的方法来实现一个全局的线程池。通过使用一个共享的全局线程池，可以构建基本的 <code>Dispatch Queue</code> API，支持串行/并行及同步/异步派发任务。本文的实现少了许多 GCD 中很赞的功能，而且也确实比 GCD 低效得多。但即便如此，本文还是可以让你窥视到 GCD 内部的运作原理，让你明白这其实也不是什么神奇的事。（除了 <code>dispatch_once</code>，着简直就是个魔法。）</p><p>这就是今天所有的内容了，记得不要错过下一次更多有趣的内容哦。另外，周五的 Q&amp;A 是由读者驱动的，所以如果你有什么想在这里讨论的，给我<a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发个邮件</a>吧！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-09-04-lets-build-dispatch_queue.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2015-09-04&lt;br&gt;译者：&lt;a href=&quot;http://hulizhen.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;智多芯&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Grand Central Dispatch 是 Apple 公司最近几年推出的重量级 API 之一。在本次“从零构建”系列文章中，我们将探索一个由 Rob Rix 建议的主题：从零构建一个具备基本功能的 Dispatch Queue。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
