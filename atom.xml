<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftGG</title>
  
  <subtitle>走心的 Swift 翻译组</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swift.gg/"/>
  <updated>2018-08-09T02:08:30.373Z</updated>
  <id>https://swift.gg/</id>
  
  <author>
    <name>SwiftGG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 4 中的字符串</title>
    <link href="https://swift.gg/2018/08/09/swift-4-strings/"/>
    <id>https://swift.gg/2018/08/09/swift-4-strings/</id>
    <published>2018-08-09T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2017/11/swift-4-strings" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-11-27<br>译者：<a href="https://weibo.com/u/5029986118" target="_blank" rel="noopener">东莞大唐和尚</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="undefined">Firecrest</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>这个系列中其他文章：</p><ol><li><a href="https://oleb.net/blog/2014/07/swift-strings/" target="_blank" rel="noopener">Swift 1 中的字符串</a></li><li><a href="https://oleb.net/blog/2016/08/swift-3-strings/" target="_blank" rel="noopener">Swift 3 中的字符串</a></li><li>Swift 4 中的字符串（本文）</li></ol><p>本文节选自我们的新书《高级 Swift 编程》「字符串」这一章。《高级 Swift 编程》新版本已根据 Swift 4 的新特性修订补充，新版现已上市。</p><a id="more"></a><p>所有的现代编程语言都有对 Unicode 编码字符串的支持，但这通常只意味着它们的原生字符串类型可以存储 Unicode 编码的数据——并不意味着所有像获取字符串长度这样简单的操作都会得到「合情合理」的输出结果。</p><p>实际上，大多数语言，以及用这些语言编写的大多数字符串操作代码，都表现出对Unicode固有复杂性的某种程度的否定。这可能会导致一些令人不开心的错误</p><p>Swift 为了字符串的实现支持 Unicode 做出了巨大的努力。Swift 中的 <a href="https://developer.apple.com/documentation/swift/string" target="_blank" rel="noopener"><code>String</code></a>（字符串）是一系列 <a href="https://developer.apple.com/documentation/swift/character" target="_blank" rel="noopener"><code>Character</code></a> 值（字符）的集合。这里的 <code>Character</code> 指的是人们视为单个字母的可读文本，无论这个字母是由多少个 Unicode 编码字符组成。因此，所有对于 <code>Collection</code>（集合）的操作（比如 <code>count</code> 或者 <code>prefix(5)</code>）也同样是按照用户所理解的字母来操作的。</p><p>这样的设计在正确性上无可挑剔，但这是有代价的，主要是人们对它不熟悉。如果你习惯了熟练操作其他编程语言里字符串的整数索引，Swift 的设计会让你觉得笨重不堪，让你感觉到奇怪。为什么 <code>str[999]</code> 不能获得字符串第一千个字符？为什么 <code>str[idx+1]</code> 不能获得下一个字符？为什么不能用类似 <code>&quot;a&quot;...&quot;z&quot;</code> 的方式遍历一个范围的 <code>Character</code>（字符）？</p><p>同时，这样的设计对代码性能也有一定的影响：<code>String</code> 不支持随意获取。换句话说，获得一个任意字符不是 O(1) 的操作——当字符宽度是个变量的时候，字符串只有查看过前面所有字符之后，才会知道第 n 个字符储存在哪里。</p><p>在本章中，我们一起来详细讨论一下 Swift 中字符串的设计，以及一些获得功能和性能最优的技巧。不过，首先我们要先来学习一下 Unicode 编码的专业知识。</p><h2 id="Unicode：抛弃固定宽度"><a href="#Unicode：抛弃固定宽度" class="headerlink" title="Unicode：抛弃固定宽度"></a>Unicode：抛弃固定宽度</h2><p>本来事情很简单。<a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII编码</a> 的字符串用 0 到 127 之间的一系列整数表示。如果使用 8 比特的二进制数组合表示字符，甚至还多余一个比特！由于每个字符的长度固定，所以 ASCII 编码的字符串是可以随机获取的。</p><p>但是，如果不是英语而是其他国家的语言的话，其中的一些字符 ASCII 编码是不够的（其实即使是说英语的英国也有一个”£”符号）。这些语言中的特殊字符大多数都需要超过 7 比特的编码。在 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859" target="_blank" rel="noopener">ISO 8859</a> 标准中，就用多出来的那个比特定义了 16 种超出 ASCII 编码范围的编码，比如第一部分（ISO8859-1）包括了几种西欧语言的编码，第五部分包括了对西里尔字母语言的编码。</p><p>但这样的做法其实还有局限。如果你想根据 ISO8859 标准，用土耳其语写古希腊语的话，你就不走运了，因为你要么得选择第七部分（拉丁语/希腊语）或者第九部分（土耳其语）。而且，总的来说 8 个比特的编码空间无法涵盖多种语言。例如，第六部分（拉丁语/阿拉伯语）就不包含同样使用阿拉伯字母的乌尔都语和波斯语中的很多字符。同时，越南语虽然使用的也是拉丁字母，但是有很多变音组合，这种情况只有替换掉一些原有 ASCII 编码的字母才可能存储到 8 个比特的空间里。而且，这种方法不适用其他很多东亚语言。</p><p>当固定长度编码空间不足以容纳更多字符时，你要做一个选择：要么提高存储空间，要么采用变长编码。起先，<a href="https://en.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a> 被定义为 2 字节固定宽度的格式，现在我们称之为 <a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set" target="_blank" rel="noopener">UCS-2</a>。彼时梦想尚未照进现实，后来人们发现，要实现大部分的功能，不仅 2 字节不够，甚至4个字节都远远不够。</p><p>所以到了今天，Unicode 编码的宽度是可变的，这种可变有两个不同的含义：一是说 Unicode 标量可能由若干个代码块组成；一是说字符可能由若干个标量组成。</p><p>Unicode 编码的数据可以用多种不同宽度的 <a href="https://www.unicode.org/glossary/#code_unit" target="_blank" rel="noopener">代码单元（<em>code unit</em>）</a> 来表示，最常见的是 8 比特（<a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8</a>）和 16（<a href="https://en.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16</a>）比特。UTF-8 编码的一大优势是它向后兼容 8 比特的 ACSCII 编码，这也是它取代 ASCII 成为互联网上最受欢迎的编码的一大原因。在 Swift 里面用 <code>UInt16</code> 和 <code>UInt8</code> 的数值代表UTC-16和UTF-8的代码单元（别名分别是 <a href="https://developer.apple.com/documentation/swift/unicode.utf8/codeunit" target="_blank" rel="noopener"><code>Unicode.UTF16.CodeUnit</code></a> 和 <a href="https://developer.apple.com/documentation/swift/unicode.utf16/codeunit" target="_blank" rel="noopener"><code>Unicode.UTF8.CodeUnit</code></a>）。</p><p>一个 <a href="https://www.unicode.org/glossary/#code_point" target="_blank" rel="noopener"><em>代码点（code point）</em></a> 指的是 Unicode 编码空间中一个单一的值，可能的范围是 <code>0</code> 到 <code>0x10FFFF</code> (换算成十进制就是 1114111)。现在已使用的代码点大约只有 137000 个，所以还有很多空间可以存储各种 emoji。如果你使用的是 <a href="https://en.wikipedia.org/wiki/UTF-32" target="_blank" rel="noopener">UTF-32</a> 编码，那么一个代码点就是一个代码块；如果使用的是 UTF-8 编码，一个代码点可能有 1 到 4 个代码块组成。最初的 256 个 Unicode 编码的代码点对应着 Latin-1 中的字母。</p><p><a href="https://www.unicode.org/glossary/#unicode_scalar_value" target="_blank" rel="noopener">Unicode 标量</a> 跟代码点基本一样，但是也有一点不一样。除开 <code>0xD800-0xDFFF</code> 中间的 2048 个代理代码点（<a href="https://en.wikipedia.org/wiki/UTF-16#U.2BD800_to_U.2BDFFF" target="_blank" rel="noopener"><em>surrogate code points</em></a>）之外，他们都是一样的。这 2048 个代理代码点是 UTF-16 中用作表示配对的前缀或尾缀编码。标量在 Swift 中用 <code>\u{xxxx}</code> 表示，xxxx 代表十进制的数字。所以欧元符号在Swift里可以表示为 <code>&quot;€&quot;</code> 或 <code>&quot;\u{20AC}&quot;</code>。与之对应的 Swift 类型是 <a href="https://developer.apple.com/documentation/swift/unicode.scalar" target="_blank" rel="noopener"><code>Unicode.Scalar</code></a>，一个 <a href="https://developer.apple.com/documentation/swift/uint32" target="_blank" rel="noopener"><code>UInt32</code></a> 数值的封装。</p><p>为了用一个代码单元代表一个 Unicode scalar，你需要一个 21 比特的编码机制（通常会达到 32 比特，比如 UTF-32），但是即便这样你也无法得到一个固定宽度的编码：最终表示字符的时候，Unicode 仍然是一个宽度可变的编码格式。屏幕上显示的一个字符，也就是用户通常认为的一个字符，可能需要多个 scalar 组合而成。Unicode 编码里把这种用户理解的字符称之为 <a href="https://www.unicode.org/glossary/#extended_grapheme_cluster" target="_blank" rel="noopener">（扩展）字位集</a>(extended grapheme cluster)。</p><p>标量组成字位集的规则决定了如何分词。例如，如果你按了一下键盘上的退格键，你觉得你的文本编辑器就应该删除掉一个字位集，即使那个“字符”是由多个 Unicode scalars 组成，且每个 scalar 在计算机内存上还由数量不等的代码块组成的。Swift中用 <code>Character</code> 类型代表字位集。<code>Character</code> 类型可以由任意数量的 Scalars 组成，只要它们形成一个用户看到的字符。在下一部分，我们会看到几个这样的例子。</p><h2 id="字位集和规范对等（Canonical-Equivalence）"><a href="#字位集和规范对等（Canonical-Equivalence）" class="headerlink" title="字位集和规范对等（Canonical Equivalence）"></a>字位集和规范对等（Canonical Equivalence）</h2><h3 id="组合符号"><a href="#组合符号" class="headerlink" title="组合符号"></a>组合符号</h3><p>这里有一个快速了解 <code>String</code> 类型如何处理 Unicode 编码数据的方法：写 “é” 的两种不同方法。Unicode 编码中定义为 <a href="https://codepoints.net/U+00E9" target="_blank" rel="noopener">U+00E9</a>，<em>Latin small letter e with acute</em>（拉丁字母小写 e 加重音符号），单一值。但是你也可以写一个正常的 <a href="https://codepoints.net/U+0065" target="_blank" rel="noopener">小写 e</a>，再跟上一个 <a href="https://codepoints.net/U+0301" target="_blank" rel="noopener">U+0301</a>，<em>combining acute accent</em>（重音符号）。在这两种情况中，显示的都是 é，用户当然会认为这两个 “résumé” 无论使用什么方式打出来的，肯定是相等的，长度也都是 6 个字符。这就是 Unicode 编码规范中所说的 <a href="https://www.unicode.org/glossary/#canonical_equivalent" target="_blank" rel="noopener">规范对等（Canonically Equivalent）</a>。</p><p>而且，在 Swift 语言里，代码行为和用户预期是一致的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> single = <span class="string">"Pok\u&#123;00E9&#125;mon"</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="string">"Poke\u&#123;0301&#125;mon"</span></span><br></pre></td></tr></table></figure><p>它们显示也是完全一致的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(single, double) <span class="comment">// → ("Pokémon", "Pokémon")</span></span><br></pre></td></tr></table></figure><p>它们的字符数也是一样的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">single.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br><span class="line">double.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br></pre></td></tr></table></figure><p>因此，比较起来，它们也是相等的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">single == double <span class="comment">// → true</span></span><br></pre></td></tr></table></figure><p>只有当你通过底层的显示方式查看的时候，才能看到它们的不同之处：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">single.utf16.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br><span class="line">double.utf16.<span class="built_in">count</span> <span class="comment">// → 8</span></span><br></pre></td></tr></table></figure><p>这一点和 Foundation 中的 <a href="https://developer.apple.com/documentation/foundation/nsstring" target="_blank" rel="noopener"><code>NSString</code></a> 对比一下：在 <code>NSString</code> 中，两个字符串是不相等的，它们的 <code>length</code> （很多程序员都用这个方法来确定字符串显示在屏幕上的长度）也是不同的。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nssingle = single <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">nssingle.length <span class="comment">// → 7</span></span><br><span class="line"><span class="keyword">let</span> nsdouble = double <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">nsdouble.length <span class="comment">// → 8</span></span><br><span class="line">nssingle == nsdouble <span class="comment">// → false</span></span><br></pre></td></tr></table></figure><p>这里，<code>==</code> 是定义为比较两个 <code>NSObject</code> ：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension <span class="built_in">NSObject</span>: Equatable &#123;</span><br><span class="line">    <span class="keyword">static</span> func ==(lhs: <span class="built_in">NSObject</span>, rhs: <span class="built_in">NSObject</span>) -&gt; Bool &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.isEqual(rhs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>NSString</code> 中，这个操作会比较两个 UTF-16 代码块。很多其他语言里面的字符串 API 也是这样的。如果你想做的是一个规范比较（cannonical comparison），你必须用 <code>NSString.compare(_:)</code> 。没听说过这个方法？将来遇到一些找不出来的 bug ，以及一些怒气冲冲的国外用户的时候，够你受的。</p><p>当然，只比较代码单元有一个很大的优点是：速度快！在 Swift 里，你也可以通过 <code>utf16</code> 视图来实现这一点：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">single.utf16.elementsEqual(double.utf16) <span class="comment">// → false</span></span><br></pre></td></tr></table></figure><p>为什么 Unicode 编码要支持同一字符的多种展现方式呢？因为 Latin-1 中已经有了类似é和ñ这样的字母，只有灵活的组合方式才能让长度可变的 Unicode 代码点兼容 Latin-1。</p><p>虽然使用起来会有一些麻烦，但是它使得两种编码之间的转换变得简单快速。</p><p>而且抛弃变音形式也没有什么用，因为这种组合不仅仅只是两个两个的，有时候甚至是多种变音符号组合。例如，约鲁巴语中有一个字符是 ọ́ ，可以用三种不同方式写出来：一个 ó 加一点，一个 ọ 加一个重音，或者一个 o  加一个重音和一点。而且，对最后一种方式来说，两个变音符号的顺序无关紧要！所以，下面几种形式的写法都是相等的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> chars: [<span class="type">Character</span>] = [</span><br><span class="line">    <span class="string">"\u&#123;1ECD&#125;\u&#123;300&#125;"</span>,      <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;F2&#125;\u&#123;323&#125;"</span>,        <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;6F&#125;\u&#123;323&#125;\u&#123;300&#125;"</span>, <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;6F&#125;\u&#123;300&#125;\u&#123;323&#125;"</span>  <span class="comment">// ọ́</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> allEqual = chars.<span class="built_in">dropFirst</span>()</span><br><span class="line">    .all(matching: &#123; $<span class="number">0</span> == chars.first &#125;) <span class="comment">// → true</span></span><br></pre></td></tr></table></figure><p><code>all(matching:)</code> 方法用来检测条件是否对序列中的所有元素都为真：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">all</span><span class="params">(matching predicate: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">try</span> !predicate(element) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，一些变音符号可以加无穷个。这一点，<a href="http://knowyourmeme.com/memes/zalgo" target="_blank" rel="noopener">网上流传很广</a> 的一个颜文字表现得很好：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> zalgo = <span class="string">"s̼̐͗͜o̠̦̤ͯͥ̒ͫ́ͅo̺̪͖̗̽ͩ̃͟ͅn̢͔͖͇͇͉̫̰ͪ͑"</span></span><br><span class="line"></span><br><span class="line">zalgo.<span class="built_in">count</span> <span class="comment">// → 4</span></span><br><span class="line">zalgo.utf16.<span class="built_in">count</span> <span class="comment">// → 36</span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>zalgo.count</code> 返回值是4（正确的），而 <code>zalgo.utf16.count</code> 返回值是 36。如果你的代码连网上的颜文字都无法正确处理，那它有什么好的？</p><p>Unicode 编码的字位分割规则甚至在你处理纯 ASCII 编码的字符的时候也有影响，回车 <a href="https://codepoints.net/U+000D" target="_blank" rel="noopener">CR</a> 和 换行<a href="https://codepoints.net/U+000A" target="_blank" rel="noopener">LF</a> 这一个字符对在 Windows 系统上通常表示新开一行，但它们其实只是一个字位：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CR+LF is a single Character</span></span><br><span class="line"><span class="keyword">let</span> crlf = <span class="string">"\r\n"</span></span><br><span class="line">crlf.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><h3 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h3><p>许多其他编程语言处理包含 emoji 的字符串的时候会让人意外。许多 emoji 的 Unicode 标量无法存储在一个 UTF-16 的代码单元里面。有些语言（例如 Java 或者 C#）把字符串当做 UTF-16 代码块的集合，这些语言定义<a href="https://emojipedia.org/face-with-tears-of-joy/" target="_blank" rel="noopener">“😂”</a>为两个 “字符” 的长度。Swift 处理上述情况更为合理：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oneEmoji = <span class="string">"😂"</span> <span class="comment">// U+1F602</span></span><br><span class="line">oneEmoji.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，重要的是字符串如何展现给程序的，<strong>不是</strong>字符串在内存中是如何存储的。对于非 ASCII 的字符串，Swift 内部用的是 UTF-16 的编码，这只是内部的实现细节。公共 API 还是基于字位集（grapheme cluster）的。</p></blockquote><p>有些 emoji 由多个标量组成。emoji 中的国旗是由两个对应 ISO 国家代码的<a href="https://en.wikipedia.org/wiki/Regional_Indicator_Symbol" target="_blank" rel="noopener">地区标识符号（reginal indicator symbols）</a>组成的。Swift 里将一个国旗视为一个 <code>Character</code> ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flags = <span class="string">"🇧🇷🇳🇿"</span></span><br><span class="line">flags.<span class="built_in">count</span> <span class="comment">// → 2</span></span><br></pre></td></tr></table></figure><p>要检查一个字符串由几个 Unicode 标量组成，需要使用 <a href="https://developer.apple.com/documentation/swift/string/1539070-unicodescalars" target="_blank" rel="noopener"><code>unicodeScalars</code></a> 视图。这里，我们将 scalar 的值格式化为十进制的数字，这是代码点的普遍格式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">flags.unicodeScalars.<span class="built_in">map</span> &#123;</span><br><span class="line">    <span class="string">"U+<span class="subst">\(String($<span class="number">0</span>.value, radix: <span class="number">16</span>, uppercase: <span class="literal">true</span>)</span>)"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// → ["U+1F1E7", "U+1F1F7", "U+1F1F3", "U+1F1FF"]</span></span><br></pre></td></tr></table></figure><p>肤色是由一个基础的角色符号（例如👧）加上一个肤色修饰符（例如🏽）组成的，Swift 里是这么处理的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> skinTone = <span class="string">"👧🏽"</span> <span class="comment">// 👧 + 🏽</span></span><br><span class="line">skinTone.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><p>这次我们用 Foundation API 里面的 <a href="https://oleb.net/blog/2016/01/icu-text-transforms/" target="_blank" rel="noopener">ICU string transform</a> 把 Unicode 标量转换成官方的 Unicode 名称：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StringTransform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> toUnicodeName = <span class="type">StringTransform</span>(rawValue: <span class="string">"Any-Name"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Unicode</span>.<span class="title">Scalar</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The scalar’s Unicode name, e.g. "LATIN CAPITAL LETTER A".</span></span><br><span class="line">    <span class="keyword">var</span> unicodeName: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// Force-unwrapping is safe because this transform always succeeds</span></span><br><span class="line">        <span class="keyword">let</span> name = <span class="type">String</span>(<span class="keyword">self</span>).applyingTransform(.toUnicodeName,</span><br><span class="line">            <span class="built_in">reverse</span>: <span class="literal">false</span>)!</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The string transform returns the name wrapped in "\\N&#123;...&#125;". Remove those.</span></span><br><span class="line">        <span class="keyword">let</span> prefixPattern = <span class="string">"\\N&#123;"</span></span><br><span class="line">        <span class="keyword">let</span> suffixPattern = <span class="string">"&#125;"</span></span><br><span class="line">        <span class="keyword">let</span> prefixLength = name.hasPrefix(prefixPattern) ? prefixPattern.<span class="built_in">count</span> : <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> suffixLength = name.hasSuffix(suffixPattern) ? suffixPattern.<span class="built_in">count</span> : <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(name.<span class="built_in">dropFirst</span>(prefixLength).<span class="built_in">dropLast</span>(suffixLength))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skinTone.unicodeScalars.<span class="built_in">map</span> &#123; $<span class="number">0</span>.unicodeName &#125;</span><br><span class="line"><span class="comment">// → ["GIRL", "EMOJI MODIFIER FITZPATRICK TYPE-4"]</span></span><br></pre></td></tr></table></figure><p>这段代码里面最重要的是对 <code>applyingTransform(.toUnicodeName,...)</code> 的调用。其他的代码只是把转换方法返回的名字清理了一下，移除了括号。这段代码很保守：先是检查了字符串是否符合期望的格式，然后计算了从头到尾的字符数。如果将来转换方法返回的名字格式发生了变化，最好输出原字符串，而不是移除多余字符后的字符串。</p><p>注意我们是如何使用标准的集合（<code>Collection</code>）方法 <code>dropFirst</code> 和 <code>droplast</code> 进行移除操作的。如果你想对字符串进行操作，但是又不想对字符串进行手动索引，这就是一个很好的例子。这个方法同样也很高效，因为 <code>dropFisrt</code> 和 <code>dropLast</code> 方法返回的是 <code>Substring</code> 值，它们只是原字符串的一部分。在我们最后一步创建一个新的 <code>String</code> 字符串，赋值为这个 substring 之前，它是不占用新的内存的。关于这一点，我们在这一章的后面还有很多东西会涉及到。</p><p>Emoji 里面对家庭和夫妻的表示（例如 <a href="https://emojipedia.org/family-man-woman-girl-boy/" target="_blank" rel="noopener">👨‍👩‍👧‍👦</a> 和 <a href="https://emojipedia.org/couple-with-heart-woman-woman/" target="_blank" rel="noopener">👩‍❤️‍👩</a>）是 Unicode 编码标准面临的又一个挑战。由于性别以及人数的可能组合太多，为每种可能的组合都做一个代码点肯定会有问题。再加上每个人物角色的肤色的问题，这样做几乎不可行。Unicode编码是这样解决这个问题的，它将这种 emoji 定义为一系列由零宽度连接符（<a href="https://codepoints.net/U+200D" target="_blank" rel="noopener"><em>zero-width joiner</em></a>）联系起来的 emoji 。这样下来，这个家庭👨‍👩‍👧‍👦 emoji 其实就是 <a href="https://emojipedia.org/man/" target="_blank" rel="noopener"><em>man</em> 👨</a> + ZWJ + <a href="https://emojipedia.org/woman/" target="_blank" rel="noopener"><em>woman</em> 👩</a> + ZWJ + <a href="https://emojipedia.org/girl/" target="_blank" rel="noopener"><em>girl</em>👧</a> + ZWJ + <a href="https://emojipedia.org/boy/" target="_blank" rel="noopener"><em>boy</em> 👦</a>。而零宽度连接符的作用就是让操作系统知道这个 emoji 应该只是一个字素。</p><p>我们可以验证一下到底是不是这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> family1 = <span class="string">"👨‍👩‍👧‍👦"</span></span><br><span class="line"><span class="keyword">let</span> family2 = <span class="string">"👨\u&#123;200D&#125;👩\u&#123;200D&#125;👧\u&#123;200D&#125;👦"</span></span><br><span class="line">family1 == family2 <span class="comment">// → true</span></span><br></pre></td></tr></table></figure><p>在 Swift 里，这样一个 emoji 也同样被认为是一个字符 <code>Character</code> ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">family1.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">family2.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><p>2016年新引入的职业类型 emoji 也是这种情况。例如女性消防队员 <a href="https://emojipedia.org/female-firefighter/" target="_blank" rel="noopener">👩‍🚒</a> 就是 <a href="https://emojipedia.org/woman/" target="_blank" rel="noopener"><em>woman</em> 👩</a> + ZWJ + <a href="https://emojipedia.org/fire-engine/" target="_blank" rel="noopener"><em>fire engine</em> 🚒</a>。男性医生就是 <a href="https://emojipedia.org/man/" target="_blank" rel="noopener"><em>man</em> 👨</a> + ZWJ + <a href="https://emojipedia.org/staff-of-aesculapius/" target="_blank" rel="noopener"><em>staff of aesculapius</em> ⚕</a>（译者注：阿斯克勒庇厄斯，是古希腊神话中的医神，一条蛇绕着一个柱子指医疗相关职业）。</p><p>将这些一系列零宽度连接符连接起来的 emoji 渲染为一个字素是操作系统的工作。2017年，Apple 的操作系统表示支持 Unicode 编码标准下的 RGI 系列（“<a href="https://unicode.org/emoji/charts/emoji-zwj-sequences.html" target="_blank" rel="noopener">recommended for general interchange</a>”）。如果没有字位可以正确表示这个序列，那文本渲染系统会回退，显示为每个单个的字素。</p><p>注意这里又可能会导致一个理解偏差，即用户所认为的字符和 Swift 所认为的字位集之间的偏差。我们上面所有的例子都是担心编程语言会把字符<strong>数多了</strong>，但这里正好相反。举例来说，上面那个家庭的 emoji 里面涉及到的肤色 emoji 还未被收录到 RGI 集合里面。但尽管大多数操作系统都把这系列 emoji 渲染成多个字素，但 Swift 仍旧只把它们看做一个字符，因为 Unicode 编码的分词规则和渲染无关：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Family with skin tones is rendered as multiple glyphs</span></span><br><span class="line"><span class="comment">// on most platforms in 2017</span></span><br><span class="line"><span class="keyword">let</span> family3 = <span class="string">"👱🏾\u&#123;200D&#125;👩🏽\u&#123;200D&#125;👧🏿\u&#123;200D&#125;👦🏻"</span> <span class="comment">// → "👱🏾‍👩🏽‍👧🏿‍👦🏻"</span></span><br><span class="line"><span class="comment">// But Swift still counts it as a single Character</span></span><br><span class="line">family3.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.emojipedia.org/diverse-emoji-families-come-to-windows/" target="_blank" rel="noopener">Windows 系统已经可以</a>把这些 emoji 渲染为一个字素了，其他操作系统厂家肯定也会尽快支持。但是，有一点是不变的：无论一个字符串的 API 如何精心设计，都无法完美支持每一个细小的案例，因为文本太复杂了。</p><blockquote><p>过去 Swift 很难跟得上 Unicode 编码标准改变的步伐。Swift 3 渲染肤色和零宽度连接符系列 emoji 是错误的，因为当时的分词算法是根据上一个版本的 Unicode 编码标准。自 Swift 4 起，Swift 开始启用操作系统的 <a href="http://site.icu-project.org" target="_blank" rel="noopener">ICU</a>库。因此，只要用户更新他们的操作系统，你的程序就会采用最新的 Unicode 编码标准。硬币的另一面是，你开发中看到的和用户看到的东西可能是不一样的。</p></blockquote><p>编程语言如果全面考虑 Unicode 编码复杂性的话，在处理文本的时候会引发很多问题。上面这么多例子我们只是谈及其中的一个问题：字符串的长度。如果一个编程语言不是按字素集处理字符串，而这个字符串又包含很多字符序列的话，这时候一个简简单单的反序输出字符串的操作会变得多么复杂。</p><p>这不是个新问题，但是 emoji 的流行使得糟糕的文本处理方法造成的问题更容易浮出表面，即使你的用户群大部分是说英语的。而且，错误的级别也大大提升：十年前，弄错一个变音符号的字母可能只会造成 1 个字符数的误差，现在如果弄错了 emoji 的话很可能就是 10 个字符数的误差。例如，一个四人家庭的 emoji在 UTF-16 编码下是 11 个字符，在 UTF-8 编码下就是 25 个字符了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">family1.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">family1.utf16.<span class="built_in">count</span> <span class="comment">// → 11</span></span><br><span class="line">family1.utf8.<span class="built_in">count</span> <span class="comment">// → 25</span></span><br></pre></td></tr></table></figure><p>也不是说其他编程语言就完全没有符合 Unicode 编码标准的 API，大部分还是有的。例如，<code>NSString</code> 就有一个 <a href="https://developer.apple.com/documentation/foundation/nsstring/1416774-enumeratesubstrings" target="_blank" rel="noopener"><code>enumerateSubstrings</code></a> 的方法可以按照字位集遍历一个字符串。但是缺省设置很重要，而 Swift 的原则就是缺省情况下，就按正确的方式来做。而且如果你需要低一个抽象级别去看，<code>String</code> 也提供不同的视图，然你可以直接从 Unicode 标量或者代码块的级别操作。下面的内容里我们还会涉及到这一点。</p><h2 id="字符串和集合"><a href="#字符串和集合" class="headerlink" title="字符串和集合"></a>字符串和集合</h2><p>我们已经看到，<code>String</code> 是一个 <code>Character</code> 值的集合。在 Swift 语言发展的前三年里，<code>String</code> 这个类在遵守还是不遵守 <code>Collection</code> 集合协议这个问题上左右摇摆了几次。坚持不要遵守集合协议的人认为，如果遵守的话，程序员会认为所有通用的集合处理算法用在字符串上是绝对安全的，也绝对符合 Unicode 编码标准的，但是显然有一些特例存在。</p><p>举一个简单的例子，两个集合相加，得到的新的集合的长度肯定是两个子集合长度的和。但是在字符串中，如果第一个字符串的后缀和第二个字符串的前缀形成了一个字位集，长度就会有变化了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flagLetterJ = <span class="string">"🇯"</span></span><br><span class="line"><span class="keyword">let</span> flagLetterP = <span class="string">"🇵"</span></span><br><span class="line"><span class="keyword">let</span> flag = flagLetterJ + flagLetterP <span class="comment">// → "🇯🇵"</span></span><br><span class="line">flag.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">flag.<span class="built_in">count</span> == flagLetterJ.<span class="built_in">count</span> + flagLetterP.<span class="built_in">count</span> <span class="comment">// → false</span></span><br></pre></td></tr></table></figure><p>出于这种考虑，在 Swift 2 和 Swift 3 中，<code>String</code> 并没有被算作一个集合。这个特性是作为 <code>String</code> 的一个 <a href="https://developer.apple.com/documentation/swift/string/1540072-characters" target="_blank" rel="noopener"><code>characters</code></a> 视图存在的，和其他几个集合视图一样：<a href="https://developer.apple.com/documentation/swift/string/1539070-unicodescalars" target="_blank" rel="noopener"><code>unicodeScalars</code></a>，<a href="https://developer.apple.com/documentation/swift/string/1539703-utf8" target="_blank" rel="noopener"><code>utf8</code></a> 和 <a href="https://developer.apple.com/documentation/swift/string/1541301-utf16" target="_blank" rel="noopener"><code>utf16</code></a>。选择一个特定的视图，就相当于让程序员转换到另一种“处理集合”的模式，相应的，程序员就必须考虑到这种模式下可能产生的问题。</p><p>但是，在实际应用中，这个改变提升了学习成本，降低了可用性；单单为了保证在那些极端个例中的正确性（其实在真实应用中很少遇到，除非你写的是个文本编辑器的应用）做出这样的改变太不值得了。因此，在 Swift 4 中，<code>String</code> 再次成了一个集合。<code>characters</code> 视图还在，但是只是为了向后兼容 Swift 3。</p><h3 id="双向获取，而非任意获取"><a href="#双向获取，而非任意获取" class="headerlink" title="双向获取，而非任意获取"></a>双向获取，而非任意获取</h3><p>然而，<code>String</code> 并<strong>不是</strong>一个可以任意获取的集合，原因的话，上一部分的几个例子已经展现的很清楚。一个字符到底是第几个字符取决于它前面有多少个 Unicode scalar，这样的情况下，根本不可能实现任意获取。由于这个原因，Swift 里面的字符串遵守双向获取（<a href="https://developer.apple.com/documentation/swift/bidirectionalcollection" target="_blank" rel="noopener"><code>BidirectionalCollection</code></a>）规则。可以从字符串的两头数，代码会根据相邻字符的组成，跳过正确数量的字节。但是，每次访问只能上移或者下移一个字符。</p><p>在写处理字符串的代码的时候，要考虑到这种方式的操作对代码性能的影响。那些依靠任意获取来保证代码性能的算法对 Unicode 编码的字符串并不合适。我们看一个例子，我们要获取一个字符串所有 prefix 的列表。我们只需要得到一个从零到字符串长度的一系列整数，然后根据每个长度的整数在字符串中找到对应长度的 prefix：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allPrefixes1: [<span class="type">Substring</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>...<span class="keyword">self</span>.<span class="built_in">count</span>).<span class="built_in">map</span>(<span class="keyword">self</span>.<span class="keyword">prefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="string">"Hello"</span></span><br><span class="line">hello.allPrefixes1 <span class="comment">// → ["", "H", "He", "Hel", "Hell", "Hello"]</span></span><br></pre></td></tr></table></figure><p>尽管这段代码看起来很简单，但是运行性能很低。它先是遍历了字符串一次，计算出字符串的长度，这还 OK。但是每次对 <a href="https://developer.apple.com/documentation/swift/substring/2893985-prefix" target="_blank" rel="noopener"><code>prefix</code></a> 进行 n+1 的调用都是一次 <em>O(n)</em> 操作，因为 <code>prefix</code> 方法需要从字符串的开头往后找出所需数量的字符。而在一个线性运算里进行另一个线性运算就意味着算法已经成了 <em>O(n2)</em> ——随着字符串长度的增加，算法所需的时间是呈指数级增长的。</p><p>如果可能的话，一个高性能的算法应该是遍历字符串一次，然后通过对字符串索引的操作得到想要的子字符串。下面是相同算法的另一个版本：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allPrefixes2: [<span class="type">Substring</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">""</span>] + <span class="keyword">self</span>.<span class="built_in">indices</span>.<span class="built_in">map</span> &#123; index <span class="keyword">in</span> <span class="keyword">self</span>[...index] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello.allPrefixes2 <span class="comment">// → ["", "H", "He", "Hel", "Hell", "Hello"]</span></span><br></pre></td></tr></table></figure><p>这段代码只需要遍历字符串一次，得到字符串的索引（<a href="https://developer.apple.com/documentation/swift/bidirectionalcollection/1785188-indices" target="_blank" rel="noopener"><code>indices</code></a>）集合。一旦完成之后，之后再 <code>map</code> 内的操作就只是 <em>O(1)</em>。整个算法也只是 <em>O(n)</em>。</p><h3 id="范围可替换，不可变"><a href="#范围可替换，不可变" class="headerlink" title="范围可替换，不可变"></a>范围可替换，不可变</h3><p><code>String</code> 还遵从于 <a href="https://developer.apple.com/documentation/swift/rangereplaceablecollection" target="_blank" rel="noopener"><code>RangeReplaceableCollection</code></a> （范围可替换）的集合操作。也就是说，你可以先按字符串索引的形式定义出一个范围，然后通过调用 <a href="https://developer.apple.com/documentation/swift/string/1641462-replacesubrange" target="_blank" rel="noopener"><code>replaceSubrange</code></a> （替换子范围）方法，替换掉字符串中的一些字符。这里有一个例子。替换的字符串可以有不同的长度，甚至还可以是空的（这时候就相当于调用 <a href="https://developer.apple.com/documentation/swift/string/2893740-removesubrange" target="_blank" rel="noopener"><code>removeSubrange</code></a> 方法了）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello, world!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> comma = greeting.index(of: <span class="string">","</span>) &#123;</span><br><span class="line">    greeting[..&lt;comma] <span class="comment">// → "Hello"</span></span><br><span class="line">    greeting.replaceSubrange(comma..., with: <span class="string">" again."</span>)</span><br><span class="line">&#125;</span><br><span class="line">greeting <span class="comment">// → "Hello again."</span></span><br></pre></td></tr></table></figure><p>同样，这里也要注意一个问题，如果替换的字符串和原字符串中相邻的字符形成了新的字位集，那结果可能就会有点出人意料了。</p><p>字符串无法提供的一个类集合特性是：<a href="https://developer.apple.com/documentation/swift/mutablecollection" target="_blank" rel="noopener"><code>MutableCollection</code></a>。该协议给集合除 <code>get</code> 之外，添加了一个通过下标进行单一元素 <code>set</code> 的特性。这并不是说字符串是不可变的——我们上面已经看到了，有好几种变化的方法。你无法完成的是使用下标操作符替换其中的一个字符。许多人直觉认为用下标操作符替换一个字符是即时发生的，就像数组 <a href="https://developer.apple.com/documentation/swift/array" target="_blank" rel="noopener"><code>Array</code></a> 里面的替换一样。但是，因为字符串里的字符长度是不定的，所以替换一个字符的时间和字符串的长度呈线性关系：替换一个元素的宽度会把其他所有元素在内存中的位置重新洗牌。而且，替换元素索引后面的元素索引在洗牌之后都变了，这也是跟人们的直觉相违背的。出于这些原因，你必须使用 <code>replaceSubrange</code> 进行替换，即使你变化只是一个元素。</p><h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h2><p>大多数编程语言都是用整数作为字符串的下标，例如 <code>str[5]</code> 就会返回 <code>str</code> 的第六个“字符”（无论这个语言定义的“字符”是什么）。Swift 却不允许这样。为什么呢？原因可能你已经听了很多遍了：下标应该是使用固定时间的(无论是直觉上，还是根据集合协议)，但是查询第 n 个“字符”的操作必须查询它前面所有的字节。</p><p><a href="https://developer.apple.com/documentation/swift/string.index" target="_blank" rel="noopener">字符串索引（<code>String.Index</code>）</a> 是字符串及其视图使用的索引类型。它是个不透明值（opaque value，内部使用的值，开发者一般不直接使用），本质上存储的是从字符串开头算起的字节偏移量。如果你想计算第 n 个字符的索引，它还是一个 <em>O(n)</em> 的操作，而且你还是必须从字符串的开头开始算起，但是一旦你有了一个正确的索引之后，对这个字符串进行下标操作就只需要 <em>O(1)</em> 次了。关键是，找到现有索引后面的元素的索引的操作也会变得很快，因为你只需要从已有索引字节后面开始算起了——没有必要从字符串开头开始了。这也是为什么有序（向前或是向后）访问字符串里的字符效率很高的原因。</p><p>字符串索引操作的依据跟你在其他集合里使用的所有 API 一样。因为我们最常用的集合——数组——使用的是整数索引，我们通常使用简单的算术来操作，所以有一点很容易忘记： <a href="https://developer.apple.com/documentation/swift/string/1782583-index" target="_blank" rel="noopener"><code>index(after:)</code></a> 方法返回的是下一个字符的索引：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"abcdef"</span></span><br><span class="line"><span class="keyword">let</span> second = s.index(after: s.startIndex)</span><br><span class="line">s[second] <span class="comment">// → "b"</span></span><br></pre></td></tr></table></figure><p>使用 <a href="https://developer.apple.com/documentation/swift/string/1786175-index" target="_blank" rel="noopener"><code>index(_:offsetBy:)</code></a>方法，你可以通过一次操作，自动地访问多个字符，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Advance 4 more characters</span></span><br><span class="line"><span class="keyword">let</span> sixth = s.index(second, offsetBy: <span class="number">4</span>)</span><br><span class="line">s[sixth] <span class="comment">// → "f"</span></span><br></pre></td></tr></table></figure><p>如果可能超出字符串末尾，你可以加一个 <a href="https://developer.apple.com/documentation/swift/anybidirectionalcollection/1781464-index" target="_blank" rel="noopener"><code>limitedBy:</code></a> 参数。如果在访问到目标索引之前到达了字符串的末尾，这个方法会返回一个 <code>nil</code> 值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> safeIdx = s.index(s.startIndex, offsetBy: <span class="number">400</span>, limitedBy: s.endIndex)</span><br><span class="line">safeIdx <span class="comment">// → nil</span></span><br></pre></td></tr></table></figure><p>比起简单的整数索引，这无疑使用了更多的代码。<strong>这是 Swift 故意的。</strong>如果 Swift 允许对字符串进行整数索引，那不小心写出性能烂到爆的代码（比如在一个循环中使用整数的下标操作）的诱惑太大了。</p><p>然而，对一个习惯于处理固定宽度字符的人来说，刚开始使用 Swift 处理字符串会有些挑战——没有了整数索引怎么搞？而且确实，一些看起来简单的任务处理起来还得大动干戈，比如提取字符串的前四个字符：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">s[..&lt;s.index(s.startIndex, offsetBy: <span class="number">4</span>)] <span class="comment">// → "abcd"</span></span><br></pre></td></tr></table></figure><p>不过谢天谢地，你可以使用集合的接口来获取字符串，这意味着许多适用于数组的方法同样也适用于字符串。比如上面那个例子，如果使用 <code>prefix</code> 方法就简单得多了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">s.<span class="keyword">prefix</span>(<span class="number">4</span>) <span class="comment">// → "abcd"</span></span><br></pre></td></tr></table></figure><p>（注意，上面的几个方法返回的都是子字符串 <a href="https://developer.apple.com/documentation/swift/substring" target="_blank" rel="noopener"><code>Substring</code></a>，你可以使用一个 <code>String.init</code> 把它转换为字符串。关于这一部分，我们下一部分会讲更多。）</p><p>没有整数索引，循环访问字符串里的字符也很简单，用 <code>for</code> 循环。如果你想按顺序排列，使用 <a href="https://developer.apple.com/documentation/swift/sequence/1641222-enumerated" target="_blank" rel="noopener"><code>enumerated()</code></a>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i, <span class="built_in">c</span>) <span class="keyword">in</span> s.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(i)</span>: <span class="subst">\(<span class="built_in">c</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者如果你想找到一个特定的字符，你可以使用 <a href="https://developer.apple.com/documentation/swift/string/2893264-index" target="_blank" rel="noopener"><code>index(of:)</code></a>:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">"Hello!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> idx = hello.index(of: <span class="string">"!"</span>) &#123;</span><br><span class="line">    hello.insert(contentsOf: <span class="string">", world"</span>, at: idx)</span><br><span class="line">&#125;</span><br><span class="line">hello <span class="comment">// → "Hello, world!"</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swift/string/2893571-insert" target="_blank" rel="noopener"><code>insert(contentsOf:at:)</code></a> 方法可以在指定索引前插入相同类型的另一个集合（比如说字符串里的字符）。并不一定是另一个字符串，你可以很容易地把一个字符的数组插入到一个字符串里。</p><h2 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h2><p>和其他的集合一样，字符串有一个特定的切片类型或者说子序列类型（<a href="https://developer.apple.com/documentation/swift/collection/1641276-subsequence" target="_blank" rel="noopener"><code>SubSequence</code></a>）：子字符串（<a href="https://developer.apple.com/documentation/swift/substring" target="_blank" rel="noopener"><code>Substring</code></a>）。子字符串就像是一个数组切片（<a href="https://developer.apple.com/documentation/swift/arrayslice" target="_blank" rel="noopener"><code>ArraySlice</code></a>）：它是原字符串的一个视图，起始索引和结束索引不同。子字符串共享原字符串的文本存储空间。这是一个很大的优势，对一个字符串进行切片操作不占用内存空间。在下面的例子中，创建<code>firstWord</code>变量不占用内存：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence = <span class="string">"The quick brown fox jumped over the lazy dog."</span></span><br><span class="line"><span class="keyword">let</span> firstSpace = sentence.index(of: <span class="string">" "</span>) ?? sentence.endIndex</span><br><span class="line"><span class="keyword">let</span> firstWord = sentence[..&lt;firstSpace] <span class="comment">// → "The"</span></span><br><span class="line">type(of: firstWord) <span class="comment">// → Substring.Type</span></span><br></pre></td></tr></table></figure><p>切片操作不占用内存意义重大，特别是在一个循环中，比如你要通过循环访问整个字符串（可能会很长）来提取其中的字符。比如在文本中找到一个单词使用的次数，比如解析一个 CSV 文件。这里有一个非常有用的字符串处理操作：split。<code>split</code> 是 <code>Collection</code> 集合中定义的一个方法，它会返回一个子序列的数组（即 <code>[Substring]</code> ）。它最常见的变种就像是这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(separator: Element, maxSplits: Int = Int.<span class="built_in">max</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        omittingEmptySubsequences: Bool = <span class="literal">true</span>)</span></span> -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以这样使用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> poem = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    Over the wintry</span></span><br><span class="line"><span class="string">    forest, winds howl in rage</span></span><br><span class="line"><span class="string">    with no leaves to blow.</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line"><span class="keyword">let</span> lines = poem.<span class="built_in">split</span>(separator: <span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">// → ["Over the wintry", "forest, winds howl in rage", "with no leaves to blow."]</span></span><br><span class="line">type(of: lines) <span class="comment">// → Array&lt;Substring&gt;.Type</span></span><br></pre></td></tr></table></figure><p>这个跟 <code>String</code> 继承自 <code>NSString</code> 的 <a href="https://developer.apple.com/documentation/swift/stringprotocol/2923413-components" target="_blank" rel="noopener"><code>components(separatedBy:)</code></a> 方法的功能类似，你还可以用一些额外设置比如是否抛弃空的组件。而且在这个操作中，所有输入字符串都没有创建新的复制。因为还有其他<code>split</code>方法的变种可以完成操作，除了比较字符以外，<code>split</code> 还可以完成更多的事情。下面这个例子是文本换行算法的一个原始的实现，最后的代码计算了行的长度：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">wrapped</span><span class="params">(after: Int = <span class="number">70</span>)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> lines = <span class="keyword">self</span>.<span class="built_in">split</span>(omittingEmptySubsequences: <span class="literal">false</span>) &#123;</span><br><span class="line">            character <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> character &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"\n"</span>, <span class="string">" "</span> <span class="keyword">where</span> i &gt;= after:</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lines.joined(separator: <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sentence.wrapped(after: <span class="number">15</span>)</span><br><span class="line"><span class="comment">// → "The quick brown\nfox jumped over\nthe lazy dog."</span></span><br></pre></td></tr></table></figure><p>或者，考虑写另外一个版本，可以拿到一个包含多个分隔符的序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">split</span>&lt;S: Sequence&gt;<span class="params">(separators: S)</span></span> -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">        <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">S</span>.<span class="type">Element</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">split</span> &#123; separators.<span class="built_in">contains</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，你还可以这么写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="string">"Hello, world!"</span>.<span class="built_in">split</span>(separators: <span class="string">",! "</span>) <span class="comment">// → ["Hello", "world"]</span></span><br></pre></td></tr></table></figure><h3 id="字符串协议-StringProtocol"><a href="#字符串协议-StringProtocol" class="headerlink" title="字符串协议 StringProtocol"></a>字符串协议 <code>StringProtocol</code></h3><p><code>Substring</code> 和 <code>String</code> 几乎有着相同的接口，因为两种类型都遵守一个共同的字符串协议（<a href="https://developer.apple.com/documentation/swift/stringprotocol" target="_blank" rel="noopener"><code>StringProtocol</code></a>）。因为几乎所有的字符串API 都是在 <a href="https://developer.apple.com/documentation/swift/stringprotocol" target="_blank" rel="noopener"><code>StringProtocol</code></a> 中定义的，所以操作 <code>Substring</code> 跟操作 <code>String</code> 没有什么大的区别。但是，在有些情况下，你还必须把子字符串转换为字符串的类型；就像所有的切片（slice）一样，子字符串只是为了短时间内的存储，为了防止一次操作定义太多个复制。如果操作结束之后，你还想保留结果，将数据传到另一个子系统里，你应该创建一个新的字符串。你可以用一个 <code>Substring</code> 的值初始化一个 <code>String</code>，就像我们在这个例子中做的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastWord</span><span class="params">(<span class="keyword">in</span> input: String)</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="comment">// Process the input, working on substrings</span></span><br><span class="line">    <span class="keyword">let</span> words = input.<span class="built_in">split</span>(separators: [<span class="string">","</span>, <span class="string">" "</span>])</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> lastWord = words.last <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="comment">// Convert to String for return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(lastWord)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lastWord(<span class="keyword">in</span>: <span class="string">"one, two, three, four, five"</span>) <span class="comment">// → "five"</span></span><br></pre></td></tr></table></figure><p>不建议子字符串长期存储背后的原因是子字符串一直关联着原字符串。即使一个超长字符串的子字符串只有一个字符，只要子字符串还在使用，那原先的字符串就还会在内存里，即使原字符串的生命周期已经结束。因此，长期存储子字符串可能导致内存泄漏，因为有时候原字符串已经无法访问了，但是还在占用内存。</p><p>操作过程中使用子字符串，操作结束的时候才创建新的字符串，通过这种方式，我们把占用内存的动作推迟到了最后一刻，而且保证了我们只会创建必要的字符串。在上面的例子当中，我们把整个字符串（可能会很长）分成了一个个的子字符串，但是在最后只是创建了一个很短的字符串。（例子中的算法可能效率不是那么高，暂时忽略一下；从后先前找到第一个分隔符可能是个更好的方法。）</p><p>遇到只接受 <code>Substring</code> 类型的方法，但是你想传递一个 <code>String</code> 的类型，这种情况很少见（大部分的方法都接受 <code>String</code> 类型或者接受所有符合字符串协议的类型），但是如果你确实需要传递一个 <code>String</code> 的类型，最便捷的方法是使用范围操作符（range operator）<code>...</code>，不限定范围：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子字符串和原字符串的起始和结束的索引完全一致 </span></span><br><span class="line"><span class="keyword">let</span> substring = sentence[...]</span><br></pre></td></tr></table></figure><hr><p><code>Substring</code> 类型是 Swift 4 中的新特性。在 Swift 3 中，<code>String.CharacterView</code> 是自己独有的切片类型（slice type）。这么做的优势是用户只需要了解一种类型，但这也意味这如果存储一个子字符串，整个原字符串也会占据内存，即使它正常情况下应该已经被释放了。Swift 4 损失了一点便捷，换来的是的方便的切片操作和可预测的内存使用。</p><p>要求 <code>Substring</code> 到 <code>String</code> 的转换必须明确写出，Swift 团队认为这没那么烦人。如果实际应用中大家都觉得问题很大，他们也会考虑直接在编译器中写一个 <code>Substring</code> 和 <code>String</code> 之间的<a href="https://github.com/apple/swift/blob/master/docs/StringManifesto.md#substrings" target="_blank" rel="noopener">模糊子类型关系（implicit subtype relationship）</a>，就像 <code>Int</code> 是 <code>Optional&lt;Int&gt;</code> 的子类型一样。这样你就可以随意传递 <code>Substring</code> 类型，编译器会帮你完成类型转换。</p><hr><p>你可能会倾向于充分利用字符串协议，把你所有的 API 写成接受所有遵守字符串协议的实例，而不是仅仅接受 <code>String</code> 字符串。但 Swift 团队的建议是，<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170626/037828.html" target="_blank" rel="noopener">别这样</a>：</p><blockquote><p>总的来说，我们建议继续使用字符串变量。 使用字符串变量，大多数的 API 都会比把它们写成通用类型（这个操作本身就有一些代价）更加简洁清晰，用户在必要的时候进行一些转换并不需要花费很大的精力。</p></blockquote><p>一些 API 极有可能和子字符串一起使用，同时无法泛化到适用于整个序列 <code>Sequence</code> 或集合 <code>Collection</code> 的级别，这些 API 可以不受这条规则的限制。一个例子就是标准库中的 <a href="https://developer.apple.com/documentation/swift/sequence/1641243-joined" target="_blank" rel="noopener"><code>joined</code></a> 方法。Swift 4 中，针对遵守字符串协议的元素组成的序列（<code>Sequence</code>）添加了一个重载（<code>overload</code>）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">StringProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 两个元素中间加上一个特定分隔符后</span></span><br><span class="line">    <span class="comment">/// 合并序列中所有元素，返回一个新的字符串</span></span><br><span class="line">    <span class="comment">/// Returns a new string by concatenating the elements of the sequence,</span></span><br><span class="line">    <span class="comment">/// adding the given separator between each element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">joined</span><span class="params">(separator: String = <span class="string">""</span>)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，你就可以直接对一个子字符串的数组调用 <code>joined</code> 方法了，没必要遍历一次数组并且把每个子字符串转换为新的字符串。这样，一切都很方便快速。</p><p>数值类型初始器（number type initializer）可以将字符串转换为一个数字。在 Swift 4 中，它也接受遵守字符串协议的值。如果你要处理一个子字符串的数组的话，这个方法很顺手：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> commaSeparatedNumbers = <span class="string">"1,2,3,4,5"</span></span><br><span class="line"><span class="keyword">let</span> numbers = commaSeparatedNumbers</span><br><span class="line">    .<span class="built_in">split</span>(separator: <span class="string">","</span>).flatMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125;</span><br><span class="line"><span class="comment">// → [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>由于子字符串的生命周期很短，所以不建议方法的返回值是子字符串，除非是序列 <code>Sequence</code> 或集合 <code>Collection</code> 的一些返回切片的 API。如果你写了一个类似的方法，只对字符串有意义，那让它的返回值是子字符串，好让读者明白这个方法并不会产生复制，不会占用内存。创建新字符串的方法需要占用内存，比如 <a href="https://developer.apple.com/documentation/swift/stringprotocol/2908613-uppercased" target="_blank" rel="noopener"><code>uppercased()</code></a>，这类的方法应该返回 <code>String</code> 字符串类型的值。</p><p>如果你想为字符串类型扩展新的功能， 好的办法是将扩展放在字符串协议 <code>StringProtocol</code> 上，保证 API 在字符串和子字符串层面的一致性。字符权协议的设计初衷就是替换原先在字符串基础上做的扩展功能。如果你想把现有的扩展从字符串转移到字符串协议上，你要做的唯一改变就是，把传递 <code>Self</code> 给只接受具体 <code>String</code> 值的 API替换为 <code>String(Self)</code>。</p><p>需要记住的一点是，从 Swift 4开始，如果你有一些自定义的字符串类型，不建议遵守字符串协议<code>StringProtocol</code>。官方文档明确警告：</p><blockquote><p>不要做任何新的遵守字符串协议 <code>StringProtocol</code> 的声明。只有标准库里的 <code>String</code> 和 <code>Substring</code> 是有效的遵守类型。</p></blockquote><p>允许开发者写自己的字符串类型（比如有特殊的存储优化或性能优化）是终极目标，但是现阶段协议的设计还没有最终确定，所以现在就启用它可能会导致你的代码在 Swift 5里无法正常运行。</p><p><code>… &lt;SNIP&gt;  &lt;内容有删减&gt;…</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Swift 语言里的字符串跟其他所有的主流编程语言里的字符串差异很大。当你习惯于把字符串当做代码块的数组后，你得花点时间转化思维，习惯 Swift 的处理方法：它把遵守 Unicode 编码标准放在<strong>简洁</strong>前面。</p><p>总的来讲，我们认为 Swift 的选择是正确的。Unicode 编码文本比其他编程语言所认为的要复杂得多。长远来看，处理你可能写出来的 bug 的时间肯定比学习新的索引方式（忘记整数索引）所需的时间多。</p><p>我们已经习惯于任意获取“字符”，以至于我们都忘了其实这个特性在真正的字符串处理的代码里很少用到。我们希望通过这一章里的例子可以说服大家，对于大多数常规的操作，简单的按序遍历也完全 OK。强迫你清楚地写出你想在哪个层面（字位集，Unicode scalar，UTF-16 代码块，UTF-8 代码块）处理字符串是另一项安全措施；读你代码的人会对你心存感激的。</p><p>2016年7月，Chris Lattner 谈到了 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html" target="_blank" rel="noopener">Swift 语言字符串处理的目标</a>，他最后是这么说的：</p><blockquote><p>我们的目标是在字符串处理上超越 Perl。</p></blockquote><p>当然 Swift 4 还没有实现这个目标——很多想要的特性还没实现，包括把 Foundation 库中的诸多字符串 API 转移到标准库，正则表达式的自然语言支持，字符串格式化和解析 API，更强大的字符串插入功能。好消息是 Swift 团队已经表示 <a href="https://github.com/apple/swift/blob/master/docs/StringManifesto.md" target="_blank" rel="noopener">会在将来解决所有这些问题</a>。</p><hr><p>如果喜欢本文的话，请考虑<a href="https://gumroad.com/a/507458675" target="_blank" rel="noopener">购买全书</a>。谢谢！</p><p>全书中第一张是本文的两本。讨论了其他的一些问题，包括如何使用以及什么时候使用字符串的代码块视图，如何和 Foundation里的处理字符串的 API（例如 <a href="https://developer.apple.com/documentation/foundation/nsregularexpression" target="_blank" rel="noopener"><code>NSRegularExpression</code></a> 或者 <a href="https://developer.apple.com/documentation/foundation/nsattributedstring" target="_blank" rel="noopener"><code>NSAttributedString</code></a>） 配合处理。贴别是后面这个问题很难，而且很容易犯错。除此之外还讨论了其他标准库里面机遇字符串的 API，例如文本输出流（<a href="https://developer.apple.com/documentation/swift/textoutputstream" target="_blank" rel="noopener"><code>TextOutputStream</code></a>）或自定义字符串转换（<a href="https://developer.apple.com/documentation/swift/customstringconvertible" target="_blank" rel="noopener"><code>CustomStringConvertible</code></a>）。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2017/11/swift-4-strings&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-11-27&lt;br&gt;译者：&lt;a href=&quot;https://weibo.com/u/5029986118&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;东莞大唐和尚&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;，&lt;a href=&quot;undefined&quot;&gt;Firecrest&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;这个系列中其他文章：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://oleb.net/blog/2014/07/swift-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift 1 中的字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://oleb.net/blog/2016/08/swift-3-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift 3 中的字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Swift 4 中的字符串（本文）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文节选自我们的新书《高级 Swift 编程》「字符串」这一章。《高级 Swift 编程》新版本已根据 Swift 4 的新特性修订补充，新版现已上市。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemannh" scheme="https://swift.gg/categories/Ole-Begemannh/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>剖析 ARM 64 架构中的 objc_msgSend</title>
    <link href="https://swift.gg/2018/08/06/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64/"/>
    <id>https://swift.gg/2018/08/06/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64/</id>
    <published>2018-08-06T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-30<br>译者：<a href="undefined">BigNerdCoding</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>很高兴，我又回来了。在刚刚过去的 WWDC 期间，我在 CocoaConf Next Door 做个一个关于剖析 ARM64 上 <code>objc_msgSend</code> 运行流程的发言。现在我将整理后的内容重新发布到 Friday Q&amp;A 上。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>每个 Objective-C 对象都会指向一个类，而每个类又包含一个方法列表。每个方法则由选择器（<code>selector</code>）、函数指针和一些元数据（<code>metadata</code>）构成。<code>objc_msgSend</code> 职责就是接收对象（<code>object</code>）和选择器（<code>selector</code>），根据选择器名称找到对应方法的函数指针并跳转执行该函数。</p><p>查找过程相对来说还是比较复杂的。若某个方法在当前类中未找到，就需要沿着继承链继续在父类中查找。如果在父类中也未查询到的话，则会触发 runtime 机制中的消息转发机制。任何对象在接收到第一条消息后都会触发类方法 <code>+initialize</code> 。</p><p>因为每次方法调用都会触发上述流程，所以在常见场景下的查找速度必须非常快。显然这与复杂的操作过程之间存在一定冲突。</p><p>为了解决这对矛盾提高查询速度，Objective-C 采用了方法缓存策略。每个类都会使用哈希表将其方法按照 Selector - IMPs（函数指针） 键值对关系缓存起来。这样在查询方法时，runtime 首先会直接去哈希表中查询。如果哈希表中不存在的话则转而执行原有复杂、缓慢的处理流程，并将最终结果缓存起来已备下次使用。</p><p><code>objc_msgSend</code> 用汇编语言进行实现，具体理由有两个：首先纯 C 语言无法实现这么一个函数：接收不定个数且未知类型的参数作为入参跳转至任意函数指针（即调用实现）；其次，执行速度对 <code>objc_msgSend</code> 来说非常重要，汇编语言能最大化提升该项指标。</p><p>当然，使用汇编语言实现整个复杂的消息处理过程是不现实的，而且也没这种必要。因为有些流程一旦触发程序都会变慢，无论采用何种语言层面的实现。整个消息处理流程代码可以分为两个部分：通过汇编代码实现的快速路径部分（fast path） ，C 语言实现的慢路径流程（slow path）。其中汇编代码对应缓存表中查询方法部分并且未命中时跳转 C 代码来进行下一步处理。</p><p>因此，<code>objc_msgSend</code> 代码处理流程大致如下：</p><ol><li>获取消息对象所对应的类信息</li><li>获取类所对应的方法缓存</li><li>在方法缓存中查询 <em>selector</em> 对象的函数实现</li><li>如果查询失败则调用 C 代码进行下一步处理</li><li>跳转到 IMP 所指的函数实现</li></ol><p>下面开始分析其具体实现。</p><h2 id="执行过程的指令"><a href="#执行过程的指令" class="headerlink" title="执行过程的指令"></a>执行过程的指令</h2><p><em>objc_msgSend</em> 在不同情形下执行路径不尽相同。对于向 <code>nil</code> 发送消息，标记指针（tagged pointers），哈希表冲突会相应特殊代码中进行处理。下面我将通过最常见也是最简单的情形来解释 <code>objc_msgSend</code>  的执行，即处理 non-nil、non-tagged 消息并且哈希表也能命中该方法。我会在该过程中标记出那些需要注意的处理路径<em>岔路口</em>，然后回过头来进行详细讲解。</p><p>我将列出单条或一组指令，然后在下面紧接相关解释内容。</p><p>每条指令前面都会有一个地址偏移量，可以将其看作一个指示跳转位置的标记量。</p><p>ARM64 架构中包含 31 个 64 位整型寄存器，对应符号表示为 x0 - x30 。每个寄存器的低 32 位也可以通过 w0 到 w30 进行访问，就像它也是一个单独的寄存器。其中 x0 到 x7 被用来保存函数调用时的前 8 个参数。这意味着 <code>objc_msgSend</code> 函数中的 <code>self</code> 参数保存在 x0 而 <code>_cmd</code> 保存在 x1 。</p><p>起始指令如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000 cmp     x0, #0x0</span><br><span class="line">0x0004 b.le    0x6c</span><br></pre></td></tr></table></figure><p>该段指令是将 <code>self</code> 与 0 进行有符号比较，如果 <code>self</code> 不大于 0 的话则会进行跳转处理。等于 0 其实就相当于 <code>nil</code> 对象，也就是说此时会调用向 <em>nil</em> 发送消息情形下对应的特定代码。另外，该指令也被用于标记指针（<code>tagged pointers</code>）的处理。ARM64 通过设置最高位为 1 来标记 Tagged Pointers（x86-64 则是最低位），此时对应有符号数比为负。对于普通指针来说，上述处理分支都会不被触发。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0008 ldr    x13, [x0]</span><br></pre></td></tr></table></figure><p>该指令将 x0 中所表示的 <em>self</em> 的 isa 地址加载到 x13 寄存器中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x000c and    x16, x13, #0xffffffff8</span><br></pre></td></tr></table></figure><p>因为 ARM64 架构下能够使用 <a href="(http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html)[http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html]"><code>non-pointer isas</code></a> 技术，所以与之前相比 isa 字段不仅可以包含指向 Class 的信息，它还能利用多余比特位存储其它有效信息（例如，引用计数）。这里通过 AND 逻辑运算去除低位的冗余信息得到最终的 Class 的地址并将其存入 x13 寄存器中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0010 ldp    x10, x11, [x16, #0x10]</span><br></pre></td></tr></table></figure><p>这是整个 <code>objc_msgSend</code> 处理流程中我最喜欢的指令。该指令会将 Class 中的方法缓存哈希表加载到 x10 和 x11 两个寄存器中。<code>ldp</code> 指令会将有效的内存信息加载到该指令的前两个寄存器中，而第三个参数则对应该信息的内存地址。在该例中缓存哈希表地址为 x16 寄存器中地址偏移 16 后所处位置。缓存对象数据结构类似于：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述 <code>ldp</code> 指令中，x10 中保存了 <code>_buckets</code> 值，而 x11 寄存器的高 32 位保存的是 <code>_occupied</code> 低 32 位则保存了 <code>_mask</code> 。</p><p><code>_occupied</code> 表示哈希表中的元素的数量，在 <code>objc_msgSend</code> 处理过程中没有太大的作用。而 <code>_mask</code> 则相对重要：它将哈希表大小描述为了一个便于进行与操作的掩码。<code>_mask</code> 值为 2^n - 1 ，换句话说它的二进制表示将以一组 1 作为结尾，形如 000000001111111 。该值为查询 selector 的哈希表索引以及标记表尾的必要条件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0014 and    w12, w1, w11</span><br></pre></td></tr></table></figure><p>该指令用于计算 <code>_cmd</code> 所传递过来的 <code>selector</code> 在哈希表中的起始位置。因为 <code>_cmd</code> 保存在 x1 寄存器中，所以 w1 寄存器则包含了 <code>_cmd</code> 的低 32 位信息。而 w11 寄存器保存了上面提到的 <code>_mask</code> 信息。通过 AND 指令我们将这两个寄存器中数值<em>与操作</em>结果保存到 w12 寄存器中。计算结果相当于 <code>_cmd % table_size</code>  ，但是它却避免了模操作的昂贵开销。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0018 add    x12, x10, x12, lsl #4</span><br></pre></td></tr></table></figure><p>仅仅得到索引是不够，为了从表中加载数据，我们需要得到最终的实际地址。而这正是该指令的目的。因为哈希表的 bucket 都是 16 个比特位，所以这里先对 x12 寄存器中的索引值左移 4 位也就是乘以 16 ，然后再将其与表首地址相加后的确切 bucket 地址信息保存到 x12 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x001c ldp    x9, x17, [x12]</span><br></pre></td></tr></table></figure><p>再一次通过 <code>ldp</code> 指令，将上一步保存在 x12 寄存器中 bucket 对应的信息加载到 x9 和 x17 寄存器中。因为 bucket 由 selector 和 IMP 两部分构成，所以 x9 对应保存了 selector 信息而 x17 则保存了 IMP 信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0020 cmp    x9, x1</span><br><span class="line">0x0024 b.ne   0x2c</span><br></pre></td></tr></table></figure><p>该段指令会将 x9 寄存器中的内容和 x1 中的 <code>_cmd</code> 进行对比，如果它们不等则意味着 bucket 中不包含我们所操作的 selector ，并且在此时跳转到 0x2c 处执行对应的未匹配处理。如果相同的话则表示命中，继续执行下一条指令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0028 br    x17</span><br></pre></td></tr></table></figure><p>该指令为无条件跳转到 x17 寄存器所指位置，也就是跳转到 IMP 所指处执行具体实现代码。此时 <code>objc_msgSend</code> 处理流程中最快的路径已经结束。其余参数所做寄存器都没有被干扰，目标方法会接受传入的全部参数，一切行如直接调用目标函数。</p><p>在最理想的情形下，<code>objc_msgSend</code> 处理流程最快可以在 3 纳秒内执行完毕。</p><p>在介绍完理想的最快情形后，接下来我们需要关注其余几种情形。首先，我们来看下当方法未缓存时的处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x002c cbz    x9, __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><p>前面提到 x9 寄存器包含了加载后的 selector 信息。将寄存器中的信息与零进行比较，如果等于 0 的话就跳转到 <code>__objc_msgSend_uncached</code> 代码处。因为等于 0 就意味着 bucket 为空也就是说方法查询失败，selector 对应的方法没有被缓存到哈希表中。此时我们需要调用 C 语言代码进行更为复杂的处理，也就是 <code>__objc_msgSend_uncached</code> 。如果仅仅只是方法不匹配且 bucket 不为空的话，则需要继续进行方法查找。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0030 cmp    x12, x10</span><br><span class="line">0x0034 b.eq   0x40</span><br></pre></td></tr></table></figure><p>该指令将 x12 寄存器中的当前 bucket 地址与 x10 寄存器中的哈希表首地址进行比较。如果两者内容匹配上了，则我们从哈希表的末尾进行反向查询。虽然我还没弄明白此时为什么没有采用常见的正向遍历查询，但是有理由认为可能这样速度更快。</p><p>0x40 表示匹配后跳转目的地址。如果两者不匹配则继续执行下面的指令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0038 ldp    x9, x17, [x12, #-0x10]!</span><br></pre></td></tr></table></figure><p>再一次代码通过 ldp 指令加载缓存信息，只不过地址为距当前 bucket  偏移 -0x10 所指位置。该指令中的 ！符号表示寄存器回写操作，也就是说会使用计算后的结果更新 x12 寄存器。将其用数学方式表示就是：x12 -= 16，将 x12 中表示的地址前移 16 个单位。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x003c b      0x20</span><br></pre></td></tr></table></figure><p>加载新的 bucket 信息后，代码重新跳转到 0x20 处循环查询过程，直到出现下列情形：找到匹配项，bucket 为空，再次回到了哈希表的起始处。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0040 add    x12, x12, w11, uxtw #4</span><br></pre></td></tr></table></figure><p>当查询到匹配想后会触发该指令。此时 x12 寄存器为最新的 bucket 地址，而 w11 保存了包含哈希表大小的掩码值。该指令将 w11 左移 4 位后将两个值进行叠加得到哈希表尾地址，并将结果保存到 x12 寄存器中，然后接着恢复查询操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0044 ldp    x9, x17, [x12]</span><br></pre></td></tr></table></figure><p>该指令为加载新 bucket 信息到 x9，x17 寄存器中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0048 cmp    x9, x1</span><br><span class="line">0x004c b.ne   0x54</span><br><span class="line">0x0050 br     x17</span><br></pre></td></tr></table></figure><p>该段指令与前面的 0x0020 处的功能一致，只要寄存器内容匹配上了就跳转到对应 IMP 位置执行代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0054 cbz    x9, __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><p>同样的，若不匹配则执行与前面 0x002c 一样的处理流程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0058 cmp    x12, x10</span><br><span class="line">0x005c b.eq   0x68</span><br></pre></td></tr></table></figure><p>该指令与 0x0030 处一致，只不过如果此时 x12 寄存器内容依旧是哈希表首地址的话程序会跳转到 0x68 处进行处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0068 b      __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><p>这种情况一般不太容易发生，因为它会导致哈希表持续膨胀。此时哈希表的查询效率会下降而去潜在哈希碰撞的可能性会变高。</p><p>至于原因，源码中的注释是这些写的：</p><blockquote><p>Clone scanning loop to miss instead of hang when cache is corrupt. The slow path may detect any corruption and halt later.<br>当缓存损坏时，需要跳出上面的循环查询流程而不是进入挂起状态。 转而执行慢速路径流程去检测任何可能的损坏并终止代码执行。</p></blockquote><p>我怀疑这种情况很常见，但很显然苹果公司的员工已经看到内存损坏会让哈希表充满无效内容所以在此处跳转到 C 代码中进行错误诊断。</p><p>此项检查的存在应该将对未损坏的缓存的影响降低到最小。去除该检查，原来的循环处理流程可以被重用，这会节省一点指令缓存空间。 无论如何，该处理程序器并不是常见的情况。 只会在哈希表的开始位置查询到所需的选择子或者发生了哈希碰撞时才会被调用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0060 ldp    x9, x17, [x12, #-0x10]!</span><br><span class="line">0x0064 b      0x48</span><br></pre></td></tr></table></figure><p>该段指令与之前功能一致，加载新 bucket 信息到 x9，x17 寄存器中。更新 x12 中的地址，并跳转到 0x48 处重复查找流程。</p><p>objc_msgSend 的主要处理流程到此告一段落，剩下 Tagged Pointer 和 <code>nil</code> 两个特殊情形的处理。</p><h2 id="标记指针的处理"><a href="#标记指针的处理" class="headerlink" title="标记指针的处理"></a>标记指针的处理</h2><p>我们回到第一组汇编指令的跳转处来讲解标记指针（<code>Tagged Pointer</code>）的处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x006c b.eq    0xa4</span><br></pre></td></tr></table></figure><p>当参数 <em>self</em> 不大于 0 时，该指令就会被触发。其中小于 0 对应标记指针，而等于零则对应 <code>nil</code> 。这两种情形有各自的处理流程，所以第一步就是要区分出到底是哪种情形。若为 <em>nil</em> 情形则跳转到 0xa4 处进行处理，否则继续执行。</p><p>在继续讲解之前，先简单讨论下标记指针工作原理。 标记指针支持多个类。其中高 4 位（在 ARM64 上）指明了“对象”的类信息，本质上就是 Tagged Pointer 的 isa 。当然 4 个比特位不足以容纳一个类指针，实际上这些信息都被存在了一张特殊表中。我们可以以高 4 位的值为索引去表中查询真正的类信息。</p><p>这还不是全部，标记指针（至少在 ARM64 上）支持拓展类。当高 4 位全为 1 时，紧接着的 8 个比特位将被用作拓展类表中的索引值。 这样在运行时支持更多的标记指针类，不过代价就是能存储的有效信息会变少。</p><p>下面继续指令的执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0070 mov    x10, #-0x1000000000000000</span><br></pre></td></tr></table></figure><p>该指令将一个整形值（高 4 位为 1 ，其余全为 0）写入 x10 寄存器中。这将用作下一步提取 <code>self</code> 标记位的掩码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0074 cmp    x0, x10</span><br><span class="line">0x0078 b.hs   0x90</span><br></pre></td></tr></table></figure><p>这一步时检查拓展标记指针内容。如果 <code>self</code> 大于或者等于 x10 中的值，则意味这 <code>self</code> 的高 4 位也全部为 1 。此时代码会跳转到 0x90 处理拓展类部分的内容，否则就继续执行下面的指令去主标记指针表中的查询类信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x007c adrp   x10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class="line">0x0080 add    x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br></pre></td></tr></table></figure><p>该段指令主要就是加载 <code>_objc_debug_taggedpointer_classes@PAGE</code>  所指的主标记指针表地址。因为 ARM64 上的指针是 64 位宽，而指令只有 32 位宽，所以需要采用类 RISC 标准技术通过两个指令来加载符号地址。</p><p>x86 架构则不存在该问题，因为它采用可变长度指令集。它可以通过一个 10 字节长的指令处理上面的问题：2 个字节用来区分具体指令和寄存器，剩下 8 个字节用来保存指针地址。</p><p>而在定长指令集机器上，我们只能通过一组命令加以应对。例如，上例就是通过两条指令实现 64 位指针地址的加载操作。adrp 指令加载高 32 位信息然后再通过 add 指令将其与低 32 位进行求和。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0084 lsr    x11, x0, #60</span><br></pre></td></tr></table></figure><p>因为索引值保存在 x0 的高 4 位中，所以该指令将 x0 进行右移 60 位取出对应的索引值（取值范围为 0-15）并保存到 x11 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0088 ldr    x16, [x10, x11, lsl #3]</span><br></pre></td></tr></table></figure><p>根据索引值获取标记指针的类信息并保存到 x16 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x008c b      0x10</span><br></pre></td></tr></table></figure><p>获得类信息后程序会无条件跳回 0x10 处，并复用主分支中的代码进行方法查询处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0090 adrp   x10, _objc_debug_taggedpointer_ext_classes@PAGE</span><br><span class="line">0x0094 add    x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</span><br></pre></td></tr></table></figure><p>该段指令与前面加载主标记指针表功能一样，只不过此时它用于处理前面提到的拓展表分支。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0098 ubfx   x11, x0, #52, #8</span><br></pre></td></tr></table></figure><p>该指令只要是取出 <em>self</em> 中从第 52 位开始的 8 位信息作为拓展表的索引值，并将其保存到 x11 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x009c ldr    x16, [x10, x11, lsl #3]</span><br></pre></td></tr></table></figure><p>再一次，我们将获得的类信息加载到 x16 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00a0 b      0x10</span><br></pre></td></tr></table></figure><p>最后，我们同样跳回到 0x10 处。</p><p>接下来，我们来看 <code>nil</code> 情形的处理过程。</p><h2 id="nil-的处理"><a href="#nil-的处理" class="headerlink" title="nil 的处理"></a><code>nil</code> 的处理</h2><p>作为最后一个特殊情况，下面就是 <code>nil</code> 情形下被执行的所有指令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00a4 mov    x1, #0x0</span><br><span class="line">0x00a8 movi   d0, #0000000000000000</span><br><span class="line">0x00ac movi   d1, #0000000000000000</span><br><span class="line">0x00b0 movi   d2, #0000000000000000</span><br><span class="line">0x00b4 movi   d3, #0000000000000000</span><br><span class="line">0x00b8 ret</span><br></pre></td></tr></table></figure><p><code>nil</code> 情形的处理与其他情形完全不同，它不会进行类查询和方法派发，而仅仅返回 0 给调用者。</p><p>该段指令最麻烦的事情是 <code>objc_msgSend</code> 不知道具体的返回值类型。是整型值、浮点值、亦或者是什么都不返回。</p><p>幸运的是，所有用于设置返回值的寄存器都能被安全覆写，即使此次调用过程不会使用到。整型返回值被保存在 x0 和 x1 中，而浮点值则保存在向量寄存器 v0 - v3 中。同时使用多个寄存器可以返回一个小型结构体类型返回值。</p><p>在处理 <code>nil</code> 情形时，上诉指令会将 x1 以及 v0 - v3 中的值全部清空并设置为 0。其中 d0 - d3 分别对应向量寄存器 v0 - v3 的后半部分，通过将其设置为 0 清除了后半部分然后在通过 movi 清除所有的寄存器内容。清空返回值寄存器后，控制权将重新回到调用方。</p><p>如果返回值为比较大的结构体，那么寄存器可能就变的不够用了。此时就需要调用者做出一些配合。调用者会在一开始为该结构体分配一块内存，然后将其地址提前写入到 x8 寄存器中。在设置返回值的时候，直接往该地址中写数据即可。<br>因为该内存大小对 <code>objc_msgSend</code> 是透明的，因此不能对其进行清空操作。取而代之的操作就是在调用 <code>objc_msgSend</code>  之前编译器会将其设置为 0 。</p><p>以上就是 <code>nil</code> 情形的处理，<code>objc_msgSend</code> 流程到此也宣告结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>深入框架底层还是很有趣的，而 <code>objc_msgSend</code>  就像一件艺术品，值得细细玩味。</p><p>今天的内容到此结束，下次再会为大家带来一些更好的内容。Friday Q&amp;A 很多内容都是由读者驱动而来，所以欢迎大家在下面积极发言。</p><h3 id="汇编指令校对者注"><a href="#汇编指令校对者注" class="headerlink" title="汇编指令校对者注"></a>汇编指令校对者注</h3><ol><li><code>#0x0</code>：“#”修饰的数字表示立即数，可简单理解为数值，而非地址：</li><li><code>b</code> ：跳转指令，b.le 指比较结果小于等于的时候跳转至某内存地址；</li><li><code>ldr</code> ：从内存中读取数据到寄存器；</li><li><code>and</code>：arm 的 <code>and</code> 指令，需要3个操作数，例如 <code>AND R0，R0，#3</code> 是将 R0 寄存器的值与数字3（0x0000003）逻辑与，将结果存储为 R0 寄存器</li><li><code>add</code>：<code>ADD[con][S] Rd,Rn,operand</code>，将 operand 数据与 Rn 的值相加，结果保存到 Rd 寄存器；</li><li><code>lsl</code>： 逻辑左移指令，可以结合 <code>add</code> 指令一起使用，如<code>ADDS R0,R1,R2,LSL#2</code>，将 R2 寄存器左移 2 位，接着 R1 和 R2 值相加，将结果存储到 R0 中；</li><li><code>cbz</code>：c对应compare，b就是上面的跳转，z对应0 zero，因此这条命令当比较结果为零（Zero）就跳转至之后的指令；</li><li><code>UXTW</code>： 32 位的逻辑左移指令，更多请见<a href="http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20140407/212142.html" target="_blank" rel="noopener">[llvm] r205861</a>;</li><li><code>LSR</code>： 逻辑右移；</li><li><code>UBFX</code>：<code>UBFX{cond} Rd, Rn, #lsb, #width</code> 从一个寄存器中提取位域，cond —可选，条件码 ；Rd — 目标寄存器 ；Rn — 源寄存器 ；lsb —位域的最低有效位的位置，范围是 0 - 31； width — 位域的宽度，范围是1到 32-lsb</li></ol><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-06-30&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;BigNerdCoding&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;，&lt;a href=&quot;http://codebuild.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shanks&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;很高兴，我又回来了。在刚刚过去的 WWDC 期间，我在 CocoaConf Next Door 做个一个关于剖析 ARM64 上 &lt;code&gt;objc_msgSend&lt;/code&gt; 运行流程的发言。现在我将整理后的内容重新发布到 Friday Q&amp;amp;A 上。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 4 弱引用实现</title>
    <link href="https://swift.gg/2018/08/02/swift-4-weak-references/"/>
    <id>https://swift.gg/2018/08/02/swift-4-weak-references/</id>
    <published>2018-08-02T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2017-09-22-swift-4-weak-references.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-09-22<br>译者：<a href="undefined">BigNerdCoding</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Swift 开源不久我就写了篇关于弱引用实现的<a href="https://mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html" target="_blank" rel="noopener">文章</a>。时移势易，Swift 4 中的弱引用实现已经与旧文不一致了。应 Guillaume Lessard 建议，今天我将会介绍新版实现，并比较其与老版的区别。</p><a id="more"></a><h2 id="旧实现"><a href="#旧实现" class="headerlink" title="旧实现"></a>旧实现</h2><p>考虑到有些人可能已经忘记了旧实现并且不愿重看前面的文章，下面我们就一起简要的回顾下之前的实现方式。</p><p>在旧实现中，Swift 对象有两个引用计数：强引用计数和弱引用计数。当强引用计数为 0 而弱引用计数不为 0 时，对象会被销毁，但是内存并不会被立即释放。内存中会保留弱引用指向的僵尸对象。</p><p>在加载弱引用时，运行时会对引用对象进行检查。如果是僵尸对象，则会对弱引用计数进行递减操作。一旦弱引用计数为 0，对象内存将会被释放。换句话说，僵尸对象的所有弱引用被加载访问后僵尸对象才会真正被清空。</p><p>虽然我喜欢该实现的简单性，但它有一些缺陷。其中一个就是，僵尸对象可能会长时间停留在内存中。对于那些拥有很多实例的类（因为它们包含许多属性，或使用类似 ManagedBuffer 分配了内联的额外内存），这会造成严重的内存浪费。</p><p>另外，在写完旧文后我还发现：对于并发读取，该实现是非线程安全的。虽然已经有补丁修复了这个问题，但从相关讨论可以看出，开发者希望找到一个更好的实现方式，避免出现类似问题。</p><h2 id="对象数据"><a href="#对象数据" class="headerlink" title="对象数据"></a>对象数据</h2><p>Swift 中的 “对象” 其实是由一组数据构成。</p><p>首先，最容易想到的就是源码中声明的那些可直接访问的存储属性。</p><p>其次就是对象的类信息。该信息主要被用于动态派发和 <strong>type(of: )</strong> 内置函数。虽然动态派发和 <strong>type(of: )</strong> 内置函数从侧面暗示了它的存在，但是实际上该信息大多是被隐藏的。</p><p>第三种就是各种引用计数信息。除非你进行一些非常规操作，例如，读取对象的原始内存或说服编译器让你调用 CFGetRetainCount，否则这些信息对你来说是完全透明不可见的。</p><p>第四种就是 Objective-C 运行时存储的辅助信息，例如 Objective-C 弱引用列表（Objective-C 的弱引用实现是通过单独追踪每个弱引用）和关联对象。</p><p>那么这些信息最终都存储在哪里呢？</p><p>在 Objective-C 中，类信息和存储属性（例如，实例变量）内联在对象内存中。其中类信息位于指针所在第一块内存，其后才是实例变量。辅助类信息则保存在外部表中。当你需要操作关联对象时，运行时机制会使用内存地址去一个大的哈希表中查找它。为了实现多线程安全，该表在操作时会加锁，所以存在一定程度访问速度问题。引用计数的保存位置，则取决于具体操作系统版本和 CPU 架构，它有时位于对象内存中，而有时又存储在外部表中。</p><p>在 Swift 旧有实现中，类信息，引用计数和存储属性全部内联在对象内存中。而辅助信息则依旧存储在单独的外部表中。</p><p>下面我们不妨将具体实现代码先放一边，仔细思考下：理论上应该如何存储这些信息呢？</p><p>每种存储方案都有利弊。将数据存储在对象内存中虽然能提高访问速度，但是会让内存空间变得吃紧。与之相对，外部存储方案则是通过牺牲速度来换空间。</p><p>Objective-C 传统存储方案不将对象引用计数保存在内存中，部分原因正是基于此。因为在 Objective-C 引入引用计数概念时，设备的性能远不如现在，而且内存容量也极为有限。Objective-C 程序中大多数对象只有一个所有者，即引用计数为 1 。此时在对象内存中腾出 4 个字节空间存储该引用计数 1 是很浪费的。而外部表方案中，数值 1 可以通过缺省默认值方式表示从而减少内存消耗。</p><p>每次进行动态方法派发时都需要对象的类信息，所有作为最常用信息，类信息应该直接保存在内存中，存在外部表中是不合适的。</p><p>而实例变量这类存储属性在编译期就确定了，而且有现实的访问速度需求，所以存在对象内存中也是最合理的设计。另外，当对象没有存储属性时，系统不会为其分配内存空间也就不存在浪费问题。</p><p>每个对象都需要保留引用计数。虽然不是每个对象的引用计数都为 1，但它依旧是一个相对常见的情形，加上现在内存足够，它可以直接保存在内存中。</p><p>大多数对象都不会有弱引用或关联对象数据，所有它们应该保存在外部以期节约内存空间。</p><p>对于那些有弱引用或关联对象数据的对象来说，访问速度确实不够快但这是合理的权衡结果。那么问题来了，该旧实现有没有改进空间和可行方法呢？</p><h2 id="Side-Tables"><a href="#Side-Tables" class="headerlink" title="Side Tables"></a>Side Tables</h2><p>在 Swift 弱引用的新版实现代码中，引入了 <em>side tables</em> 概念来改进上诉缺陷。</p><p>Side table 本质就是用于保存额外信息的单独内存块，并且它还是可选的。也就是说，对于那些无需保存额外信息的对象来说并没有多余开销。</p><p>每个对象都有一个指向其对应 side table 的指针，而 side table 也有一个指针指向该对象。另外，side table 可以存储关联的对象数据等其他信息。</p><p>为了避免 side table 带来的 8 字节空间开销，Swift 做了一个漂亮的优化。通常内存中的第一个字（Word）是类信息，第二个字则是引用计数。当对象存在 side table 需求时，第二个字将保存指向 side table 的指针。因为引用计数是必要信息，所以此时会将引用计数保存到 side table 中。至于程序运行时到底是哪种情形，则由该块内存中的一个标志位进行区分。</p><p>通过将弱引用从指向对象本身改为指向 side table ，Swift 得以在保留原有引用计数设计的同时修复了旧设计中的缺陷。</p><p>因为 side table 比较小并且弱引用不再指向对象本身，这样之前大型僵尸对象的内存空间将能立即释放从而降低了内存浪费。同时该实现也让线程安全问题变得更易解决：不再需要提前将弱引用置空。因为 side table 比较小，指向它的弱引用可以持续保留，直到这些引用自身被覆写或销毁。</p><p>这里需要提醒一下，当前 side table 实现中只保存引用计数和指向原始对象的指针。类似保存关联对象等用途只是一个猜想和假设。因为 Swift 还没有内建关联对象功能，而 Objective-C API 仍在使用全局表。</p><p>该技术还有不少潜力可挖，也许在不久的将来能看到其应用在关联对象等内容上。我希望它能为类拓展中的存储属性和其他有趣的功能打开一扇新窗。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>因为 Swift 已经开源，所有相关代码都能直接访问。</p><p>关于 side table 的大部分代码都在 <a href="https://github.com/apple/swift/blob/c262440e70896299118a0a050c8a834e1270b606/stdlib/public/SwiftShims/RefCount.h" target="_blank" rel="noopener">stdlib/public/SwiftShims/RefCount.h</a> 。</p><p>高层级的弱引用 API 以及相关注释都在 <a href="https://github.com/apple/swift/blob/c262440e70896299118a0a050c8a834e1270b606/stdlib/public/runtime/WeakReference.h" target="_blank" rel="noopener">swift/stdlib/public/runtime/WeakReference.h</a>。</p><p>更多关于堆对象的实现和注释在 <a href="https://github.com/apple/swift/blob/c262440e70896299118a0a050c8a834e1270b606/stdlib/public/runtime/HeapObject.cpp" target="_blank" rel="noopener">stdlib/public/runtime/HeapObject.cpp</a>。</p><p>上述链接其实带着版本信息，以便后面的读者也能找到本文内容当时的上下文。如果你想看最新的实现代码，你在点击链接后切换到 master 分支即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>弱引用是一个重要的语言特性。Swift 最初的实现方式非常聪明，也有一些不错的特性，但是同时也存在一些问题。通过引入 side table，Swift 开发工程师在保留原有特点的同时还解决了这些缺陷。Side table 的实现也为将来更多新特性创造了更多可能性。</p><p>今天内容到此为止。下次我还会带来与编程和代码相关的新内容。当然你也可以将你感兴趣的话题<a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发送给我</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2017-09-22-swift-4-weak-references.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-09-22&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;BigNerdCoding&lt;/a&gt;；校对：&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/Cee&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cee&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 开源不久我就写了篇关于弱引用实现的&lt;a href=&quot;https://mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;。时移势易，Swift 4 中的弱引用实现已经与旧文不一致了。应 Guillaume Lessard 建议，今天我将会介绍新版实现，并比较其与老版的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="Swift 入门" scheme="https://swift.gg/tags/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>构建一个 @synchronized</title>
    <link href="https://swift.gg/2018/07/30/friday-qa-2015-02-20-lets-build-synchronized/"/>
    <id>https://swift.gg/2018/07/30/friday-qa-2015-02-20-lets-build-synchronized/</id>
    <published>2018-07-30T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-02-20-lets-build-synchronized.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-02-20<br>译者：<a href="undefined">Sunnyyoung</a>；校对：<a href="http://hulizhen.me" target="_blank" rel="noopener">智多芯</a>；定稿：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>上一篇文章讲了线程安全，今天这篇最新一期的 Let’s Build 我会探讨一下如何实现 Objective-C 中的 <code>@synchronized</code>。本文基于 Swift 实现，Objective-C 版本大体上也差不多。</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p><code>@synchronized</code> 在 Objective-C 中是一种控制结构。它接受一个对象指针作为参数，后面跟着一段代码块。对象指针充当锁，在任何时候 <code>@synchronized</code> 代码块中只允许有一个线程使用该对象指针。</p><p>这是一种使用锁进行多线程编程的简单方法。举个例子，你可以使用 <code>NSLock</code> 来保护对 NSMutableArray 的操作：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array;</span><br><span class="line"><span class="built_in">NSLock</span> *arrayLock;</span><br><span class="line"></span><br><span class="line">[arrayLock lock];</span><br><span class="line">[array addObject: obj];</span><br><span class="line">[arrayLock unlock];</span><br></pre></td></tr></table></figure><p>也可以使用 <code>@synchronized</code> 来将数组本身加锁：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(array) &#123;</span><br><span class="line">    [array addObject: obj];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我个人更喜欢显式的锁，这样做既可以使事情更清楚，<code>@synchronized</code> 的性能没那么好，原因如下图所示。但它（<code>@synchronized</code>）使用很方便，不管怎样，实现起来都很有意思。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Swift 版本的 <code>@synchronized</code> 是一个函数。它接受一个对象和一个闭包，并使用持有的锁调用闭包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">synchronized</span><span class="params">(obj: AnyObject, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是，如何将任意对象变成锁？</p><p>在一个理想的世界里（从实现这个函数的角度来看），每个对象都会为锁留出一些额外空间。在这个额外的小空间里 <code>synchronized</code> 可以使用适当的 <code>lock</code> 和 <code>unlock</code> 方法。然而实际上并没有这种额外空间。这可能是件好事，因为这会增大对象占用的内存空间，但是大多数对象永远都不会用到这个特性。</p><p>另一种方法是用一张表来记录对象到锁的映射。<code>synchronized</code> 可以查找表中的锁，然后执行 <code>lock</code> 和 <code>unlock</code> 操作。这种方法的问题是表本身需要保证线程安全，它要么需要自己的锁，要么需要某种特殊的无锁数据结构。为表单独设置一个锁要容易得多。</p><p>为了防止锁不断累积常驻，表需要跟踪锁的使用情况，并在不再需要锁的时候销毁或者复用。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>要实现将对象映射到锁的表，<code>NSMapTable</code> 非常合适。它可以把原始对象的地址设置成键（key），并且可以保存对键（key）和值（value）的弱引用，从而允许系统自动回收未被使用的锁。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> locksTable = <span class="type">NSMapTable</span>.weakToWeakObjectsMapTable()</span><br></pre></td></tr></table></figure><p>表中存储的对象是 <code>NSRecursiveLock</code> 实例。因为它是一个类，所以可以直接用在 <code>NSMapTable</code> 中，这点 <code>pthread_mutex_t</code> 就做不到。<code>@synchronized</code> 支持递归语义，我们的实现一样支持。</p><p>表本身也需要一个锁。自旋锁（spinlock）在这种情况下很适合使用，因为对表的访问是短暂的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> locksTableLock = <span class="type">OS_SPINLOCK_INIT</span></span><br></pre></td></tr></table></figure><p>有了这个表，我们就可以实现以下方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">synchronized</span><span class="params">(obj: AnyObject, f: Void -&gt; Void)</span></span> &#123;</span><br></pre></td></tr></table></figure><p>它所做的第一件事就是在 <code>locksTable</code> 中找出与 <code>obj</code> 对应的锁，执行操作之前必须持有 <code>locksTableLock</code> 锁：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">OSSpinLockLock</span>(&amp;locksTableLock)</span><br><span class="line"><span class="keyword">var</span> lock = locksTable.objectForKey(obj) <span class="keyword">as</span>! <span class="type">NSRecursiveLock</span>?</span><br></pre></td></tr></table></figure><p>如果表中没有找到对应锁，则创建一个新锁并保存到表中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> lock == <span class="literal">nil</span> &#123;</span><br><span class="line">    lock = <span class="type">NSRecursiveLock</span>()</span><br><span class="line">    locksTable.setObject(lock!, forKey: obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了锁之后主表锁就可以释放了。为了避免死锁这必须要在调用 <code>f</code> 之前完成：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">OSSpinLockUnlock</span>(&amp;locksTableLock)</span><br></pre></td></tr></table></figure><p>现在我们可以调用 <code>f</code> 了，在调用前后分别进行加锁和解锁操作：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    lock!.lock()</span><br><span class="line">    f()</span><br><span class="line">    lock!.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对比苹果的方案"><a href="#对比苹果的方案" class="headerlink" title="对比苹果的方案"></a>对比苹果的方案</h2><p>苹果实现 <code>@synchronized</code> 的方案可以在 Objective-C runtime 源码中找到:</p><p><a href="http://www.opensource.apple.com/source/objc4/objc4-646/runtime/objc-sync.mm" target="_blank" rel="noopener">http://www.opensource.apple.com/source/objc4/objc4-646/runtime/objc-sync.mm</a></p><p>它的主要目标是性能，因此不像上面那个玩具般的例子那么简单。对比它们之间有什么异同是一件非常有趣的事。</p><p>基本概念是相同的。存在一个全局表，它将对象指针映射到锁，然后该锁在 <code>@synchronized</code> 代码块前后进行加锁解锁操作。</p><p>对于底层的锁对象，Apple 使用配置为递归锁的 <code>pthread_mutex_t</code>。<code>NSRecursiveLock</code> 内部很可能也使用了 <code>pthread_mutex_t</code>，直接使用就省去了中间环节，并避免了运行时对 Foundation 的依赖。</p><p>表本身的实现是一个链表而不是一个哈希表。常见的情况是在任何给定的时间里只存在少数几个锁，所以链表的性能表现很不错，可能比哈希表性能更好。每个线程缓存了最近在当前线程查找的锁，从而进一步提高性能。</p><p>苹果的实现并不是只有一个全局表，而是在一个数组里保存了 16 个表。对象根据地址映射到不同的表，这减少了不同对象 <code>@synchronized</code> 操作导致的不必要的资源竞争，因为它们很可能使用的是两个不同的全局表。</p><p>苹果的实现没有使用弱指针引用（这会大量增加额外开销），而是为每个锁保留一个内部的引用计数。当引用计数达到零时，该锁可以给新对象重新使用。未使用的锁不会被销毁，但复用意味着在任何时间锁的总数都不能超过激活锁的数量，也就是说锁的数量不随着新对象的创建无限制增长。</p><p>苹果的实现方案非常巧妙，性能也不错。但与使用单独的显式锁相比，它仍然会带来一些不可避免的额外开销。尤其是：</p><ol><li>如果不相关的对象刚好被分配到同一个全局表中，那么它们仍然可能存在资源竞争。</li><li>通常情况下在线程缓存中查找一个不存在的锁时，必须获取并释放一个自旋锁。</li><li>必须做更多的工作来查找全局表中对象的锁。</li><li>即使不需要，每个加锁/解锁周期都会产生递归语义方面的开销。</li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>@synchronized</code> 是一个有趣的语言结构，实现起来并不简单。它的作用是实现线程安全，但它的实现本身也需要同步操作来保证线程安全。我们使用全局锁来保护对锁表的访问，苹果的实现中则使用不同的技巧来提高性能。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-02-20-lets-build-synchronized.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2015-02-20&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;Sunnyyoung&lt;/a&gt;；校对：&lt;a href=&quot;http://hulizhen.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;智多芯&lt;/a&gt;；定稿：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;上一篇文章讲了线程安全，今天这篇最新一期的 Let’s Build 我会探讨一下如何实现 Objective-C 中的 &lt;code&gt;@synchronized&lt;/code&gt;。本文基于 Swift 实现，Objective-C 版本大体上也差不多。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Block 形式的通知中心观察者是否需要手动注销</title>
    <link href="https://swift.gg/2018/07/26/notificationcenter-removeobserver/"/>
    <id>https://swift.gg/2018/07/26/notificationcenter-removeobserver/</id>
    <published>2018-07-26T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2018/01/notificationcenter-removeobserver/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-01-05<br>译者：<a href="undefined">BigNerdCoding</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>简单回答：需要 （在 iOS 11.2 上验证过）</p><p>几周之前，我在 twitter 上提出了一个<a href="https://twitter.com/olebegemann/status/938085544780877824" target="_blank" rel="noopener">问题</a>：</p><blockquote><p>在 iOS 11 中是否还需要手动移除基于 block 形式的通知观察者？苹果开发文档中比较模糊。<a href="https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver" target="_blank" rel="noopener"><code>addObserver(forName:object:queue:using:)</code></a> 中说需要，而 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver" target="_blank" rel="noopener"><code>removeObserver(_:)</code></a> 中又表明 iOS 9 之后都不在需要。</p></blockquote><p>虽然我没有统计准确的数字，但是大致看来持不同意见的人差不多五五开。</p><p>所以下面我们就来具体测试验证一下。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>首先，我所说的基于 block 的接口声明是 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver" target="_blank" rel="noopener"><code>NotificationCenter.addObserver(forName: object: queue: using:)</code></a> 。使用该 API 我们在通知中心注册了一个函数用于处理对应的通知，并且得到一个表示观察者的返回值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> observation: <span class="type">Any</span>? = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        observation = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(</span><br><span class="line">            forName: myNotification, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123; notification <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Received <span class="subst">\(notification.name.rawValue)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是：当代码中的返回值 <em>observation</em> 销毁时（例如，MyObserver 实例对象析构了），通知中心会不会自动忽略并停止调用处理函数呢？毕竟基于 <a href="https://developer.apple.com/documentation/swift/key_path_expressions" target="_blank" rel="noopener">KeyPath</a> 的 <a href="http://skyefreeman.io/programming/2017/06/28/kvo-in-ios11.html" target="_blank" rel="noopener">KVO 新接口</a>当观察者销毁后，响应处理不再被调用，所以通知可能也被理解成是这样进行的。</p><p>或者，我们依旧需要手动调用 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver" target="_blank" rel="noopener"><code>NotificationCenter.removeObserver(_:)</code></a>（例如，在 MyObserver 的析构函数 <strong>deinit</strong> 手动注销）？</p><h2 id="文档中的说明"><a href="#文档中的说明" class="headerlink" title="文档中的说明"></a>文档中的说明</h2><p>基于 selector 形式的观察接口 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1415360-addobserver" target="_blank" rel="noopener"><code>addObserver(_:selector:name:object:)</code></a> 的手动注销操作在 iOS 9 和 OSX 10.11 之后已经变成可选了。然而在 <a href="https://developer.apple.com/library/archive/releasenotes/Foundation/RN-FoundationOlderNotes/index.html#10_11NotificationCenter" target="_blank" rel="noopener">Foundation 发布注意事项</a>中明确表明 Block 形式的接口依然需要进行手动注销操作。</p><blockquote><p>通过 <code>-[NSNotificationCenter addObserverForName:object:queue:usingBlock:_]</code> 形式添加的block类型观察者在无用时依然需要进行注销操作，因为系统会保留对该观察者的强引用。</p></blockquote><p>该文档发布之后是否存在新变化呢？</p><p>在 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver" target="_blank" rel="noopener"><code>addObserver(forName:object:queue:using:)</code></a> 文档说明部分也明确指出了注销操作是必要的：</p><blockquote><p>所有通过 <code>addObserver(forName:object:queue:using:)</code> 创建的观察者在析构之前都需要调用 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver" target="_blank" rel="noopener"><code>removeObserver(_:)</code></a> 或者 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1407263-removeobserver" target="_blank" rel="noopener"><code>removeObserver(_:name:object:)</code></a> 进行注销操作。</p></blockquote><p>然而 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver" target="_blank" rel="noopener"><code>removeObserver(_:)</code></a> 文档说明处似乎与之相反：</p><blockquote><p>如果你的 APP 运行在 iOS 9 或者 macOS 10.11 及最新的版本上的话则不需要注销这个观察者在它的析构方法。</p></blockquote><p>该文档中并没有对 selector 或者 block 进行区分说明，也就是说该操作同时适用于两者。</p><h2 id="进行测试验证"><a href="#进行测试验证" class="headerlink" title="进行测试验证"></a>进行测试验证</h2><p>通过我写的<a href="https://github.com/ole/NotificationUnregistering" target="_blank" rel="noopener">测试应用</a>，你可以得到验证上诉问题（通过 Xcode 的终端输出）。</p><p>下面是我发现的：</p><ul><li>基于block 形式的观察者依然需要进行手动注销操作（即使在 iOS 11.2 上），所以 <code>removeObserver (_:)</code> 文档存在明显的误导。</li><li>如果没有进行注销操作的话，那么 block 就会被一直持有而且依然能够被相关通知触发执行。此时该行为对 APP 的潜在威胁取决于 block 内部持有的对象。</li><li>即使你在 <em>deinit</em> 中调用了注销操作，你依旧需要注意 block 中不能捕获 self 引用，否则会造成循环引用此时 <em>deinit</em> 也永远不会得到执行。</li></ul><h2 id="自动注销"><a href="#自动注销" class="headerlink" title="自动注销"></a>自动注销</h2><p>处理这个问题最好的方式是什么呢？我的建议是：对观察对象进行一次封装。该封装类型的指责就是保持观察者对象并且在析构函数中自动将其注销。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Wraps the observer token received from </span></span><br><span class="line"><span class="comment">/// NotificationCenter.addObserver(forName:object:queue:using:)</span></span><br><span class="line"><span class="comment">/// and unregisters it in deinit.</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationToken</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> notificationCenter: <span class="type">NotificationCenter</span></span><br><span class="line">    <span class="keyword">let</span> token: <span class="type">Any</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(notificationCenter: <span class="type">NotificationCenter</span> = .<span class="keyword">default</span>, token: <span class="type">Any</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.notificationCenter = notificationCenter</span><br><span class="line">        <span class="keyword">self</span>.token = token</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        notificationCenter.removeObserver(token)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过封装处理，我们将观察者的生命周期和该类型实例进行了绑定。接下来我们只需要将该封装类型实例通过私有属性进行保存，那么其持有者就会 <em>deinit</em> 触发时销毁该封装实例紧接着销毁观察者实例对象。这样就不需要在代码中对其进行手动注销操作了。另外我们还可以将该实例声明为 <code>Optional &lt;Notification​Token&gt;</code> ，这样通过将其设置为 nil 也能进行手动注销操作。该模式被称为<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" target="_blank" rel="noopener"> <strong>资源获取即初始化</strong> （RAII）</a>。</p><p>接下来让我们为 <code>NotificationCenter</code> 编写一个便利点的方法，它为我们承担了包装观察接口的任务。 </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NotificationCenter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Convenience wrapper for addObserver(forName:object:queue:using:)</span></span><br><span class="line">    <span class="comment">/// that returns our custom NotificationToken.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">observe</span><span class="params">(name: NSNotification.Name?, object obj: Any?, </span></span></span><br><span class="line"><span class="function"><span class="params">    queue: OperationQueue?, using block: @escaping <span class="params">(Notification)</span></span></span> -&gt; ())</span><br><span class="line">    -&gt; <span class="type">NotificationToken</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> token = addObserver(forName: name, object: obj, queue: queue, using: block)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NotificationToken</span>(notificationCenter: <span class="keyword">self</span>, token: token)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此时将原有的 <code>addObserver(forName:​object:​queue:​using:)</code> 替换为新 API ，并将得到 <em>NotificationToken</em> 实例通过属性保存的话，你将不再需要手动注销操作了。</p><p>Chris 和 Florian 也在 <a href="https://talk.objc.io/episodes/S01E27-typed-notifications-part-1" target="_blank" rel="noopener"><strong>Swift Talk episode 27: Typed Notifications</strong></a> 中提到过该技术，我向你强烈的推荐它。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2018/01/notificationcenter-removeobserver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-01-05&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;BigNerdCoding&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;简单回答：需要 （在 iOS 11.2 上验证过）&lt;/p&gt;
&lt;p&gt;几周之前，我在 twitter 上提出了一个&lt;a href=&quot;https://twitter.com/olebegemann/status/938085544780877824&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;问题&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 iOS 11 中是否还需要手动移除基于 block 形式的通知观察者？苹果开发文档中比较模糊。&lt;a href=&quot;https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;addObserver(forName:object:queue:using:)&lt;/code&gt;&lt;/a&gt; 中说需要，而 &lt;a href=&quot;https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;removeObserver(_:)&lt;/code&gt;&lt;/a&gt; 中又表明 iOS 9 之后都不在需要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然我没有统计准确的数字，但是大致看来持不同意见的人差不多五五开。&lt;/p&gt;
&lt;p&gt;所以下面我们就来具体测试验证一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>在 Swift 中使用马尔可夫链生成文本</title>
    <link href="https://swift.gg/2018/07/23/friday-qa-2018-04-27-generating-text-with-markov-chains-in-swift/"/>
    <id>https://swift.gg/2018/07/23/friday-qa-2018-04-27-generating-text-with-markov-chains-in-swift/</id>
    <published>2018-07-23T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2018-04-27-generating-text-with-markov-chains-in-swift.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-28<br>译者：<a href="http://wuqiuhao.github.io" target="_blank" rel="noopener">Hale</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/u/2d46948e84e3" target="_blank" rel="noopener">mmoaay</a>，<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>马尔可夫链可用于快速生成真实但无意义的文本。今天，我将使用这种技术来创建一个基于这篇博客内容的文本生成器。这个灵感来源于读者 Jordan Pittman。</p><a id="more"></a><h2 id="马尔可夫链"><a href="#马尔可夫链" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h2><p>理论上讲，马尔可夫链是一种状态机，每一个状态转换都有一个与之相关的概率。你可以选择一个起始状态，然后随机地转换成其他状态，通过转移概率来加权，直到到达一个终止状态。</p><p>马尔可夫链有着<a href="https://en.wikipedia.org/wiki/Markov_chain#Steady-state_analysis_and_limiting_distributions" target="_blank" rel="noopener">广泛的应用</a>，但最有趣的是用于文本生成。在本文生成领域，每个状态是文本的一部分，通常是一个单词。状态和转换是由一些语料库生成的，然后遍历整个链并为每个状态输出单词来生成文本。这样生成的文本通常没有实际意义，因为该链不包含足够的信息来保留语料库的任何潜在含义及语法结构，但是缺乏意义本身却给文本带来了意料之外的乐趣。</p><h2 id="构建算法"><a href="#构建算法" class="headerlink" title="构建算法"></a>构建算法</h2><p>链中的节点由 <code>Word</code> 类的实例表示，此类将会为它所表示的单词保存一个字符串，同时持有一组指向其他单词的链接。</p><p>我们如何表示这一组链接呢？最直接的方法是采用某种计数的集合，它将存储其他 <code>Word</code> 实例以及在输入语料库中转换次数的计数。不过，从这样一个集合中随机选择一个链接可能会非常棘手。一个简单的方法是生成一个范围从 0 到集合元素总计数之间的随机数，然后遍历该集合直到取到很多的链接，然后选中你想要的链接。虽然这个方式简单，但可能比较耗时。另一种方法是预先生成一个数组，用于存储数组中每个链接的累积总数，然后对 0 和总数之间的随机数进行二分搜索。这相对来说更繁琐一些，但执行效率更高。如果你追求更好的方案，你其实可以做更多的预处理，并最终得到一个可以在<a href="http://www.keithschwarz.com/darts-dice-coins/" target="_blank" rel="noopener">常量时间内完成查询的紧凑结构</a>。</p><p>最终，我决定偷懒使用一种在空间上极其浪费，但在时间上效率很高且易于实现的结构。该结构每个 <code>Word</code> 包含一个后续 <code>Words</code> 的数组。如果一个链接被指向多次，那么将会保存重复的 <code>Words</code> 数组。在数组中选择一个随机索引，根据索引返回具有适当权重的随机元素。</p><p><code>Word</code> 类结构如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span> </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> str: <span class="type">String</span>?</span><br><span class="line">   <span class="keyword">var</span> links: [<span class="type">Word</span>] = []</span><br><span class="line"></span><br><span class="line">   <span class="keyword">init</span>(str: <span class="type">String</span>?) &#123;</span><br><span class="line">       <span class="keyword">self</span>.str = str</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">randomNext</span><span class="params">()</span></span> -&gt; <span class="type">Word</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> index = arc4random_uniform(<span class="type">UInt32</span>(links.<span class="built_in">count</span>))</span><br><span class="line">       <span class="keyword">return</span> links[<span class="type">Int</span>(index)]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>links</code> 数组可能会导致大量循环引用。为了避免内存泄漏，我们需要手动清理那些内存。</p><p>我们引入 <code>Chain</code> 类，它将管理链中所有的 <code>Words</code> 。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> words: [<span class="type">String</span>?: <span class="type">Word</span>] = [:]</span><br></pre></td></tr></table></figure><p>在 <code>deinit</code> 方法中，清除所有的 <code>links</code> 数组，以消除所有的循环引用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words.values &#123;</span><br><span class="line">        word.links = []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有这一步，许多单词实例的内存都会泄漏。</p><p>现在让我们看看如何将单词添加到链中。<code>add</code> 方法需要一个字符串数组，该数组中每一个元素都保存着一个单词（或调用者希望使用的其他任何字符串）:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> words: [String])</span></span> &#123;</span><br></pre></td></tr></table></figure><p>如果链中没有单词，那么提前返回。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> words.isEmpty &#123; <span class="keyword">return</span> &#125;</span><br></pre></td></tr></table></figure><p>我们想要遍历那些成对的单词，遍历规则是第二个元素的第一个单词紧随第一个元素后面的单词。例如，在句子 “Help, I’m being oppressed,” 中，我们要迭代 <code>(&quot;Help&quot;, &quot;I&#39;m&quot;)</code> ， <code>(&quot;I&#39;m&quot;, &quot;being&quot;)</code> ， <code>(&quot;being&quot;, &quot;oppressed&quot;)</code> 。</p><p>实际上，还需要多做一点事情，因为我们需要编码句子的开头和结尾。我们将句子的开头和结尾用 <code>nil</code> 表示，所以我们要迭代的实际序列是 <code>(nil, &quot;Help&quot;)</code> ， <code>(&quot;Help&quot;, &quot;I&#39;m&quot;)</code> ， <code>(&quot;I&#39;m&quot;, &quot;being&quot;)</code> ， <code>(&quot;being&quot;, &quot;oppressed&quot;)</code> ， <code>(&quot;oppressed&quot;, nil)</code> 。</p><p>为了允许值为 <code>nil</code> ， 我们的数组声明为 <code>String?</code> 类型，而不是 <code>String</code>  类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> words = words <span class="keyword">as</span> [<span class="type">String</span>?]</span><br></pre></td></tr></table></figure><p>接下来构造两个数组，一个头部添加 <code>nil</code>，另一个尾部添加 <code>nil</code>。把它们通过 <code>zip</code> 合并在一起生成我们想要的序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wordPairs = <span class="built_in">zip</span>([<span class="literal">nil</span>] + words, words + [<span class="literal">nil</span>])</span><br><span class="line"><span class="keyword">for</span> (first, second) <span class="keyword">in</span> wordPairs &#123;</span><br></pre></td></tr></table></figure><p>对于这一对中的每个单词，我们使用一个辅助方法来获取相应的 <code>Word</code> 对象：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstWord = word(first)</span><br><span class="line"><span class="keyword">let</span> secondWord = word(second)</span><br></pre></td></tr></table></figure><p>然后把第二个单词添加到第一个单词的链接中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">        firstWord.links.append(secondWord)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Word</code> 辅助方法从 <code>words</code> 字典中提取实例，如果实例不存在就创建一个新实例并将其放入字典中。这样就不用担心字符串匹配不到单词：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">word</span><span class="params">(<span class="number">_</span> str: String?)</span></span> -&gt; <span class="type">Word</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> word = words[str] &#123;</span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> word = <span class="type">Word</span>(str: str)</span><br><span class="line">        words[str] = word</span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后生成我们要的单词序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br></pre></td></tr></table></figure><p>我们将逐个生成单词，并将他们存储在下面的数组中:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result: [<span class="type">String</span>] = []</span><br></pre></td></tr></table></figure><p>这是一个无限循环。因为退出条件没有清晰的映射到循环条件，代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br></pre></td></tr></table></figure><p>在 <code>result</code> 中获取最后一个字符串构成 <code>Word</code> 实例。这很好地处理了当 <code>result</code> 为空时的初始情况，因为一旦 <code>last</code> 取值为 <code>nil</code> 就表示第一个单词：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currentWord = word(result.last)</span><br></pre></td></tr></table></figure><p>随机获取链接的词：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nextWord = currentWord.randomNext()</span><br></pre></td></tr></table></figure><p>如果链接的单词不是结尾，将其追加到 <code>result</code> 中。如果是结束，则终止循环：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> str = nextWord.str &#123;</span><br><span class="line">        result.append(str)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回包含所有单词的 <code>result</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一件事：我们正在使用 <code>String?</code> 作为 <code>words</code> 的键类型，但 <code>Optional</code> 不符合 <code>Hashable</code> 协议。下面是一个扩展，当它的封装类型遵循 <code>Hashable</code> 时添加 <code>Optional</code> 对 <code>Hashable</code> 的实现：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span>: <span class="title">Hashable</span> <span class="title">where</span> <span class="title">Wrapped</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> wrapped?: <span class="keyword">return</span> wrapped.hashValue</span><br><span class="line">        <span class="keyword">case</span> .<span class="keyword">none</span>: <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>备注：Swift 4.2 中 <code>Optional</code> 类型已默认实现 <code>Hashable</code> 协议</p></blockquote><h2 id="生成输入数据"><a href="#生成输入数据" class="headerlink" title="生成输入数据"></a>生成输入数据</h2><p>以上就是马尔可夫链的结构，下面我们输入一些真实文本试试看。</p><p>我决定从 <code>RSS</code> 提要中提取文本。还有什么比用我自己博客全文作为输入更好的选择呢？</p><p><code>let feedURL = URL(string: &quot;https://www.mikeash.com/pyblog/rss.py?mode=fulltext&quot;)!</code></p><p><code>RSS</code> 是一种 <code>XML</code> 格式，所以我们使用 <code>XMLDocument</code> 来解析它：</p><p><code>let xmlDocument = try! XMLDocument(contentsOf: feedURL, options: [])</code></p><p>文章主体被嵌套在 <code>item</code> 节点下的 <code>description</code> 节点。通过 <code>XPath</code> 查询检索：</p><p><code>let descriptionNodes = try! xmlDocument.nodes(forXPath: &quot;//item/description&quot;)</code></p><p>我们需要 <code>XML</code> 节点中的字符串，所以我们从中提取并过滤掉为 <code>nil</code> 的内容。</p><p><code>let descriptionHTMLs = descriptionNodes.compactMap({ $0.stringValue })</code></p><p>我们根本不用关心标签。<code>NSAttributedString</code> 可以解析 <code>HTML</code> 并生成一个 <code>AttributedString</code>，然后我们可以过滤它：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> descriptionStrings = descriptionHTMLs.<span class="built_in">map</span>(&#123;</span><br><span class="line">   <span class="type">NSAttributedString</span>(html: $<span class="number">0</span>.data(using: .utf8)!, options: [:], documentAttributes: <span class="literal">nil</span>)!.string</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们需要一个将字符串分解成若干部分的函数。我们的目的是生成 String 数组，每个数组对应文本里的一句话。一段文本可能会有很多句话，所以 <code>wordSequences</code> 函数会返回一个 String 的二维数组：</p><p><code>func wordSequences(in str: String) -&gt; [[String]] {</code></p><p>然后我们将处理结果存储在一个局部变量中：</p><p><code>var result: [[String]] = []</code></p><p>将字符串分解成句子并不简单。你可以直接搜索标点符号，但需要考虑到像 <code>“Mr. Jock, TV quiz Ph.D., bags few lynx.”</code> 这样的句子，按照标点符号会被分割成四段，但这是一个完整的句子。</p><p><code>NSString</code> 提供了一些智能检查字符串部分的方法，前提是你需要 <code>import Foundation</code> 。我们会枚举 <code>str</code> 包含的句子，并让 <code>Foundation</code> 进行处理：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">str.enumerateSubstrings(<span class="keyword">in</span>: str.startIndex..., options: .bySentences, &#123; substring, substringRange, enclosingRange, stop <span class="keyword">in</span></span><br></pre></td></tr></table></figure><p>在将句子拆分成单词的时候会遇到相似的问题。<code>NSString</code> 也提供了一种用于枚举词的方法，但是存在一些问题，例如丢失标点符号。我最终决定用一种愚蠢的方式来进行单词分割，只按空格进行分割。这意味着你最终将包含标点符号的单词作为字符串的一部分。与标点符号被删除相比，这更多地限制了马尔可夫链，但另一方面，输出会包含合理的标点符号。我觉得这个折中方案还不错。</p><p>一些换行符会进入数据集，我们首先将这些换行符移除：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> words = substring!.<span class="built_in">split</span>(separator: <span class="string">" "</span>).<span class="built_in">map</span>(&#123;</span><br><span class="line">    $<span class="number">0</span>.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.newlines)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>分割的句子最终被添加到 <code>result</code> 中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    result.append(words)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>枚举完成后，根据输入的句子计算出 <code>result</code> ，然后将其返回给调用者：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到主代码。现在已经有办法将字符串转换为句子列表，我们就可以继续构建自己的马尔可夫链。首先我们创建一个空的 <code>Chain</code> 对象：</p><p><code>let chain = Chain()</code></p><p>然后我们遍历所有的字符串，提取句子，并将它们添加到链中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> str <span class="keyword">in</span> descriptionStrings &#123;</span><br><span class="line">   <span class="keyword">for</span> sentence <span class="keyword">in</span> wordSequences(<span class="keyword">in</span>: str) &#123;</span><br><span class="line">       chain.add(sentence)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步当然是生成一些新句子！我们调用 <code>generate()</code>，然后用空格连接结果。输出结果可能命中也可能不命中（考虑到该技术的随机性，这并不奇怪），所以我们会多生成一些：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span> ..&lt; <span class="number">200</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"\""</span> + chain.generate().joined(separator: <span class="string">" "</span>) + <span class="string">"\""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h2><p>为了演示，下面是这个程序的一些示例输出：</p><ul><li>“We’re ready to be small, weak references in New York City.”</li><li>“It thus makes no values?”</li><li>“Simple JSON tasks, it’s wasteful if you can be.”</li><li>“Another problem, but it would make things more programming-related mystery goo.”</li><li>“The escalating delays after excessive focus on Friday, September 29th.”</li><li>“You may not set.”</li><li>“Declare conformance to use = Self.init() to detect the requested values.”</li><li>“The tagged pointer is inlined at this nature; even hundreds of software and writing out at 64 bits wide.”</li><li>“We’re ready to express that it works by reader ideas, so the decoding methods for great while, it’s inaccessible to 0xa4, which takes care of increasing addresses as the timing.”</li><li>“APIs which is mostly a one-sided use it yourself?”</li><li>“There’s no surprise.”</li><li>“I wasn’t sure why I’ve been called ‘zero-cost’ in control both take serious effort to miss instead of ARC and games.”</li><li>“For now, we can look at the filesystem.”</li><li>“The intent is intended as reader-writer locks.”</li><li>“For example, we can use of the code?”</li><li>“Swift’s generics can all fields of Swift programming, with them is no parameters are static subscript, these instantiate self = cluster.reduce(0, +) / Double(cluster.count)”</li><li>“However, the common case, you to the left-hand side tables.”</li></ul><p>上面有很多无意义的句子，所以你必须深入挖掘才能找到有意义的句子，但不可否认马尔可夫链可以产生一些非常有趣的输出。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>马尔可夫链有许多实际用途，在用于生成文本时它可能显得比较有趣但不是很实用。除了展示了其娱乐性之外，该代码还说明了在没有明确引用关系的情况下如何处理循环引用，如何灵活地使用 <code>NSString</code> 提供的枚举方法从文本中提取特征，以及简要说明了条件一致性（<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0143-conditional-conformances.md" target="_blank" rel="noopener">conditional conformances</a>）的优点。</p><p>今天就讲这些。期待下次一起分享更多的乐趣，在娱乐中进行学习。<code>Friday Q&amp;A</code> 是由读者的想法驱动的，所以如果你有一些想在这里看到的话题，请给我<a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发送邮件</a>！</p><blockquote><p>你喜欢这篇文章吗？我正在卖收录了这些文章的一本书！第二卷和第三卷现在也出来了！包括 ePub，PDF，实体版以及 iBook 和 Kindle。<a href="https://www.mikeash.com/book.html" target="_blank" rel="noopener">点击这里查看更多信息</a>。</p></blockquote><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了使用 Swift 来构造马尔可夫链结构，并使用该结构指定输入数据源随机生成文本。
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift Package Manager 重写 macOS 部署目标</title>
    <link href="https://swift.gg/2018/07/19/swift-3-1-package-manager-deployment-target/"/>
    <id>https://swift.gg/2018/07/19/swift-3-1-package-manager-deployment-target/</id>
    <published>2018-07-19T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2017/04/swift-3-1-package-manager-deployment-target/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-04-07<br>译者：<a href="undefined">EyreFree</a>；校对：<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>，<a href="undefined">Firecrest</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Swift 3.1 修复了 <a href="https://swift.org/package-manager/" target="_blank" rel="noopener">Swift Package Manager</a> 无法重写 MacOS 部署目标的 Bug。</p><p>当你在 macOS 上执行 <code>swift build</code> 命令时，包管理器目前（Swift 3.0 和 3.1）会将部署目标硬编码为 macOS 10.10 ¹  现已证明是命令参数的一个 <a href="https://bugs.swift.org/browse/SR-2535" target="_blank" rel="noopener">Bug</a> 引起的 Swift 3.0 中无法重写部署目标这个问题。</p><a id="more"></a><p>因此，你不能轻松编译用到了最新 API 的代码 ²  举个栗子，假设有一个非常简单的包，只包含几行代码在一个源文件中。这个程序用到了 macOS 10.12 引入的新的 <a href="https://oleb.net/blog/2016/07/measurements-and-units/" target="_blank" rel="noopener">单位和测量类型</a> 来将一个值从以 km/h 转换为 m/s ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.swift</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> kph = <span class="type">Measurement</span>(value: <span class="number">100</span>,</span><br><span class="line">    unit: <span class="type">UnitSpeed</span>.kilometersPerHour)</span><br><span class="line"><span class="keyword">let</span> mps = kph.converted(to: .metersPerSecond)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(kph)</span> is <span class="subst">\(mps)</span>"</span>)</span><br></pre></td></tr></table></figure><p>在 macOS（Swift 3.0 或 3.1）上用 <code>swift build</code> 命令编译上面这段代码会报错，因为这段代码用到的 API 在 macOS 10.10 上不可用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swift build</span><br><span class="line">Compile Swift Module <span class="string">'Units'</span> (1 sources)</span><br><span class="line">main.swift:3:11: error: <span class="string">'Measurement'</span> is only available on OS X 10.12 or newer</span><br><span class="line"><span class="built_in">let</span> kph = Measurement(value: 100,</span><br><span class="line">          ^</span><br><span class="line">main.swift:3:11: note: add <span class="string">'if #available'</span> version check</span><br><span class="line"><span class="built_in">let</span> kph = Measurement(value: 100,</span><br><span class="line">          ^</span><br><span class="line">...</span><br><span class="line">&lt;unknown&gt;:0: error: build had 1 <span class="built_in">command</span> failures</span><br><span class="line">error: <span class="built_in">exit</span>(1): /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift-build-tool -f .build/debug.yaml</span><br></pre></td></tr></table></figure><p>在 Swift 3.1 中，你可以在命令行中修改部署目标，如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swift build -Xswiftc <span class="string">"-target"</span> \</span><br><span class="line">    -Xswiftc <span class="string">"x86_64-apple-macosx10.12"</span></span><br><span class="line">Compile Swift Module <span class="string">'Units'</span> (1 sources)</span><br><span class="line">Linking ./.build/debug/Units</span><br></pre></td></tr></table></figure><p>现在，你可以正常执行之前的这段代码了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ .build/debug/Units</span><br><span class="line">100.0 km/h is 27.7778 m/s</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>除了部署目标，另一个常见的自定义编译设置例子是传递一个 <code>DEBUG</code> 标志给编译器，所以可以在你的代码中使用 <code>#if DEBUG/#endif</code> 代码段作为标志传递给编译器，从而来判断是否处于 Debug 模式 - 当前包管理器并没有在 Debug 构建模式下自动完成这些工作。你可以通过 <code>swift build -Xswiftc &quot;-D&quot; -Xswiftc &quot;DEBUG&quot;</code> 命令实现这一目的。</p><p>这仍然不够理想 - 你在每次执行 <code>swift build</code> 或 <code>swift test</code> 命令时都需要手动输入命令行参数 - 但至少这是可行的。</p><p>对于包管理器来说能够在包配置清单中指定自定义编译设置是 <a href="https://lists.swift.org/pipermail/swift-evolution-announce/2017-January/000307.html" target="_blank" rel="noopener">Swift 4 路线图</a>的一部分。我猜我们很快就会看到一个和这一特性有关的 <a href="https://apple.github.io/swift-evolution/" target="_blank" rel="noopener">Swift 发展提案</a>。</p><hr><ol><li>你可以通过添加如下代码段到你的 <code>main.swift</code> 文件然后编译并执行对应包的方式来验证这一点：</li></ol><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> os(macOS)</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"macOS deployment target:"</span>, __MAC_OS_X_VERSION_MIN_REQUIRED)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>如果在 macOS 执行，将会打印：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">macOS deployment target: 101000</span><br></pre></td></tr></table></figure><ol start="2"><li>你必须把所有依赖新 API 的代码用 <code>if #available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *) { ... }</code> 或类似的 block 进行包裹。</li></ol><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2017/04/swift-3-1-package-manager-deployment-target/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-04-07&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;EyreFree&lt;/a&gt;；校对：&lt;a href=&quot;https://weibo.com/1743643682/profile?topnav=1&amp;amp;wvr=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;liberalism&lt;/a&gt;，&lt;a href=&quot;undefined&quot;&gt;Firecrest&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 3.1 修复了 &lt;a href=&quot;https://swift.org/package-manager/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift Package Manager&lt;/a&gt; 无法重写 MacOS 部署目标的 Bug。&lt;/p&gt;
&lt;p&gt;当你在 macOS 上执行 &lt;code&gt;swift build&lt;/code&gt; 命令时，包管理器目前（Swift 3.0 和 3.1）会将部署目标硬编码为 macOS 10.10 ¹  现已证明是命令参数的一个 &lt;a href=&quot;https://bugs.swift.org/browse/SR-2535&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bug&lt;/a&gt; 引起的 Swift 3.0 中无法重写部署目标这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>何时用 struct？何时用 class？</title>
    <link href="https://swift.gg/2018/07/16/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes/"/>
    <id>https://swift.gg/2018/07/16/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes/</id>
    <published>2018-07-16T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-07-17<br>译者：<a href="http://muhlenxi.com/" target="_blank" rel="noopener">muhlenXi</a>；校对：<a href="undefined">Firecrest</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>在 Swift 的世界中，有一个热议很久的主题，何时使用 <code>class</code> 和何时使用 <code>struct</code> ，今天，我想发表一下我自己的观点。</p><a id="more"></a><h2 id="值类型-VS-引用类型"><a href="#值类型-VS-引用类型" class="headerlink" title="值类型 VS 引用类型"></a>值类型 VS 引用类型</h2><p>事实上，这个问题的答案很简单：当你需要值语义的时候用 <code>struct</code> ，当你需要引用语义的时候就用 <code>class</code> 。</p><p>好了，下周同一时间请再次访问我的博客……</p><p><strong>等等</strong></p><p>怎么了？</p><p><strong>这没有回答上述中的问题</strong></p><p>你什么意思？答案就在那儿。</p><p><strong>是的，但是……</strong></p><p>但是什么？</p><p><strong>那什么是值语义，什么是引用语义呢？</strong></p><p>昂，你提醒了我。我确实应该讲解一下。</p><p><strong>还有它们和 struct、class 的关系</strong></p><p>好吧。</p><p>这些问题的核心就是数据和数据的存储位置。我们用局部变量、参数、属性和全局变量来存储数据。存储数据有两种最基本的方式。</p><p>对于值语义，数据是直接保存在变量中。对于引用语义，数据保存在其他地方，变量存储的是该数据的引用地址。当我们访问数据时，这种差异不一定很明显。但是拷贝数据时就完全不一样了。对于值语义，你得到的是该数据的拷贝。对于引用语义，你得到的是该数据的引用地址拷贝。</p><p>这有些抽象，我们通过一个示例来了解一下。先暂时跳过 Swift 的示例，一起来看一个 Objective-C 的示例：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SomeClass</span> : <span class="title">NSObject</span> </span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> number;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SomeClass</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> SomeStruct &#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SomeClass *reference = [[SomeClass alloc] init];</span><br><span class="line">reference.number = <span class="number">42</span>;</span><br><span class="line">SomeClass *reference2 = reference;</span><br><span class="line">reference.number = <span class="number">43</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"The number in reference2 is %d"</span>, reference2.number);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> SomeStruct value = &#123;&#125;;</span><br><span class="line">value.number = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">struct</span> SomeStruct value2 = value;</span><br><span class="line">value.number = <span class="number">43</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"The number in value2 is %d"</span>, value2.number);</span><br></pre></td></tr></table></figure><p>打印的结果如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">The number <span class="keyword">in</span> reference2 is <span class="number">43</span></span><br><span class="line">The number <span class="keyword">in</span> value2 is <span class="number">42</span></span><br></pre></td></tr></table></figure><p>为什么打印结果会不一样?</p><p>代码 <code>SomeClass *reference = [[SomeClass alloc] init]</code> 在内存中创建了 SomeClass 类的一个新实例，然后将该实例的引用放到 reference 变量中。代码 <code>reference2 = reference</code> 将 reference 变量的值（实例的引用）赋值给新的 reference2 变量。然后 <code>reference.number = 43</code> 将两个变量指向的对象（同一个对象）的 number 属性修改为 43。 这就导致打印的 reference2 的值也是 43。</p><p>代码 <code>struct SomeStruct value = {}</code> 创建  SomeStruct 结构体的一个新实例并赋值给变量 value。代码 <code>value2 = value</code> 拷贝 value 的值到 变量 value2 中。每个变量包含各自的数据块。而代码 <code>value.number = 43</code> 仅仅修改 value 变量的值。所以，value2 变量的值仍然是 42。</p><p>用 Swift 实现这个例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reference = <span class="type">SomeClass</span>()</span><br><span class="line">reference.number = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> reference2 = reference</span><br><span class="line">reference.number = <span class="number">43</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The number in reference2 is <span class="subst">\(reference2.number)</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="type">SomeStruct</span>()</span><br><span class="line">value.number = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> value2 = value</span><br><span class="line">value.number = <span class="number">43</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The number in value2 is <span class="subst">\(value2.number)</span>"</span>)</span><br></pre></td></tr></table></figure><p>和之前一样，打印如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">The</span> number <span class="keyword">in</span> reference2 <span class="keyword">is</span> <span class="number">43</span></span><br><span class="line"><span class="type">The</span> number <span class="keyword">in</span> value2 <span class="keyword">is</span> <span class="number">42</span></span><br></pre></td></tr></table></figure><h2 id="使用值类型的经验"><a href="#使用值类型的经验" class="headerlink" title="使用值类型的经验"></a>使用值类型的经验</h2><p>值类型不是新出的类型。但是对于很多人来说，他们<em>感觉上</em>很新。这是怎么回事？</p><p>大部分 Objective-C 代码不会用到 struct。我们通常操作的是 CGRect 、 CGPoint 和友元，很少自己定义结构体。一方面，结构体不实用，无法做函数式的引用赋值。在 Objective-C 中，正确保存对象的引用到 struct 中是很困难的，尤其是使用 ARC 的时候。</p><p>大部分语言没有类似 struct 结构体的东西。像 Python 和 JavaScript 这样“一切皆对象”的语言都只有引用类型。如果你是从这样的语言转到 Swift，值类型这个概念可能对你来说更加陌生。</p><p>不过等一下！有一个地方几乎所有的语言都会使用值类型：数值（number）！只要你写过一段时间代码，无论是什么语言，肯定能理解下面这段代码的行为：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> x2 = x</span><br><span class="line">x++</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"x=<span class="subst">\(x)</span> x2=<span class="subst">\(x2)</span>"</span>)</span><br><span class="line"><span class="comment">// prints: x=43 x2=42</span></span><br></pre></td></tr></table></figure><p>这对我们来说是非常明显和自然的，我们甚至没有意识到它的行为与众不同。但是它确确实实是值类型。从你编程的第一天开始就一直在使用值类型，即使你没有意识到这一点。</p><p>由于许多语言的核心是“一切皆对象”，number 其实是用引用类型来实现的。然而，它们是不可变引用类型，不可变引用类型和值类型的差异是很难察觉的。它们的行为和值类型一样，即使它们不是以这种方式实现。</p><p>这是理解值类型和引用类型的重要部分。就语言语义方面，区别是很重要的。当修改数据时，如果你的数据是不可变的，那么值类型/引用类型之间的区别就消失了，或者至少变成纯粹的性能问题而不是语义问题。</p><p>Objective-C 中也有类似的东西，就是标记指针（tagged pointers）。标记指针把对象直接存储在指针值中，因此它实际上是值类型，拷贝指针相当于拷贝对象。Objective-C 的库只会把不可变类型存储到标记指针中，所以使用的时候感受不到区别。有些 NSNumber 是引用类型，有些是值类型，但是使用上没有区别。</p><h2 id="做出选择"><a href="#做出选择" class="headerlink" title="做出选择"></a>做出选择</h2><p>既然我们已经知道值类型是如何工作的，那么你自己的数据类型该用什么呢？</p><p>这两者之间的根本区别在于，当你使用 <code>=</code> 时会发生什么。值类型会得到该对象的副本，引用类型仅仅得到该对象的引用。</p><p>因此，决定使用哪一个的基本问题是：是否需要拷贝？是否需要经常拷贝？</p><p>首先来看一些毫无争议的例子。Integer 显然是可拷贝的，它应该是值类型。网络套接字（Network sockets）明显是不可拷贝的，它应该是引用类型。再比如使用 (x, y) 实数对表示的坐标（Points）是可拷贝的，它应该是值类型。代表磁盘的控制器是明显不可拷贝的，它应该是引用类型。</p><p>有些类型理论上<em>可以</em>拷贝，但是这种拷贝可能不是你想要的。这种情况下，它们应该是引用类型。举个例子，屏幕上的按钮在代码层面可以拷贝，但是拷贝的按钮和原始按钮并不一样。点击拷贝的按钮并不会触发原始按钮，拷贝的按钮在屏幕上的位置也和原始按钮不一样。如果你需要把按钮当成参数传递，或者将它赋值给一个新变量，那你需要的是原始按钮的引用，只有明确声明的时候才进行拷贝。因此，按钮应该是引用类型。</p><p>视图和窗口控制器也类似。它们可以支持拷贝，但一般来说这不是你期望的行为，它们应该是引用类型。</p><p>接着谈谈模型（model）类型。假设你有一个 User 类型，用来表示系统中的用户，然后用 Crime 类型来表示 User 的操作。这两个类型看起来都可以拷贝，可以设置成值类型。但是，如果你的程序需要更新 User 的 Crime 并且能把改动同步到其他代码，那最好用一个用户控制器（User Controller）来管理 User，显然这个用户控制器应该是引用类型。</p><p>集合是个有趣的例子。集合包括数组、字典、字符串等类型。它们是可拷贝的吗？显然是。是否需要经常拷贝？这就不好说了</p><p>大部分语言的回答是“No”，它们的集合是引用类型。比如 Objective-C、Java、Python、JavaScript 以及一些我能想到的语言。（一个例外是 C++ 的 STL 集合，但是 C++ 是语言中的疯子，它做的每件事都很奇怪。）</p><p>Swift 是可拷贝的。这意味着 <code>Array</code> 、 <code>Dictionary</code> 和 <code>String</code> 是结构体而不是类。可以将他们的拷贝作为参数来使用。如果拷贝付出的代价很小，这么做就完全合理。Swift 为了实现这个功能花了很大功夫。。</p><h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>嵌套值类型和引用类型有四种方式。哪怕只用到了其中一种，你的生活都会变得更加有趣。</p><ol><li>包含其他引用类型的引用类型，这没什么特别的。如果持有内部或外部值的引用，就可以修改这个值。改动会同步到所有持有者。</li><li>包含其他值类型的值类型，这样做的结果是一个更庞大的值类型。当内部值是外部值的一部分时，如果你将外部值存储到某个新地方，整个值类型都会被拷贝，包括内部值。如果你将内部值储存到新地方，那就只拷贝内部值。</li><li>包含值类型的引用类型，被引用的值会变大。外部值的引用可以操作整个对象，包括内部值。修改内部值时，外部值引用的持有者都会同步改动。如果你将内部值储存到新地方，它会被拷贝。</li><li>包含引用类型的值类型，这就有点复杂了。你可能会遇到意料之外的行为。这有利有弊，取决于你的使用方式。如果你将一个引用类型放到值类型中，然后拷贝这个值类型到一个新地方，拷贝中的内部对象的引用值是相同的，它们都指向相同的地方。下面是一个示例：</li></ol><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">42</span></span><br><span class="line">    <span class="keyword">var</span> inner = <span class="type">Inner</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> outer = <span class="type">Outer</span>()</span><br><span class="line"><span class="keyword">var</span> outer2 = outer</span><br><span class="line">outer.value = <span class="number">43</span></span><br><span class="line">outer.inner.value = <span class="number">43</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"outer2.value=<span class="subst">\(outer2.value)</span> outer2.inner.value=<span class="subst">\(outer2.inner.value)</span>"</span>)</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">outer2.value=<span class="number">42</span> outer2.inner.value=<span class="number">43</span></span><br></pre></td></tr></table></figure><p><code>outer2</code> 是 <code>outer</code> 的拷贝，它仅仅拷贝了 <code>inner</code> 的引用，因此两个结构体的 <code>inner</code> 共享一个存储空间。因此更新 <code>outer.inner.value</code> 的值会影响 <code>outer2.inner.value</code> 的值。神奇！</p><p>如果使用得当，上面的这种行为使编程变得很方便，它允许你创建一个支持写时复制的 <code>struct</code> ，允许你不需要拷贝大量的数据就可以实现值语义。这就是 Swift 的集合工作机制，你也可以创建自己的集合。如果想了解更多，可以阅读 <a href="https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html" target="_blank" rel="noopener">一起来构建 Swift Array</a>。</p><p>这种行为也相当危险。举个例子，你有一个可拷贝的 Person 类，所以它可以是 <code>struct</code> 类型，为了怀旧，你决定用 <code>NSString</code> 类型来保存姓名：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> name: <span class="type">NSString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后生成一对夫妇的实例，分别给每个实例的姓名赋值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="type">NSMutableString</span>()</span><br><span class="line">name.appendString(<span class="string">"Bob"</span>)</span><br><span class="line">name.appendString(<span class="string">" "</span>)</span><br><span class="line">name.appendString(<span class="string">"Josephsonson"</span>)</span><br><span class="line"><span class="keyword">let</span> bob = <span class="type">Person</span>(name: name)</span><br><span class="line"></span><br><span class="line">name.appendString(<span class="string">", Jr."</span>)</span><br><span class="line"><span class="keyword">let</span> bobjr = <span class="type">Person</span>(name: name)</span><br></pre></td></tr></table></figure><p>打印他们的姓名：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line"><span class="built_in">print</span>(bobjr.name)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Bob</span> <span class="type">Josephsonson</span>, <span class="type">Jr</span>.</span><br><span class="line"><span class="type">Bob</span> <span class="type">Josephsonson</span>, <span class="type">Jr</span>.</span><br></pre></td></tr></table></figure><p>喔！</p><p>发生了什么？与 Swift 中的 <code>String</code> 类型不同，<code>NSString</code> 是一个引用类型，是不可变的，但是它有一个可变的子类 <code>NSMutableString</code> 。构建 bob 时，生成了一个被 name 中字符串所持有的引用。随后改变 这个字符串时，改动被同步到了 bob 中。虽然 bob 是用 <code>let</code> 声明值类型，但是此处的赋值操作显然改变了 bob。事实上，这没有覆写 bob，只不过是改变了 bob 持有的引用的数据。因为 name 是 bob 的一部分数据，从语义上看，就好像覆写了 bob。</p><p>这种行为在 Objective-C 中一直存在。每个有经验的 Objective-C 开发者都能避免这种行为。因为一个 <code>NSString</code> 实际上可能是一个 <code>NSMutableString</code> 。为了防止这种行为，可以声明一个 <code>copy</code> 的属性或者在初始化的时候显式的调用 <code>copy</code> 方法。在许多 Cocoa 的集合中可以发现这种做法。</p><p>Swift 的解决方法很简单：用值类型而不是引用类型。在这种情况下，声明 name 为 <code>String</code> 类型即可。这样就不用担心无意中出现存储共享的问题。</p><p>有些情况下，解决方法可能没有这么简单。举个例子，你可能会创建一个 包含引用类型变量 view 的 <code>struct</code> ，并且它不能改变为值类型。这<em>也许</em>表示你的类型不应该是 <code>struct</code> ，因为你无论如何也不能实现值语义。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>移动值语义类型的数据时，新数据是原数据的拷贝。然而，引用语义类型的数据得到的是原数据的引用拷贝。这意味着你可以在任何地方通过引用覆写原数据。而值语义只能通过改变原数据来改变原数据的值。选择类型时，要考虑该类型是否适合拷贝和倾向于拷贝的固有类型。最后，注意值类型中嵌套的引用类型，如果你不留心将会发生一些糟糕的事情。</p><p>今天的内容到此结束，这次是真的结束了，下次再见。你们的建议对 Friday Q&amp;A  是最好的鼓励，所以如果你关于这个主题有什么好的想法，请<a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发邮件到这里</a>。</p><blockquote><p>你喜欢这篇文章么？我的书里还有更多有意思的内容！第二卷 和 第三卷正在出售中！包括 ePub，PDF，纸质版，iBooks 和 Kindle，<a href="https://www.mikeash.com/book.html" target="_blank" rel="noopener">点击查看更多信息</a>。</p></blockquote><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2015-07-17&lt;br&gt;译者：&lt;a href=&quot;http://muhlenxi.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;muhlenXi&lt;/a&gt;；校对：&lt;a href=&quot;undefined&quot;&gt;Firecrest&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/Cee&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cee&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在 Swift 的世界中，有一个热议很久的主题，何时使用 &lt;code&gt;class&lt;/code&gt; 和何时使用 &lt;code&gt;struct&lt;/code&gt; ，今天，我想发表一下我自己的观点。&lt;/p&gt;
    
    </summary>
    
      <category term="mikeash.com" scheme="https://swift.gg/categories/mikeash-com/"/>
    
    
      <category term="Swift 入门" scheme="https://swift.gg/tags/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>关于注释</title>
    <link href="https://swift.gg/2018/07/11/on-comments/"/>
    <id>https://swift.gg/2018/07/11/on-comments/</id>
    <published>2018-07-11T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2017/03/on-comments/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-03-22<br>译者：<a href="undefined">TonyHan</a>；校对：<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>，<a href="undefined">Firecrest</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>写代码的过程中，复杂性是最大的敌人。对于大型的软件项目来说，维护多层抽象并且让在代码库中工作的开发者正确的理解这些概念是很重要的。</p><p>注释可以对管理代码复杂性起到一定作用，但也会对代码产生不良影响。</p><p>我对注释的看法来自于两个事实：1）注释并不复杂。2）注释通常在语法高亮中使用柔和的色彩。因为它们不参与编译，并且因为它们并不醒目，所以在更改代码时，很容易忽略它们。如果更改了代码但不更新注释，便得到了一份无法准确描述代码功能的注释。</p><a id="more"></a><p>理想的情况下，可以在代码审查中对注释及时修正，但是实际开发中很难做到这一点。代码审查工具也会有语法高亮显示，这同样会让注释显得不醒目。另外，由于代码审查只会显示被改动的几行代码，只有当注释在改动的附近时，这些已经不适用的注释才会被观察到。如果在一个方法中不起眼的位置修改了一行代码，使得方法的前提条件发生了变化，审查代码的人则很难注意到，也不会告知你去更新注释。</p><p>这里有一些避免最常见注释误区的技巧，其中一些在<a href="http://www.strongopinionsweaklytyped.com/blog/2014/08/27/beware-the-siren-song-of-comments/" target="_blank" rel="noopener">我的老领导的博客</a>中提到过，其他的安德鲁没有想到是因为他是 Ruby（一门动态类型的语言） 程序员。</p><ol><li><p>良好的命名习惯！优秀注释的第一步就是避免使用单字母、抽象或模糊的名字。名字越精确，所需的注释就越少。</p></li><li><p>如果方法有前提条件，并且添加了一个断言，来使得传入非法参数的情况崩溃（至少在调试的时候！）。如果只接受正整数，则写一些类似这样的代码：<code>precondition(int &gt; 0)</code>。</p></li><li><p>编译时的断言比运行时的断言更好。如果方法仅接受非空数组，则可以提前使用判断：<code>precondition(!array.isEmpty)</code>。但是也可以使用一种永远不能表达为空数组的<a href="https://github.com/khanlou/NonEmptyArray" target="_blank" rel="noopener">类型</a>。调用你 API 时永远不可能传入空的组数作为参数。<br>同样，如果是 bool 类型的参数，能不能通过命名两个枚举选项来更好的表达？<a href="http://khanlou.com/2017/03/that-one-optional-property/" target="_blank" rel="noopener">你的选项是否以枚举的方式更好的表达出来？</a><a href="http://wiki.c2.com/?IntentionRevealingNames" target="_blank" rel="noopener">使用命名来表达意图。</a></p></li><li><p>标记出黑科技、临时代码和原型代码。我经常使用类似于 <code>hack_</code> 的前缀代码来标记出此功能实现地并不完美。在 Swift 的方法命名中使用下划线显得不伦不类，我能感觉到我代码变得更糟，于是我会想要修复它。我们最近写了一个前缀为 <code>shouldReallyBeInTheCoordinator_</code> 的函数，这是因为需要代码审查，但是代码并不在正确的类中。当糟糕的代码变成丑陋的代码，代码库的需求和你自己的感觉会统一起来。其他的好前缀比如：<code>perf_</code> 和 <code>temp_</code>。</p></li><li><p>你可以在方法名中添加 ID 来进行 bug 的追踪，这样它们就会在堆栈中出现。UIKit 框架在少数情况下也使用了数字。比如以下：</p></li></ol><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-[<span class="built_in">UIViewController</span> _hackFor11408026_beginAppearanceTransition:animated:]</span><br></pre></td></tr></table></figure><ol start="6"><li><p>不要担心在方法名里描述为何如此命名。你可以将方法命名为 <code>updateFrameOnNextTickBecauseAutoLayoutHasntCompletedYet(frame: CGRect)</code>。编译器并不关心方法命名的长短，代码读的次数比写的次数多得多。注释只是文字，方法名也是。将来维护代码的人肯定会赞同你详细的命名。</p></li><li><p>设置一个辅助函数，例如 <code>TODO(date: Date, message: String)</code> ，如果 TODO 将来一直没有被修改，则会打印错误日志（甚至更进一步，在调试中崩溃）。可以参考 Jordan Rose 的另一个<a href="https://twitter.com/UINT_MIN/status/836316697388695552" target="_blank" rel="noopener">例子</a>。</p></li><li><p>将所有的算法需求编码到测试中。如果以上几条都无法使用，并且无法依赖前提条件、类型或方法名来解决某个问题，那就写一个测试用例。这对边界情况特别适用。如果有人重写这部分代码，测试将会失败，他便会知道需要在新代码也要处理此种情况。</p></li></ol><p>切记：这并不是写复杂代码并且不加注释的借口。如果要跳过注释，那么代码必须清晰。对我而言，注释是最后的手段。如果我能找到任何其他的方式来将我的意图传达给下一个程序员，我都不会添加注释。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul><li><a href="http://ericasadun.com/2016/11/03/swift-holy-war-comments-are-not-an-anti-pattern/" target="_blank" rel="noopener">Erica Sadun 的关于为何注释是有益的</a>。</li></ul><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2017/03/on-comments/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-03-22&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;TonyHan&lt;/a&gt;；校对：&lt;a href=&quot;https://weibo.com/1743643682/profile?topnav=1&amp;amp;wvr=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;liberalism&lt;/a&gt;，&lt;a href=&quot;undefined&quot;&gt;Firecrest&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;写代码的过程中，复杂性是最大的敌人。对于大型的软件项目来说，维护多层抽象并且让在代码库中工作的开发者正确的理解这些概念是很重要的。&lt;/p&gt;
&lt;p&gt;注释可以对管理代码复杂性起到一定作用，但也会对代码产生不良影响。&lt;/p&gt;
&lt;p&gt;我对注释的看法来自于两个事实：1）注释并不复杂。2）注释通常在语法高亮中使用柔和的色彩。因为它们不参与编译，并且因为它们并不醒目，所以在更改代码时，很容易忽略它们。如果更改了代码但不更新注释，便得到了一份无法准确描述代码功能的注释。&lt;/p&gt;
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用类型来让你自己更可靠</title>
    <link href="https://swift.gg/2018/07/03/using-types-to-keep-yourself-honest/"/>
    <id>https://swift.gg/2018/07/03/using-types-to-keep-yourself-honest/</id>
    <published>2018-07-03T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：MATTHIJS HOLLEMANS，<a href="http://machinethink.net/blog/using-types-to-keep-yourself-honest/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016-03-25<br>译者：<a href="undefined">TonyHan</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>这篇文章展示了如何利用 Swift 的类型系统来使你的程序更具表现力和健壮性。</p><p>在最近一周左右的时间里，我一直在倒腾 Swift 的机器学习算法。我们可以通过使用矩阵来简洁有效地实现这些算法。</p><p>如果你忘记了线性代数，那只需将矩阵看作数字表格。</p><p>当提到 “M 是一个 4 乘 3 的矩阵”，意思是指 M 是一个 4 行 3 列的数字表格。关于矩阵你就需要了解这些（译者注:即可将其看作是表格），就可以理解本文后面的讲解。</p><a id="more"></a><p>下面是一个 4×3 矩阵的例子：</p><p><img src="/img/articles/using-types-to-keep-yourself-honest/Matrix.png1530582060.2468634" alt="Matrix"></p><p>下面写代码创建一个 <code>矩阵结构体</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rows: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> columns: <span class="type">Int</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经常需要对矩阵的操作是将它们相乘，因此我创建了一个函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(m1: Matrix, <span class="number">_</span> m2: Matrix)</span></span> -&gt; <span class="type">Matrix</span> &#123;</span><br><span class="line">  <span class="comment">// bunch of math...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一切可能看起来很简单，但是还有些让我很烦的东西。</p><p>即便 m1 和 m2 都是 Matrix 对象，但是实际上它们可能具有不同数量的行和列。这可能是一个问题。</p><p>例如，使用矩阵乘法，两个矩阵的大小必须以特定方式匹配。</p><p><img src="/img/articles/using-types-to-keep-yourself-honest/MatrixMultiplication.png1530582060.3889682" alt="MatrixMultiplication"></p><p>第一个矩阵中的列数必须与第二个矩阵中的行数相同。如果第一个矩阵的大小为 <code>U × V</code>，则第二个矩阵的大小必须为 <code>V × W</code>。这就是数学上规定的。</p><p>结果是大小为 <code>U × W</code> 的新矩阵。如果矩阵的大小不匹配这种特定的方式，我们就不能将它们相乘。</p><p>例如，以下将工作正常：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>(rows: <span class="number">4</span>, columns: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>(rows: <span class="number">3</span>, columns: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">C</span> = multiply(<span class="type">A</span>, <span class="type">B</span>)                <span class="comment">// gives a 4×2 matrix</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在数学中，矩阵通常用大写表示，我在这里遵循变量名称的惯例。</p></blockquote><p>由于 <code>A.columns == B.rows</code>，因此可以将 <code>A</code> 与 <code>B</code> 进行乘法。相反地，以下就不是有效的操作：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">D</span> = multiply(<span class="type">B</span>, <span class="type">A</span>)</span><br></pre></td></tr></table></figure><p>矩阵 <code>B</code> 中的列数与矩阵 <code>A</code> 中的行数不匹配。也就是 <code>B.columns！= A.rows</code>。从数学定义来说，矩阵B和A相乘没有任何意义。</p><p>目前，捕捉这些错误的唯一方法是在运行时触发断言：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(m1: Matrix, <span class="number">_</span> m2: Matrix)</span></span> -&gt; <span class="type">Matrix</span> &#123;</span><br><span class="line">  <span class="comment">// do the matrices have the correct sizes?</span></span><br><span class="line">  <span class="built_in">precondition</span>(m1.columns == m2.rows)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// bunch of math...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做当然可以，但我并不喜欢。Swift 静态类型的重点在于编译器可以在编译期间发现尽可能多的编程错误。如果我们可以使编译器也捕获这种错误，这就会很棒。</p><p>事实证明是可以的！在本文中，我将探讨如何使用 Swift 的类型系统来避免这样的错误。</p><h2 id="不太好的实现"><a href="#不太好的实现" class="headerlink" title="不太好的实现"></a>不太好的实现</h2><p>解决这个问题的比较原始的方法是为不同大小的矩阵创建不同的结构体：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix_4x3</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix_3x2</span>()</span><br></pre></td></tr></table></figure><p>但是，还需要一个将这些特定类型作为参数的 <code>multiply()</code> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(m1: Matrix_4x3, <span class="number">_</span> m2: Matrix_3x2)</span></span> -&gt; <span class="type">Matrix_4x2</span></span><br></pre></td></tr></table></figure><p>这似乎有点傻，导致了很多重复的代码。</p><p>更糟糕的是，编译时可能并不知道矩阵的大小。在机器学习问题中，我们经常需要从文件中加载数据集，但并不会提前知道有多少行。</p><p>所以这不是一个可行的解决方案。然而，为不同大小的矩阵声明不同类型的思路还是有希望的…</p><h2 id="通用的解决方案"><a href="#通用的解决方案" class="headerlink" title="通用的解决方案"></a>通用的解决方案</h2><p>我们希望将矩阵的维度以某种方式并入 Matrix 的类型，而不需要任何矩阵代码，如 <code>multiply()</code> 知道其具体大小。</p><p>定义以下 Matrix：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&lt;<span class="title">R</span>,<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rows: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> columns: <span class="type">Int</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它现在有两个通用参数 <code>R</code> 和 <code>C</code>，其中 <code>R</code> 表示行数，<code>C</code> 表示列数。</p><p>我们可以这样定义 <code>multiply()</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span>&lt;U,V,W&gt;<span class="params">(m1: Matrix&lt;U,V&gt;, <span class="number">_</span> m2: Matrix&lt;V,W&gt;)</span></span> -&gt; <span class="type">Matrix</span>&lt;<span class="type">U</span>,<span class="type">W</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// bunch of math...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">Matrix</span>(rows: m1.rows, columns: m2.columns)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意获取矩阵乘法规则的方法：大小为 <code>U × V</code> 的矩阵乘以大小为 <code>V × W</code> 的矩阵，得到 <code>U × W</code> 大小的新矩阵。</p><p>下面是如何使用新的 <code>Matrix</code> 的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumExamples</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumFeatures</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OneDimensional</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;(rows: <span class="number">20</span>, columns: <span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>&lt;<span class="type">NumFeatures</span>, <span class="type">OneDimensional</span>&gt;(rows: <span class="number">10</span>, columns: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>我们创建了三种新的类型 - 名为 <code>NumExamples</code> ，<code>NumFeatures</code> 和 <code>OneDimensional</code> —— 来表示矩阵的可能维数。注意我如何给出这些类型的描述性名称，从而更容易展现出它们的用途。</p><p><code>NumExamples</code> 和 <code>NumFeatures</code> 的名称来自机器学习，因为我将在其中使用这些矩阵。<code>NumExamples</code> 是数据集中的对象数目，<code>NumFeatures</code> 是每个示例的属性数。(当然，如果你要使用这些矩阵来做别的事情，你可以使用不同的名字。）</p><p><code>OneDimensional</code> 意指矩阵 <code>B</code> 只有一列。在线性代数中，我们称之为列向量而不是矩阵。为了使我们的代码更清晰，如果我们可以这样写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">ColumnVector</span>&lt;<span class="type">Rows</span>&gt; = <span class="type">Matrix</span>&lt;<span class="type">Rows</span>, <span class="type">OneDimensional</span>&gt;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">RowVector</span>&lt;<span class="type">Columns</span>&gt; = <span class="type">Matrix</span>&lt;<span class="type">OneDimensional</span>, <span class="type">Columns</span>&gt;</span><br></pre></td></tr></table></figure><p>类型别名会将 <code>ColumnVector</code> 和 <code>RowVector</code> 标记成 <code>Matrix</code> 的特殊情况。但不幸的是，Swift 2.2 中不支持这种语法。即将发布(<strong>原文日期=2016/03/25</strong>)的 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md" target="_blank" rel="noopener">Swift 3.0</a> 中可能会支持。</p><p>不管怎样让我们回到本例中。当你写下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">C</span> = multiply(<span class="type">A</span>, <span class="type">B</span>)</span><br></pre></td></tr></table></figure><p>它便会按照预期给出了一个新的 20×1矩阵。然而，与之前不同的是，无效的乘法尝试会导致编译器错误：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">D</span> = multiply(<span class="type">B</span>, <span class="type">A</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: cannot convert value of type 'Matrix&lt;NumFeatures, OneDimensional&gt;'</span></span><br><span class="line"><span class="comment">// to expected argument type 'Matrix&lt;_, _&gt;'</span></span><br></pre></td></tr></table></figure><p>错误消息有点模糊，但是使用 Swift 的类型系统来捕获这种错误是极好的。而不是在运行时崩溃应用程序，现在不可能将两个不具有正确维度的矩阵相乘。现在已经实现禁止将两个不具有正确维度的矩阵相乘，避免了在运行时崩溃。</p><p>果真如此么？我们仍然可以骗过编译器：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;(rows: <span class="number">20</span>, columns: <span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>&lt;<span class="type">NumFeatures</span>, <span class="type">OneDimensional</span>&gt;(rows: <span class="number">500</span>, columns: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>通过将 <code>B</code> 的行数改为 500，我们仍然处于与之前相同的情况。现在 <code>multiply(A, B)</code> 不再有效。</p><p>只有这些额外的类型是不够的…我们需要确保类型 <code>NumFeatures</code> 无论它在哪里使用，总会以某种方式引用相同的数字。</p><h2 id="使用协议弥补"><a href="#使用协议弥补" class="headerlink" title="使用协议弥补"></a>使用协议弥补</h2><p>我们可以像这样做：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumExamples</span> </span>&#123; <span class="keyword">let</span> size = <span class="number">20</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumFeatures</span> </span>&#123; <span class="keyword">let</span> size = <span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure><p>但是运行时这些维度的大小便被固定了。请记住，我们希望能够在运行时设置矩阵大小，例如通过从文件读取数据集——而且我们可能不知道该文件中有多少数据。对矩阵大小进行硬编码不是一种好办法。</p><p>相反，让我们定义一个新协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Dimension</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> size: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是 <code>Matrix</code> 变成了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&lt;<span class="title">R</span>: <span class="title">Dimension</span>, <span class="title">C</span>: <span class="title">Dimension</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rows: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> columns: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">self</span>.rows = <span class="type">R</span>.size</span><br><span class="line">    <span class="keyword">self</span>.columns = <span class="type">C</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>init(rows:columns:)</code> 方法已经被去掉。矩阵的大小直接由泛型 <code>R</code> 和 <code>C</code> 决定。</p><p>最后一步是使我们的维度类型符合新协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumExamples</span>: <span class="title">Dimension</span> </span>&#123; <span class="keyword">static</span> <span class="keyword">var</span> size = <span class="number">20</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumFeatures</span>: <span class="title">Dimension</span> </span>&#123; <span class="keyword">static</span> <span class="keyword">var</span> size = <span class="number">10</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OneDimensional</span>: <span class="title">Dimension</span> </span>&#123; <span class="keyword">static</span> <span class="keyword">var</span> size = <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>然后可以如下实现 <code>multiply()</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span>&lt;U: Dimension, V: Dimension, W: Dimension&gt;</span></span><br><span class="line"><span class="function">             <span class="params">(m1: Matrix&lt;U,V&gt;, <span class="number">_</span> m2: Matrix&lt;V,W&gt;)</span></span> -&gt; <span class="type">Matrix</span>&lt;<span class="type">U</span>,<span class="type">W</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// bunch of math...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">Matrix</span>&lt;<span class="type">U</span>,<span class="type">W</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，矩阵 m1 和 m2 不可能不匹配。编译器根本不会接受这种情况。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>&lt;<span class="type">NumFeatures</span>, <span class="type">OneDimensional</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">C</span> = multiply(<span class="type">A</span>, <span class="type">B</span>)   <span class="comment">// yay!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">D</span> = multiply(<span class="type">B</span>, <span class="type">A</span>)   <span class="comment">// compiler error</span></span><br></pre></td></tr></table></figure><p>这样就不会出现无意的错误。当然，你仍然可以通过这样做来欺骗系统：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;()</span><br><span class="line"><span class="type">NumFeatures</span>.size = <span class="number">500</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>&lt;<span class="type">NumFeatures</span>, <span class="type">OneDimensional</span>&gt;()</span><br></pre></td></tr></table></figure><p>即便 Swift 的类型系统也无法阻止出于恶意的行为。（也许在 <code>multiply()</code> 中保留 <code>precondition()</code> 是明智的。）</p><p>顺便说一句，你实际上需要有改变 <code>NumFeatures.size</code> 的能力。但你使用时应该多加小心。正如直到我们运行该程序才能知道它特定大小，它也没有理由会一直保持不变。例如，你可能需要使用相同的流程来处理不同大小的多个数据集。</p><p>当然，你可以使用矩阵来做更多事情，而不仅仅是乘以它们。以下是这些维度类型用处的另一个示例：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processData</span>&lt;M: Dimension, N: Dimension&gt;</span></span><br><span class="line"><span class="function">                <span class="params">(X: Matrix&lt;M, N&gt;, <span class="number">_</span> y: Matrix&lt;M, OneDimensional&gt;)</span></span> </span><br><span class="line">                -&gt; <span class="type">Matrix</span>&lt;<span class="type">OneDimensional</span>, <span class="type">N</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// do impressive stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">X</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> y = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">OneDimensional</span>&gt;()</span><br><span class="line">processData(<span class="type">X</span>, y)</span><br></pre></td></tr></table></figure><p>该函数采用矩阵 <code>X</code> 和列向量 <code>y</code> ，并对它们进行一些处理。例如，可能会训练学习系统。这里的约束是 <code>X</code> 和 <code>y</code> 必须具有相同的行数。多亏了我们的维度类型，编译器可以强制执行该约束。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们使用类型来更好地告诉编译器我们的程序正在做什么。这有助于编译器捕获错误。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：MATTHIJS HOLLEMANS，&lt;a href=&quot;http://machinethink.net/blog/using-types-to-keep-yourself-honest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-03-25&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;TonyHan&lt;/a&gt;；校对：&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;这篇文章展示了如何利用 Swift 的类型系统来使你的程序更具表现力和健壮性。&lt;/p&gt;
&lt;p&gt;在最近一周左右的时间里，我一直在倒腾 Swift 的机器学习算法。我们可以通过使用矩阵来简洁有效地实现这些算法。&lt;/p&gt;
&lt;p&gt;如果你忘记了线性代数，那只需将矩阵看作数字表格。&lt;/p&gt;
&lt;p&gt;当提到 “M 是一个 4 乘 3 的矩阵”，意思是指 M 是一个 4 行 3 列的数字表格。关于矩阵你就需要了解这些（译者注:即可将其看作是表格），就可以理解本文后面的讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="machinethink" scheme="https://swift.gg/categories/machinethink/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的强制编译时报错</title>
    <link href="https://swift.gg/2018/06/25/forcing-compiler-errors-in-swift/"/>
    <id>https://swift.gg/2018/06/25/forcing-compiler-errors-in-swift/</id>
    <published>2018-06-25T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Erica Sadun，<a href="https://ericasadun.com/2018/04/18/forcing-compiler-errors-in-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-18<br>译者：<a href="http://wuqiuhao.github.io" target="_blank" rel="noopener">Hale</a>；校对：<a href="undefined">梁杰</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>得益于<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0196-diagnostic-directives.md" target="_blank" rel="noopener">SE-0196</a>，Swift 4.2 将引进 <code>#warning()</code> 和 <code>#error()</code> 两个编译指令。这两个指令允许你在编译期间合并诊断消息和抛出错误。下面这个例子来自已被确定接受的提议并且已经被实施。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#warning(<span class="string">"this is incomplete"</span>)</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> <span class="type">MY_BUILD_CONFIG</span> &amp;&amp; <span class="type">MY_OTHER_BUILD_CONFIG</span></span><br><span class="line">  #error(<span class="string">"MY_BUILD_CONFIG and MY_OTHER_BUILD_CONFIG cannot both be set"</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><code>#error</code> 指令的例子使用条件编译标志（用-D选项设置）来检察编译是否产生了配置冲突。</p><p>我(原文作者)已经写了很多关于我不喜欢在Swift中使用蛇形命名法（THINGS_LIKE_THIS）的文章。但不可避免的，开发者们都喜欢使用蛇形命名法则来定义条件编译标志。无论是 <code>MY_BUILD_CONFIG</code> 、 <code>MY_OTHER_BUILD_CONFIG</code> 还是 <code>DEBUG</code> 。虽然这是行业标准，但感觉这和Swift的美学存在冲突。</p><p>我也写过关于如何不显示使用 <code>DEBUG</code> 标志来<a href="https://ericasadun.com/2018/04/15/writing-swift-adventures-in-compiler-mods/" target="_blank" rel="noopener">检测调试条件的提议</a>。这边我附上了提议的链接，你们可以点击查看更多该提议的相关内容。</p><p>言归正传，Swift新近提出的 <code>#error</code> 和 <code>#warning</code> 指令，在当前的实践基础上有了很大进步。它们通常依赖于运行时的反馈而非编译时。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> !<span class="type">DEBUG</span></span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">"This code is incomplete. Please fix before release."</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>这个代码块中的缩进样式是 Swift 默认的，主要是为了避免条件编译块中出现轻微的<a href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming" target="_blank" rel="noopener">Pyramid of doom</a>)(金字塔厄运)。但如果把里面的代码缩进，在这个条件块的周围代码还是纵向增长的，主观上感觉有点丑。为了避免这种情况，一些编码人员采用内联方式，用最少的条件块和更简洁的方法强制编译时（而不是运行时）报错。</p><p>以下是我从 John Estropia 那发现的一个例子（他借鉴于他的同事）。他使用条件编译指令来设置 <code>TODO</code> 或 <code>FIXME</code> 等类型别名，然后在需要的地方使用它们。在 debug 环境时，编译能够通过而在 release 环境下编译就会报错：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span> </span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">typealias</span> <span class="type">TODO</span>&lt;<span class="type">T</span>&gt; = <span class="type">T</span></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Remove this later"</span>) <span class="keyword">as</span> <span class="type">TODO</span></span><br></pre></td></tr></table></figure><p>这个主意很棒。<code>TODO</code> 类型别名将支持 debug 过程中在想要注释的行末尾使用 <code>as TODO</code> ，在 release 编译环境下就会抛出异常。这确保了所有用 <code>TODO</code> 标注的点能够实现编译时反馈。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">error: <span class="type">ManyWays</span>.playground:<span class="number">5</span>:<span class="number">31</span>: error: use of undeclared type '<span class="type">TODO'</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Remove this later"</span>) <span class="keyword">as</span> <span class="type">TODO</span></span><br></pre></td></tr></table></figure><p>虽然不是很美观，但这很有效。它包含了关于代码调用的位置信息和你要发送的信息。如果我正在使用这个方法，我可能会创建一个 <code>todo</code> 方法，而不是直接使用上面的方法。在下面的例子中，我使用驼峰式命名使调用看起来更具有指令性，而不像标准的全局函数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">enum</span> <span class="title">IssueLevel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">    mildImportance,</span><br><span class="line">    moderateImportance,</span><br><span class="line">    highImportance,</span><br><span class="line">    criticalImportance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">ToDo</span><span class="params">(<span class="number">_</span> level: IssueLevel, <span class="number">_</span> string: String)</span></span> &#123;&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供编译错误、描述信息和优先级</span></span><br><span class="line"><span class="type">ToDo</span>(.highImportance, <span class="string">"Remove this later"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: ManyWays.playground:13:1: error: use of unresolved identifier 'ToDo'</span></span><br><span class="line"><span class="comment">// ToDo(.highImportance, "Remove this later")</span></span><br></pre></td></tr></table></figure><p>这种方式最大的好处就是从 debug 环境到 release 环境，只需通过 <code>#if</code> 进行判断。这种做法很诱人，只要确保全局都在需要标注的地方使用，然后在切换到 release 之前解决或移除所有的标注即可。</p><p>目前，Swift 不支持用 <code>#message</code> 指令来执行类似的任务。很多开发者将警告视为错误，他们无法在两者之间进行细微的区分。如果 <code>#warning</code> 被发布了，你就可以使用 <code>#warning</code> 实现类似“fix me”的反馈了。进一步改良的话，<code>#messageOrDie</code> （或者其他叫法，命名真的很难）可以在 debug build 时发送警告消息，在 release build 时报出错误，通过 <code>断言</code> 来判断申明是否发生。</p><p>Dave DeLong 为结构性项目语义提供了另一种方法。他介绍了一个 <code>Fatal</code> 类型为开发中一些比较常见的结果判断例如 <code>noImplemented</code>、<code>unreachable</code> 和 <code>mustOverride</code> 等提供<a href="https://forums.swift.org/t/introducing-namespacing-for-common-swift-error-scenarios/10773" target="_blank" rel="noopener">运行时线索</a>,它没有用“you need to remember to implement this”这样的提示，而是以运行时奔溃的形式，通过上报完整的位置和方法信息来解释。另一个检索被命名为 <code>silenceXcode()</code> 允许你添加你认为永远不会实现的一些方法，如果你使用了它也会报错。</p><p>Swift 仍有很大的空间来扩展这方面的支持。我不介意看到这两种方式都被添加到未来 Swift 的实现中。一种用于编译时（像 <code>#messageOrDie</code> ）另一种用于运行时（像 <code>Fatal</code> 命名空间的静态检索方法）</p><p>你们怎么看待这些？在 Swift 中还有哪些部分是元编程开发过程中（像宏）让你感到困惑的？我很想知道还有哪些已经确定发布的特性能够更好地支持开发。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了Swift4.2即将发布的
    
    </summary>
    
      <category term="iAchieved.it" scheme="https://swift.gg/categories/iAchieved-it/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>重新实现可选类型的隐式解包</title>
    <link href="https://swift.gg/2018/06/19/swift-org-blog-iuo/"/>
    <id>https://swift.gg/2018/06/19/swift-org-blog-iuo/</id>
    <published>2018-06-19T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mark Lacey，<a href="https://swift.org/blog/iuo/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-26<br>译者：<a href="undefined">灰s</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="undefined"> mmoaay</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>今年早些时候，Swift 编译器实现了一种新的可选类型隐式解包 (IUOs)，在最近的 Swift <a href="https://swift.org/download/#snapshots" target="_blank" rel="noopener">测试版本</a> 中开放使用。它实现了 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md" target="_blank" rel="noopener"> SE-0054 - Abolish ImplicitlyUnwrappedOptional Type</a>。对于 Swift 来说，这是一次重大的改变，消除了类型检测中的一些矛盾，并且阐明了处理这些值的规则，使语义保持一致且易于推理。更多信息可以阅读这条提案的 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md#motivation" target="_blank" rel="noopener">动机</a>。</p><p>主要变化是，当引用一个被声明为隐式解包可选的基础类型 <code>T</code> 时，在诊断信息中会打印 <code>T?</code>，而不是之前的 <code>T!</code>。你可能会遇到源代码兼容性问题，需要修改代码之后才能编译成功。</p><a id="more"></a><h2 id="隐式解包是声明的一部分"><a href="#隐式解包是声明的一部分" class="headerlink" title="隐式解包是声明的一部分"></a>隐式解包是声明的一部分</h2><p><em>可选类型的隐式解包</em> 在编译时会根据需要自动解包。要声明一个可选类型的隐式解包，需要将类型后面的 <code>?</code> 改成 <code>!</code>。  </p><p>在很多人的认知中，隐式解包的可选类型与常规可选类型并不属于同一个类别。在 Swift 3 中，它们也确实不一样：像 <code>var a: Int?</code>  这样的声明，会创建一个拥有 <code>Optional&lt;Int&gt;</code> 类型的 <code>a</code>；像 <code>var b: String!</code>  这样的声明，会创建一个拥有 <code>ImplicitlyUnwrappedOptional&lt;String&gt;</code> 类型的 <code>b</code> 。  </p><p>在 IUOs 的新模型中，你需要将 <code>!</code> 视为 <code>?</code> 的同义词，它只是在声明中添加一个标志让编译器知道被声明的值可以进行隐式解包。  </p><p>换句话说，对于 <code>String!</code> 的理解你可以认为是 “这个值拥有 <code>Optional&lt;String&gt;</code> 类型并且携带了信息说在需要的时候它可以被隐式的解包。”  </p><p>这种思维模型与新的实现相匹配。现在，任何地方你申明了 <code>T!</code> ，编译器都会将它看做 <code>T?</code> 类型，然后在申明的内部表示中添加一个标签使得类型检测器知道当需要的时候可以对它进行隐式解包。  </p><p>这一变化最明显的结果就是对于申明为 <code>T!</code> 的变量，你将看到关于 <code>T?</code> 的诊断而不是 <code>T!</code>。 在诊断中看到 <code>T?</code> 而不是 <code>T!</code> 可能需要一点时间去适应它，但是拥抱这一新的思维模型将会一直帮助你。</p><p><strong>为了便于理解，译者自己做了配图，展示新旧 Swift 的区别：</strong>  </p><p><img src="/img/articles/swift-org-blog-iuo/40166397-082f067e-59f1-11e8-931a-3d3d0cb892eb.png1529377151.6054707" alt="old"><br><img src="/img/articles/swift-org-blog-iuo/40166527-52d1029a-59f1-11e8-94f2-44d9dc1660ce.png1529377151.9917665" alt="new"></p><h2 id="源代码兼容性"><a href="#源代码兼容性" class="headerlink" title="源代码兼容性"></a>源代码兼容性</h2><h3 id="强制转换为-T"><a href="#强制转换为-T" class="headerlink" title="强制转换为 T!"></a>强制转换为 <code>T!</code></h3><p>按照 SE-0054 提案，<code>as T!</code> 这样的强制转换已经不再被允许。</p><p>在 Swift 4.1 中，这种形式的强制转换会显示一个弃用警告。多数情况下，使用 <code>as T?</code> 来替代 <code>as T!</code> 或者直接移除该强制转换即可编译成功。</p><p>如果这两种方法都不管用，新的实现中也有对应的特殊处理。具体来说，如果遇到 <code>x as T!</code>，编辑器首先会尝试 <code>x as T?</code>。如果失败，编辑器会用 <code>(x as T?)!</code> 来进行强制解包。</p><p>但是，这种形式的强制转换仍然不推荐使用，在将来的 Swift 版本中有可能会移除这种特殊处理。</p><h3 id="在类型中使用"><a href="#在类型中使用" class="headerlink" title="在类型中使用 !"></a>在类型中使用 <code>!</code></h3><p>强制转换为 <code>T!</code> 作为一个特例存在于一个更普遍的问题中：使用 <code>!</code> 作为类型的一部分。  </p><p>可以在下面三个地方使用 <code>!</code> 作为类型中的一部分：</p><pre><code>1. 属性声明2. 方法的参数类型声明3. 方法的返回值类型声明</code></pre><p>在其它地方使用 <code>!</code> 将被标记成一个错误。Swift 4.1 之前的版本就已经实现了这个检测，但是遗漏了一些情况：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn: (<span class="type">Int</span>!) -&gt; <span class="type">Int</span>! = ...   <span class="comment">// error: not a function declaration!</span></span><br></pre></td></tr></table></figure><p>这里 Swift 4.1 显示了弃用警告，但是仍然默认了隐式解包的行为。在近期测试版本的新实现中，编译器会将 <code>!</code> 视为 <code>?</code>，同时在诊断信息中告诉你发生了什么，以及这种用法会被废弃。  </p><p><strong>译者配图：</strong>  </p><p><img src="/img/articles/swift-org-blog-iuo/40213466-2dd070ba-5a88-11e8-888a-0ca5066f4d36.png1529377152.1436236" alt="old-2"><br><img src="/img/articles/swift-org-blog-iuo/40213471-336db9ba-5a88-11e8-9b8e-11287e1bfccd.png1529377152.292037" alt="new-2"></p><h3 id="隐式解包可选类型的-map-方法"><a href="#隐式解包可选类型的-map-方法" class="headerlink" title="隐式解包可选类型的 map 方法"></a>隐式解包可选类型的 map 方法</h3><p>以前的代码是这样的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> values: [<span class="type">Any</span>]! = [<span class="type">C</span>()]</span><br><span class="line"><span class="keyword">let</span> transformed = values.<span class="built_in">map</span> &#123; $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">C</span> &#125;</span><br></pre></td></tr></table></figure><p>上面的代码会对 <code>values</code> 强制解包，然后对数组调用 <code>map(_:)</code> 方法。即使你在 <code>ImplicitlyUnwrappedOptional</code> 的扩展中定义了 <code>map(_:)</code> 方法也无法覆盖默认方法，因为它并不会像你想的那样，在 <code>ImplicitlyUnwrappedOptional</code> 中执行方法查找。  </p><p>在新的实现中，因为 <code>!</code> 和 <code>?</code> 是同义词，编译器会尝试使用 <code>Optional&lt;T&gt;</code> 中的 <code>map(_:)</code> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> transformed = values.<span class="built_in">map</span> &#123; $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">C</span> &#125; <span class="comment">// calls Optional.map; $0 has type [Any]</span></span><br></pre></td></tr></table></figure><p>并且显示： <code>warning: cast from &#39;[Any]&#39; to unrelated type &#39;C&#39; always fails</code>。  </p><p>这样从语义上就通过了类型检测，我们不需要对 <code>values</code> 进行强制解包。  </p><p>你可以使用可选链制造一个可选的数组来解决这个问题：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> transformed = values?.<span class="built_in">map</span> &#123; $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">C</span> &#125; <span class="comment">// transformed 的类型是 Optional&lt;[C]&gt;</span></span><br></pre></td></tr></table></figure><p>或者对 <code>values</code> 进行强制解包来得到一个数组：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> transformed = values!.<span class="built_in">map</span> &#123; $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">C</span> &#125; <span class="comment">// transformed has type [C]</span></span><br></pre></td></tr></table></figure><p>注意，大部分情况下你不需要修改代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values: [<span class="type">Int</span>]! = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> transformed = values.<span class="built_in">map</span> &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>它将继续按照老版本的方式工作，因为在这里将表达式看作 <code>Optional</code> 执行 <code>map(_:)</code> 方法无法进行类型检测。取而代之，我们会对 <code>values</code> 进行强制解包，并对返回的数组执行 <code>map(_:)</code> 方法。</p><h3 id="无法推断类型"><a href="#无法推断类型" class="headerlink" title="无法推断类型"></a>无法推断类型</h3><p>因为隐式解包可选不再是一个类型，所以不能被推断成一种类型或者类型的任何部分。</p><p>在下面的例子中，尽管右边的赋值包含一个被声明为隐式解包的值，左边类型推断仅表示这个值（或者返回值）是一个可选类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">Int</span>!</span><br><span class="line"><span class="keyword">let</span> y = x   <span class="comment">// y has type Int?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forcedResult</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>! &#123; ... &#125;</span><br><span class="line"><span class="keyword">let</span> getValue = forcedResult    <span class="comment">// getValue 的类型是 () -&gt; Int?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">id</span>&lt;T&gt;<span class="params">(<span class="number">_</span> value: T)</span></span> -&gt; <span class="type">T</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line"><span class="keyword">let</span> z = id(x)   <span class="comment">// z 的类型是 Int?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span>&lt;T&gt;<span class="params">(<span class="number">_</span> fn: <span class="params">()</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span> &#123; <span class="keyword">return</span> fn() &#125;</span><br><span class="line"><span class="keyword">let</span> w: <span class="type">Int</span> = apply(forcedResult)    <span class="comment">// 报错，因为 apply() 返回的是 Int?</span></span><br></pre></td></tr></table></figure><p>还有一些特殊的实例会遇到这个问题，比如 <code>AnyObject</code> 的查找操作，<code>try?</code> 和 <code>switch</code>。</p><h4 id="AnyObject-的查找操作"><a href="#AnyObject-的查找操作" class="headerlink" title="AnyObject 的查找操作"></a>AnyObject 的查找操作</h4><p><code>AnyObject</code> 的查找结果会被当作一个隐式解包的可选类型。如果你查找一个本身就被声明成隐式解包的属性，那么表达式现在就有两层隐式解包 ( <code>property</code> 被声明为 <code>UILabel!</code>)：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLabel</span><span class="params">(object: AnyObject)</span></span> -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> object.property <span class="comment">// forces both optionals, resulting in a UILabel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if let</code> 和 <code>guard let</code> 仅能解包一层可选属性。  </p><p>在下面的例子中，之前的 Swift 版本在经过 <code>if let</code> 进行一层解包之后，推测出 <code>label</code> 的属性为 <code>UILabel!</code>。在测试版本中 Swift 将推测出 <code>UILabel?</code> ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// label is inferred to be UILabel?</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> label = object.property &#123; </span><br><span class="line">   <span class="comment">// Error due to passing a UILabel? where a UILabel is expected</span></span><br><span class="line">  functionTakingLabel(label)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用一个明确的类型来修复这个问题：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Implicitly unwrap object.property due to explicit type.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> label: <span class="type">UILabel</span> = object.property &#123;</span><br><span class="line">  functionTakingLabel(label) <span class="comment">// okay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="try"><a href="#try" class="headerlink" title="try?"></a><code>try?</code></h4><p>类似的，<code>try?</code> 会添加一层可选性，所以当对一个返回值为隐式可选类型的方法使用 <code>try?</code> 时，你可能会发现现在需要更改代码来显式对两层可选性进行解包。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span>! &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x = <span class="keyword">try</span>? test() &#123;</span><br><span class="line">  <span class="keyword">let</span> y: <span class="type">Int</span> = x    <span class="comment">// error: x is an Int?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x: <span class="type">Int</span> = <span class="keyword">try</span>? test() &#123; <span class="comment">// explicitly typed as Int</span></span><br><span class="line">  <span class="keyword">let</span> y: <span class="type">Int</span> = x    <span class="comment">// okay, x is an Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x = <span class="keyword">try</span>? test(), <span class="keyword">let</span> y = x &#123; <span class="comment">// okay, x is Int?, y is Int</span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a><code>switch</code></h4><p>Swift 4.1 可以编译下面这样的代码，因为它将 <code>output</code> 作为隐式解包对待：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchExample</span><span class="params">(input: String!)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> input &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"okay"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fine"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> output:</span><br><span class="line">    <span class="keyword">return</span> output  <span class="comment">// 隐式解包可选值，返回 String</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，如果用下面这种方法实现这个例子，无法编译成功：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchExample</span><span class="params">(input: String!)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> output = input  <span class="comment">// output is inferred to be String?</span></span><br><span class="line">  <span class="keyword">switch</span> input &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"okay"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fine"</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> output  <span class="comment">// error: value of optional type 'String?' not unwrapped;</span></span><br><span class="line">                   <span class="comment">// did you mean to use '!' or '?'?</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在新的实现中，第一个例子中的 <code>output</code> 将被推断成没有隐式解包的 <code>String?</code> 类型。  </p><p>下面是一种修复方法，对值进行强制解包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> output:</span><br><span class="line">   <span class="keyword">return</span> output!</span><br></pre></td></tr></table></figure><p>另一种修复方法是对 non-nil 和 nil 进行显式的模式匹配：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchExample</span><span class="params">(input: String!)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> input &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"okay"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fine"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> output?: <span class="comment">// non-nil case</span></span><br><span class="line">    <span class="keyword">return</span> output   <span class="comment">// okay; output is a String</span></span><br><span class="line">  <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;empty&gt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用可选类型和隐式解包可选类型重载输入输出参数"><a href="#使用可选类型和隐式解包可选类型重载输入输出参数" class="headerlink" title="使用可选类型和隐式解包可选类型重载输入输出参数"></a>使用可选类型和隐式解包可选类型重载输入输出参数</h3><p>如果在 Swift 4.1 中尝试去重载一个函数并且 in-out 参数是隐式解包可选类型，会显示一个弃用警告</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someKindOfOptional</span><span class="params">(<span class="number">_</span>: <span class="keyword">inout</span> Int?)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Warning in Swift 4.1.  Error in new implementation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someKindOfOptional</span><span class="params">(<span class="number">_</span>: <span class="keyword">inout</span> Int!)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Swift 4.1 中，如果 in-out 参数是可选的，那可以直接传入一个隐式解包可选类型的值，反之亦然。这样就可以删除上面的第二个重载（假设两个函数实现完全一致）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someKindOfOptional</span><span class="params">(<span class="number">_</span>: <span class="keyword">inout</span> Int?)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span>! = <span class="number">1</span></span><br><span class="line">someKindOfOptional(&amp;i)   <span class="comment">// 完全没问题，i 的类型是 Optional&lt;Int&gt;</span></span><br></pre></td></tr></table></figure><p>在之后的新版本中，由于 <code>Int!</code> 与 <code>Int?</code> 是同义词，重载的可选性不再有意义。因此，和上面例子中类似的重载都会报错，并且第二个重载（声明为 <code>Int!</code>）必须被删除。</p><h3 id="ImplicitlyUnwrappedOptional-扩展"><a href="#ImplicitlyUnwrappedOptional-扩展" class="headerlink" title="ImplicitlyUnwrappedOptional 扩展"></a>ImplicitlyUnwrappedOptional 扩展</h3><p>现在 <code>ImplicitlyUnwrappedOptional&lt;T&gt;</code> 只是 <code>Optional&lt;T&gt;</code> 的别名，而且不能直接使用，所以尝试给它创建 <code>extension</code> 会编译失败：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1:11: error: 'ImplicitlyUnwrappedOptional' has been renamed to 'Optional'</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImplicitlyUnwrappedOptional</span> </span>&#123;</span><br></pre></td></tr></table></figure><h3 id="nil-桥接"><a href="#nil-桥接" class="headerlink" title="nil 桥接"></a>nil 桥接</h3><p>对 <code>nil</code> 类型的值进行桥接时不会报运行时错误，而是把 <code>nil</code> 桥接为 <code>NSNull</code> 。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>: <span class="title">NSObject</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iuoElement: <span class="type">C</span>! = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> array: [<span class="type">Any</span>] = [iuoElement <span class="keyword">as</span> <span class="type">Any</span>]</span><br><span class="line"><span class="keyword">let</span> ns = array <span class="keyword">as</span> <span class="type">NSArray</span></span><br><span class="line"><span class="keyword">let</span> element = ns[<span class="number">0</span>] <span class="comment">// Swift 4.1: Fatal error: Attempt to bridge</span></span><br><span class="line">                    <span class="comment">// an implicitly unwrapped optional containing nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = element <span class="keyword">as</span>? <span class="type">NSNull</span>, value == <span class="type">NSNull</span>() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"pass"</span>)     <span class="comment">// 新版本中会执行到这里</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"fail"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>隐式解包的可选类型已经被重新实现，它们不再是 <code>Optional&lt;T&gt;</code> 的特殊形式。因此，类型检测的一致性将会更好，编译器的特殊情况也会更少。删除这些特殊情况会减少处理声明时的错误数量。  </p><p>导入的 Object-C API 可能会返回隐式解包的值。你可能会发现在声明 <code>@IBOutlet</code> 属性（或者任何初始化之前不会使用的值）时使用隐式解包会更加方便。不过总体来说，隐式解包能不用最好别用，改用 <code>if let</code> 和 <code>guard let</code> 来显式解包。如果确定有值，就用 <code>!</code> 来显式强制解包。</p><h3 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h3><p>如果你对这篇文章有疑问或者想法，可以在 Swift 论坛中参与<a href="https://forums.swift.org/t/swift-org-blog-reimplementation-of-implicitly-unwrapped-optionals/12175" target="_blank" rel="noopener">相关讨论</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      重新实现隐式解包的原因，会碰到问题。
    
    </summary>
    
      <category term="swift.org" scheme="https://swift.gg/categories/swift-org/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 中内存释放的并发问题</title>
    <link href="https://swift.gg/2018/06/11/friday-qa-2015-05-29-concurrent-memory-deallocation-in-the-objective-c-runtime/"/>
    <id>https://swift.gg/2018/06/11/friday-qa-2015-05-29-concurrent-memory-deallocation-in-the-objective-c-runtime/</id>
    <published>2018-06-11T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-05-29-concurrent-memory-deallocation-in-the-objective-c-runtime.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-06-05<br>译者：<a href="https://github.com/YangGao1991" target="_blank" rel="noopener">阳仔</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Objective-C Runtime 是绝大多数 Mac 和 iOS 程序代码的核心。Runtime 的核心就是 <code>objc_msgSend</code> 函数，这个函数最关键的就是方法缓存。我在这篇文章中将会阐述一下，Apple 是如何在不影响性能的情况下，以线程安全的方式来重新分配缓存大小、释放方法缓存。</p><a id="more"></a><h3 id="消息传递的概念"><a href="#消息传递的概念" class="headerlink" title="消息传递的概念"></a>消息传递的概念</h3><p><code>objc_msgSend</code> 会查找被调用的方法的实现，然后去执行。从概念上讲，查找方法的过程如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IMP lookUp(id obj, SEL selector) &#123;</span><br><span class="line">    Class c = object_getClass(obj);</span><br><span class="line"></span><br><span class="line">    while(c) &#123;</span><br><span class="line">        for(int i = 0; i &lt; c-&gt;numMethods; i++) &#123;</span><br><span class="line">            Method m = c-&gt;methods[i];</span><br><span class="line">            if(m.selector == selector) &#123;</span><br><span class="line">                return m.imp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c = c-&gt;superclass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _objc_msgForward;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到源码的版权，一些变量名做了修改。如果你想看看真实的实现代码，可以查看 Objective-C runtime 的<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">开源代码</a>。</p><h3 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h3><p>绝大部分 Objective-C 的代码都用到了消息传递。如果每一次消息传递都需要进行一次完整查找的话，速度将会非常慢。</p><p>解决方法是建立方法的缓存。每个类持有一个哈希表，将方法名映射到方法的实现。这个哈希表需要尽可能地提高读取效率，<code>objc_msgSend</code> 函数使用精心构造的汇编代码来快速实现这个哈希表的查询。这样，在有缓存的情况下，一条消息的传递只需要几纳秒的时间。虽然每条消息第一次被传递的时候还是很慢，但这之后，就会变得很快。</p><p>我们所说的“缓存”，通常来说是指为了加快多次访问最近使用过的资源的速度，而开辟的一块有限大小的区域。例如，你可能会把从网络上下载的图片缓存起来，那么接下来的一段时间，如果再需要使用到这些图片的话，就不需要再去从网络下载了。尽管如此，你也不会希望缓存占用太多的内存空间。所以你可能会限制缓存图片的最大数量。当缓存的图片达到最大数量后，每次缓存新的图片，就会把最旧的那个从缓存中去掉。</p><p>这对于大部分问题来说是一个不错的做法，但它也可能导致性能上的损耗。比如，你设定图片缓存最多缓存 40 张图片，但在某种情况下，你的应用需要一直循环使用 41 张图片，这时你会发现缓存完全不起作用！</p><p>对于我们自己的应用，可以通过测试，调整缓存的大小来避免出现这种情况，但 Objective-C 的 runtime 并不能这样做。方法缓存对性能来说非常重要，并且每个方法的缓存占用的空间都很小，因此，runtime 并不会对缓存空间的大小进行限制，而是会在需要时随时扩大缓存空间，来缓存所有发送过的消息。</p><p>请注意，runtime 的方法缓存有时确实是会刷新的。比如当将新的代码加载到进程时，或者修改了一个类的方法列表时，可能会导致某些缓存的数据失效。这时，相应的旧的缓存数据就会被删除，并重新写入新的缓存数据。</p><h3 id="改变缓存大小，销毁，以及线程问题"><a href="#改变缓存大小，销毁，以及线程问题" class="headerlink" title="改变缓存大小，销毁，以及线程问题"></a>改变缓存大小，销毁，以及线程问题</h3><p>改变缓存大小，从概念上来说比较简单，比如这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *newCache = <span class="built_in">malloc</span>(newSize);</span><br><span class="line">copyEntries(newCache, class-&gt;cache);</span><br><span class="line"><span class="built_in">free</span>(class-&gt;cache);</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">newCache</span>;</span></span><br></pre></td></tr></table></figure><p>实际上，Objective-C runtime 在这个基础上又对代码进行了精简：旧的缓存数据并没有被复制到新的缓存空间中！毕竟，这只是一块缓存空间而已，并没有要求一定要保留其中的数据。在消息发送的时候，新的数据自然又会被缓存下来。因此，事实上，代码是这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(class-&gt;cache);</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br></pre></td></tr></table></figure><p>如果只讲单线程，需要做的就是这么多了，这篇文章到这也可以结束了。但是，Objective-C runtime 肯定要支持多线程操作，这就意味着所有的代码必须保证线程安全。每一个类的缓存数据都可能会被多个线程同时操作，因此，这里的代码必须谨慎处理，才能满足线程安全的条件。</p><p>像上面的写法自然不行。在释放了旧的缓存空间，并且还没有正确赋值新开辟的空间的这段“窗口时间”中，另一个线程就可能访问到非法的地址，这会导致其访问到垃圾数据。此外，如果那块内存没有进行映射的话，就会造成闪退。</p><p>我们如何解决这个问题？典型的做法是使用线程锁，就像这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lock(class-&gt;lock);</span><br><span class="line"><span class="built_in">free</span>(class-&gt;cache);</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line">unlock(class-&gt;lock);</span><br></pre></td></tr></table></figure><p>所有访问都必须由锁控制，包括读操作。这样就意味着，<code>objc_msgSend</code> 方法可能需要获取线程锁，访问缓存空间，然后释放锁。考虑到缓存的查找本身只会占用几纳秒的时间，每次获取、释放锁会增加很多时间的损耗，对性能的影响太大了。</p><p>我们也可以尝试用另外的方法去解决“窗口时间”，比如先分配和赋值新的内存空间，再销毁旧的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line"><span class="built_in">free</span>(oldCache);</span><br></pre></td></tr></table></figure><p>这也许有点用，但并没有解决问题。另一个线程也可能先获取到旧缓存的指针，然后在访问内存前被系统中断。然后，旧的缓存被销毁后，另外的线程又重新启动，这就导致了和前面一样的问题。</p><p>如果我们加一个延迟呢？比如说：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line">after(<span class="number">5</span> <span class="comment">/* seconds */</span>, ^&#123;</span><br><span class="line">    <span class="built_in">free</span>(oldCache);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这似乎是可行的，但还是可以想到一种情况，就是一个线程刚好被中断足够久，以至于五秒的延迟结束了才重新启动。虽然这样的情况及其罕见，但并不是毫无可能。</p><p>如果不是设置一个固定的延迟时间，而是确定等到“窗口时间”结束呢。我们可以给 <code>objc_msgSend</code> 函数增加一个计数器，就像这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gInMsgSend++;</span><br><span class="line">lookUpCache(class-&gt;cache);</span><br><span class="line">gInMsgSend--;</span><br></pre></td></tr></table></figure><p>正确的线程安全的做法需要对计数器使用原子性，以及使用内存屏障，来保证互相依赖的缓存的读取/存储正确进行。这里我们假设计数器已经满足这些条件。</p><p>有了计数器，重新分配缓存的代码就会像这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line"><span class="keyword">while</span>(gInMsgSend)</span><br><span class="line">    ; <span class="comment">// spin</span></span><br><span class="line"><span class="built_in">free</span>(oldCache);</span><br></pre></td></tr></table></figure><p>注意，我们并不需要阻塞 <code>objc_msgSend</code> 执行，就能让这段代码正确工作。在给缓存的指针重新赋值后，一旦某一时刻，确认没有方法在调用 <code>objc_msgSend</code> 了，就可以将旧的缓存空间释放。另一个线程有可能会在旧缓存空间被释放的时候调用 <code>objc_msgSend</code> ，但这个新的调用不会访问到旧的缓存的指针，因此是安全的。</p><p>然而，轮询操作效率较低，且不优雅。事实上，释放旧的缓存空间并不是十分要紧的一件事。内存能够正确释放当然是好的，但晚点再释放也没有什么大不了的。因此，我们可以不使用轮询，而是持有一份未释放的缓存的记录表。每次需要释放缓存时，就清空所有待释放的缓存：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line"></span><br><span class="line">append(gOldCachesList, oldCache);</span><br><span class="line"><span class="keyword">if</span>(!gInMsgSend) &#123;</span><br><span class="line">    <span class="keyword">for</span>(cache in gOldCachesList) &#123;</span><br><span class="line">        <span class="built_in">free</span>(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    gOldCachesList.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一条消息正在传递的话，那这里并不会立刻清空旧的缓存。但没关系，当下次时机来临时，比如消息传递结束或未来的某个时间点，这些过期的缓存都会被清空。</p><p>这个版本已经很接近 Objective-C runtime 的源码了。</p><h3 id="零消耗的标志位"><a href="#零消耗的标志位" class="headerlink" title="零消耗的标志位"></a>零消耗的标志位</h3><p>消息传递中的两部分存在着明显的不同。<code>objc_msgSend</code> 可能每秒钟需要运行数百万次，因此速度必须足够快，最好单次调用只消耗几纳秒的时间。然而，重新分配缓存却是个比较不频繁的操作，而且随着应用的持续运行，该操作也会变得越来越少。一旦应用达到一个稳定状态，不再加载新的代码，不再修改消息列表，这时缓存也就达到了它们所需的最大容量，再也不需要重新分配缓存了。在这之前，可能会发生成百上千次的缓存的重新分配，但相比于 <code>objc_msgSend</code> 来说，调用次数还是很少，因此对性能的要求也很低。</p><p>因此，应当尽可能少的去干预消息传递的过程，尽管这样会让缓存释放的过程变慢。如果在 <code>objc_msgSend</code> 阶段能减少一个 CPU 周期，那么即使每次缓存释放操作都会消耗一百万个 CPU 周期，那也能极大提高效率。</p><p>这么说来，哪怕设置一个全局的计数器，性能损耗的代价还是太高。那意味着 <code>objc_msgSend</code> 过程中需要增加两次内存访问，从而增加很多性能开销。而需要使用原子性以及内存屏障只会让这变得更糟。幸运的是，Objective-C runtime 能够将 <code>objc_msgSend</code> 的性能损耗降到零，代价是会让缓存释放的过程变得慢很多。</p><p>在上面的代码中，我们设置全局计数器的目的是追踪是否有线程处于消息传递的过程中。事实上，线程本身知道自己正在运行什么代码：程序计数器。这是一个记录当前指令的内存地址的 CPU 寄存器。我们可以用它来代替全局的计数器，来检查每个线程是否处于 <code>objc_msgSend</code> 当中。如果所有线程都不处于 <code>objc_msgSend</code> 中，那么旧的缓存就可以被安全释放。这种方法的实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ThreadsInMsgSend</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(thread in GetAllThreads()) &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> pc = thread.GetPC();</span><br><span class="line">        <span class="keyword">if</span>(pc &gt;= objc_msgSend_startAddress &amp;&amp; pc &lt;= objc_msgSend_endAddress) &#123;</span><br><span class="line">            <span class="keyword">return</span> YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line"></span><br><span class="line">append(gOldCachesList, oldCache);</span><br><span class="line"><span class="keyword">if</span>(!ThreadsInMsgSend()) &#123;</span><br><span class="line">    <span class="keyword">for</span>(cache in gOldCachesList) &#123;</span><br><span class="line">        <span class="built_in">free</span>(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    gOldCachesList.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objc_msgSend</code> 并不需要额外做任何事情，它可以不用考虑设置标志位，直接访问缓存：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lookUpCache(class-&gt;cache);</span><br></pre></td></tr></table></figure><p>缓存释放的代码效率很低，因为它需要检查进程中所有线程的状态。但这样 <code>objc_msgSend</code> 可以做到与单线程环境中同样高的效率，这是一个值得付出的代价。这就是 Apple 的 runtime 源码实现方式。</p><h3 id="真实代码"><a href="#真实代码" class="headerlink" title="真实代码"></a>真实代码</h3><p>具体的实现可以查看 runtime 源码 <a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-cache.mm" target="_blank" rel="noopener">objc-cache.mm</a> 中的 <code>_collecting_in_critical</code> 函数。</p><p>需要使用程序计数器的入口和出口位置被储存在全局变量中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OBJC_EXPORT <span class="keyword">uintptr_t</span> objc_entryPoints[];</span><br><span class="line">OBJC_EXPORT <span class="keyword">uintptr_t</span> objc_exitPoints[];</span><br></pre></td></tr></table></figure><p>事实上，<code>objc_msgSend</code> 有多种实现方式（比如返回 struct 类型），内部的 <code>cache_getImp</code> 也会直接访问缓存。这些都需要在缓存释放的时候被检查。</p><p><code>_collecting_in_critical</code> 函数没有入参，返回一个 <code>int</code> 类型，被当做一个布尔类型的标志位，指明是否有线程处于关键的函数中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _collecting_in_critical(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>我会跳过该函数中不重要的部分，只介绍最关键的部分。如果你想阅读完整代码，可以查看 <a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-cache.mm" target="_blank" rel="noopener">opensource.apple.com</a>。</p><p>获取线程信息的 API 处于 mach 层。<code>task_threads</code> 能够获取到指定任务（进程在 mach 中的表示）中的所有线程，这里用它来获取当前进程中的线程：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret = task_threads(mach_task_self(), &amp;threads, &amp;number);</span><br></pre></td></tr></table></figure><p>函数会在 <code>threads</code> 中保存 <code>thread_t</code> 数组，在 <code>number</code> 中保存线程的数量。然后会遍历所有线程：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; number; count++)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>获取一个线程的程序计数器是在另外一个单独的函数中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pc = _get_pc_for_thread (threads[count]);</span><br></pre></td></tr></table></figure><p>然后，程序会遍历所有的入口和出口，并逐个进行判断：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (region = <span class="number">0</span>; objc_entryPoints[region] != <span class="number">0</span>; region++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pc &gt;= objc_entryPoints[region]) &amp;&amp;</span><br><span class="line">            (pc &lt;= objc_exitPoints[region])) </span><br><span class="line">        &#123;</span><br><span class="line">            result = TRUE;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历结束后，将结果返回给调用者：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_get_pc_for_thread</code> 函数是怎么工作的呢？它只是简单地调用 <code>thread_get_state</code> 函数来获得目标线程的寄存器状态。之所以要放到一个单独的函数中，是因为寄存器状态的结构体是与具体架构相关的，不同架构都有不同的寄存器。也就是说，这个函数需要对每个支持的架构有一套单独的实现，尽管这些实现差别不大。下面是 x86-64 下的实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> _get_pc_for_thread(<span class="keyword">thread_t</span> thread)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">x86_thread_state64_t</span>            state;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = x86_THREAD_STATE64_COUNT;</span><br><span class="line">    <span class="keyword">kern_return_t</span> okay = thread_get_state (thread, x86_THREAD_STATE64, (<span class="keyword">thread_state_t</span>)&amp;state, &amp;count);</span><br><span class="line">    <span class="keyword">return</span> (okay == KERN_SUCCESS) ? state.__rip : PC_SENTINEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rip 是 x86-64 下程序计数器的寄存器名字。“R”代表“register”，“IP”代表“instruction pointer”。</p><p>上面所说的入口和出口的代码位置，与其函数一同定义在汇编文件中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.private_extern _objc_entryPoints</span><br><span class="line">_objc_entryPoints:</span><br><span class="line">    .quad   _cache_getImp</span><br><span class="line">    .quad   _objc_msgSend</span><br><span class="line">    .quad   _objc_msgSend_fpret</span><br><span class="line">    .quad   _objc_msgSend_fp2ret</span><br><span class="line">    .quad   _objc_msgSend_stret</span><br><span class="line">    .quad   _objc_msgSendSuper</span><br><span class="line">    .quad   _objc_msgSendSuper_stret</span><br><span class="line">    .quad   _objc_msgSendSuper2</span><br><span class="line">    .quad   _objc_msgSendSuper2_stret</span><br><span class="line">    .quad   <span class="number">0</span></span><br><span class="line"></span><br><span class="line">.private_extern _objc_exitPoints</span><br><span class="line">_objc_exitPoints:</span><br><span class="line">    .quad   LExit_cache_getImp</span><br><span class="line">    .quad   LExit_objc_msgSend</span><br><span class="line">    .quad   LExit_objc_msgSend_fpret</span><br><span class="line">    .quad   LExit_objc_msgSend_fp2ret</span><br><span class="line">    .quad   LExit_objc_msgSend_stret</span><br><span class="line">    .quad   LExit_objc_msgSendSuper</span><br><span class="line">    .quad   LExit_objc_msgSendSuper_stret</span><br><span class="line">    .quad   LExit_objc_msgSendSuper2</span><br><span class="line">    .quad   LExit_objc_msgSendSuper2_stret</span><br><span class="line">    .quad   <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>_collecting_in_critical</code> 的用法和上面我们假设的例子很相似。它在释放缓存之前被调用。事实上，runtime 有两种工作模式：一种是如果其他线程正在调用相关函数的话，就把垃圾内存的清理工作留到下一次调用；另一种是一直轮询，直到确认没有线程正在调用，然后再进行销毁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Synchronize collection with objc_msgSend and other cache readers</span></span><br><span class="line"><span class="keyword">if</span> (!collectALot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_collecting_in_critical ()) &#123;</span><br><span class="line">        <span class="comment">// objc_msgSend (or other cache reader) is currently looking in</span></span><br><span class="line">        <span class="comment">// the cache and might still be using some garbage.</span></span><br><span class="line">        <span class="keyword">if</span> (PrintCaches) &#123;</span><br><span class="line">            _objc_inform (<span class="string">"CACHES: not collecting; "</span></span><br><span class="line">                          <span class="string">"objc_msgSend in progress"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No excuses.</span></span><br><span class="line">    <span class="keyword">while</span> (_collecting_in_critical()) </span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free garbage here</span></span><br></pre></td></tr></table></figure><p>第一种将垃圾内存留到下一次调用时清理的模式，是在正常的重新分配缓存大小时采用；第二种始终清理垃圾内存的模式，是在需要刷新所有类的所有缓存时使用，因为这样往往会产生大量的垃圾内存。以我阅读代码来看，这种情况只会在开启一项日志调试功能时发生。日志调试会将所有的消息发送记录到文件中，消息缓存会影响这一日志，因此需要全部刷新。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>性能和线程安全经常会互相冲突。不同部分的代码对同一块内存的访问方式往往不同，也就允许我们以更加有效率的方式来实现线程安全。方式之一是用一个全局标志位或者计数器来指明对内存的改动操作是否安全。在 Objective-C runtime 中，Apple 更进一步，使用了各个线程的程序计数器来判断线程是否正在进行不安全的操作。这是一个很专业的案例，这种做法想要用到其他地方也不是很有用，但研究它的原理本身就是一件很有意思的事情。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-05-29-concurrent-memory-deallocation-in-the-objective-c-runtime.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2015-06-05&lt;br&gt;译者：&lt;a href=&quot;https://github.com/YangGao1991&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阳仔&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://weibo.com/1743643682/profile?topnav=1&amp;amp;wvr=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;liberalism&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Objective-C Runtime 是绝大多数 Mac 和 iOS 程序代码的核心。Runtime 的核心就是 &lt;code&gt;objc_msgSend&lt;/code&gt; 函数，这个函数最关键的就是方法缓存。我在这篇文章中将会阐述一下，Apple 是如何在不影响性能的情况下，以线程安全的方式来重新分配缓存大小、释放方法缓存。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的锁和线程安全</title>
    <link href="https://swift.gg/2018/06/07/friday-qa-2015-02-06-locks-thread-safety-and-swift/"/>
    <id>https://swift.gg/2018/06/07/friday-qa-2015-02-06-locks-thread-safety-and-swift/</id>
    <published>2018-06-07T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-02-06-locks-thread-safety-and-swift.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-02-06<br>译者：<a href="undefined">Lefe_x</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>在 Swift 中有个有趣的现象：它没有与线程相关的语法，也没有明确的互斥锁/锁（<code>mutexes/locks</code>）概念，甚至 Objective-C 中有的 <code>@synchronized</code> 和原子属性它都没有。幸运的是，苹果系统的 API 可以非常容易地应用到 Swift 中。今天，我会介绍这些 API 的用法以及从 Objective-C 过渡的一些问题，这些灵感都来源于 Cameron Pulsford。</p><a id="more"></a><h2 id="快速回顾一下锁"><a href="#快速回顾一下锁" class="headerlink" title="快速回顾一下锁"></a>快速回顾一下锁</h2><p>锁（<code>lock</code>）或者互斥锁（<code>mutex</code>）是一种结构，用来保证一段代码在同一时刻只有一个线程执行。它们通常被用来保证多线程访问同一可变数据结构时的数据一致性。主要有下面几种锁：</p><ul><li>阻塞锁（<code>Blocking locks</code>）：常见的表现形式是当前线程会进入休眠，直到被其他线程释放。</li><li>自旋锁（<code>Spinlocks</code>）：使用一个循环不断地检查锁是否被释放。如果等待情况很少话这种锁是非常高效的，相反，等待情况非常多的情况下会浪费 CPU 时间。</li><li>读写锁（<code>Reader/writer locks</code>）：允许多个读线程同时进入一段代码，但当写线程获取锁时，其他线程（包括读取器）只能等待。这是非常有用的，因为大多数数据结构读取时是线程安全的，但当其他线程边读边写时就不安全了。</li><li>递归锁（<code>Recursive locks</code>）：允许单个线程多次获取相同的锁。非递归锁被同一线程重复获取时可能会导致死锁、崩溃或其他错误行为。</li></ul><h2 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h2><p>苹果提供了一系列不同的锁 API，下面列出了其中一些： </p><ul><li><code>pthread_mutex_t</code></li><li><code>pthread_rwlock_t</code></li><li><code>dispatch_queue_t</code></li><li><code>NSOperationQueue</code> 当配置为 <code>serial</code> 时</li><li><code>NSLock</code></li><li><code>OSSpinLock</code></li></ul><p>除此之外，Objective-C 提供了 <code>@synchronized</code> 语法结构，它其实就是封装了 <code>pthread_mutex_t</code> 。与其他 API 不同的是，<code>@synchronized</code> 并未使用专门的锁对象，它可以将任意 Objective-C 对象视为锁。<code>@synchronized(someObject)</code> 区域会阻止其他 <code>@synchronized(someObject)</code> 区域访问同一对象指针。不同的 API 有不同的行为和能力： </p><ul><li><code>pthread_mutex_t</code> 是一个可选择性地配置为递归锁的阻塞锁；</li><li><code>pthread_rwlock_t</code> 是一个阻塞读写锁；</li><li><code>dispatch_queue_t</code> 可以用作阻塞锁，也可以通过使用 barrier block 配置一个同步队列作为读写锁，还支持异步执行加锁代码；</li><li><code>NSOperationQueue</code> 可以用作阻塞锁。与 <code>dispatch_queue_t</code> 一样，支持异步执行加锁代码。</li><li><code>NSLock</code> 是 Objective-C 类的阻塞锁，它的同伴类 <code>NSRecursiveLock</code> 是递归锁。</li><li><code>OSSpinLock</code> 顾名思义，是一个自旋锁。</li></ul><p>最后，<code>@synchronized</code> 是一个阻塞递归锁。</p><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>注意，<code>pthread_mutex_t</code>，<code>pthread_rwlock_t</code> 和 <code>OSSpinLock</code> 是值类型，而不是引用类型。这意味着如果你用 <code>=</code> 进行赋值操作，实际上会复制一个副本。这会造成严重的后果，因为这些类型无法复制！如果你不小心复制了它们中的任意一个，这个副本无法使用，如果使用可能会直接崩溃。这些类型的 <code>pthread</code> 函数会假定它们的内存地址与初始化时一样，因此如果将它们移动到其他地方就可能会出问题。<code>OSSpinLock</code> 不会崩溃，但复制操作会生成一个完全独立的锁，这不是你想要的。</p><p>如果使用这些类型，就必须注意不要去复制它们，无论是显式的使用 <code>=</code> 操作符还是隐式地操作。<br>例如，将它们嵌入到结构中或在闭包中捕获它们。</p><p>另外，由于锁本质上是可变对象，需要用 <code>var</code> 来声明它们。</p><p>其他锁都是是引用类型，它们可以随意传递，并且可以用 <code>let</code> 声明。 </p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>2015-02-10 更新：本节中所描述的问题已经以惊人的速度被淘汰。苹果昨天发布了 Xcode 6.3 beta 1，其中包括 Swift 1.2。在其他更改中，现在使用一个空的初始化器导入 C 结构，将所有字段设置为零。简而言之，你现在可以直接使用 <code>pthread_mutex_t()</code>，不需要下面提到的扩展。</p><p>pthread 类型很难在 swift 中使用。它们被定义为不透明的结构体中包含了一堆存储变量，例如：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">_opaque_pthread_mutex_t</span> </span>&#123;</span><br><span class="line">    long __sig;</span><br><span class="line">    char __opaque[__PTHREAD_MUTEX_SIZE__];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目的是声明它们，然后使用 init 函数对它们进行初始化，使用一个指针存储和填充。在 C 中，它看起来像： </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>这段代码可以正常的工作，只要你记得调用 <code>pthread_mutex_init</code>。然而，Swift 真的真的不喜欢未初始化的变量。与上面代码等效的 Swift 版本无法编译： </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex: pthread_mutex_t</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// error: address of variable 'mutex' taken before it is initialized</span></span><br></pre></td></tr></table></figure><p>Swift 需要变量在使用前初始化。<code>pthread_mutex_init</code> 不使用传入的变量的值，只是重写它，但是 Swift 不知道，因此它产生了一个错误。为了满足编译器，变量需要用某种东西初始化。在类型之后使用 <code>()</code>，但这样写仍然会报错：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex = pthread_mutex_t()</span><br><span class="line"><span class="comment">// error: missing argument for parameter '__sig' in call</span></span><br></pre></td></tr></table></figure><p>Swift 需要那些不透明字段的值。<code>__sig</code> 可以传入零，但是 <code>__opaque</code> 就有点烦人了。下面的结构体需要桥接到 swift 中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">_opaque_pthread_mutex_t</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> __sig: <span class="type">Int</span></span><br><span class="line">   <span class="keyword">var</span> __opaque: (<span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>,</span><br><span class="line">               <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前没有简单的方法使用一堆 0 构建一个元组，只能像下面这样把所有的 0 都写出来：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex = pthread_mutex_t(__sig: <span class="number">0</span>,</span><br><span class="line">                             __opaque: (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>这么写太难看了，但我没找到好的方法。我能想到最好的做法就是把它写到一个扩展中，这样直接使用空的 <code>()</code> 就可以了。下面是我写的两个扩展： </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">pthread_mutex_t</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        __sig = <span class="number">0</span></span><br><span class="line">        __opaque = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">pthread_rwlock_t</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        __sig = <span class="number">0</span></span><br><span class="line">        __opaque = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过下面这种方式使用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex = pthread_mutex_t()</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h2 id="锁的封装"><a href="#锁的封装" class="headerlink" title="锁的封装"></a>锁的封装</h2><p>为了使这些不同的 API 更易于使用，我编写了一系列小型函数。我决定把 <code>with</code> 作为一个方便、简短、看起来像语法的名字，灵感来自 python 的 <code>with</code> 声明。Swift 函数重载允许不同类型使用相同的名称。基本形式如下所示：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(lock: SomeLockType, f: Void -&gt; Void)</span></span> &#123; ...</span><br></pre></td></tr></table></figure><p>然后在锁定的情况下执行函数 f。下面我们来实现这些类型。</p><p>对于值类型，它需要一个指向锁的指针，以便 lock/unlock 函数可以修改它。这个实现<code>pthread_mutex_t</code> 只是调用相应的 lock 和 unlock 函数，f 函数在两者之间调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(mutex: UnsafeMutablePointer&lt;pthread_mutex_t&gt;, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    pthread_mutex_lock(mutex)</span><br><span class="line">    f()</span><br><span class="line">    pthread_mutex_unlock(mutex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pthread_rwlock_t</code> 的实现几乎完全相同：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(rwlock: UnsafeMutablePointer&lt;pthread_rwlock_t&gt;, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    pthread_rwlock_rdlock(rwlock)</span><br><span class="line">    f()</span><br><span class="line">    pthread_rwlock_unlock(rwlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与读写锁做个对比，它们看起来很像：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with_write</span><span class="params">(rwlock: UnsafeMutablePointer&lt;pthread_rwlock_t&gt;, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    pthread_rwlock_wrlock(rwlock)</span><br><span class="line">    f()</span><br><span class="line">    pthread_rwlock_unlock(rwlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_queue_t</code> 更简单。它只需要封装 <code>dispatch_sync：</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(queue: dispatch_queue_t, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    dispatch_sync(queue, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个人想显摆自己很聪明，那么可以充分利用 Swift 的函数式特性简单的写出这样的代码：</p><p><code>let with = dispatch_sync</code></p><p>这种写法存在一些问题，最大的问题是它会和我们这里使用的基于类型的重载混淆。</p><p><code>NSOperationQueue</code> 在概念上是相似的，不过没有 <code>dispatch_sync</code> 可以用。我们需要创建一个操作（<code>operation</code>），将其添加到队列中，并显式等待它完成：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(opQ: NSOperationQueue, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> op = <span class="type">NSBlockOperation</span>(f)</span><br><span class="line">    opQ.addOperation(op)</span><br><span class="line">    op.waitUntilFinished()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>NSLock</code> 看起来像 <code>pthread</code> 版本，只是锁定调用有些不同：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(lock: NSLock, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    lock.lock()</span><br><span class="line">    f()</span><br><span class="line">    lock.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，<code>OSSpinLock</code> 的实现同样也是如此：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">with</span><span class="params">(spinlock: UnsafeMutablePointer&lt;OSSpinLock&gt;, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    <span class="type">OSSpinLockLock</span>(spinlock)</span><br><span class="line">    f()</span><br><span class="line">    <span class="type">OSSpinLockUnlock</span>(spinlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模仿-synchronized"><a href="#模仿-synchronized" class="headerlink" title="模仿 @synchronized"></a>模仿 <code>@synchronized</code></h3><p>有了上面的封装，模仿 <code>@synchronized</code> 的实现就变得很简单。给你的类添加一个属性，持有一个锁，然后使用 <code>with</code> 替代 <code>@synchronized</code> ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"com.example.myqueue"</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setEntryForKey</span><span class="params">(key: Key, entry: Entry)</span></span> &#123;</span><br><span class="line">    with(queue) &#123;</span><br><span class="line">        entries[key] = entry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 block 中获取数据比较麻烦。<code>@synchronized</code> 可以从内部 <code>return</code> ，但是 <code>with</code> 做不到。你必须使用一个 <code>var</code> 变量在 block 内部赋值给它：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entryForKey</span><span class="params">(key: Key)</span></span> -&gt; <span class="type">Entry</span>? &#123;</span><br><span class="line">    <span class="keyword">var</span> result: <span class="type">Entry</span>?</span><br><span class="line">    with(queue) &#123;</span><br><span class="line">        result = entries[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按理说可以将这段代码当做模板封装在一个通用函数中，但是它无法通过 Swift 编译器的类型推断，目前还没有找到解决方法。</p><h3 id="模拟原子属性"><a href="#模拟原子属性" class="headerlink" title="模拟原子属性"></a>模拟原子属性</h3><p>原子属性（<code>atomic</code>）并不常用。与其他代码属性不同，原子属性并不支持组合率。如果函数 f 不存在内存泄漏，函数 g 不存在内存泄漏，那么函数 h 只是调用 f 和 g 也不会存在内存泄漏。但是原子属性并不满足这个条件。举一个例子，假设你有一个定义成原子属性并且线程安全的 Account 类：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> checkingAccount = <span class="type">Account</span>(amount: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> savingsAccount = <span class="type">Account</span>(amount: <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>现在要把钱转到储蓄账户中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">checkingAccount.withDraw(<span class="number">100</span>)</span><br><span class="line">savingsAccount.deposit(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>在另一个线程中，统计并显示余额：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">"Your total balance is: <span class="subst">\(checkingAccount.amount + savingsAccount.amount)</span>"</span>)</span><br></pre></td></tr></table></figure><p>在某些情况下，这段代码会打印 0，而不是 100，尽管事实上这些 Account 对象本身是原子属性，并且用户确实有 100 的余额。所以，最好让整个子系统都满足原子性，而不是单个属性。</p><p>在极少数情况下，原子属性是有用的，因为它并不依赖其他特性，只需要线程安全即可。要在 Swift 中实现这一点，需要一个计算属性来完成锁定，用另一个常规属性保存值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"..."</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _myPropertyStorage: <span class="type">SomeType</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myProperty: <span class="type">SomeType</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result: <span class="type">SomeType</span>?</span><br><span class="line">        with(queue) &#123;</span><br><span class="line">            result = _myPropertyStorage</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        with(queue) &#123;</span><br><span class="line">            _myPropertyStorage = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何选择锁-API"><a href="#如何选择锁-API" class="headerlink" title="如何选择锁 API"></a>如何选择锁 API</h3><p><code>pthread</code> API 在 Swift 中不太好用，而且功能并不比其它 API 多。一般我比较喜欢在 C 和 Objective-C 中使用它们，因为它们又好用又高效。但是在 Swift 中，除非必要，我一般不会用。</p><p>一般来说不需要用读写锁，大多数情况下读写速度都非常快。读写锁带来的额外开销超过了并发读取带来的效率提升。</p><p>递归锁会发生死锁。多数情况下它们是有用的，但如果你发现自己需要获取一个已经在当前线程被锁住的锁，那最好重新设计代码，通常来说不会出现这种需求。</p><p>我的建议是，如果不知道该用什么，那就默认选择 <code>dispatch_queue_t</code> 。虽然用起来相对麻烦，但是不会产生太多问题。该 API 非常方便，并且确保你永远不会忘记调用 lock 和 unlock。它提供了许多有用的 API，如使用单个 <code>dispatch_async</code> 在后台执行被锁定的代码，或者设置定时器或其他作用于 queue 的事件源，以便它们自动执行锁定。你甚至可以用它作为 <code>NSNotificationCenter</code> 观察者，或者使用 <code>NSOperationQueue</code> 的属性 <code>underlyingQueue</code> 作为 <code>NSURLSession</code> 代理。</p><p><code>NSOperationQueue</code> 可能认为自己和 <code>dispatch_queue_t</code> 一样牛👃，但是实际上很少有场景需要使用它。这个 API 使用起来更麻烦，而且和其他 API 比没有什么优势，无非在某些情况下，它能自动进行操作的依赖关系管理，也就这点比较有用。</p><p><code>NSLock</code> 是一个简单的锁定类，易于使用且效率很高。如果需要显式锁定和解锁，那可以用它替代 <code>dispatch_queue_t</code> 。但在大多数情况下不需要使用它。</p><p><code>OSSpinLock</code> 对于经常使用锁定、竞争较少且锁定代码运行速度快的用户来说，是一个很好的选择。它的开销非常少，有助于提升性能。如果代码可能会在很长一段时间内保持锁定或竞争很多，那最好不要用这个 API，因为这会浪费 CPU 时间。通常来说，你可以先使用 <code>dispatch_queue_t</code> ，如果这块出现了性能问题，再考虑换成 <code>OSSpinLock</code> 。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Swift 语言层面并不支持线程同步，但是 Apple 的系统框架有很多好用的 API。<code>GCD</code> 和 <code>dispatch_queue_t</code> 非常好用，并且Swift 中的 API 也是如此。虽然 Swift 里没有 <code>@synchronized</code> 和原子属性，但我们有其他更好的选择。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-02-06-locks-thread-safety-and-swift.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2015-02-06&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;Lefe_x&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;，&lt;a href=&quot;https://weibo.com/1743643682/profile?topnav=1&amp;amp;wvr=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;liberalism&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在 Swift 中有个有趣的现象：它没有与线程相关的语法，也没有明确的互斥锁/锁（&lt;code&gt;mutexes/locks&lt;/code&gt;）概念，甚至 Objective-C 中有的 &lt;code&gt;@synchronized&lt;/code&gt; 和原子属性它都没有。幸运的是，苹果系统的 API 可以非常容易地应用到 Swift 中。今天，我会介绍这些 API 的用法以及从 Objective-C 过渡的一些问题，这些灵感都来源于 Cameron Pulsford。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 工具类：处理临时文件</title>
    <link href="https://swift.gg/2018/06/04/temp-file-helper/"/>
    <id>https://swift.gg/2018/06/04/temp-file-helper/</id>
    <published>2018-06-04T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2018/03/temp-file-helper/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-03-22<br>译者：<a href="http://daizi.me" target="_blank" rel="noopener">小袋子</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>我经常需要在某些操作中创建临时文件，每次都很繁琐：必须有合适的临时目录，确保文件名是唯一的，最后还不能忘记在操作完成之后删除文件。</p><p>实际上，“创建”是一个错误的说法，因为创建工作通常是由我使用的 API 负责的 — 而我只是提供了一个指向目的位置的 URL。举个例子，假设你的应用提供了一个分享 PDF 文件的功能。你需要创建一个 <a href="https://developer.apple.com/documentation/uikit/uigraphicspdfrenderer" target="_blank" rel="noopener"><code>UIGraphicsPDFRenderer</code></a>对象来生成 PDF，然后调用 <a href="https://developer.apple.com/documentation/uikit/uigraphicspdfrenderer/1649119-writepdf" target="_blank" rel="noopener"><code>writePDF</code></a> 方法并传入临时文件的 URL 生成 PDF 文件，最后在 iOS 分享列表（share sheet）中分享它。</p><p>为了使这个操作更加简便，我最近写了一个简单的 Swift 工具类。你可以这样使用：</p><a id="more"></a><p>1、选择一个文件名来初始化 <code>TemporaryFile</code> ：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tmp = <span class="keyword">try</span> <span class="type">TemporaryFile</span>(creatingTempDirectoryForFilename: <span class="string">"report.pdf"</span>)</span><br></pre></td></tr></table></figure></p><p>这样就新建了一个唯一的临时目录。正如我前面提到的，这是个空目录，<code>TemporaryFile</code> 并不会创建任何文件。更确切地说，它只是提供了一个可以安全创建很多文件的目录，并且不用担心命名冲突。</p><p>2、<code>TemporaryFile</code>有两个属性，<code>directoryURL</code> 是创建的临时目录 URL。<code>fileURL</code> 是目录中的文件 URL，即初始化时指定的文件名：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tmp.directoryURL.path)</span><br><span class="line"><span class="comment">// → /var/folders/v8/tft1q…/T/…-8DC6DD131DC1</span></span><br><span class="line"><span class="built_in">print</span>(tmp.fileURL.path)</span><br><span class="line"><span class="comment">// → /var/folders/v8/tft1q…/T/…-8DC6DD131DC1/report.pdf</span></span><br></pre></td></tr></table></figure><p>再次强调一下，该 URL 对应的文件暂时还不存在——你必须自己创建文件，通常来说可以把 URL 传入其他 API 来生成文件：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> renderer = <span class="type">UIGraphicsPDFRenderer</span>(...)</span><br><span class="line"><span class="keyword">try</span> renderer.writePDF(to: tmp.fileURL) &#123; context <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 编写代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在目录中创建不同名字的文件，但是 <code>TemporaryFile</code> 类型目前只能用来存储单一的文件 URL。如果能够支持多文件 URL 的存储，那就会更好用了。</p><p>3、创建文件后，<code>TemporaryFile</code> 的值被应用中使用该文件的对象所持有（例如，创建文件函数的调用者）。当该对象完成后并且不再需要该文件时，可以调用<code>DeleTeDirectory</code>方法删除临时目录，包括其中的所有文件：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如将 temp 文件传给 UIActivityController 用以分享</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 当你完成后, 调用 deleteDirectory</span></span><br><span class="line"><span class="keyword">try</span> tmp.deleteDirectory()</span><br></pre></td></tr></table></figure><p>我曾考虑到让这个步骤自动化 — 你可以创建 <code>TemporaryFile</code> 类，然后在 <code>deinitializer</code> 中调用 <code>deleteDirectory</code>。最后我放弃了，因为这种行为可能让类型的使用者感到困惑。如果能够添加一个初始化标志位来配置删除行为就好了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>以下是完整代码 (Swift 4.0):</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="comment">/// 临时目录中临时文件的包装（Wrapper）。目录是为文件而特别创建的，因此不再需要文件时，可以安全地删除该文件。</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 在你不再需要文件时，调用 `deleteDirectory`</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TemporaryFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> directoryURL: <span class="type">URL</span></span><br><span class="line">    <span class="keyword">let</span> fileURL: <span class="type">URL</span></span><br><span class="line">    <span class="comment">/// 删除临时目录和其中的所有文件。</span></span><br><span class="line">    <span class="keyword">let</span> deleteDirectory: () <span class="keyword">throws</span> -&gt; <span class="type">Void</span></span><br><span class="line"><span class="comment">/// 使用唯一的名字来创建临时目录，并且使用 `fileURL` 目录中名为 `filename` 的文件来初始化接收者。</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - 注意: 这里不会创建文件！</span></span><br><span class="line">    <span class="keyword">init</span>(creatingTempDirectoryForFilename filename: <span class="type">String</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (directory, deleteDirectory) = <span class="keyword">try</span> <span class="type">FileManager</span>.<span class="keyword">default</span></span><br><span class="line">            .urlForUniqueTemporaryDirectory()</span><br><span class="line">        <span class="keyword">self</span>.directoryURL = directory</span><br><span class="line">        <span class="keyword">self</span>.fileURL = directory.appendingPathComponent(filename)</span><br><span class="line">        <span class="keyword">self</span>.deleteDirectory = deleteDirectory</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FileManager</span> </span>&#123;</span><br><span class="line"><span class="comment">/// 创建一个有唯一名字的临时目录并返回 URL。</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - 返回：目录 URL 的 tuple 以及删除函数。</span></span><br><span class="line">    <span class="comment">///   完成后调用函数删除目录。</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - 注意: 在应用退出后，不应该存在依赖的临时目录。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">urlForUniqueTemporaryDirectory</span><span class="params">(preferredName: String? = <span class="literal">nil</span>)</span></span> <span class="keyword">throws</span></span><br><span class="line">        -&gt; (url: <span class="type">URL</span>, deleteDirectory: () <span class="keyword">throws</span> -&gt; <span class="type">Void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> basename = preferredName ?? <span class="type">UUID</span>().uuidString</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> createdSubdirectory: <span class="type">URL</span>? = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> subdirName = counter == <span class="number">0</span> ? basename : <span class="string">"<span class="subst">\(basename)</span>-<span class="subst">\(counter)</span>"</span></span><br><span class="line">                <span class="keyword">let</span> subdirectory = temporaryDirectory</span><br><span class="line">                    .appendingPathComponent(subdirName, isDirectory: <span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">try</span> createDirectory(at: subdirectory, withIntermediateDirectories: <span class="literal">false</span>)</span><br><span class="line">                createdSubdirectory = subdirectory</span><br><span class="line">            &#125; <span class="keyword">catch</span> <span class="type">CocoaError</span>.fileWriteFileExists &#123;</span><br><span class="line">                <span class="comment">// 捕捉到文件已存在的错误，并使用其他名字重试。</span></span><br><span class="line">                <span class="comment">// 其他错误传播到调用方。</span></span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> createdSubdirectory == <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> directory = createdSubdirectory!</span><br><span class="line">        <span class="keyword">let</span> deleteDirectory: () <span class="keyword">throws</span> -&gt; <span class="type">Void</span> = &#123;</span><br><span class="line">            <span class="keyword">try</span> <span class="keyword">self</span>.removeItem(at: directory)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (directory, deleteDirectory)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2018/03/temp-file-helper/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-03-22&lt;br&gt;译者：&lt;a href=&quot;http://daizi.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小袋子&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;我经常需要在某些操作中创建临时文件，每次都很繁琐：必须有合适的临时目录，确保文件名是唯一的，最后还不能忘记在操作完成之后删除文件。&lt;/p&gt;
&lt;p&gt;实际上，“创建”是一个错误的说法，因为创建工作通常是由我使用的 API 负责的 — 而我只是提供了一个指向目的位置的 URL。举个例子，假设你的应用提供了一个分享 PDF 文件的功能。你需要创建一个 &lt;a href=&quot;https://developer.apple.com/documentation/uikit/uigraphicspdfrenderer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;UIGraphicsPDFRenderer&lt;/code&gt;&lt;/a&gt;对象来生成 PDF，然后调用 &lt;a href=&quot;https://developer.apple.com/documentation/uikit/uigraphicspdfrenderer/1649119-writepdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;writePDF&lt;/code&gt;&lt;/a&gt; 方法并传入临时文件的 URL 生成 PDF 文件，最后在 iOS 分享列表（share sheet）中分享它。&lt;/p&gt;
&lt;p&gt;为了使这个操作更加简便，我最近写了一个简单的 Swift 工具类。你可以这样使用：&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的 Error Handling</title>
    <link href="https://swift.gg/2018/05/31/error-handling-swift/"/>
    <id>https://swift.gg/2018/05/31/error-handling-swift/</id>
    <published>2018-05-31T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.369Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Nick Hanan，<a href="http://www.codingexplorer.com/error-handling-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016/05/05<br>译者：<a href="undefined">TonyHan</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p><img src="/img/articles/error-handling-swift/ErrorHandlingInSwiftTitle.png1527734952.362786" alt=""></p><p>理想情况下，错误永远不会出现。我们所需的文件永远可以访问，网络永远可用并且稳定。不幸的是，现实并不理想，我们需要处理这种不理想的结果。幸运的是，Swift 团队在 Swift 2 中包含了一种很好的方式来处理与理想情况的偏差。Swift Error Handling 能够让我们快速而简便的告知编译器一个函数能否抛出错误，并且在抛出后以合适的方式去处理错误。</p><a id="more"></a><p>Objective-C 处理错误的方式与新的 Swift Error Handling 有一个主要区别。如果你之前在 Objective-C 中处理过 NSError，说实话，在处理可能抛出错误的方法时，你有没有过为其赋值为 “nil” 而不是 NSError 指针？是的，我也是这么认为。在 Objective-C 中，要正确的处理错误，你需要这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSError *err = nil;</span><br><span class="line">NSString *fileStuff = [[NSString alloc] initWithContentsOfFile:@&quot;someFile.txt&quot; encoding:NSUTF8StringEncoding error:&amp;err];</span><br></pre></td></tr></table></figure><p>上述代码所做的，是创建一个空的 NSError 对象，然后你可以用 ＆ 符号传入构造方法，＆ 符号用于辨识出传入的是变量地址。然后，如果有错误，方法或构造函数可以通过此地址找到对应的内存，将 NSError 赋值过去，然后退出函数。将可赋值的地址作为参数传入，是一种实现函数多返回值的手段。在 Swift 中这被转变成了方法原型中的 “inout” 关键字。</p><p>现在，如果有错误，你可以查看 “err” 变量，从而确认是什么错误，然后正确的处理错误。但是，如果不关心错误，可以不传错误指针（即 &amp;err）而直接传入 “nil”，然后任何 NSError 都会被忽略掉。</p><p>Swift 中新的错误处理的语法，使错误处理更加明确。函数会明确的标识出它们会抛出错误，你的程序需要对此很明确，同时要正确处理这些错误（或明确地忽略）。</p><h4 id="创建-Swift-错误"><a href="#创建-Swift-错误" class="headerlink" title="创建 Swift 错误"></a>创建 Swift 错误</h4><p>这可真是个奇怪的标题，什么是创建一个错误？事实上，我们是要创建一个能够表示程序中真实错误的实例。如果一切运行正常，或者文件甚至不存在，这当然没问题。如果存在，用户可能没有访问权限，或者文件因为未知原因损坏。我们需要为要访问这个文件的函数创建 Swift Error 并列出以下选项：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FileReadingError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FileNotFound</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">InsufficientPermission</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">FileCorrupted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，创建 Swift Error 的最简单方法是创建符合 ErrorType 协议的枚举。然后列出代表不同错误情况的选项。从技术来讲，任何对象都可以符合 ErrorType 协议，所以你可以使用一个结构体或一个类，但我觉得不应该这样做。枚举是更完美的方案，它能够列举出有限数目的错误名称。关联值的功能会让枚举更强大，比如说，你可以使用 InsufficientPermission，来显示出当前用户的权限等级。如果想了解更多关于枚举的内容，请查看这篇文章 <a href="http://www.codingexplorer.com/enumerations-swift/" target="_blank" rel="noopener">Enumerations in Swift</a>。</p><p>现在我们来创建一个能抛出错误的函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pretendToReadTestFile</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">NSData</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">FileReadingError</span>.<span class="type">FileNotFound</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，上述代码实际上什么也不会返回，只会自动抛出错误，但我们只是想了解如何实现抛出错误的机制，而并非真正实现一个访问文件并返回文件内容的函数。</p><p>首先，你必须将方法标记为能够抛出错误。要实现这个，只需要在在参数之后、用于表示返回类型的箭头 “ -&gt; “ 之前使用 “throws” 关键字即可。接下来要在函数内部实现抛出错误，只需要输入 “throw” 然后列出想要作为错误的选项。就是这么简单！</p><p>只需要在调用函数之前使用 “try” 关键字，便可以捕获函数的错误：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">try</span> pretendToReadTestFile()</span><br></pre></td></tr></table></figure><h4 id="处理-Swift-Errors"><a href="#处理-Swift-Errors" class="headerlink" title="处理 Swift Errors"></a>处理 Swift Errors</h4><p>主要有四种处理 Swift Errors 的方式：</p><h5 id="让其他人处理"><a href="#让其他人处理" class="headerlink" title="让其他人处理"></a>让其他人处理</h5><p>第一种方法就是不做处理，让其他人来处理。要实现这个特性，需要将函数标记为会抛出错误的函数。之后再调用此函数时则必须进行处理。最终需要有地方来正确处理错误，但不一定是调用抛出错误方法的地方。例如，如果有一个负责读写或其他文件管理操作的文件管理器对象，我们可能只想将错误抛给调用者而不是在其里面处理。</p><p>要实现上述特性，只需要用 “throws” 关键字标记函数即可。这仍然需要用 “try” 将调用功能函数的函数标记为可能抛出错误。如果需要存储抛出错误函数的返回值，只需要正常调用函数然后保存数据即可，但需要在等号和函数调用之间使用 “try” 关键字。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDataFromSomething</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">NSData</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span> pretendToReadTestFile()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="处理特定的-Swift-Errors"><a href="#处理特定的-Swift-Errors" class="headerlink" title="处理特定的 Swift Errors"></a>处理特定的 Swift Errors</h5><p>在其他语言中，这可能是最熟悉的用来处理异常的方法了。Swift Error 的处理方式与异常的处理有显著的不同，会更高效。抛出 Swift Error 更像是替代了返回语句，至少在使用方式上是这样：函数会返回相应的 Swift Error，而不是返回某个预期的返回值。</p><p>首先使用 “do” 语句将抛出错误的函数包裹起来，然后使用 “catch” 语句，有点像 Switch 的 “case” 语句，或者 if 语句的 else-if，来得到需要的 Swift Errors，如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> someData = <span class="keyword">try</span> pretendToReadTestFile()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">FileReadingError</span>.<span class="type">FileNotFound</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The file was not found."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码块 “do” 包含了调用抛出错误的函数的代码。如果出现错误，将会跳转到对应的 catch 语句，很像 switch case 语句。同时，如果考虑不到所有可能的错误情况，则需要类似 Switch 语句中 “default” 或 if 语句中 “else” 的选项，只用 “catch” 来处理其余所有的 Swift Error：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> someData = <span class="keyword">try</span> pretendToReadTestFile()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Something weird happened."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="抛出错误的函数返回可选类型"><a href="#抛出错误的函数返回可选类型" class="headerlink" title="抛出错误的函数返回可选类型"></a>抛出错误的函数返回可选类型</h5><p>如果只需要返回值或是否有返回值，而不关心是什么错误，听起来这有点像 Swift 的可选类型。这样的话，即便返回值不是可选的，也可以告诉编译器“如果有错误，我也并不关心，只需要将返回值设置为 nil”。可以在 “try” 关键字后面使用问号，如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleData = <span class="keyword">try</span>? pretendToReadTestFile()</span><br><span class="line"><span class="comment">//possibleData now contains "nil"</span></span><br></pre></td></tr></table></figure><p>根据实际需要来决定使用 do-catch 语句还是使用上述方式来处理指定的错误。如果的确不需要明确错误原因，或者错误原因很明显，那么使用 “try?” 将更合适。如果是网络调用，错误是由于无效的 URL、连接失败还是无法找到主机对于你的 App 的用户有意义么？对于有的 App 或许有意义，但也有的没有意义，上面那三种情况都意味着没有拿到数据。既然没有请求到数据，那么 “nil” 已经可以告知你的代码如何处理此种情况。</p><h5 id="确保编译器不会抛出-Error"><a href="#确保编译器不会抛出-Error" class="headerlink" title="确保编译器不会抛出 Error"></a>确保编译器不会抛出 Error</h5><p>如果有使用问号的版本，那么你可以猜到这个地方可能会有感叹号的版本（译者注：可选类型和强制解包）。如果使用 “try!”，更像是强制解包可选类型。你可以调用抛出错误的函数，但如果真的抛出错误，App 将会崩溃。如果你确认调用不会出问题，可以使用这种方式。Apple 的 iBook 解释了一种原因，即使用抛出错误的函数来访问 App 的 bundle 中的文件。既然资源来自 App，那它就应该存在，所以不会出现 “File Not Found” 或其他类似错误。如果真出现了错误，那么应该考虑下是不是有更严重的问题。</p><p>如果我们的函数总会抛出错误，那这种方式肯定会引发崩溃，以下仅仅展示了如何使用（顺便看下崩溃是什么样）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> definitelyNoData = <span class="keyword">try</span>! pretendToReadTestFile()</span><br><span class="line"><span class="comment">//Execution was interrupted, reason:  EXC_BAD_INSTRUCTION</span></span><br><span class="line"><span class="comment">//error: 'try!' expression unexpectedly raised an error: FileReadingError.FileNotFound</span></span><br></pre></td></tr></table></figure><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><blockquote><p>译者注:所有贴出的代码都在 Xcode 7.3.1 进行了测试。</p></blockquote><p>Swift Team 在 Swift 中实现了错误的处理，这点我感到很满意。表面上看这是一种相当常见的处理方式，但实际上，这更高效，并且与其表亲 “Exception Handling” 相比危害更小。不用使用调用栈，仅仅通过不同的返回值来告诉我们错误的性质。</p><p>我希望这篇文章对读者有所帮助。如果真的是这样，请毫不犹豫地在 Twitter 或其他社交媒体上分享这片文章，任何分享都可以。当然，如果有任何疑问，也请毫不犹豫地到联系<a href="http://www.codingexplorer.com/contact/" target="_blank" rel="noopener">页面联系</a>我，或者在 Twitter 上 <a href="https://twitter.com/CodingExplorer" target="_blank" rel="noopener">@CodingExplorer</a>，我会尽量提供帮助的。谢谢！</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://itunes.apple.com/us/book/swift-programming-language/id881256329?mt=11&amp;uo=4&amp;at=10lJ3x&amp;ct=blog-SwiftErrorHandling" target="_blank" rel="noopener">The Swift Programming Language – Apple Inc.</a></li></ul><blockquote><p>译者注：目前在中国大陆 iBooks 不可用。<br>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Xcode 7.3.1, Swift 2.2
    
    </summary>
    
      <category term="Coding Explorer Blog" scheme="https://swift.gg/categories/Coding-Explorer-Blog/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Core ML入门：构建一个简单的图像识别应用</title>
    <link href="https://swift.gg/2018/05/28/coreml-introduction/"/>
    <id>https://swift.gg/2018/05/28/coreml-introduction/</id>
    <published>2018-05-28T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.369Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sai Kambampati，<a href="http://www.appcoda.com/coreml-introduction/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-14<br>译者：<a href="http://hulizhen.me" target="_blank" rel="noopener">智多芯</a>；校对：<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>，<a href="https://lision.me/" target="_blank" rel="noopener">Lision</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Apple 公司在 WWDC 2017 发布了几个令开发者感到兴奋的框架和 API，而在这些新框架中最受欢迎的绝对非 <a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="noopener">Core ML</a> 莫属了。开发者可以通过 Core ML 框架将机器学习模型集成到应用程序中，该框架最大的优点是使用它并不需要开发者具备额外的神经网络或机器学习知识。Core ML 框架的另一个特点是，只要开发者将已经训练好的数据模型转换成了 Core ML 模型即可使用。为了演示，本文将直接使用 Apple 开发者网站上提供的一个 Core ML 模型。闲话少说，下面开始学习 Core ML。</p><blockquote><p>注：本文要求使用 Xcode 9 beta 编写代码，还需要一个安装了 iOS 11 beta 的设备（译者注：也可使用 iOS 模拟器）用于测试文中实现的功能。虽然 Xcode 9 beta 同时支持 Swift 3.2 和 4.0，但文中所有的代码都使用了 Swift 4.0 编写。</p></blockquote><a id="more"></a><h2 id="什么是-Core-ML"><a href="#什么是-Core-ML" class="headerlink" title="什么是 Core ML"></a>什么是 Core ML</h2><blockquote><p>Core ML 使得开发者能够将各种各样的机器学习模型集成到应用程序中。它除了支持超过 30 层类型的广泛深度学习，还支持如树集成、<a href="https://en.wikipedia.org/wiki/Support_vector_machine" target="_blank" rel="noopener">SVMs</a> 和广义线性模型等标准模型。Core ML 建立在像 Metal 和 Accelerate 这样的底层技术之上，因此它能够无缝地充分利用 CPU 和 GPU 以实现性能最大化。机器学习模型可直接运行在设备上，以至于数据被分析时不需要脱离设备。</p><p>- <a href="https://developer.apple.com/machine-learning/" target="_blank" rel="noopener">关于 Core ML 的 Apple 官方文档</a></p></blockquote><p>Core ML 是今年在 WWDC 上随着 iOS 11 发布的一个全新的机器学习框架。通过 Core ML，开发者可以直接将机器学习模型集成到应用程序中。那么什么是机器学习呢？简单地说，机器学习是赋予计算机学习能力的应用，而不需要明确地对它编程。一个训练好的模型就是结合机器学习算法对一些数据集进行训练的结果。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/trained-model.png" alt=""></p><p>作为一个应用程序开发者，我们主要关心的是如何将机器学习模型应用到应用程序中以实现更有意思的功能。幸运的是，Apple 提供的 Core ML 框架大大简化了将不同的机器学习模型集成到应用程序中的过程。这为开发者开发如图像识别、自然语言处理、文本预测等功能提供了非常多的可能性。</p><p>现在你可能想知道将这种类型的人工智能加入到应用程序中会不会很困难，这就是最有意思的部分了，实际上 Core ML 非常易用。在本文中，你将会看到只要 10 行代码就可以将 Core ML 集成到应用程序中。</p><p>很酷吧？下面开始吧！</p><h2 id="演示程序概览"><a href="#演示程序概览" class="headerlink" title="演示程序概览"></a>演示程序概览</h2><p>本文将要实现的程序十分简单。该程序让用户拍摄或者从相册中选择一张照片，然后机器学习算法将会尝试预测照片中的物体。虽然预测结果可能并不完美，但你将借此了解到如何将 Core ML 应用到应用程序上。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-app-demo.png" alt=""></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先，打开 Xcode 9 beta 并创建一个新项目。为该项目选择单视图应用程序（<code>Single View App</code>）模板，并确保使用的语言设置为 Swift。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/xcode9-new-proj.png" alt=""></p><h2 id="创建用户界面"><a href="#创建用户界面" class="headerlink" title="创建用户界面"></a>创建用户界面</h2><blockquote><p>如果你不想从头开始搭建 UI 界面，可以从<a href="https://github.com/appcoda/CoreMLDemo/raw/master/CoreMLDemoStarter.zip" target="_blank" rel="noopener">这里下载起始项目</a>并直接跳到 Core ML 部分。</p></blockquote><p>下面就开始吧！首先打开 <code>Main.storyboard</code>，并添加一些 UI 元素到视图中。选择 storyboard 中的视图控制器，然后依次点击 Xcode 菜单栏：<code>Editor-&gt; Embed In-&gt; Navigation Controller</code>。随后即可看到一个导航栏出现在视图上方。将该导航栏命名为 Core ML（或者任何你觉得合适的名字）。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/pic3.png" alt=""></p><p> 放到视图底端并对其缩放，使其两端刚好与视图两端重合。这样就搭建好了该应用的界面。</p><p>虽然本文没涉及到自动布局，但还是强烈建议使用。如果你没法做到自动布局，那就直接在 storyboard 中选择你将要运行的设备类型。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-storyboard.png" alt=""></p><h2 id="实现拍照和相册功能"><a href="#实现拍照和相册功能" class="headerlink" title="实现拍照和相册功能"></a>实现拍照和相册功能</h2><p>既然已经搭好了界面，接着就开始实现功能吧。本节将实现相册和拍照按钮的功能。在 <code>ViewController.swift</code> 中，先遵从 <code>UIImagePickerController</code> 所要求的 <code>UINavigationControllerDelegate</code> 协议。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UINavigationControllerDelegate</span></span></span><br></pre></td></tr></table></figure><p>然后为之前的 <code>UILabel</code> 和 <code>UIImageView</code> 新增两个 IBOutlet。为了简单起见，本文分别将 <code>UIImageView</code> 和 <code>UILabel</code> 命名为 <code>imageView</code> 和 <code>classifier</code>。代码如下所示：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> classifier: <span class="type">UILabel</span>!</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着还需要实现对应按钮被点击的响应动作，在 <code>ViewController</code> 中添加如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">camera</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="type">UIImagePickerController</span>.isSourceTypeAvailable(.camera) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cameraPicker = <span class="type">UIImagePickerController</span>()</span><br><span class="line">    cameraPicker.delegate = <span class="keyword">self</span></span><br><span class="line">    cameraPicker.sourceType = .camera</span><br><span class="line">    cameraPicker.allowsEditing = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    present(cameraPicker, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">openLibrary</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> picker = <span class="type">UIImagePickerController</span>()</span><br><span class="line">    picker.allowsEditing = <span class="literal">false</span></span><br><span class="line">    picker.delegate = <span class="keyword">self</span></span><br><span class="line">    picker.sourceType = .photoLibrary</span><br><span class="line">    present(picker, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码创建了一个 <code>UIImagePickerController</code> 类型的常量并确保用户无法修改已拍摄的照片（无论该照片是刚拍摄的或者从相册中选择的）。然后将 <code>delegate</code> 设置为 <code>self</code>，最后将 <code>UIImagePickerController</code> 展示给用户。</p><p>至此还未添加 <code>UIImagePickerControllerDelegate</code> 对应的方法到 <code>ViewController.swift</code> 中，因此 Xcode 将会有错误提示。这里通过 <code>extension</code> 的形式来实现该协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</span><br><span class="line">        dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码对用户取消选择照片的动作做了相应处理。到目前为止代码大致如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> classifier: <span class="type">UILabel</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">camera</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="type">UIImagePickerController</span>.isSourceTypeAvailable(.camera) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> cameraPicker = <span class="type">UIImagePickerController</span>()</span><br><span class="line">        cameraPicker.delegate = <span class="keyword">self</span></span><br><span class="line">        cameraPicker.sourceType = .camera</span><br><span class="line">        cameraPicker.allowsEditing = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        present(cameraPicker, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">openLibrary</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> picker = <span class="type">UIImagePickerController</span>()</span><br><span class="line">        picker.allowsEditing = <span class="literal">false</span></span><br><span class="line">        picker.delegate = <span class="keyword">self</span></span><br><span class="line">        picker.sourceType = .photoLibrary</span><br><span class="line">        present(picker, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</span><br><span class="line">        dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保你有回到 storyboard 并为所有的 IBOutlet 和 IBAction 都建立好了连接。</p><p>为了访问摄像头和相册，还有做一件事。打开 <code>Info.plist</code> 并添加两项：<em>Privacy - Camera Usage Description</em> 和 <em>Privacy – Photo Library Usage Description</em>。这是因为从 iOS 10 开始，访问摄像头和相册需要指明访问原因。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-plist-privacy.png" alt=""></p><p>接下来将开始本文的核心部分了。再声明一次，如果你不想从头搭建界面，你可以<a href="https://github.com/appcoda/CoreMLDemo/raw/master/CoreMLDemoStarter.zip" target="_blank" rel="noopener">从这里下载起始项目</a>。</p><h2 id="集成-Core-ML-数据模型"><a href="#集成-Core-ML-数据模型" class="headerlink" title="集成 Core ML 数据模型"></a>集成 Core ML 数据模型</h2><p>现在开始将 Core ML 数据模型集成到应用程序中。正如前文所提到的，要使 Core ML 能正常工作还需要提供一个训练好的模型。你可以使用自己训练的模型，但本文将使用 Apple 开发者网站上提供的已经训练好的模型。</p><p>在 Apple 开发者网站的 <a href="https://developer.apple.com/machine-learning/" target="_blank" rel="noopener">Machine Learning</a> 页面向下滚动到底部就可以看到 4 个已经训练好的 Core ML 模型。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-pretrained-model.png" alt=""></p><p>本教程将使用 <em>Inception v3</em> 模型，但你也可以尝试下其他三个。在下载了 <em>Inception v3</em> 模型后，将其添加到 Xcode 项目中，然后看看 Xcode 都显示了哪些信息。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-model-desc.png" alt=""></p><blockquote><p>备注：请确保该项目的 <code>Target Membersip</code> 被选中了，否则应用将无法访问到该文件。</p></blockquote><p>在上面的截图中，可以看出该数据模型的类型为神经网络分类器。其他需要注意的信息还有模型评估参数，它表示该模型的输入和输出参数。本文使用的模型需要输入一张 <code>299x299</code> 的图像，并输出最为可能的类型及其对应每个类型的概率。</p><p>该截图中的另一个重要信息是模型类（model class），它是机器学习模型（<code>Inceptionv3</code>）自动生成的可以直接在代码中使用的类。点击 <code>Inceptionv3</code> 右边的箭头就可以看到该类的源码。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/inceptionv3-class.png" alt=""></p><p>现在将该模型添加到代码中。打开 <code>ViewController.swift</code> 文件，在开头导入 Core ML 框架：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> CoreML</span><br></pre></td></tr></table></figure><p>接着，为 <code>Inceptionv3</code> 模型声明一个 <code>model</code> 变量，并在 <code>viewWillAppear()</code> 方法中初始化：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> model: <span class="type">Inceptionv3</span>!</span><br><span class="line"> </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">    model = <span class="type">Inceptionv3</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我知道你现在在想什么。</p><p>“为什么不早点对这个模型进行初始化？”</p><p>“在 <code>viewWillAppear</code> 方法中定义它的意义何在？”</p><p>亲爱的朋友，它的意义在于，当应用程序尝试识别图像中的物体时，速度会快得多。（译者注：直接在声明 <code>model</code> 变量时直接初始化似乎也没什么影响，读者可自行测试。）</p><p>现在回到 <code>Inceptionv3.mlmodel</code> ，该模型接受的唯一输入参数是一张尺寸为 <code>299x299</code> 的图像，所以接下来要处理的就是如何将一张图像转换成这种尺寸。</p><h2 id="转换图片"><a href="#转换图片" class="headerlink" title="转换图片"></a>转换图片</h2><p>在 <code>ViewController.swift</code> 的 extension 中，将代码更新成如下代码。它实现了 <code>imagePickerController(_:didFinishPickingMediaWithInfo)</code> 方法用于处理选中的图像：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</span><br><span class="line">        dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any])</span></span> &#123;</span><br><span class="line">        picker.dismiss(animated: <span class="literal">true</span>)</span><br><span class="line">        classifier.text = <span class="string">"Analyzing Image..."</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image = info[<span class="string">"UIImagePickerControllerOriginalImage"</span>] <span class="keyword">as</span>? <span class="type">UIImage</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="type">UIGraphicsBeginImageContextWithOptions</span>(<span class="type">CGSize</span>(width: <span class="number">299</span>, height: <span class="number">299</span>), <span class="literal">true</span>, <span class="number">2.0</span>)</span><br><span class="line">        image.draw(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">299</span>, height: <span class="number">299</span>))</span><br><span class="line">        <span class="keyword">let</span> newImage = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()!</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> attrs = [kCVPixelBufferCGImageCompatibilityKey: kCFBooleanTrue, kCVPixelBufferCGBitmapContextCompatibilityKey: kCFBooleanTrue] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">        <span class="keyword">var</span> pixelBuffer : <span class="type">CVPixelBuffer</span>?</span><br><span class="line">        <span class="keyword">let</span> status = <span class="type">CVPixelBufferCreate</span>(kCFAllocatorDefault, <span class="type">Int</span>(newImage.size.width), <span class="type">Int</span>(newImage.size.height), kCVPixelFormatType_32ARGB, attrs, &amp;pixelBuffer)</span><br><span class="line">        <span class="keyword">guard</span> (status == kCVReturnSuccess) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="type">CVPixelBufferLockBaseAddress</span>(pixelBuffer!, <span class="type">CVPixelBufferLockFlags</span>(rawValue: <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">let</span> pixelData = <span class="type">CVPixelBufferGetBaseAddress</span>(pixelBuffer!)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> rgbColorSpace = <span class="type">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">CGContext</span>(data: pixelData, width: <span class="type">Int</span>(newImage.size.width), height: <span class="type">Int</span>(newImage.size.height), bitsPerComponent: <span class="number">8</span>, bytesPerRow: <span class="type">CVPixelBufferGetBytesPerRow</span>(pixelBuffer!), space: rgbColorSpace, bitmapInfo: <span class="type">CGImageAlphaInfo</span>.noneSkipFirst.rawValue) <span class="comment">//3</span></span><br><span class="line">        </span><br><span class="line">        context?.translateBy(x: <span class="number">0</span>, y: newImage.size.height)</span><br><span class="line">        context?.scaleBy(x: <span class="number">1.0</span>, y: -<span class="number">1.0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">UIGraphicsPushContext</span>(context!)</span><br><span class="line">        newImage.draw(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: newImage.size.width, height: newImage.size.height))</span><br><span class="line">        <span class="type">UIGraphicsPopContext</span>()</span><br><span class="line">        <span class="type">CVPixelBufferUnlockBaseAddress</span>(pixelBuffer!, <span class="type">CVPixelBufferLockFlags</span>(rawValue: <span class="number">0</span>))</span><br><span class="line">        imageView.image = newImage</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>imagePickerController(_:didFinishPickingMediaWithInfo)</code> 函数中的代码解释如下：</p><ol><li>#7-11 行：该方法的前几行将选中的图像从 <code>info</code> 字典中（使用 <code>UIImagePickerControllerOriginalImage</code>键）取出。另外，一旦有图像被选中就 Dismiss <code>UIImagePickerController</code>。</li><li>#13-16 行：因为本文使用的模型只接受尺寸为 <code>299x299</code> 的图像，因此我们将选中的图像转换为一个正方形，然后将其赋值给另一个常量 <code>newImage</code>。</li><li>#18-23 行：将 <code>newImage</code> 转换为 <code>CVPixelBuffer</code>。对于不熟悉 <code>CVPixelBuffer</code> 的读者来说，它就是一个用来在内存中存放像素的图像缓冲区，详情可查阅<a href="https://developer.apple.com/documentation/corevideo/cvpixelbuffer-q2e" target="_blank" rel="noopener">这里</a>。</li><li>#31-32 行：将该图像的所有像素转换到独立于设备的 RGB 颜色空间。接着创建一个容纳所有像素数据的 <code>CGContext</code>，当需要渲染（或者改变）该上下文的一些基本属性时就可以很轻松的调用它。这也是我们这两行所做的事情——对图像进行平移和缩放。</li><li>#34-38 行：最后，将该图形上下文放入当前上下文中，渲染图像，从栈顶删除该上下文，再将 <code>imageView.image</code> 设置成 <code>newImage</code>。</li></ol><p>如果你现在无法理解以上的大部分代码也没关系，这只是一些超出本文范围的 <code>Core Image</code> 的高级代码片段而已。你只需要知道上面的代码将选中的图像转换成了数据模型能够接受的形式。我建议你能改动下代码中的数字并留意对应的结果，以更好地理解上面的代码。</p><h2 id="使用-Core-ML"><a href="#使用-Core-ML" class="headerlink" title="使用 Core ML"></a>使用 Core ML</h2><p>现在我们把注意力重新放回到 Core ML 上来。我们使用了 Inceptionv3 模型来实现对象识别。借助 Core ML，我们所需要做的只是添加几行代码。将以下代码段粘贴到 <code>imageView.image = newImage</code>  之后。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> prediction = <span class="keyword">try</span>? model.prediction(image: pixelBuffer!) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">classifier.text = <span class="string">"I think this is a <span class="subst">\(prediction.classLabel)</span>."</span></span><br></pre></td></tr></table></figure><p>这就完了！<code>Inceptionv3</code> 类自动生成了一个名为 <code>prediction(image:)</code> 的方法，可以用来预测给定图像中出现的物体。这里我们将调整后的图像以 <code>pixelBuffer</code> 作为参数传给了该方法。一旦 <code>String</code> 类型的预测结果返回了，就将 <code>classifier</code> 标签更新为识别出的物体名称。</p><p>是时候测试一下这个应用了。编译并在模拟器或者你的 iPhone（安装了 iOS 11 beta）上运行该应用，从相册选择或使用摄像头拍摄一张照片，该应用将识别出图像中有什么物体。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-successful-case.jpg" alt=""></p><p>在测试该应用的过程中，你可能会注意到它并不总能准确地做出预测。其实这并不是代码的问题，问题出在被训练过的模型上。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2017/06/coreml-failed-case.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望你已经懂得了如何将 Core ML 集成到你的应用中，本文仅仅是一篇入门教程而已。如果你对将训练好的 Caffe、Keras 或者 SciKit 模型转换成 Core ML 模型感兴趣的话，请 <a href="http://facebook.com/appcodamobile" target="_blank" rel="noopener">继续关注</a> 我们的下一篇 Core ML 系列教程。我将教你如何将一个模型转换为 Core ML 模型。</p><p>如果想参考本文的演示应用程序，请 <a href="https://github.com/appcoda/CoreMLDemo" target="_blank" rel="noopener">查看 GitHub 上的完整项目</a>。</p><p>关于 Core ML 框架的更详细信息，请参考 <a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="noopener">官方 Core ML 文档</a>。也可以参考 Apple 的 WWDC 2017 视频：</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2017/703/" target="_blank" rel="noopener">Introducing Core ML</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2017/710/" target="_blank" rel="noopener">Core ML in Depth</a></li></ul><p>关于 Core ML 如果你还有什么想说的，记得给我们留言哦！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Sai Kambampati，&lt;a href=&quot;http://www.appcoda.com/coreml-introduction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-06-14&lt;br&gt;译者：&lt;a href=&quot;http://hulizhen.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;智多芯&lt;/a&gt;；校对：&lt;a href=&quot;https://weibo.com/1743643682/profile?topnav=1&amp;amp;wvr=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;liberalism&lt;/a&gt;，&lt;a href=&quot;https://lision.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lision&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Apple 公司在 WWDC 2017 发布了几个令开发者感到兴奋的框架和 API，而在这些新框架中最受欢迎的绝对非 &lt;a href=&quot;https://developer.apple.com/documentation/coreml&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Core ML&lt;/a&gt; 莫属了。开发者可以通过 Core ML 框架将机器学习模型集成到应用程序中，该框架最大的优点是使用它并不需要开发者具备额外的神经网络或机器学习知识。Core ML 框架的另一个特点是，只要开发者将已经训练好的数据模型转换成了 Core ML 模型即可使用。为了演示，本文将直接使用 Apple 开发者网站上提供的一个 Core ML 模型。闲话少说，下面开始学习 Core ML。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：本文要求使用 Xcode 9 beta 编写代码，还需要一个安装了 iOS 11 beta 的设备（译者注：也可使用 iOS 模拟器）用于测试文中实现的功能。虽然 Xcode 9 beta 同时支持 Swift 3.2 和 4.0，但文中所有的代码都使用了 Swift 4.0 编写。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="AppCoda" scheme="https://swift.gg/categories/AppCoda/"/>
    
    
      <category term="机器学习" scheme="https://swift.gg/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>苹果的深度学习框架：BNNS 和 MPSCNN 的对比</title>
    <link href="https://swift.gg/2018/05/24/apple-deep-learning-bnns-versus-metal-cnn/"/>
    <id>https://swift.gg/2018/05/24/apple-deep-learning-bnns-versus-metal-cnn/</id>
    <published>2018-05-24T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.369Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：MATTHIJS HOLLEMANS，<a href="http://machinethink.net/blog/apple-deep-learning-bnns-versus-metal-cnn/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-02-07<br>译者：<a href="undefined">TonyHan</a>；校对：<a href="http://www.desgard.com/" target="_blank" rel="noopener">冬瓜</a>，<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>从 iOS 10 开始，苹果在 iOS 平台上引入了两个深度学习的框架：BNNS 和 MPSCNN。</p><ul><li><p>BNNS：全称为香蕉（bananas，译者注：此处开玩笑），Basic Neural Network Subroutines，是 <a href="https://developer.apple.com/reference/accelerate" target="_blank" rel="noopener">Accelerate  框架</a>的一部分。这个框架能够充分利用 CPU 的快速矢量指令，并提供一系列的数学函数。</p></li><li><p>MPSCNN 是 <a href="https://developer.apple.com/metal/" target="_blank" rel="noopener">Metal Performance Shaders</a> 的一部分。Metal Performance Shaders 是一个经过优化过的计算内核框架，并且可以运行在 GPU （而不是 CPU）上。</p></li></ul><p>所以，作为 iOS 开发者，有了两个用于做深度学习的框架，它们有很多类似的地方。</p><p>应该选择哪个呢？</p><p>在这篇文章中，我们将针对 BNNS 和 MPSCNN 进行对比来显示出这两者的差异。而且我们会对这两个 API 进行速度测试，来看下谁更快一些。</p><a id="more"></a><h2 id="为什么要优先使用-BNNS-或-MPSCNN-？"><a href="#为什么要优先使用-BNNS-或-MPSCNN-？" class="headerlink" title="为什么要优先使用 BNNS 或 MPSCNN ？"></a>为什么要优先使用 BNNS 或 MPSCNN ？</h2><p>我们首先讨论这两个框架的作用。</p><p>目前 BNNS 和 MPSCNN 在<strong>卷积神经网络</strong>领域中用于<strong>变分推断</strong>。</p><p>与类似的 <a href="https://tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a>（使用此方案可以通过构建一个计算图，从头开始建立你的神经网络）相比，BNNS 和 MPSCNN 提供更高级的 API，不需要担心你的数学。</p><p>这也有一个缺点：BNNS 和 MPSCNN 的功能远远少于其他框架，如 TensorFlow。它们更容易上手，但同时限制了所能做的深度学习的种类。</p><p>苹果的深度学习框架只是为了一个目的：通过网络层级<strong>尽可能快地传递数据</strong>。</p><h4 id="一切都与层级有关"><a href="#一切都与层级有关" class="headerlink" title="一切都与层级有关"></a>一切都与层级有关</h4><p>你可以将神经网络想象为数据流经的管道。管道中的不同阶段便是网络<strong>层级</strong>。这些层级以不同的方式转换你的数据。同时深度学习，我们可以使用多达 10 层甚至 100 层的神经网络。</p><p><img src="/img/articles/apple-deep-learning-bnns-versus-metal-cnn/Cat2Probability@2x.png1527128648.556878" alt="Cat2Probability"></p><p>层级有不同的种类。BNNS 和 MPSCNN 提供的有：卷积层（convolutional layer）、池化层（pooling layer）、全连接层（Fully Connected Layer）和规范化层（normalization layer）。</p><p>在 BNNS 和 MPSCNN 中，<strong>层级是主要的建构单元</strong>。你可以创建层级对象，将数据放入层级中，然后再从层级中读出结果。顺便说一句，BNNS 称它们为“过滤器”，而不是层级：数据以一种形式进入过滤器并以另一种形式从过滤器出来。</p><p>为了说明层级作为建构单元的思想，下面描述了数据如何通过一个简单的神经网络在 BNNS 中流动：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为中间结果和最终结果分配内存。</span></span><br><span class="line"><span class="keyword">var</span> tempBuffer1: [<span class="type">Float</span>] = . . .</span><br><span class="line"><span class="keyword">var</span> tempBuffer2: [<span class="type">Float</span>] = . . .</span><br><span class="line"><span class="keyword">var</span> results: [<span class="type">Float</span>] = . . .</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对输入的数据（比如说一张图片）应用第一层级。</span></span><br><span class="line"><span class="type">BNNSFilterApply</span>(convLayer, inputData, &amp;tempBuffer1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对第一层级的输出应用第二层级。</span></span><br><span class="line"><span class="type">BNNSFilterApply</span>(poolLayer, tempBuffer1, &amp;tempBuffer2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用第三和最后的层级。结果通常是概率分布。</span></span><br><span class="line"><span class="type">BNNSFilterApply</span>(fcLayer, tempBuffer2, &amp;results)</span><br></pre></td></tr></table></figure><p>要使用 BNNS 和 MPSCNN 构建神经网络，只需要设置层级并向它们发送数据。框架负责处理层级<em>内</em>发生的事情，但你需要做的是连接层级。</p><p>不幸的是，这可能有点无聊。例如，通过加载一个<a href="http://caffe.berkeleyvision.org/model_zoo.html" target="_blank" rel="noopener">提前训练好的 caffemodel 文件</a>来获取一个完整配置的“神经网络”是行不通的。你必须手写代码，仔细地创建层级并进行配置来复制出网络的设计。这样就很容易犯错。</p><h4 id="BNNS-和-MPSCNN-不做训练"><a href="#BNNS-和-MPSCNN-不做训练" class="headerlink" title="BNNS 和 MPSCNN 不做训练"></a>BNNS 和 MPSCNN 不做训练</h4><p>在你使用神经网络之前，你必须先<strong>训练</strong>它。训练需要大量的数据和耐心——至少几个小时，甚至几天或几周，取决于你可以投入多少计算能力。你肯定不想在手机上进行训练（这可能会使手机着火）。</p><p>当得到一个训练网络，便可以用来进行<strong>预测</strong>。这被称为“推断”。训练本应需要使用重型计算机，但在现代的手机上进行推断是完全可能的。</p><p>这正是 BNNS 和 MPSCNN 设计的目的。</p><h4 id="仅限卷积网络"><a href="#仅限卷积网络" class="headerlink" title="仅限卷积网络"></a>仅限卷积网络</h4><p>但是这两个 API 都有限制。目前，BNNS 和 MPSCNN 仅支持一种深度学习：卷积神经网络（CNN）。CNN 的主要应用场景是<strong>机器视觉</strong>任务。例如，你可以使用 CNN 来<a href="http://machinethink.net/blog/convolutional-neural-networks-on-the-iphone-with-vggnet/" target="_blank" rel="noopener">描述给定照片中的对象</a>。</p><p>虽然 CNN 很牛逼，但在 BNNS 或 MPSCNN 中无法支持其他深度学习架构（例如递归神经网络）。</p><p>然而，已经提供的建构单元（卷积层，池化层和全连接层）高效并且为构建更复杂的神经网络提供了<strong>良好的基础</strong>，即便你必须手工编写一些代码来填补 API 中的空白。</p><ul><li>备注：Metal Performance Shaders 框架还附带有用于在 GPU 上进行快速矩阵乘法的计算内核。同时，Accelerate 框架包含用于在 CPU 上执行相同操作的 BLAS 库。所以，即使 BNNS 或 MPSCNN 不包含你所需的深层学习架构的所有层级类型，你也可以借助这些矩阵例程来推出自己的层级类型。而且，如果有必要的话，你可以用 Metal Shading Language 编写你自己的 GPU 代码。</li></ul><h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><p>假如它们的功能一致，那为何 Apple 要给我们两个 API？</p><p>很简单：BNNS 运行在 CPU 上，MPSCNN 运行在 GPU 上。有时使用 CPU 速度更快，有时使用 GPU 更快。</p><ul><li>“等一下…难道 GPU 不是高度并行的计算怪物么？难道我们不应该一直在 GPU 上运行我们的深层神经网络吗？！”</li></ul><p>并没有。对于培训，你一定希望通过 GPU 来进行大规模并行计算（即使只是一个许多 GPU 的集群）但推论时，使用枯燥的旧的 2 或 4 核 CPU 可能会更快。</p><p>下面我将详细讨论的速度差异，但首先让我们来看看这两个 API 是有哪些不同。</p><ul><li>备注：Metal Performance Shaders 框架仅适用于 iOS 和 tvOS，不适用于 Mac。BNNS 也适用于 macOS 10.12 及更高版本。如果你想要保证 iOS 和 MacOS 之间的深度学习代码的可移植性，BNNS 是你唯一的选择（或使用第三方框架）。</li></ul><h4 id="它是-Swifty-的么"><a href="#它是-Swifty-的么" class="headerlink" title="它是 Swifty 的么?"></a>它是 Swifty 的么?</h4><p>BNNS 实际上是一个基于 C 的 API。如果你使用 Objective-C 是可以的，但 Swift 使用它有点麻烦。相反，MPSCNN 更兼容 Swift。</p><p>不过，你必须接受这些 API 比所谓的 UIKit 更低级的事实。Swift 并没有将所有的东西都抽象成简单的类型。你经常需要使用 Swift 的 <code>UnsafeRawPointer</code> 指针来处理原始字节。</p><p>Swift 也没有一个原生的 <strong>16 位浮点类型</strong>，但是 BNNS 和 MPSCNN 在使用这样的半精度浮点数时才是最高效的。你将不得不使用 Accelerate 框架在常规类型和半精度浮点数之间进行转换。</p><p>从理论上讲，当使用 MPSCNN 时，你不必自己编写任何 GPU 代码，但实际上我发现某些预处理步骤——如从每个图像像素中减去平均 RGB 值，使用 Metal Shading Language（基于 C++ 实现） 中的定制的计算内核是最容易实现的。</p><p>所以，即使你在 Swift 中使用这两个框架，也要准备好用这两个 API 来进行一些底层级别的 Hacking 行为。</p><h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p>随着数据在神经网络中从一层流向下一层，数据在每层都会以某种方式被转换。层级应用了激活函数，来作为此转换的一部分。没有这些激活函数，神经网络将无法学习非常有趣的事情。</p><p>激活函数有很多选择，BNNS 和 MPSCNN 都支持最常用的功能：</p><ul><li>修正线性单元（ReLU）和带泄漏修改线性单元（Leaky ReLU）</li><li>逻辑函数（logistic sigmoid）</li><li>双曲正切函数（<em>tanh</em>）和 扩展双曲正切函数（scaled <em>tanh</em>）</li><li>绝对值</li><li>恒等函数（the identity function），它传递数据而不改变数据</li><li>线性（只在 MPSCNN 上）</li></ul><p>你会认为这与 API 一样简单，但是奇怪的是，与 MPSCNN 相比，BNNS 有一个不同的定义这些激活函数的方式。</p><p>例如，BNNS 定义了两种类型，<code>BNNSActivationFunctionRectifiedLinear</code> 和 <code>BNNSActivationFunctionLeakyRectifiedLinear</code>，但在 MPSCNN 中，只有一种 <code>MPSCNNNeuronReLU</code> 类型，使用 <code>alpha</code> 参数来标记是否为带泄漏的修正线性单元（Leaky ReLU）。同样的还有双曲正切函数（tanh）和 扩展双曲正切函数（scaled tanh）。</p><p>可以肯定地说，MPSCNN 采用比 BNNS 更灵活和可定制的方法。整个 API 层面都是如此。</p><p>例如：MPSCNN 允许您通过继承 <code>MPSCNNNeuron</code> 并编写一些 GPU 代码来创建自己的激活函数。使用 BNNS 就无法实现，因为没有用于定制的激活函数的 API；只提供了枚举。如果你想要的激活函数不在列表中，那么使用 BNNS 就会掉进大坑。</p><ul><li><p>17年2月10号更新：以上内容有点误导，所以我应该澄清下。由于 BNNS 在 CPU 上运行，你可以简单地获取层级的输出并根据你的喜好进行修改。如果你需要一种特殊的激活函数，你可以在 Swift 中自己实现（最好使用 Accelerate 框架）并在进入下一层之前将其应用于上一层的输出。所以 BNNS 在这方面的能力不亚于 Metal。</p></li><li><p>17年6月29日更新：关于 <code>MPSCNNNeuron</code> 子类的澄清：如果你这样做，实际上并不能使用 <code>MPSCNNConvolution</code> 的子类。这是因为 MPS 在 GPU 内核中执行激活函数时使用了一个技巧，但这只适用于 Apple 自己的 MPSCNNNeuron 子类，不适用于你自己创建的任何子类。</p></li></ul><p>事实上，在 MPSCNN 中，<em>一切</em>都是 <code>MPSCNNKernel</code> 的一个子类。这意味着你可以单独使用一个激活函数，如 <code>MPSCNNNeuronLinear</code>，就像它是一个单独的层级一样。在预处理步骤中，这对以常量进行缩放数据是很有用的。（顺便说一句，BNNS 没有类似于“线性”的激活函数。）</p><ul><li>备注：在我看来，感觉就像 BNNS 和 MPSCNN 是由 Apple 内部不同的团体创建的。它们有非常相似的功能，但它们的 API 之间有一些奇怪的差异。我不在 Apple 公司工作，所以我不知道这些差异存在的原因。也许是出于技术或性能的原因。但是你应该知道 BNNS 和 MPSCNN 不是“热插拔”的。如果你想要知道在 CPU 或 GPU 上进行推理时哪种方法最快，你将不得不实现两次深度学习网络。</li></ul><h4 id="层级类型"><a href="#层级类型" class="headerlink" title="层级类型"></a>层级类型</h4><p>我之前提到深层神经网络是由不同类型的层级组成的：</p><ul><li>卷积（Convolutional）</li><li>池化（Pooling），最大值和平均值</li><li>完全连接（Fully-connected）</li></ul><p>BNNS 和 MPSCNN 都实现了这三种层级类型，但是每种 API 的实现方式都有细微差别。</p><p>例如，BNNS 可以在池化层中使用激活函数，但是 MPSCNN 不行。但是，在 MPSCNN 中，你可以将激活函数添加到池化层后面作为单独的一层，所以最终这两个 API 能实现相同的功能，但是它们实现的路径不同。</p><p>在 MPSCNN 中，完全连接层被视为卷积的一个特例，而在 BNNS 中，它被实现为矩阵向量乘法。实践中并不会有差别，但是这表明这两个框架采取了不同的方法来解决同样的问题。</p><p>我觉得对于开发者来说，<strong>MPSCNN 使用起来更方便</strong>。</p><p>当对图像使用卷积时，除非添加“填充”像素，否则输出图像会缩小一些。使用 MPSCNN，就不必担心这一点：你只需告诉它，希望输入和输出图像有多大。使用 BNNS 你就必须自己计算填充量。像这样的细节让 MPSCNN 成为更易用的 API。</p><p>除了基础层级，MPSCNN 还提供以下层级：</p><ul><li>归一化（特征归一化、跨通道归一化（弱化）、局部对比度归一化）</li><li>Softmax，也称为归一化指数函数</li><li>对数 Softmax，即使用 Softmax 函数并配合 log 似然代价函数</li><li>激活函数层</li></ul><p>这些额外的层级类型无法在 BNNS 中找到。</p><p>对于规范化层来说，这可能不是什么大问题，因为我觉得它们并不常见，但 softmax 是大多数卷积网络在某些时候需要做的事情（通常在最后）。</p><p>softmax 函数将神经网络的输出转化为概率分布：“我 95％ 肯定这张照片是一只猫，但只有 5％ 确定它是一只 <code>Pokémon</code> 。”</p><p>在 BNNS 中没有提供 softmax 是有点奇怪的。在 Accelerate 框架中使用 vDSP 函数来写代码实现并不难，但是也不是很方便。</p><h4 id="学习参数"><a href="#学习参数" class="headerlink" title="学习参数"></a>学习参数</h4><p>训练神经网络时，训练过程会调整一组数字来表示网络正在学习什么。这些数字被称为<strong>学习参数</strong>。</p><p>学习参数由所谓的权重和偏差值组成，这些值只是一些浮点数。当你向神经网络发送数据时，各层级实际上将你的数据乘以这些权重，添加偏差值，然后再应用激活函数。</p><p>创建层级时，需要为每个层级指定权重和偏差值。这两个 API 只需要一个原始指针指向浮点值的缓冲区。需要由你来确保这些数字以正确的方式组织。如果这里操作错误，神经网络将会输出垃圾数据。</p><p>你可能猜到了：BNNS 和 MPSCNN 为权重使用不同的内存分配。😅</p><p>对于 MPSCNN 权重数组看起来像这样：</p><p><code>weights[ outputChannel ][ kernelY ][ kernelX ][ inputChannel ]</code></p><p>但是对于 BNNS 来说，顺序是不同的：</p><p><code>weights[ outputChannel ][ inputChannel ][ kernelY ][ kernelX ]</code></p><p>我认为 MPSCNN 将输入通道放在最后的原因是，这样可以很好地映射到存储数据的 <code>MTLTexture</code>s 中的 RGBA 像素。但是对于 BNNS 所使用的 CPU 矢量指令，将输入通道视为单独的内存块会更高效。</p><p>这种差异对于开发者来说不是一个大问题，但是当你导入训练好的模型时你需要<strong>知道权重的内存分配</strong>。</p><p>备注：你可能需要编写一个转换脚本来导出培训工具中的数据，例如 TensorFlow 或 Caffe，并将其转换为 BNNS 或 MPSCNN 预期的格式。这两个 API 都不能读取这些工具所保存的模型，它们只接受原始的浮点值的缓冲数据。</p><p>MPSCNN 总是复制权重和偏差值，并将它们作为 16 位浮点内部存储。由于你必须将它们作为单精度浮点数提供，因此这有效地将你的学习参数的精度减半。</p><p>BNNS 在这里比较开放一些：它可以让你选择你想要存储学习参数的格式，也可以让你选择不复制。</p><p>将权重加载到网络中仅仅在创建网络时的 App 启动时起到重要作用。但是，如果你有大量的权重，你仍然需要认真对待。我的 <a href="http://machinethink.net/blog/convolutional-neural-networks-on-the-iphone-with-vggnet/" target="_blank" rel="noopener">VGGNet implementation</a> 不能在 iPhone 6 上工作，因为 App 试图一次性将所有权重加载到 MPSCNN 时导致内存不足。（可以先创建大的层级，然后是再创建较小的层级。）</p><h4 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h4><p>一旦你创建了所有的层级对象，你终于可以开始使用神经网络进行推断啦！</p><p>正如你所看到的，BNNS 或 MPSCNN 都没有真正的“神经网络”的概念，他们只能看到每个层级。你需要逐个将数据放入这些层级中的每一层。</p><p>作为神经网络的用户，你关心的数据是进入第一层（例如一张图片）的输入和从最后一层出来的输出（这张图片是猫的概率）。其他在各层之间传递的数据，只是临时的中间结果。</p><p>那么你需要输入什么格式的数据？</p><p>MPSCNN 要求将所有数据放置在一个特殊的 <code>MPSImage</code> 对象内，这个对象实际上是 2D 纹理的集合。如果你正在使用图片，这会非常有意义 - 但是如果你的数据不是图片，则需要将其转换为 Metal 纹理。这会消耗 CPU 的性能。（你可以使用 Accelerate 框架来解决这个问题。）</p><p>备注：iOS 设备使用统一的内存模型，这意味着 CPU 和 GPU 访问相同的 RAM 芯片。与桌面计算机或服务器上的情况不同，你不需要将数据复制到 GPU。所以至少你的 iOS App 不会有这些性能消耗。</p><p>另一方面，BNNS 只需要一个指向浮点值缓冲区的指针。不需要将数据加载到特定对象中。所以这似乎比使用纹理更快…是么？</p><p>这样有一个重要的限制：在 BNNS 中，不同“通道”中的输入不能交错。</p><p>如果你的输入是图片，那么它有三个通道：一个用于红色像素，一个用于绿色像素，另一个用于蓝色像素。问题是像 PNG 或 JPEG 这样的图像文件会作为交错的 RGBA 值被加载到内存中。BNNS 并不会接受这种情况。</p><p><img src="/img/articles/apple-deep-learning-bnns-versus-metal-cnn/InterleavedPlanar@2x.png1527128648.7662659" alt=""></p><p>目前没有办法告诉 BNNS 使用红色像素值作为通道 0，绿色像素值作为通道 1，蓝色值作为通道 2，并跳过 alpha 通道。相反，你将不得不重新排列像素数据，以便输入缓冲区的首先包含所有 R 值，然后是所有 G 值，然后是所有 B 值。</p><p>我们若采取这种预处理，就会占用宝贵的计算时间。其次，也许这些限制允许 BNNS 在其层级如何执行其的计算方面做一定的优化，从而使整个事情是个净增益。但这谁也不知道。</p><p>在任何情况下，如果您使用 BNNS 处理图像（CNNs主要的用途）那么你可能需要对输入数据进行一些调整以获得正确的格式。</p><p>还有<strong>数据类型</strong>的问题。</p><p>BNNS 和 MPSCNN 都允许你将输入数据指定为浮点值（16 位和 32 位）或整数（8、16 或 32 位）。你想将浮点数据作为网络的输入，你可能无法选择输入数据的格式。</p><p>通常，当你加载 PNG 或 JPEG 图像，或者从手机相机中取出静止图像时，会得到一个 8Bit 纹理，该纹理使用无符号的 8 位整数作为像素的 RGBA 值。使用 MPSCNN 这是没有问题的：纹理会自动转换为浮点值。</p><p>用 BNNS 你可以指定 <code>Int8</code> 作为图像的数据类型，但是我实践后发现是行不通的。其实也许是因为我没有投入大量的时间来研究它。由于我要重新修改输入图像的通道，于是顺便就轻松地将像素数据转换为浮点数。</p><p>备注：即使 BNNS 允许你指定整数作为数据和权重的数据类型，它在内部也会将其转换为浮点数据，进行计算，然后将结果转换为整数。为了获得最好的速度，你可能想要跳过这个转换步骤，并且总是直接处理浮点数据，即使它们占用了 2 到 4 倍的内存。</p><h4 id="临时数据"><a href="#临时数据" class="headerlink" title="临时数据"></a>临时数据</h4><p>在 BNNS 和 MPSCNN 中，每个层级都需要处理。你将数据放入一个层级，并从一个层级中获取数据。</p><p>深层网络将会有很多层级。我们只关心最后一层的输出，而不关心所有其他层的输出。但是我们仍然需要将这些中间结果存储在某个地方，即使它们只用了一小会儿。</p><p>MPSCNN 对此有一个特殊的对象，<code>MPSTemporaryImage</code>。它就像一个 <code>MPSImage</code>，但只能使用一次。写入一次数据，读取一次数据。之后，它的内存将被回收。（如果您熟悉 Metal，它们是使用 Metal 的资源堆来实现的。）</p><p>你应该尽可能地使用 <code>MPSTemporaryImage</code>，因为这样可以避免大量的内存分配和释放。</p><p>使用 BNNS 的话就得靠自己。你需要自己管理临时数据缓冲区。幸运的是，它非常简单：您可以分配一个或两个大数组，然后在这些层级之间重复使用它们。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>你可能想要在后台线程中构建网络层级。加载学习参数的所有数据可能需要几秒钟的时间。</p><p>在后台线程上执行推断也是一个好主意。</p><p>使用足够深的神经网络，推断可能需要 0.1 到 0.5 秒之间的时间，这样的延迟对于用户是很明显的。</p><p>使用 MPSCNN 创建一个命令队列和一个命令缓冲区，然后通知所有层级编码到命令缓冲区中，最后将工作提交给 GPU。GPU 完成后，会通过回调通知你。</p><p>每项工作的编码都可以在后台线程中进行，你不需要做任何事情来进行同步。</p><p>备注：在实时情况下（例如，将摄像机的实时视频帧提供给神经网络时），你希望 GPU 保持繁忙状态，并且避免 CPU 和 GPU 相互等待的情况。当 GPU 仍在处理前一帧时，CPU 应该已经编码了下一个视频帧。你需要使用 <code>MPSImage</code> 对象数组，并通过信号量保证对它们的同步访问——但说实话，如果现在的移动设备能够实时地进行深度学习，我会感到非常惊讶。</p><p>BNNS 在 CPU 上工作，所以你可以在后台线程中开始工作，然后阻塞，直到 BNNS 完成。</p><p>最好让 BNNS 弄清楚如何在可用的 CPU 内核上分割工作，但是有一个配置选项告诉 BNNS 有多少线程可以用来执行计算。（MPSCNN 不需要这个，它将使用尽可能多的 GPU 线程。）</p><p>备注：你不应该在多个线程之间共享 MPSCNN 对象或 BNNS 对象。它们可以在单个后台线程中使用，但不能同时在使用多个线程中使用。</p><h2 id="速度问题"><a href="#速度问题" class="headerlink" title="速度问题"></a>速度问题</h2><p>决定是否使用 BNNS 或 MPSCNN 是基于一个权衡：<strong>CPU 数据更快还是 GPU 更快？</strong></p><p>并非所有数据都适合 GPU 处理。图像或视频是非常合适的，但像时间序列数据可能不适合。</p><p>将数据加载到 GPU 中是需要花费的，因为你需要将其封装到 <code>MTLTexture</code> 对象中。一旦 GPU 完成，读取结果就需要再次从纹理对象中获取。</p><p>使用基于 CPU 的 BNNS，便不会有这些开销，但是你也无法利用 GPU 的大规模并行性来进行计算。</p><p>在实践中，开发人员可能会<strong>尝试两种方法，看看哪一个更快</strong>。但是，如上所示，由于 BNNS 和 MPSCNN 具有不同的 API，因此需要编写两次代码。</p><p>因为我很好奇，所以我决定分别使用 BNNS 和 MPSCNN 建立一个非常基本的卷积神经网络来测量哪一个更快。</p><p>我的神经网络设计大概是这样（点击图片放大）：</p><p><img src="/img/articles/apple-deep-learning-bnns-versus-metal-cnn/ConvNet@2x.png1527128648.814062" alt="The convolutional neural network used for the speed test"></p><p>这种网络设计可以用来分类图像。网络采用 256×256 的 RGB 图像（无 alpha 通道）作为输入，并产生一个具有 100 个 <code>浮点值</code> 的数组。输出会表示出 100 多种可能类别的对象的概率分布。</p><p>实际上，神经网络需要有更多的层级才能真正有用。它最后也本该有一个 softmax 层，但是因为 BNNS 没有使用 softmax 函数，所以我把它去掉了。</p><p>我实际上并没有训练这个神经网络来学习任何有用的东西，而是用合理的随机值进行初始化。这是一个没有用的神经网络。然而，它确实允许我们比较在 BNNS 和 MPSCNN 中建立相同的神经网络所需要的内容，以及每个网络运行有多快。</p><p>如果你想一起实践，<a href="https://github.com/hollance/BNNS-vs-MPSCNN" target="_blank" rel="noopener">这是 GitHub 上的代码</a>。在 Xcode 中打开这个项目，并在至少有一个 A8 处理器的 iOS 10 兼容设备上运行它（它不能在模拟器上运行）。</p><p><img src="/img/articles/apple-deep-learning-bnns-versus-metal-cnn/Screenshot@2x.png1527128648.8787365" alt="The speed test app"></p><p>点击按钮后，App 冻结几秒钟，同时在每个神经网络上执行 100 个独立的推断。该 App 显示了创建网络需要多长时间（并不是很有趣），以及需要多长时间才能完成 100 次重复的推断。</p><p>该 App 还打印出每个网络计算的结果。由于网络并没有进行训练，因此这些数字什么意义都没有，仅仅是用于调试目的。我想确保两个网络实际上计算的事情相同，从而保证测试是公平的。</p><p>答案中的小差异是由于浮点四舍五入（由于 Metal 在内部使用的 16 位浮点数，我们只得到 3 位小数的精度），而且也可能是由于每个框架具体执行计算的差异而产生的。但结果足够接近。</p><h4 id="App-的工作原理"><a href="#App-的工作原理" class="headerlink" title="App 的工作原理"></a>App 的工作原理</h4><p>这个 App 创建的神经网络具有 2 个卷积层、1 个 max-pooling 层，1 个 average-pooling 层和 1 个全连接层。然后，它会测量向网络发送 100 次相同图像需要多长时间。</p><p>与此有关的主要源文件是 <strong>BNNSTest.swift</strong> 和 <strong>MetalTest.swift</strong>。</p><p>你猜对了，<code>BNNSTest</code> 类使用 BNNS 功能创建神经网络。以下是创建第一个卷积层所需的一小段代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">inputImgDesc = <span class="type">BNNSImageStackDescriptor</span>(width: <span class="number">256</span>, height: <span class="number">256</span>, channels: <span class="number">3</span>, </span><br><span class="line">                   row_stride: <span class="number">256</span>, image_stride: <span class="number">256</span>*<span class="number">256</span>, </span><br><span class="line">                   data_type: dataType, data_scale: <span class="number">0</span>, data_bias: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">conv1imgDesc = <span class="type">BNNSImageStackDescriptor</span>(width: <span class="number">256</span>, height: <span class="number">256</span>, channels: <span class="number">16</span>, </span><br><span class="line">                   row_stride: <span class="number">256</span>, image_stride: <span class="number">256</span>*<span class="number">256</span>, </span><br><span class="line">                   data_type: dataType, data_scale: <span class="number">0</span>, data_bias: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> relu = <span class="type">BNNSActivation</span>(function: <span class="type">BNNSActivationFunctionRectifiedLinear</span>, </span><br><span class="line">                          alpha: <span class="number">0</span>, beta: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> conv1weightsData = <span class="type">BNNSLayerData</span>(data: conv1weights, data_type: dataType, </span><br><span class="line">                           data_scale: <span class="number">0</span>, data_bias: <span class="number">0</span>, data_table: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> conv1biasData = <span class="type">BNNSLayerData</span>(data: conv1bias, data_type: dataType, </span><br><span class="line">                        data_scale: <span class="number">0</span>, data_bias: <span class="number">0</span>, data_table: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> conv1desc = <span class="type">BNNSConvolutionLayerParameters</span>(x_stride: <span class="number">1</span>, y_stride: <span class="number">1</span>, </span><br><span class="line">                    x_padding: <span class="number">2</span>, y_padding: <span class="number">2</span>, k_width: <span class="number">5</span>, k_height: <span class="number">5</span>, </span><br><span class="line">                    in_channels: <span class="number">3</span>, out_channels: <span class="number">16</span>, </span><br><span class="line">                    weights: conv1weightsData, bias: conv1biasData, </span><br><span class="line">                    activation: relu)</span><br><span class="line"></span><br><span class="line">conv1 = <span class="type">BNNSFilterCreateConvolutionLayer</span>(&amp;inputImgDesc, &amp;conv1imgDesc, </span><br><span class="line">                                         &amp;conv1desc, &amp;filterParams)</span><br></pre></td></tr></table></figure><p>使用 BNNS，你需要创建大量“描述符”助手来描述你将要使用的数据以及层级的属性和权重。其他层级也会重复此操作。现在你可以明白为什么我之前说这个会很无聊。</p><p><code>MetalTest</code> 类使用 <code>MPSCNN</code>做同样的事情：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">conv1imgDesc = <span class="type">MPSImageDescriptor</span>(channelFormat: channelFormat, width: <span class="number">256</span>, </span><br><span class="line">                                  height: <span class="number">256</span>, featureChannels: <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> relu = <span class="type">MPSCNNNeuronReLU</span>(device: device, a: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> conv1desc = <span class="type">MPSCNNConvolutionDescriptor</span>(kernelWidth: <span class="number">5</span>, kernelHeight: <span class="number">5</span>, </span><br><span class="line">                    inputFeatureChannels: <span class="number">3</span>, outputFeatureChannels: <span class="number">16</span>, </span><br><span class="line">                    neuronFilter: relu)</span><br><span class="line"></span><br><span class="line">conv1 = <span class="type">MPSCNNConvolution</span>(device: device, convolutionDescriptor: conv1desc, </span><br><span class="line">            kernelWeights: conv1weights, biasTerms: conv1bias, flags: .<span class="keyword">none</span>)</span><br></pre></td></tr></table></figure><p>在这里你也可以创建各种描述符对象，但代码会短一些。</p><p>你已经看到如何使用 BNNS 进行推断：你在每个层级调用一次 <code>BNNSFilterApply()</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">BNNSFilterApply</span>(conv1, imagePointer, &amp;temp1) != <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"BNNSFilterApply failed on layer conv1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="type">BNNSFilterApply</span>(pool1, temp1, &amp;temp2) != <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"BNNSFilterApply failed on layer pool1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="type">BNNSFilterApply</span>(conv2, temp2, &amp;temp1) != <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"BNNSFilterApply failed on layer conv2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="type">BNNSFilterApply</span>(pool2, temp1, &amp;temp2) != <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"BNNSFilterApply failed on layer pool2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="type">BNNSFilterApply</span>(fc3, temp2, &amp;results) != <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"BNNSFilterApply failed on layer fc3"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>imagePointer</code> 指向一个<code>浮点值</code>的 Swift 数组。同样，<code>temp1</code> 和 <code>temp2</code> 是普通的 <code>Swift</code> <code>浮点值</code>数组。我们不断重复使用这些数组来存储中间结果。网络的最终输出会写入 <code>[Float]</code> 类型的 <code>results</code> 中。一旦网络完成计算，我们可以立即读取这个数组的结果，并在我们 App 的其他地方使用它们。</p><p>使用 MPSCNN 的过程是非常相似的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> commandBuffer = commandQueue.makeCommandBuffer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> conv1img = <span class="type">MPSTemporaryImage</span>(commandBuffer: commandBuffer, </span><br><span class="line">                                 imageDescriptor: conv1imgDesc)</span><br><span class="line">conv1.encode(commandBuffer: commandBuffer, sourceImage: inputImage, </span><br><span class="line">             destinationImage: conv1img)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pool1img = <span class="type">MPSTemporaryImage</span>(commandBuffer: commandBuffer, </span><br><span class="line">                                 imageDescriptor: pool1imgDesc)</span><br><span class="line">pool1.encode(commandBuffer: commandBuffer, sourceImage: conv1img, </span><br><span class="line">             destinationImage: pool1img)</span><br><span class="line">. . . </span><br><span class="line"></span><br><span class="line">fc3.encode(commandBuffer: commandBuffer, sourceImage: pool2img, </span><br><span class="line">           destinationImage: outputImage)</span><br><span class="line"></span><br><span class="line">commandBuffer.commit()</span><br></pre></td></tr></table></figure><p>你创建一个 <code>MPSTemporaryImage</code> 对象来保存当前层级的结果，然后通知层级对其自身使用 <code>encode()</code> 并添加到 Metal 的命令缓冲区。这些 <code>MPSTemporaryImage</code> 对象跟我们在 <code>BNNS</code> 代码中使用的 <code>temp1</code> 和 <code>temp2</code> 的是等价的。MPSCNN 在后台管理自己的存储。</p><p><code>inputImage</code> 和 <code>outputImage</code> 分别是网络的输入和输出，因此保存在持久化的 <code>MPSImage</code> 对象中。</p><p>请注意，除非你在命令缓冲区上调用 <code>commit()</code>，否则 GPU 将不会执行任何操作。使用 BNNS，每次调用 <code>BNNSFilterApply()</code> 便会立即开始处理。但是 MPSCNN 中的 <code>layer.encode(...)</code> 只是创建了 GPU 命令，不会马上执行它们。在调用 <code>commit()</code> 之后，GPU 才开始处理数据，而 CPU 可以自由地处理更多东西。</p><p>我们真正想要的是神经网络的输出是一个<code>浮点值</code>的数组。BNNS 已经可以处理普通的 Swift 数组，所以在此我们不需要做任何特别的事情。但是对于 MPSCNN，我们需要将输出的 <code>MPSImage</code> 对象的纹理转换成我们可以在 Swift 中使用的东西。在 App 的 <strong><code>MPSImage + Floats.swift</code></strong> 文件中包含一些辅助代码。</p><p>备注：如果你使用 BNNS 的 16 位浮点数（你很可能会这样做），那么在某些时候你需要转换回 32 位浮点数。在演示的 App 中，这是在最后一个层级之前做的，而不是之后，因为完全连接层无法处理 16 位浮点数。</p><h4 id="测试指标"><a href="#测试指标" class="headerlink" title="测试指标"></a>测试指标</h4><p>我想对 BNNS 和 MPSCNN 中创建的完全相同的神经网络的运行时间进行公平的比较。</p><p>我没有测试将输入数据转换为正确格式所需的时间。如果输入的数据是图像，并且使用 MPSCNN，你可以将其加载到纹理中，然后就不用管了。但是 BNNS 不行：你需要首先在内存中重新排列图像数据，这可能会非常费时。</p><p>然而，这实际上取决于你使用的是什么神经网络，这就是为什么我不想测量它。但是在我们的速度测试中，它确实给 BNNS 带来了轻微的优势，因为对于 BNNS 来说，获得正确形式的输入数据比较慢。</p><p>对于输出数据，我测量了将其转换回 Swift 数组所需的时间。在这里，MPSCNN 比较慢，而 BNNS 根本没有成本（如果使用 32 位浮点数的话）。所以这也有利于 BNNS。</p><p>然而，我认为在这种情况下的测量中包含转换是公平的，因为转换网络输出是你几乎总要做的事情。这是将 GPU 用于通用计算工作的一个缺点，因此降低了使用 GPU 所带来的性能收益。</p><p>对于一个公平的测试，我想在 MPSCNN 和 BNNS 中使用 16 位浮点数。MPSCNN 在内部总是将权重存储为 <code>float16</code> 类型，所以为了保持公正，我们也应该让 BNNS 使用 16 位浮点数。缺点是 Swift 没有“半浮点”类型，所以我们即使在使用 BNNS 时，总是需要用“真实的” 32 位浮点数来回转换。</p><p>备注：在 <strong>ViewController.swift</strong> 文件中有几个选项可以让你改变所测试的东西。特别是，它允许你更改学习参数的数据类型以及层级用来用于执行计算的数据类型。还有一个选项可以增大网络，这会增加所需的计算的数量，因为最初的网络很小，不一定代表真实的深度学习架构。</p><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>你准备好了吗？</p><p>对于基本的 5 层卷积网络，在我的 iPhone 6s 上，使用 16 位浮点数，BNNS 比 MPSCNN 快大约 25％。</p><p>所以这是CPU的胜利。</p><p>然而，如果我们在每一层中通过提供更多的处理通道（改变 App 中的<code>乘数值</code>）来使网络更庞大，MPSCNN 将轻松超越 BNNS。</p><p>当使用 32 位浮点数时，MPSCNN 也比 BNNS 更快。（可能是因为 MPSCNN 在内部总是使用 16 位浮点数，但 BNNS 现在有两倍的工作量。）</p><p>作为一个全面的指导方针，如果发送到网络的推断需要做<strong>超过3亿次的浮点运算</strong>，那么最好切换到 MPSCNN。</p><p>我以下面的方式来到这个数字：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number of flops per layer = 2 × kernelWidth   × kernelHeight   ×</span><br><span class="line">                                inputChannels × outputChannels ×</span><br><span class="line">                                outputWidth   × outputHeight</span><br></pre></td></tr></table></figure><p>然后我为每一层添加了触发器，并试验了网络的大小，来验证 MPSCNN 变得比 BNNS 更快的临界点。</p><p>警告：这是一个超级不科学的实验，我的计算可能会失败。但是，如果你为深层网络做了一个后台计算，并且发现它需要 1 Gflops（每秒10亿次的浮点运算数）或更多，那么很明显 BNNS 就不行了。</p><p>但请注意，这取决于许多因素：</p><ul><li><p>设备类型。我只在iPhone 6s上测试过。在较慢的 iPhone 6 或较快的 iPhone 7 上，性能可能会有所不同。</p></li><li><p>你的数据。正如我所指出的，MPSCNN 可以轻松地将图像加载到纹理中，但对于 BNNS ，你需要首先完全重新排列像素数据。你需要执行的预处理会对性能产生影响。</p></li><li><p>同样，为了在 Swift 中使用而对网络输出的数据进行的任何转换，都可能会减慢处理过程。</p></li><li><p>内存带宽。在我的 <a href="http://machinethink.net/blog/convolutional-neural-networks-on-the-iphone-with-vggnet/" target="_blank" rel="noopener">VGGNet 实现</a>中，学习参数占用大约 260 MB 的 RAM。对于每个推断，神经网络不仅需要做大量的计算，还需要访问数百万个存储单元。随时都可能遇到带宽的瓶颈。</p></li></ul><p>我试图尽可能公平地进行测试，但是由于这两个框架中的错误和其他怪异行为，使得过程并不完美。</p><p>例如，BNNS 全连接层不能接受 16 位浮点数，所以我必须先将数据转换回 32 位浮点数。由于完全连接层执行了大量的计算，如果支持这些半精度浮点数，BNNS 可能会更快。MPSCNN 的一些层级也有自己的怪异之处（详见<a href="https://github.com/hollance/BNNS-vs-MPSCNN" target="_blank" rel="noopener">源代码</a>）。</p><p>备注：我没有测试批处理。这两个 API 都可以一次处理多个输入图像。这只会增加一次性向网络发送的数据量。然而，GPU 可能在这方面有优势，因为批处理可能会更好地使用 GPU 带宽。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以应该使用哪个 API ？这要结合实际情况。</p><p>这两个 API 功能都有限，而且仍然有一些不足之处。对于较小的网络，BNNS 速度较快，但较大的网络速度较慢。BNNS 的功能也较少，你必须自己编写更多的代码。总的来说，BNNS API 比 MPSCNN 更丑陋一点，可能是因为它是一个 C API 被导入到 Swift 中。</p><p>但是，BNNS 与 MPSCNN 相比有一个优势：它也能运行在 macOS 上。</p><p>提示：<strong>使用16位浮点数</strong>。尽管 16 位浮点数不是 Swift 的本地类型，但它们能使 BNNS 执行得更高效，即使这意味着您必须将常规数组转换为 16 位浮点数，然后再返回。</p><p>就个人而言，我可能会坚持 MPSCNN 。它更加灵活，你可以将它与 Metal Performance Shaders 的快速矩阵乘法程序和自己的计算内核结合使用。</p><p><strong>最重要的是你的 App 运行得有多快，以及推断的效果如何。</strong></p><p>如果你的项目紧急，需要快点，请使用 MPSCNN。但是如果你能腾出时间，那最好用这两种 API 来分别实现你的神经网络，通过对比来达到最佳速度。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      在这篇文章中，我们将针对 BNNS 和 MPSCNN 进行对比来显示出这两者的差异
    
    </summary>
    
      <category term="machinethink" scheme="https://swift.gg/categories/machinethink/"/>
    
    
      <category term="深度学习" scheme="https://swift.gg/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift 的可选型枚举</title>
    <link href="https://swift.gg/2018/05/17/enums-and-optionals/"/>
    <id>https://swift.gg/2018/05/17/enums-and-optionals/</id>
    <published>2018-05-17T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.369Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2018/04/enums-and-optionals/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-11<br>译者：<a href="https://weibo.com/u/1771329710" target="_blank" rel="noopener">ennisk</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>去年我写了一篇关于<a href="http://khanlou.com/2017/03/that-one-optional-property/" target="_blank" rel="noopener">在类中添加普通可选型属性使扩展功能变得更简单</a>的文章，但是从长远来看会对代码库造成一定的损害，本文接上一篇内容。</p><p>假设你正在设计 App 中的认证流程，而且知道这个流程不是简单的线性执行代码，所以想写一些测试代码。</p><a id="more"></a><p>首先列举出流程中的每一步：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AuthFlowStep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> collectUsernameAndPassword</span><br><span class="line">    <span class="keyword">case</span> findFriends</span><br><span class="line">    <span class="keyword">case</span> uploadAvatar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将所有复杂的逻辑放入到一个函数中，该函数接收当前步骤和当前状态，返回流程中的下一个步骤。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepAfter</span><span class="params">(<span class="number">_</span> currentStep: AuthFlowStep, context: UserState)</span></span> -&gt; <span class="type">AuthFlowStep</span></span><br></pre></td></tr></table></figure><p>这应该很容易测试，到目前为止一切正常。</p><p>但是，在认真思考逻辑之后，你会发现有时候不能返回 <code>AuthFlowStep</code> 。一旦用户提交了所有认证需要的数据，你就需要想个办法表示流程已经结束了。在这个函数中，你需要返回一个特殊值。所以要怎么做呢？很简单，把返回类型改为可选值即可：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepAfter</span><span class="params">(<span class="number">_</span> currentStep: AuthFlowStep, context: UserState)</span></span> -&gt; <span class="type">AuthFlowStep</span>?</span><br></pre></td></tr></table></figure><p>这个方法可以解决问题，你可以在 <a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener">coordinator</a> 中调用这个函数，继续实现你的功能：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finished</span><span class="params">(flowStep: AuthFlowStep, state: UserState, from vc: SomeViewController)</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> nextState = stepAfter(flowStep, context: state)</span><br></pre></td></tr></table></figure><p>由于 <code>nextState</code> 是可选值，所以最直接的想法就是用 <code>guard</code> 方法把它变成非可选值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> nextState = stepAfter(flowStep, context: state) <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">self</span>.parentCoordinator.authFlowFinished(on: <span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">switch</span> nextState &#123;</span><br><span class="line">  <span class="keyword">case</span> .collectUsernameAndPassword:</span><br><span class="line"><span class="comment">//build and present next view controller</span></span><br></pre></td></tr></table></figure><p>但是我总觉得这里的写法有点问题。阅读 <a href="http://alisoftware.github.io/swift/pattern-matching/2016/04/24/pattern-matching-3/#syntactic-sugar-on-optionals" target="_blank" rel="noopener">Olivier 的模式匹配指南</a> 之后，我发现可以在 <code>switch</code> 语句中同时处理可选值和枚举值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finished</span><span class="params">(flowStep: AuthFlowStep, state: UserState, from viewController: SomeViewController)</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> nextState = stepAfter(flowStep, context: state) <span class="comment">// Optional&lt;AuthFlowStep&gt;</span></span><br><span class="line"><span class="keyword">switch</span> nextState &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">self</span>.parentCoordinator.authFlowFinished(on: <span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">case</span> .collectUsernameAndPassword?:</span><br><span class="line"><span class="comment">//build and present next view controller</span></span><br></pre></td></tr></table></figure><p>代码里的那个问号可以匹配枚举的可选值。这种写法确实更好，但还是有点不对劲。既然我已经用了 <code>switch</code>，为什么还要做解包操作？<code>nil</code> 在这个上下文中又代表着什么？</p><p>如果你认真读过这篇文章的标题，或许已经猜到了我下面要做什么。我们先来看看可选值的定义。在底层代码中，它和 <code>AuthFlowState</code> 一样是个枚举：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">case</span> some(<span class="type">Wrapped</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把枚举转换成可选类型时，实际上只是向枚举中添加了一个新值。既然我们能直接控制 <code>AuthFlowStep</code>，直接给它添加一个新值就能实现同样的效果。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AuthFlowStep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> collectUsernameAndPassword</span><br><span class="line">    <span class="keyword">case</span> findFriends</span><br><span class="line">    <span class="keyword">case</span> uploadAvatar</span><br><span class="line">    <span class="keyword">case</span> finished</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以从函数返回值类型中删掉 <code>?</code> 了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepAfter</span><span class="params">(<span class="number">_</span> currentStep: AuthFlowStep, context: UserState)</span></span> -&gt; <span class="type">AuthFlowStep</span></span><br></pre></td></tr></table></figure><p>我们的 <code>switch</code> 语句现在可以直接处理所有步骤，不需要对 <code>nil</code> 做特殊处理。</p><p>为什么这样更好？有几个原因：</p><p>首先，现在 <code>nil</code> 对应的情况有了具体的名字。以前，使用该函数的用户可能不清楚函数返回 <code>nil</code> 意味着什么。他们要么去阅读文档求助，要么直接阅读函数代码，分析什么时候会返回 <code>nil</code> 。</p><p>第二，简单才是王道，不需要先用 <code>guard</code> 解包再用 <code>switch</code> 判断，也不需要用 <code>swtich</code> 语句处理两层枚举，一层枚举更容易处理。</p><p>最后，代码更加健壮。<code>return nil</code> 应该留给真正异常情况。下一个开发者可能需要在某些特殊情况发生时退出函数，他想都没想就写了个 <code>return nil</code>。这时 <code>nil</code> 就具备了两种含义，你的代码无法正确处理。</p><p>当你把特殊情况添加到枚举中时，需要想好到底使用什么名字。你有很多选择，挑一个最合适的：<code>.unknow</code>，<code>.none</code>，<code>.finished</code>，<code>.initial</code>，<code>.notFound</code>，<code>.default</code>，<code>.nothing</code>，<code>.unspecified</code> 等等（需要注意，如果你有一个 case 匹配的是 <code>.none</code>，并且匹配的值是可选值，那么 <code>Option.none</code> 和 <code>YourEnum.none</code> 都会引起歧义，所以不要在匹配可选值的时候使用 <code>.none</code> 去表示你自己的状态）。</p><p>这篇文章介绍的是流程状态，但我觉得这种模式也同样适用其他情况 — 如果你想把一个枚举改成可选值，最好先停下来想一想，是否可以给枚举加一个新值来表示特殊情况。</p><p>感谢 <a href="https://irace.me/" target="_blank" rel="noopener">Bryan Irace</a> 提出的反馈和示例代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2018/04/enums-and-optionals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-04-11&lt;br&gt;译者：&lt;a href=&quot;https://weibo.com/u/1771329710&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ennisk&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;去年我写了一篇关于&lt;a href=&quot;http://khanlou.com/2017/03/that-one-optional-property/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在类中添加普通可选型属性使扩展功能变得更简单&lt;/a&gt;的文章，但是从长远来看会对代码库造成一定的损害，本文接上一篇内容。&lt;/p&gt;
&lt;p&gt;假设你正在设计 App 中的认证流程，而且知道这个流程不是简单的线性执行代码，所以想写一些测试代码。&lt;/p&gt;
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>使非法状态不可表示</title>
    <link href="https://swift.gg/2018/05/14/making-illegal-states-unrepresentable/"/>
    <id>https://swift.gg/2018/05/14/making-illegal-states-unrepresentable/</id>
    <published>2018-05-14T00:00:00.000Z</published>
    <updated>2018-08-09T02:08:30.369Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2018/03/making-illegal-states-unrepresentable/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-03-27<br>译者：<a href="http://daizi.me" target="_blank" rel="noopener">小袋子</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><blockquote><p>你知道 <code>URLSession</code> 能同时返回响应和错误吗？</p></blockquote><p><a href="https://oleb.net/blog/2015/07/swift-type-system/" target="_blank" rel="noopener">我之前介绍过</a>，Swift 强类型系统的一个主要优点是天生具备编译器强制遵循的文档规范。</p><h2 id="类型是编译器强制遵循的文档规范"><a href="#类型是编译器强制遵循的文档规范" class="headerlink" title="类型是编译器强制遵循的文档规范"></a>类型是编译器强制遵循的文档规范</h2><p>类型为函数的行为设立了一种“界限”，因此一个易用的 API 应该精心选择输入输出类型。</p><a id="more"></a><p>仔细思考以下 Swift 函数声明：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> / <span class="params">(dividend: Int, divisor: Int)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>在不阅读任何函数实现的情况下，你就可以推断出这应该是<a href="http://mathworld.wolfram.com/IntegerDivision.html" target="_blank" rel="noopener">整型除法</a>，因为返回的类型不可能是小数。相较之下，如果函数的返回类型是既可以表示整型，也可以表示浮点型数值的 <a href="https://developer.apple.com/documentation/foundation/nsnumber" target="_blank" rel="noopener"><code>NSNumber</code></a>，那你就只能祈祷开发者自觉遵循文档只返回整数。</p><p>随着类型系统的表现越来越好，这种使用类型来记录函数行为的技巧变得越来越有用。如果 <code>Swift</code> 有一个<a href="#quote1"><code>NonZeroInt</code> 类型</a>代表 “除了 <code>0</code> 之外的整型” ，那么除法函数可能就会变成下面这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> / <span class="params">(dividend: Int, divisor: NonZeroInt)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>类型检查不允许传入的除数为 <code>0</code> ，因此你不用关心函数如何处理除数为 <code>0</code> 的错误。函数会中断吗？会返回一个没有意义的值吗？如果你用的是上一种定义，就必须在文档里单独说明特殊情况的处理方式。</p><h2 id="使非法状态成为不可能"><a href="#使非法状态成为不可能" class="headerlink" title="使非法状态成为不可能"></a>使非法状态成为不可能</h2><p>我们可以把这个观点转换为一条通用规则：<strong>使用类型让你的程序无法表现非法状态</strong>。</p><p>如果你想学习更多相关知识，可以看看 Brandon Williams 和 Stephen Celis 的最新视频系列 <a href="https://www.pointfree.co/" target="_blank" rel="noopener">Point-Free</a>。他们讲了很多这方面的知识和相关话题，前八集真的特别棒，我强烈推荐大家去订阅，你会学到很多东西。</p><p>在<a href="https://www.pointfree.co/episodes/ep4-algebraic-data-types" target="_blank" rel="noopener">第四集</a>关于代数数据类型（<a href="https://en.wikipedia.org/wiki/Algebraic_data_type" target="_blank" rel="noopener">algebraic data types</a>）的视频中，Brandon 和 Stephen 讨论了如何组合 <code>enums</code> 和 <code>structs</code>（或者 <code>tuples</code>）来精确表示期望状态的类型，并且让所有非法状态无法表示。在视频的最后，他们用 Apple 的 <a href="https://developer.apple.com/documentation/foundation/urlsession" target="_blank" rel="noopener">URLSession</a> API 作为反面教材进行介绍，因为这个 API 没有使用最合适的类型，这就引出了本文的子标题——“你知道 URLSession 能同时返回响应和错误吗？”。</p><h2 id="URLSession"><a href="#URLSession" class="headerlink" title="URLSession"></a>URLSession</h2><p>Swift 的类型系统比 Objective-C 更富有表现力。然而，很多 Apple 自己的 API 也没有利用这个优势，可能是因为没空更新老旧的 API，或者是为了维持 Objective-C 的兼容性。</p><p>在 iOS 中发起一个<a href="https://developer.apple.com/documentation/foundation/urlsession/1410330-datatask" target="_blank" rel="noopener">网络请求</a>的通用方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLSession</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dataTask</span><span class="params">(with url: URL,</span></span></span><br><span class="line"><span class="function"><span class="params">        completionHandler: @escaping <span class="params">(Data?, URLResponse?, Error?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">        -&gt; <span class="type">URLSessionDataTask</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调函数的参数是三个可选值：<a href="https://developer.apple.com/documentation/foundation/data" target="_blank" rel="noopener"><code>Data?</code></a>，<a href="https://developer.apple.com/documentation/foundation/urlresponse" target="_blank" rel="noopener"><code>URLResponse?</code></a> 和 <a href="https://developer.apple.com/documentation/swift/error" target="_blank" rel="noopener"><code>Error?</code></a>。这将产生 <code>2 × 2 × 2 = 8</code> 种<a href="#quote2">可能的状态</a>，但是其中有多少种是合法的呢？</p><p>引述 <a href="https://www.pointfree.co/episodes/ep4-algebraic-data-types" target="_blank" rel="noopener">Brandon 和 Stephen</a> 的观点：“这里有很多状态毫无意义”。有些组合很明显没有意义，另外我们基本可以确定，这三个值不可能全为 <code>nil</code> 或全为非 <code>nil</code>。</p><h2 id="响应和错误能够同时非-nil"><a href="#响应和错误能够同时非-nil" class="headerlink" title="响应和错误能够同时非 nil"></a>响应和错误能够同时非 <code>nil</code></h2><p>其他状态就很棘手了，在这里 Brandon 和 Stephen 犯了一点小错误：他们认为 API 要么返回一个有效的 <code>Data</code> 和 <code>URLResponse</code>，要么返回一个 <code>Error</code>。毕竟接口不可能同时返回一个非 <code>nil</code> 的响应和错误。看起来很有道理，对不对？</p><p>但事实上这是错误的。<code>URLResponse</code> 封装了服务器的 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html" target="_blank" rel="noopener">HTTP 响应头部</a>，只要接收到一个有效的响应头部， <code>URLSession</code> API 就会一直给你提供这个值，无论后续的阶段请求是否出错（例如取消和超时)。因而 API 的完成处理中有可能包含一个有效的 <code>URLResponse</code> 和非 <code>nil</code> 的错误值（但是没有 <code>Data</code>）。</p><p>如果你对 <code>URLSession</code> 代理（delegate）API 比较熟悉的话，应该不会太惊讶，因为代理方法就是分成 <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/1410027-urlsession" target="_blank" rel="noopener"><code>didReceiveResponse</code></a> 和 <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/1411528-urlsession" target="_blank" rel="noopener"><code>didReceiveData</code></a>。实际上，<a href="https://developer.apple.com/documentation/foundation/urlsession/1410330-datatask" target="_blank" rel="noopener"><code>dataTask​(with:​completionHandler:)</code>的文档</a>也提到了这个问题：</p><blockquote><p>如果收到服务器的响应，那么<strong>无论请求成功或失败</strong>，响应参数都会有值。</p></blockquote><p>不过，我敢打赌 Cocoa 开发人员普遍对此抱有误解。仅仅在过去的四周，我就看到<a href="https://davedelong.com/blog/2018/03/02/apple-networking-feedback/" target="_blank" rel="noopener">两</a>篇<a href="https://ruiper.es/2018/03/03/ras-s2e1/" target="_blank" rel="noopener">文章</a>的作者犯了同样的错误（至少没有领悟其中的真谛）。</p><p>说真的，我很喜欢这个充满讽刺意味的事实：Brandon 和 Stephen 试图指出由于类型问题导致的 API 缺陷，但在指出错误的同时，这个类型问题又让他们犯了另一个错误。如果原始 API 使用了更好的类型，那么这两个错误就都能避免，这反而证明了他们的观点：一个有更加严格类型的 API 能够避免错误使用。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>如果你想自己体验一下 <code>URLSession</code> 的功能，你可以复制以下代码到 Swift playground：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> PlaygroundSupport</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果返回 404，把 URL 换成随便一个大文件</span></span><br><span class="line"><span class="keyword">let</span> bigFile = <span class="type">URL</span>(string: <span class="string">"https://speed.hetzner.de/1GB.bin"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: bigFile) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"data:"</span>, data <span class="keyword">as</span> <span class="type">Any</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"response:"</span>, response <span class="keyword">as</span> <span class="type">Any</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error:"</span>, error <span class="keyword">as</span> <span class="type">Any</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task.resume()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过几秒之后取消下载</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">3</span>) &#123;</span><br><span class="line">    task.cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">PlaygroundPage</span>.current.needsIndefiniteExecution = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这段代码首先下载一个大文件，然后在几秒后取消。最后，完成的处理中返回了一个非 <code>nil</code> 的响应和错误。</p><p>（这里假设指定的时间间隔内，能够获取到服务器响应的头部，但不能完成下载。如果你的网速非常慢或者非常变态，请自行调整这个时间参数）</p><h2 id="正确的类型应该是什么？"><a href="#正确的类型应该是什么？" class="headerlink" title="正确的类型应该是什么？"></a>正确的类型应该是什么？</h2><p>Brandon 和 Stephen 随后在 <a href="https://www.pointfree.co/episodes/ep9-algebraic-data-types-exponents" target="_blank" rel="noopener">Point-Free 的第九集视频</a>中发布了他们对问题的跟进。他们认为“正确”的参数类型应该是：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(<span class="type">URLResponse</span>?, <span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">Error</span>&gt;)</span><br></pre></td></tr></table></figure><p>我不同意，因为如果有数据，就一定有响应，不可能只有数据没有响应。我认为应该是这样的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Result</span>&lt;(<span class="type">Data</span>, <span class="type">URLResponse</span>), (<span class="type">Error</span>, <span class="type">URLResponse</span>?)&gt;</span><br></pre></td></tr></table></figure><p>解读：你将要么得到数据和响应（后者肯定不是 <code>nil</code>），要么得到一个错误和一个可选类型的响应。不可否认，我的建议与一般的 <code>Result</code> 类型定义相悖，因为它将失败参数约束为不能符合 <code>Error</code> 的 <a href="https://developer.apple.com/documentation/swift/error" target="_blank" rel="noopener">Error</a> 协议—<code>(Error, URLResponse?)</code>。目前 <a href="https://forums.swift.org/t/adding-result-to-the-standard-library/6932/58" target="_blank" rel="noopener">Swift 论坛正在讨论</a> <code>Error</code> 约束是否有必要。</p><h2 id="Result-类型"><a href="#Result-类型" class="headerlink" title="Result 类型"></a><code>Result</code> 类型</h2><p>由于 <code>URLResponse</code> 参数的非直观行为，<code>URLSession</code> 的API 显得特别棘手。但是 Apple 几乎所有的基于回调的异步 API 都有相同的问题，它们所提供的类型使得非法状态可以表示。</p><p>如何解决这个问题呢？</p><p>Swift 的通用方案是定义一个 <a href="https://github.com/antitypical/Result/blob/03fba33a0a8b75492480b9b2e458e88651525a2a/Result/Result.swift" target="_blank" rel="noopener">Result 类型</a>—一个可以代表通用成功值或错误的枚举。最近，又有人试图将 <a href="https://forums.swift.org/t/adding-result-to-the-standard-library/6932/20" target="_blank" rel="noopener">Result 添加到标准库</a>。</p><p>如果 Swift 5 添加了 <code>Result</code>（大胆假设），Apple 可能（更大胆的假设）会自动导入类似这样 <code>completionHandler: (A?, Error?) -&gt; Void as (Result&lt;A&gt;) -&gt; Void</code> 的 Cocoa API，将四个可表现的状态转为两个。在那之前（如果真的会发生的话），我建议你还是先自己<a href="https://oleb.net/blog/2017/01/result-init-helper/" target="_blank" rel="noopener">实现转换</a>。</p><p>长远来看，Swift 终有一天能从语言层面正确支持异步 API。社区和 Swift 团队可能会提出新的解决方案，<a href="https://gist.github.com/lattner/429b9070918248274f25b714dcfc7619#conversion-of-imported-objective-c-apis" target="_blank" rel="noopener">把现有的 Cocoa API 移植到新系统中</a>，就像把 Objective-C 的 <code>NSError **</code> 参数作为抛出（throwing）函数引入 Swift 一样。不过不要太过期待，Swift 6 之前肯定实现不了。</p><hr><p><span id="quote1"><br>1、你可以自己定义一个 <code>NonZeroInt</code> 类型，但是没有办法告诉编译器“如果有人尝试用零去初始化这个类型，就引发一个错误”。你必须依赖运行时检查。</span></p><p>不过，引入这样的类型通常是个不错的想法，因为类型的用户可以在初始化之后依赖于所声明的不变性。我还没有在其他地方看到一个 <code>NonZeroInt</code> 类型，保证类型为非空集合的自定义类型更受欢迎。<br></p><p><span id="quote2"><br>2、我只是把“<code>nil</code>”或“非<code>nil</code>”作为可能的状态。显然，非 <code>nil</code> 数据值可以具有无数种可能的状态，并且对于其他两个参数也是如此。但是这些状态对我们来说并不好玩。<br></span></p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2018/03/making-illegal-states-unrepresentable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-03-27&lt;br&gt;译者：&lt;a href=&quot;http://daizi.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小袋子&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;blockquote&gt;
&lt;p&gt;你知道 &lt;code&gt;URLSession&lt;/code&gt; 能同时返回响应和错误吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://oleb.net/blog/2015/07/swift-type-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我之前介绍过&lt;/a&gt;，Swift 强类型系统的一个主要优点是天生具备编译器强制遵循的文档规范。&lt;/p&gt;
&lt;h2 id=&quot;类型是编译器强制遵循的文档规范&quot;&gt;&lt;a href=&quot;#类型是编译器强制遵循的文档规范&quot; class=&quot;headerlink&quot; title=&quot;类型是编译器强制遵循的文档规范&quot;&gt;&lt;/a&gt;类型是编译器强制遵循的文档规范&lt;/h2&gt;&lt;p&gt;类型为函数的行为设立了一种“界限”，因此一个易用的 API 应该精心选择输入输出类型。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
</feed>
