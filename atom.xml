<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftGG</title>
  
  <subtitle>走心的 Swift 翻译组</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swift.gg/"/>
  <updated>2023-08-26T12:25:35.817Z</updated>
  <id>https://swift.gg/</id>
  
  <author>
    <name>SwiftGG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>属性修饰器</title>
    <link href="https://swift.gg/2020/05/24/propertywrapper/"/>
    <id>https://swift.gg/2020/05/24/propertywrapper/</id>
    <published>2020-05-23T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/propertywrapper/" target="_blank" rel="noopener">原文链接</a>，原文日期：2019-06-24<br>译者：ericchuhong；校对：Desgard，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.sketchk.xyz" target="_blank" rel="noopener">SketchK</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>几年前，我们 <a href="https://nshipster.com/at-compiler-directives/" target="_blank" rel="noopener">会说</a> “at 符号”（<code>@</code>）——以及方括号和可笑的长方法名称——是 Objective-C 的特性，正如括号之于 <a href="https://en.wikipedia.org/wiki/Lisp_%28programming_language%29" target="_blank" rel="noopener">Lisp</a> 或者标点之于 <a href="https://nshipster.com/assets/qbert-fe44c1a26bd163d2dfafa5334c7bfa7957c3c243cd0c19591f494a9cea9302dc.png" target="_blank" rel="noopener">Perl</a>。</p><p>然后 Swift 来了，并用它来结束这些古怪小 🥨 图案一样的字形。或者说我们本以为会这样。</p><a id="more"></a><p>一开始，Swift 中的 <code>@</code> 只用在和 Objective-C 的混编中：<code>@IBAction</code>、<code>@NSCopying</code>、<code>@UIApplicationMain</code>等等。但之后 Swift 扩展出了越来越多的带有 <code>@</code> 前缀的 <a href="https://docs.swift.org/swift-book/ReferenceManual/Attributes.html" target="_blank" rel="noopener">属性</a>。</p><p>我们在 <a href="https://nshipster.com/wwdc-2019/" target="_blank" rel="noopener">WWDC 2019</a> 上第一次看到了 Swift 5.1 和 SwiftUI 的同时公布。并且随着每一张“令人兴奋”的幻灯片出现了一个个前所未有的属性：<code>@State</code>、<code>@Binding</code>、<code>@EnvironmentObject</code>……</p><p>我们看到了Swift的未来，它充满了 <code>@</code> 符号。</p><hr><p>等 SwiftUI 逐步成熟起来，我们才会深入介绍它。</p><p>本周，我们想仔细看看 SwiftUI 的一个关键语言特性——可能会对 Swift 5.1 之前版本产生最大影响的东西：<em>属性修饰器</em></p><hr><h2 id="关于-属性-代理-修饰器"><a href="#关于-属性-代理-修饰器" class="headerlink" title="关于 属性 代理 修饰器"></a>关于 属性 <del>代理</del> 修饰器</h2><p>属性修饰器是在 2019 年 3 月第一次 <a href="https://forums.swift.org/t/pitch-property-delegates/21895" target="_blank" rel="noopener">在 Swift 论坛首次出现</a>——SwiftUI 公布的前一个月。</p><p>在开始的时候，Swift 核心团队成员 Douglas Gregor 将它作为用户常用功能特性的一个统称（当时称为 <em>“属性代理”</em>），像有 <code>lazy</code> 关键字之类的。</p><p>懒惰是程序员的美德，这种普遍适用的功能是周到设计决策的特征，这让 Swift 成为一种很好用的语言。当一个属性被声明为 <code>lazy</code> 时，它推迟初始化其默认值，直到第一次访问才进行初始化。例如，你可以自己尝试实现这样的功能，使用一个私有属性，它需通过计算后才行被访问。而单单一个 <code>lazy</code> 关键字就可以让所有这些都变得没有必要。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &lt;#<span class="title">Structure</span>#&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 lazy 关键字进行属性延迟初始化</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> deferred = &lt;#...#&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有 lazy 关键字的等效行为</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _deferred: &lt;#<span class="type">Type</span>#&gt;?</span><br><span class="line">    <span class="keyword">var</span> deferred: &lt;#<span class="type">Type</span>#&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> value = _deferred &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">            <span class="keyword">let</span> initialValue = &lt;#...#&gt;</span><br><span class="line">            _deferred = initialValue</span><br><span class="line">            <span class="keyword">return</span> initialValue</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            _deferred = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md" target="_blank" rel="noopener">SE-0258: 属性修饰器</a> 目前正在进行第三次审核（预定于昨天结束，就在发布的时候）, 并且承诺开放像 <code>lazy</code> 这样的功能，以便库作者可以自己实现类似的功能。</p><p>由于这个提案在其设计和实现上的阐述非常出色，我们这里就不做更多的解释了。我们不妨把重点放在别处，一起来看看这个功能为 Swift 带来了哪些新的可能——而且，在这个过程中，我们可以更好了解如何在项目使用这个新功能。</p><p>所以，供你参考，以下是新 <code>@propertyWrapper</code> 属性的四个潜在用例：</p><ul><li><a href="#constraining-values">约束值</a></li><li><a href="#transforming-values-on-property-assignment">转换属性赋值时的值</a></li><li><a href="#changing-synthesized-equality-and-comparison-semantics">改变生成的等式和比较语义</a></li><li><a href="#auditing-property-access">审查属性访问</a></li></ul><hr><p><a name="constraining-values"></a></p><h2 id="约束值"><a href="#约束值" class="headerlink" title="约束值"></a>约束值</h2><p>SE-0258 提供了大量实用案例，包括了 <code>@Lazy</code>，<code>@Atomic</code>，<code>@ThreadSpecific</code> 和 <code>@Box</code>。但最让我们兴奋的是那个关于 <code>@Constrained</code> 的属性修饰器。</p><p>Swift 标准库提供了 <a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">精确</a>、高性能的浮点数类型，并且你可以拥有任何想要的精度——只要它是 <a href="https://developer.apple.com/documentation/swift/float" target="_blank" rel="noopener">32</a> 或 <a href="https://developer.apple.com/documentation/swift/double" target="_blank" rel="noopener">64</a>（或 <a href="https://developer.apple.com/documentation/swift/float80" target="_blank" rel="noopener">80</a>）位长度。</p><p>如果你想要实现自定义浮点数类型，而且有强制要求有效值范围，这从 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md" target="_blank" rel="noopener">Swift 3</a> 开始已经成为可能。但是这样做需要遵循错综复杂的协议要求：</p><p><img src="https://raw.githubusercontent.com/SwiftGGTeam/ggtalk/master/translation_image.svg"></p><p>来自：<a href="https://flight.school/books/numbers/" target="_blank" rel="noopener">航空学院的 Swift 数字指引</a></p><p>要把这么多协议实现下来工作量可不小，并且对于大多数用例，通常需要大量的工作来验证。</p><p>幸好，属性修饰器提供了一种将标准数字类型参数化的方式，同时又大大减少工作量。</p><h3 id="实现一个限制值范围的属性修饰器"><a href="#实现一个限制值范围的属性修饰器" class="headerlink" title="实现一个限制值范围的属性修饰器"></a>实现一个限制值范围的属性修饰器</h3><p>思考下面的 <code>Clamping</code> 结构。作为一个属性修饰器（由 <code>@propertyWrapper</code> 属性表示），它会自动在规定的范围内“限制”越界的值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Clamping</span>&lt;<span class="title">Value</span>: <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Value</span></span><br><span class="line">    <span class="keyword">let</span> range: <span class="type">ClosedRange</span>&lt;<span class="type">Value</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(initialValue value: <span class="type">Value</span>, <span class="number">_</span> range: <span class="type">ClosedRange</span>&lt;<span class="type">Value</span>&gt;) &#123;</span><br><span class="line">        <span class="built_in">precondition</span>(range.<span class="built_in">contains</span>(value))</span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">        <span class="keyword">self</span>.range = range</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; value &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; value = <span class="built_in">min</span>(<span class="built_in">max</span>(range.lowerBound, newValue), range.upperBound) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用 <code>@Clamping</code> 保证属性在转成模型 <a href="https://en.wikipedia.org/wiki/PH" target="_blank" rel="noopener">化学溶液中的酸度</a> 的过程中，处于 0-14 的常规范围内。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    @<span class="type">Clamping</span>(<span class="number">0</span>...<span class="number">14</span>) <span class="keyword">var</span> pH: <span class="type">Double</span> = <span class="number">7.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> carbonicAcid = <span class="type">Solution</span>(pH: <span class="number">4.68</span>) <span class="comment">// 在标准情况下为 1 mM</span></span><br></pre></td></tr></table></figure><p>如果尝试将 pH 值设定在限制的范围之外，将得到最接近的边界值（最小值或者最大值）来代替。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> superDuperAcid = <span class="type">Solution</span>(pH: -<span class="number">1</span>)</span><br><span class="line">superDuperAcid.pH <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>你可以在其他属性修饰器的实现中使用属性修饰器。例如，这个 <code>UnitInterval</code> 属性修饰起器委托给 <code>@Clamping</code>，把值约束在 0 和 1 之间，包括 0 和 1。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnitInterval</span>&lt;<span class="title">Value</span>: <span class="title">FloatingPoint</span>&gt; </span>&#123;</span><br><span class="line">    @<span class="type">Clamping</span>(<span class="number">0</span>...<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> = .zero</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(initialValue value: <span class="type">Value</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.wrappedValue = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再比如，你可以使用 <code>@UnitInterval</code> 属性修饰器定义一个 <code>RGB</code> 的类型，用来表示红色、绿色、蓝色的百分比强度。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RGB</span> </span>&#123;</span><br><span class="line">    @<span class="type">UnitInterval</span> <span class="keyword">var</span> red: <span class="type">Double</span></span><br><span class="line">    @<span class="type">UnitInterval</span> <span class="keyword">var</span> green: <span class="type">Double</span></span><br><span class="line">    @<span class="type">UnitInterval</span> <span class="keyword">var</span> blue: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cornflowerBlue = <span class="type">RGB</span>(red: <span class="number">0.392</span>, green: <span class="number">0.584</span>, blue: <span class="number">0.929</span>)</span><br></pre></td></tr></table></figure><h4 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h4><ul><li>实现一个 <code>@Positive</code>/<code>@NonNegative</code> 属性装饰器，将无符号整数赋值成有符号整数类型。</li><li>实现一个 <code>@NonZero</code> 属性装饰器，使得一个数值要么大于，要么小于 <code>0</code>。</li><li><code>@Validated</code> 或者 <code>@Whitelisted</code>/<code>@Blacklisted</code> 属性装饰器，约束了什么样的值可以被赋值。</li></ul><p><a name="transforming-values-on-property-assignment"></a></p><h2 id="转换属性赋值时的值"><a href="#转换属性赋值时的值" class="headerlink" title="转换属性赋值时的值"></a>转换属性赋值时的值</h2><p>从用户接收文本输入是应用开发者经常头疼的问题。从无聊的字符串编码到恶意的文本字段注入攻击，开发者有太多事情需要注意。但在开发者面对的的问题中，最难以捉摸和令人困扰的是接收用户生成的内容，而且这些内容开头和结尾都带有空格。</p><p>在内容开头有一个单独的空格，可以让 URL 无效，也可以混淆日期解析器，还可能造成差一错误（off-by-one error）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="type">URL</span>(string: <span class="string">" https://nshipster.com"</span>) <span class="comment">// nil (!)</span></span><br><span class="line"></span><br><span class="line"><span class="type">ISO8601DateFormatter</span>().date(from: <span class="string">" 2019-06-24"</span>) <span class="comment">// nil (!)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> words = <span class="string">" Hello, world!"</span>.components(separatedBy: .whitespaces)</span><br><span class="line">words.<span class="built_in">count</span> <span class="comment">// 3 (!)</span></span><br></pre></td></tr></table></figure><p>说到用户输入，客户端经常以没留意做理由，然后把所有东西 <em>原原本本</em> 发送给服务器。<code>¯\_(ツ)_/¯</code>。</p><p>当然我不是在倡导客户端应该为此负责更多处理工作，这种情况就涉及到了 Swift 属性修饰器另外一个引人注目的用例。</p><hr><p>Foundation 框架将 <code>trimmingCharacters(in:)</code> 方法桥接到了 Swift 的字符串中，除了一些其他作用以外，它提供了便利的方式来裁剪掉 <code>String</code> 值首位两端的空格。虽然可以通过调用这个方法来保证数据健全，但是还不够便利。如果你也有过类似的经历，你肯定会想知道有没有更好的方案。</p><p>或许你找到了一种较为通用的方法，通过 <code>willSet</code> 属性回调来寻解脱……唯一让人不能满意的是，这个方法无法改变已经发生的事情。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            title = newValue.trimmingCharacters(<span class="keyword">in</span>: .whitespacesAndNewlines)</span><br><span class="line">            <span class="comment">/* ⚠️ 尝试在它自己的 willSet 中存储属性 'title'，该属性将会被新值覆盖*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面看，你可能想到可以用 <code>didSet</code>，作为解决问题的康庄大道……不过我想你马上就会想起来 Swift 里的一条规定，即 <code>didSet</code> 在属性初始化赋值时是不会被调用的。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// 😓 初始化期间未调用</span></span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.title = title.trimmingCharacters(<span class="keyword">in</span>: .whitespacesAndNewlines)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在属性自己的 <code>didSet</code> 回调方法里面，很幸运不会再次触发回调，所以你不必担心意料之外的递归调用。</p></blockquote><p>在你的坚持不懈下，你很可能用尽了一切办法……但回过头来，你发现其实并没有什么方法能够既满足人因工程学的标准，又满足性能方面的要求</p><p>如果你对此深有体会，那么恭喜你，你在这方面的探索可以到此为止了，因为属性装饰器将是这个问题的终极解决方案。</p><h3 id="实现为字符串值裁截空格的属性修饰器"><a href="#实现为字符串值裁截空格的属性修饰器" class="headerlink" title="实现为字符串值裁截空格的属性修饰器"></a>实现为字符串值裁截空格的属性修饰器</h3><p>看下下面的 <code>Trimmed</code> 结构体，它从输入的字符串裁截了空格和换行。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line">@propertyWrapper</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trimmed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> value: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; value &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; value = newValue.trimmingCharacters(<span class="keyword">in</span>: .whitespacesAndNewlines) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(initialValue: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.wrappedValue = initialValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码为 <code>Post</code> 结构中每个 <code>String</code> 属性标记了 <code>@Trimmed</code> ，通过这种方式，任何赋值给 <code>title</code> 或 <code>body</code> 的字符串值——无论是在初始化期间还是通过属性访问后——都将自动删除其开头或结尾的空格。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line">    @<span class="type">Trimmed</span> <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    @<span class="type">Trimmed</span> <span class="keyword">var</span> body: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> quine = <span class="type">Post</span>(title: <span class="string">"  Swift Property Wrappers  "</span>, body: <span class="string">"&lt;#...#&gt;"</span>)</span><br><span class="line">quine.title <span class="comment">// "Swift Property Wrappers" (no leading or trailing spaces!)</span></span><br><span class="line"></span><br><span class="line">quine.title = <span class="string">"      @propertyWrapper     "</span></span><br><span class="line">quine.title <span class="comment">// "@propertyWrapper" (still no leading or trailing spaces!)</span></span><br></pre></td></tr></table></figure><h4 id="举一反三-1"><a href="#举一反三-1" class="headerlink" title="举一反三"></a>举一反三</h4><ul><li>实现一个 <code>@Transformed</code> 属性修饰器，它允许对输入的字符串进行 <a href="https://developer.apple.com/documentation/foundation/nsstring/1407787-applyingtransform" target="_blank" rel="noopener">ICU 转换</a>。</li><li>实现一个 <code>@Normalized</code> 属性修饰器，它允许一个 <code>String</code> 属性自定义它<a href="https://unicode.org/reports/tr15/#Norm_Forms" target="_blank" rel="noopener">正规形式</a></li><li>实现一个 <code>@Quantized</code>/<code>@Rounded</code>/<code>@Truncated</code> 属性修饰器，它会把数值转换到一种特定的精度（例如：向上舍入到最近的 ½ 精度），但是内部要关注到精确过程的中间值，防止连锁的舍入错误。</li></ul><p><a name="changing-synthesized-equality-and-comparison-semantics"></a></p><h2 id="改变生成的等式和比较语义"><a href="#改变生成的等式和比较语义" class="headerlink" title="改变生成的等式和比较语义"></a>改变生成的等式和比较语义</h2><blockquote><p>这个方式取决于遵循 synthesized 协议的实现细节，并且可能会在这个功能完成之前发生改变（尽管我们希望这个方法仍然像下面所说一样继续可用）。</p></blockquote><p>在 Swift 中，两个 <code>String</code> 值如果他们 <a href="https://unicode.org/reports/tr15/#Canon_Compat_Equivalence" target="_blank" rel="noopener"><em>标准等价</em></a> 就会被人认为是相等。在大多数情况下，Swift 字符串的比较方式与我们的预期一致：即两个字符串包含有相同的字符就会相等，不管它是一个合成字符，还是将这个合成字符拆解成多个字符——举个例子来说，就是“é”（<code>U+00E9 带有锐音的拉丁小写字母 E</code>）等于“e”（<code>U+0065 拉丁小写字母 E</code>）+“◌́”（<code>U+0301T 和锐音组合</code>）。</p><p>但是，如果你在特殊的情况下需要不同的相等语义呢？例如字符串相等的时候 <em>不区分大小写</em>？</p><p>在今天，你可以使用许多方法，利用已有的语言特性解决这个问题：</p><ul><li>要完成这个功能，你可以在 <code>==</code> 比较的时候用 <code>lowercased()</code> 做一次处理，但和其他手动处理方式一样，这种方式容易出现人为的错误。</li><li>你可以创建一个包含 <code>String</code> 值的自定义 <code>CaseInsensitive</code> 类型。但你必须要完成很多额外的工作，才能把它打磨的像标准的 <code>String</code> 类型一样即符合人因工程学的标准，又提供完全相同的功能。</li><li>虽然你可以定义一个<a href="https://nshipster.com/swift-operators/#defining-custom-operators" target="_blank" rel="noopener">自定义操作符</a> 但又有什么操作符能比 <code>==</code> 更贴近相等的含义呢。</li></ul><p>上面的方法并没有哪个能让人完全信服，还好在 Swift 5.1 中，属性修饰器的特性让我们拥有了一个完美的解决方案。</p><blockquote><p>和文章开头提到状况一样（即实现一个自定义浮点数类型），Swift 采用面向协议的方式，将完成字符串的职责代理给一系列的更细粒度的类型（narrowly-defined types）.</p></blockquote><p>对于好奇心强的读者，这里是一张关系图，里面展示了在 Swift 标准库中所有字符串类型之间的关系。</p><p><img src="https://raw.githubusercontent.com/SwiftGGTeam/ggtalk/master/translation_image_2.svg"></p><p>来自：<a href="https://flight.school/books/strings/" target="_blank" rel="noopener">航空学院的 Swift 字符串指引</a></p><p>当你 <em>能够</em> 创建一个与 <code>String</code> 等价的自定义类型时，<a href="https://developer.apple.com/documentation/swift/stringprotocol" target="_blank" rel="noopener">文档</a> 却又强烈的建议不要这样做：</p><blockquote><p>不应该再有别的类型遵循 StringProtocol 。在标准库中应当只有 <code>String</code> 和 <code>Substring</code> 遵循它。</p></blockquote><h3 id="实现一个不区分大小写的属性修饰器"><a href="#实现一个不区分大小写的属性修饰器" class="headerlink" title="实现一个不区分大小写的属性修饰器"></a>实现一个不区分大小写的属性修饰器</h3><p>下面的 <code>CaseInsensitive</code> 类型实现了一个修饰 <code>String</code>/<code>SubString</code> 的属性修饰器。通过桥接 <code>NSString</code> 的 API <a href="https://developer.apple.com/documentation/foundation/nsstring/1414769-caseinsensitivecompare" target="_blank" rel="noopener"><code>caseInsensitiveCompare(_:)</code></a> ，<code>CaseInsensitive</code> 类型符合了 <code>Comparable</code> 协议（本质是通过扩展的方式实现了 <code>Equatable</code> 协议）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line">@propertyWrapper</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CaseInsensitive</span>&lt;<span class="title">Value</span>: <span class="title">StringProtocol</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CaseInsensitive</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(<span class="number">_</span> other: CaseInsensitive)</span></span> -&gt; <span class="type">ComparisonResult</span> &#123;</span><br><span class="line">        wrappedValue.caseInsensitiveCompare(other.wrappedValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: CaseInsensitive, rhs: CaseInsensitive)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        lhs.compare(rhs) == .orderedSame</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt; (lhs: CaseInsensitive, rhs: CaseInsensitive) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">        lhs.compare(rhs) == .orderedAscending</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &gt; <span class="params">(lhs: CaseInsensitive, rhs: CaseInsensitive)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        lhs.compare(rhs) == .orderedDescending</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>虽然大于运算符（<code>&gt;</code>）<a href="https://nshipster.com/equatable-and-comparable/#comparable" target="_blank" rel="noopener">可以被自动派生</a>，我们为了优化性能应该在这里实现它，避免对底层方法 <code>caseInsensitiveCompare</code> 进行不必要的调用。</p></blockquote><p>构造两个只是大小写不同的字符串，并且对于标准的相等检查他们会返回 <code>false</code>，但是在用 <code>CaseInsensitive</code> 对象修饰的时候返回 <code>true</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hello: <span class="type">String</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">HELLO</span>: <span class="type">String</span> = <span class="string">"HELLO"</span></span><br><span class="line"></span><br><span class="line">hello == <span class="type">HELLO</span> <span class="comment">// false</span></span><br><span class="line"><span class="type">CaseInsensitive</span>(wrappedValue: hello) == <span class="type">CaseInsensitive</span>(wrappedValue: <span class="type">HELLO</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>到目前为止，这个方法看起来和前文提到的方案，即创建一个包含 <code>String</code> 值的自定义 <code>CaseInsensitive</code> 类型，没什么区别。不过想要让自定义的 <code>CaseInsensitive</code> 类型变得和 <code>String</code> 一样好用，我们还需要考虑实现诸如 <code>ExpressibleByStringLiteral</code> 在内的其他协议，所以这才是漫漫长路的开始。</p><p>不过属性修饰器允许我们抛开这些繁琐的工作：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Account</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    @<span class="type">CaseInsensitive</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        $name = <span class="type">CaseInsensitive</span>(wrappedValue: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> johnny = <span class="type">Account</span>(name: <span class="string">"johnny"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">JOHNNY</span> = <span class="type">Account</span>(name: <span class="string">"JOHNNY"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Jane</span> = <span class="type">Account</span>(name: <span class="string">"Jane"</span>)</span><br><span class="line"></span><br><span class="line">johnny == <span class="type">JOHNNY</span> <span class="comment">// true</span></span><br><span class="line">johnny == <span class="type">Jane</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">johnny.name == <span class="type">JOHNNY</span>.name <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">johnny.name = <span class="string">"Johnny"</span></span><br><span class="line">johnny.name <span class="comment">// "Johnny"</span></span><br></pre></td></tr></table></figure><p>这里，<code>Account</code> 对象通过 <code>name</code> 属性进行了一次判等，且判等的过程中不区分字母的大小写。可是当我们去获取或设置 <code>name</code> 属性时，它又像一个 <em>真正的</em> <code>String</code> 值一样区分字母大小写了。</p><p><em>这很整洁，但这里到底发生了什么？</em></p><p>自 Swift 4 以后，如果某个类型里的存储属性都遵守了 <code>Equatable</code> 协议的话，那么编译器将自动为这个类型增加 <code>Equatable</code> 的能力。因为这些实现是隐式的（至少目前看起来是这样），属性修饰器是通过被封装的值进行判等的，而不是对构成属性修饰器的值判等。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由 Swift 编译器生成</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Account</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Account, rhs: Account)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        lhs.$name == rhs.$name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="举一反三-2"><a href="#举一反三-2" class="headerlink" title="举一反三"></a>举一反三</h4><ul><li>定义 <code>@CompatibilityEquivalence</code> 属性修饰器，当修饰 <code>String</code> 类型的属性时，带有 <code>&quot;①&quot;</code> 和 <code>&quot;1&quot;</code> 时会被认为相等。</li><li>实现一个 <code>@Approximate</code> 属性修饰器，来重新定义浮点数类型的相等语义 （另见 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0259-approximately-equal.md" target="_blank" rel="noopener">SE-0259</a>）。</li><li>实现一个 <code>@Ranked</code> 属性修饰器，它会带有一个函数，函数中定义了枚举值的排序；而这个排序需要符合我们通常打牌时的规则，例如牌面为 A 时，它既有可能是最大值，也可能是最小值。</li></ul><p><a name="auditing-property-access"></a></p><h2 id="审查属性访问"><a href="#审查属性访问" class="headerlink" title="审查属性访问"></a>审查属性访问</h2><p>业务要求可能会用某些控制措施，规定谁可以访问哪些记录，或者规定一些形式表格要随着时间变换。</p><p>重申一下，类似这样的功能通常不会在 iOS 端上完成；大多数业务逻辑都是在服务端完成的，许多客户端开发者并不想与这样的业务逻辑打交道。而下面的这个例子打开了一个新的视角来看待这个问题，当然这也归功于属性修饰器的功劳。</p><h3 id="为属性值增加版本记录"><a href="#为属性值增加版本记录" class="headerlink" title="为属性值增加版本记录"></a>为属性值增加版本记录</h3><p>下面的 <code>Versioned</code> 结构体函数用作一个属性修饰器，拦截了输入的值，并在设置每个值的时候创建带时间戳的记录。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line">@propertyWrapper</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Versioned</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: <span class="type">Value</span></span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> timestampedValues: [(<span class="type">Date</span>, <span class="type">Value</span>)] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; value &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> &#123; timestampedValues.append((<span class="type">Date</span>(), value)) &#125;</span><br><span class="line">            value = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(initialValue value: <span class="type">Value</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.wrappedValue = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <code>ExpenseReport</code> 类，它带有一个名为 <code>state</code> 的属性并被 <code>@Versioned</code> 属性修饰期所修饰。通过这种方式，我们可以回溯每一次的操作记录。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpenseReport</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123; <span class="keyword">case</span> submitted, received, approved, denied &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Versioned</span> <span class="keyword">var</span> state: <span class="type">State</span> = .submitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="举一反三-3"><a href="#举一反三-3" class="headerlink" title="举一反三"></a>举一反三</h3><ul><li>实现一个 <code>@Audited</code> 属性修饰器，在每次读写属性的时候打印日志。</li><li>实现一个 <code>@Decaying</code> 属性修饰器，它在每次值被读取的时候都会去除以一个设定的值。</li></ul><hr><p>不可否认的是，这个特定的示例还是暴露了属性修饰器的一些局限性：<strong>属性无法被标记为 <code>throws</code>。</strong>当然这个问题的根源还是在 Swift 语言自身上。</p><p>由于在错误处理上的能力欠缺，属性修饰器并没有什么好办法让代码完全按照你的设想执行。例如我们想让 <code>@Versioned</code> 属性修饰器支持这样一个特性，即在设置 <code>state</code> 属性时 ，当属性被设置为 <code>.denied</code> 后，就不能再被设置为 <code>.approved</code>，针对这种场景，现有的最佳方案是 <code>fatalError()</code>，但在实际的生产环境中，这可就不一定了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpenseReport</span> </span>&#123;</span><br><span class="line">    @<span class="type">Versioned</span> <span class="keyword">var</span> state: <span class="type">State</span> = .submitted &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> newValue == .approved,</span><br><span class="line">                $state.timestampedValues.<span class="built_in">map</span> &#123; $<span class="number">0.1</span> &#125;.<span class="built_in">contains</span>(.denied)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fatalError</span>(<span class="string">"J'Accuse!"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tripExpenses = <span class="type">ExpenseReport</span>()</span><br><span class="line">tripExpenses.state = .denied</span><br><span class="line">tripExpenses.state = .approved <span class="comment">// Fatal error: "J'Accuse!"</span></span><br></pre></td></tr></table></figure><p>属性修饰器的局限性还有不少，这里提到的只是其中一点。所以为了更理性的看待这个特性，文章剩下的篇幅将会说说它的局限性都体现在哪里。</p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><blockquote><p>受我目前的理解能力和想象能力所限，下面给出的观点可能比较主观，有可能并不是属性修饰器这个提议本身造成的。<br>如果你有任何好的建议或者意见，欢迎 <a href="https://twitter.com/NSHipster/" target="_blank" rel="noopener">联系我们</a> 。</p></blockquote><h3 id="属性不能参与错误处理"><a href="#属性不能参与错误处理" class="headerlink" title="属性不能参与错误处理"></a>属性不能参与错误处理</h3><p>属性不像函数，无法使用 <code>throws</code> 标记。</p><p>关于上面提到的问题，原本就是函数与属性之间为数不多的区别之一。由于属性同时拥有获取方法（getter）和设置方法（setter），所以在这里如何进行错误处理并没有明确的最佳实践。尤其是你需要在兼顾访问控制，自定义获取方法/设置方法和回调的状态下，还写出优雅的语句。</p><p>如上一节所示，可以通过下面两种方式来处理非法值问题：</p><ol><li>忽略它们（静默地）</li><li>用 <code>fatalError()</code> 抛出崩溃。</li></ol><p>不论哪一种方案都不够优雅，所以如果你对这个问题有更好的解决方案，欢迎分享。</p><h3 id="属性修饰器无法起别名"><a href="#属性修饰器无法起别名" class="headerlink" title="属性修饰器无法起别名"></a>属性修饰器无法起别名</h3><p>这个提议的另外一个限制就是，你不能使用属性修饰器的实例作为属性修饰器。</p><p>还记得前面提到的 <code>UnitInterval</code> 么？我们可以用它来限制属性值的范围在 0 到 1 之间。所以我们是不是可以用写成下面的样子呢？：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">UnitInterval</span> = <span class="type">Clamping</span>(<span class="number">0</span>...<span class="number">1</span>) <span class="comment">// ❌</span></span><br></pre></td></tr></table></figure><p>可惜这样是不被允许的。同样你也不能使用属性修饰器的实例来修饰属性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">UnitInterval</span> = <span class="type">Clamping</span>(<span class="number">0</span>...<span class="number">1</span>)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Solution</span> </span>&#123; @<span class="type">UnitInterval</span> <span class="keyword">var</span> pH: <span class="type">Double</span> &#125; <span class="comment">// ❌</span></span><br></pre></td></tr></table></figure><p>上面的代码说明一个问题，在实际使用过程中，我们可能会写出比预期多的重复代码。但考虑到这个问题的本质是计算机编程语言中值与类型是两种完全不同的东西引起的。所以从避免错误抽象的角度来看，这一小点的重复是完全可以忍受的。</p><h3 id="属性修饰器很难组合"><a href="#属性修饰器很难组合" class="headerlink" title="属性修饰器很难组合"></a>属性修饰器很难组合</h3><p>属性修饰器的组合不是一个可交换的操作；你声明它们的顺序影响了它们的作用顺序。</p><p>属性在进行 <a href="https://nshipster.com/valuetransformer/#thinking-forwards-and-backwards" target="_blank" rel="noopener">字符串字符串的 string inflection 操作</a> 和 string transforms 操作会互相影响。例如下面的属性修饰器组合，它的功能是将博客文章中的 URL “slug” 属性自动格式化，但这里的问题在于将短划线替换成空格的操作和去除空格的操作会互相影响，进而导致最终的结果发生变化。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line">    &lt;#...#&gt;</span><br><span class="line">    @<span class="type">Dasherized</span> @<span class="type">Trimmed</span> <span class="keyword">var</span> slug: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，要让它先发挥作用，说起来容易做起来难！尝试组合 <code>String</code> 值的两个属性修饰器方法失败，因为最外层修饰器影响了在最内层的修饰器类型的值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dasherized</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> value: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; value &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; value = newValue.replacingOccurrences(of: <span class="string">" "</span>, with: <span class="string">"-"</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(initialValue: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.wrappedValue = initialValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line">    &lt;#...#&gt;</span><br><span class="line">    @<span class="type">Dasherized</span> @<span class="type">Trimmed</span> <span class="keyword">var</span> slug: <span class="type">String</span> <span class="comment">// ⚠️ 发生内部错误.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前是有一个办法实现这个特性，但并不怎么优雅。关于这个问题是会在后续的版本中进行修复，还是通过文档正式说明都需要我们耐心的等待。</p><h3 id="属性修饰器不是一等依赖类型"><a href="#属性修饰器不是一等依赖类型" class="headerlink" title="属性修饰器不是一等依赖类型"></a>属性修饰器不是一等依赖类型</h3><p><em>依赖类型</em> 是由它的值定义的类型。例如，“一对后者比前者更大的整数”和“一个具有素数元素的数组”都是依赖类型，因为他们的类型定义取决与他们的值。</p><p>在 Swift 的类型系统里缺少对依赖类型的支持，如果想获得相关的特性需要在运行时完成。</p><p>好消息是，相比于其他语言，Swift 的属性修饰器算是第一个吃螃蟹的，不过即使这样，属性修饰器还不能算是一个完整的值依赖类型解决方案。</p><p>例如，你还是不能使用属性修饰器定义一个新类型，即使属性修饰器本身没什么毛病。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> pH = @<span class="type">Clamping</span>(<span class="number">0</span>...<span class="number">14</span>) <span class="type">Double</span> <span class="comment">// ❌</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acidity</span><span class="params">(of: Chemical)</span></span> -&gt; pH &#123;&#125;</span><br></pre></td></tr></table></figure><p>你也不能使用属性修饰器去注解集合中的键类型或值类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTP</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> headers: [@<span class="type">CaseInsensitive</span> <span class="type">String</span>: <span class="type">String</span>] <span class="comment">// ❌</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些缺点还是可以忍受的。属性修饰器非常有用，并且弥补了语言中的重要空白。</p><p>不知道属性修饰器的诞生会不会重燃大家对依赖类型的关注，当然另外一种可能是大家觉得当前的状态“也不是不能用”，也就没必要将依赖类型这个概念进一步正式化。</p><h3 id="属性修饰器难以被文档化"><a href="#属性修饰器难以被文档化" class="headerlink" title="属性修饰器难以被文档化"></a>属性修饰器难以被文档化</h3><p><strong>突击测验：</strong>SwiftUI 框架提供了哪些可用的属性修饰器？</p><p>去吧，看下 <a href="https://developer.apple.com/documentation/swiftui" target="_blank" rel="noopener">SwiftUI 官方文档</a>，然后试着回答。</p><p>😬</p><p>公平地讲，这种失败不是属性修饰器所特有的。</p><p>如果你的任务是明确标准库中某个 API 都需要哪些协议响应，或是在 <code>developer.apple.com</code> 文档中明确某个运算符都支持哪些类型时，你其实就可以考虑转行了。</p><p>随着 Swift 的复杂性不断增加，它的可理解性就会不断下降，我想没有比这更让人头疼了吧。</p><h3 id="属性修饰器让-Swift-进一步复杂化"><a href="#属性修饰器让-Swift-进一步复杂化" class="headerlink" title="属性修饰器让 Swift 进一步复杂化"></a>属性修饰器让 Swift 进一步复杂化</h3><p>Swift 是一门比 Objective-C <em>更加</em> 复杂的语言。自 Swift 1.0 以来，这就是一条不变的真理。</p><p>在 Swift 中有大量的 <code>@</code> 前缀，从 Swift 4 提出的 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md" target="_blank" rel="noopener"><code>@dynamicMemberLookup</code></a> 和 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md" target="_blank" rel="noopener"><code>@dynamicCallable</code></a> ，到 <a href="https://github.com/tensorflow/swift" target="_blank" rel="noopener">Swift for Tensorflow</a> 里的 <a href="https://forums.swift.org/t/pre-pitch-swift-differentiable-programming-design-overview/25992" target="_blank" rel="noopener"><code>@differentiable</code> 和 <code>@memberwise</code></a>，即使有文档在手，这些东西也使得 Swift 的 API 越来越难理解。从这个角度来看，<code>@propertyWrapper</code> 无疑是加重了这个问题的严重性。</p><p>我们要如何理解这一切？（这是一个客观的真是问题，不是反问。）</p><hr><p>好了，现在让我们总结一下这个新特性——</p><p>属性修饰器能够让开发者使用到更高层级的语言特性，而这在以前是不可能的。这个提议在提高代码安全性和降低代码复杂性上有巨大的潜力，现阶段我们只是看到了它的一些基本可能性而已。</p><p>然而，他们有所承诺，属性修饰器及其他语言特性与 SwiftUI 一起的首次亮相将给 Swift 带来了巨大的变化。果不其然，如他们之前承诺的一样，属性修饰器和其他的新特性随着 SwitUI 在这个夏天闪亮登场，而这一次亮相，为整个 Swift 生态环境带来了巨大的变化。</p><p>或者，正如 Nataliya Patsovska 在 <a href="https://twitter.com/nataliya_bg/status/1140519869361926144" target="_blank" rel="noopener">一篇推特</a> 中所提到的:</p><blockquote><p>iOS API 设计简史：</p><ul><li>Objective C - 在名字中描述了所有语义，类型并不重要</li><li>Swift 1 到 5 - 名字侧重于清晰度，基础结构体，枚举，类和协议持有语义</li><li>Swift 5.1 - @wrapped \$path @yolo</li></ul><p>——<a href="https://twitter.com/nataliya_bg/" target="_blank" rel="noopener">@nataliya_bg</a></p></blockquote><p>也许我们后面回头看才能知道， Swift 5.1 是不是为我们热爱的语言树立了一个临界点或者转折点。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Swift 属性修饰器要让 SwiftUI 成为可能还有很长的路要走，但他们在塑造整个语言的未来方面可能发挥着更重要的作用。
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
    
      <category term="新特性" scheme="https://swift.gg/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中类型别名的用途</title>
    <link href="https://swift.gg/2020/04/11/2019-05-15-the-usefulness-of-typealiases/"/>
    <id>https://swift.gg/2020/04/11/2019-05-15-the-usefulness-of-typealiases/</id>
    <published>2020-04-10T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Benedikt Terhechte，<a href="http://appventure.me/posts/2019-5-15-the-usefulness-of-typealiases-in-swift.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2019-05-15<br>译者：<a href="https://github.com/Ji4n1ng" target="_blank" rel="noopener">Ji4n1ng</a>；校对：<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>，<a href="https://nemocdz.github.io/" target="_blank" rel="noopener">Nemocdz</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><h2 id="什么是-typealias？"><a href="#什么是-typealias？" class="headerlink" title="什么是 typealias？"></a>什么是 <code>typealias</code>？</h2><p>当我们回忆那些 Swift 强大的语言特性时，很少有人会首先想到 <code>typealias</code>。然而，许多情况下类型别名会很有用。本文将简要介绍 <code>typealias</code> 是什么，如何定义它，并列出多个示例说明如何在自己的代码中使用它们。让我们开始深入了解吧！</p><a id="more"></a><p>顾名思义，<code>typealias</code> 是特定类型的别名。类型，例如 <code>Int</code>、<code>Double</code>、<code>UIViewController</code> 或一种自定义类型。<code>Int32</code> 和 <code>Int8</code> 是不同的类型。换句话说，类型别名在你的代码库里插入现有类型的另一个名称。例如：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Money</span> = <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>为 <code>Int</code> 类型创建别名。这样就可以在代码中的任何地方使用 <code>Money</code>，就像是 <code>Int</code> 一样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">Money</span> = <span class="type">Int</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> credit: <span class="type">Money</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(amount: Money)</span></span> &#123;</span><br><span class="line">    credit += amount</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">withdraw</span><span class="params">(amount: Money)</span></span> &#123;</span><br><span class="line">    credit -= amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面有一个结构体 <code>Bank</code> 来管理钱。但是，没有使用 <code>Int</code> 作为金额，而是使用 <code>Money</code> 类型。可以看出 <code>+=</code> 和 <code>-=</code> 运算符仍然可以按预期工作。</p><p>还可以混合使用类型别名和原始类型，以及匹配二者。可以这么做是因为对于 Swift 编译器来说，它们都解析为同一个东西：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">DepositMoney</span> = <span class="type">Int</span></span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">WithdrawMoney</span> = <span class="type">Int</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> credit: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(amount: DepositMoney)</span></span> &#123;</span><br><span class="line">    credit += amount</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">withdraw</span><span class="params">(amount: WithdrawMoney)</span></span> &#123;</span><br><span class="line">    credit -= amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们混合使用了 <code>Int</code> 及其不同自定义类型别名 <code>DepositMoney</code> 和 <code>WithdrawMoney</code>。</p><h3 id="泛型类型别名"><a href="#泛型类型别名" class="headerlink" title="泛型类型别名"></a>泛型类型别名</h3><p>除上述内容外，类型别名也可以具有泛型参数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">MyArray</span>&lt;<span class="type">T</span>&gt; = <span class="type">Array</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"><span class="keyword">let</span> newArray: <span class="type">MyArray</span> = <span class="type">MyArray</span>(arrayLiteral: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>上面，为 <code>MyArray</code> 定义了一个类型别名，该别名与常规数组一样。最后，类型别名的泛型参数甚至可以具有约束。想象一下，我们希望新的 <code>MyArray</code> 只保留遵循 <code>StringProtocol</code> 的类型：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">MyArray</span>&lt;<span class="type">T</span>&gt; = <span class="type">Array</span>&lt;<span class="type">T</span>&gt; <span class="keyword">where</span> <span class="type">T</span>: <span class="type">StringProtocol</span></span><br></pre></td></tr></table></figure><p>这是一个不错的特性，你可以快速为特定类型定义数组，而不必将 <code>Array</code> 子类化。说到这里，让我们看一下类型别名的一些实践应用。</p><h2 id="实践应用"><a href="#实践应用" class="headerlink" title="实践应用"></a>实践应用</h2><h3 id="更清晰的代码"><a href="#更清晰的代码" class="headerlink" title="更清晰的代码"></a>更清晰的代码</h3><p>第一个，同时也显而易见的用例，我们已经简要介绍过了。类型别名可以使代码更具含义。在 <code>typealias Money = Int</code> 示例中，我们引入了 <code>Money</code> 类型——一个清晰的概念。像 <code>let amount: Money = 0</code> 这样来使用它，比 <code>let amount: Int = 0</code> 更容易理解。在第一个示例中，你立刻就明白这是<em>金钱</em>的<em>数额</em>。而在第二个示例中，它可以是任何东西：自行车的数量、字符的数量、甜甜圈的数量——这谁知道！</p><p>这显然不是都必要的。如果函数签名已经清楚地说明了参数的类型（<code>func orderDonuts(amount: Int)</code>），那么包含其他的类型别名将是不必要的开销。另一方面，对于变量和常量来说，它通常可以提高可读性并极大地帮助编写文档。</p><h3 id="更简单的可选闭包"><a href="#更简单的可选闭包" class="headerlink" title="更简单的可选闭包"></a>更简单的可选闭包</h3><p>Swift 中的可选闭包有点笨拙。接受一个 <code>Int</code> 参数并返回 <code>Int</code> 的闭包的常规定义如下所示：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(action: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>现在，如果要使此闭包为可选型，则不能仅添加问号：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(action: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int?</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>毕竟，这不是一个可选型的闭包，而是<em>一个返回可选 <code>Int</code></em> 的闭包。正确的方法是添加括号：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(action: <span class="params">(<span class="params">(Int)</span></span></span></span> -&gt; <span class="type">Int</span>)?) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>如果有多个这样的闭包，这将变得尤为难看。下面，有一个函数，它可以处理成功和失败情况，以及随着操作的进行调用一个附加的闭包。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(success: <span class="params">(<span class="params">(Int)</span></span></span></span> -&gt; <span class="type">Int</span>)?,</span><br><span class="line">            failure: ((<span class="type">Error</span>) -&gt; <span class="type">Void</span>)?,</span><br><span class="line">            progress: ((<span class="type">Double</span>) -&gt; <span class="type">Void</span>)?) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这小段代码包含<em>很多</em>括号。由于我们不打算成为 lisper（译者注：lisp 语言使用者），因此想通过对不同的闭包使用类型别名来解决此问题：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Success</span> = (<span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Failure</span> = (<span class="type">Error</span>) -&gt; <span class="type">Void</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Progress</span> = (<span class="type">Double</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle2</span><span class="params">(success: Success?, failure: Failure?, progress: Progress?)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>实际上，这个函数看起来确实更具可读性。虽然这很好，但我们确实通过使用三行 <code>typealias</code> 引入了其他语法。但是，从长远来看，这实际上可能对我们有帮助，就像我们将在接下来看到的。</p><h3 id="集中定义"><a href="#集中定义" class="headerlink" title="集中定义"></a>集中定义</h3><p>这些特定类型不仅仅可以用在前面示例的那些操作处理器中。下面是经过略微修改，更符合实际使用的操作处理器类：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> successHandler: ((<span class="type">Int</span>) -&gt; <span class="type">Void</span>)?</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> errorHandler: ((<span class="type">Error</span>) -&gt; <span class="type">Void</span>)?</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(success: <span class="params">(<span class="params">(Int)</span></span></span></span> -&gt; <span class="type">Void</span>)?, error: ((<span class="type">Error</span>) -&gt; <span class="type">Void</span>)?) &#123;</span><br><span class="line">    <span class="keyword">self</span>.successHandler = success</span><br><span class="line">    <span class="keyword">self</span>.errorHandler = error</span><br><span class="line">    internalHandle()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(success: <span class="params">(<span class="params">(Int)</span></span></span></span> -&gt; <span class="type">Void</span>)?) &#123;</span><br><span class="line">   <span class="keyword">self</span>.successHandler = success</span><br><span class="line">    internalHandle()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(error: <span class="params">(<span class="params">(Int)</span></span></span></span>-&gt; <span class="type">Void?</span>)) &#123;</span><br><span class="line">    <span class="keyword">self</span>.errorHandler = error</span><br><span class="line">    internalHandle()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">internalHandle</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该结构体引入了两个闭包，一个用于成功情况，一个用于错误情况。但是，我们还希望提供更方便的函数，调用其中一个处理器即可。在上面的示例中，如果要向成功和错误处理器添加另一个参数（例如 <code>HTTPResponse</code>），那么需要更改很多代码。在三个地方，<code>((Int) -&gt; Void)?</code> 需要变成 <code>((Int, HTTPResponse) -&gt; Void)?</code>。错误处理器也是一样的。通过使用多个类型别名，可以避免这种情况，只需要在一个地方修改类型：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">Success</span> = (<span class="type">Int</span>, <span class="type">HTTPResponse</span>) -&gt; <span class="type">Void</span></span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">Failure</span> = (<span class="type">Error</span>, <span class="type">HTTPResponse</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> successHandler: <span class="type">Success?</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> errorHandler: <span class="type">Failure?</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(success: Success?, error: Failure?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.successHandler = success</span><br><span class="line">    <span class="keyword">self</span>.errorHandler = error</span><br><span class="line">    internalHandle()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(success: Success?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">self</span>.successHandler = success</span><br><span class="line">    internalHandle()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(error: Failure?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.errorHandler = error</span><br><span class="line">    internalHandle()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">internalHandle</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不仅易于阅读，而且随着在更多地方使用该类型，它也会继续发挥它的作用。</p><h3 id="泛型别名"><a href="#泛型别名" class="headerlink" title="泛型别名"></a>泛型别名</h3><p>类型别名也可以是泛型的。一个简单的用例是强制执行具有特殊含义的容器。假设我们有一个处理图书的应用。一本书由章节组成，章节由页面组成。从根本上讲，这些只是数组。下面是 <code>typealias</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Chapter</span> = <span class="type">Array</span>&lt;<span class="type">Page</span>&gt;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Book</span> = <span class="type">Array</span>&lt;<span class="type">Chapter</span>&gt;</span><br></pre></td></tr></table></figure><p>与仅使用数组相比，这有两个好处。</p><ol><li>该代码更具解释性。</li><li>包装页面的数组<em>只</em>能包含页面，而不能包含其它的。</li></ol><p>回顾我们先前使用<em>成功</em>和<em>失败</em>处理程序的示例，我们可以通过使用泛型处理程序来进一步改进：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Handler</span>&lt;<span class="type">In</span>&gt; = (<span class="type">In</span>, <span class="type">HTTPResponse?</span>, <span class="type">Context</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(success: Handler&lt;Int&gt;?, </span></span></span><br><span class="line"><span class="function"><span class="params">            failure: Handler&lt;Error&gt;?,</span></span></span><br><span class="line"><span class="function"><span class="params">           progress: Handler&lt;Double&gt;?,)</span></span></span><br></pre></td></tr></table></figure><p>这样的组合确实非常棒。这使我们能够编写一个更简单的函数，并可以在一个地方编辑 <code>Handler</code>。</p><p>这种方法对于自定义的类型也非常有用。你可以创建一个泛型定义，然后定义详细的类型别名：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComputationResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> result: <span class="type">T</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">DataResult</span> = <span class="type">ComputationResult</span>&lt;<span class="type">Data</span>&gt;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">StringResult</span> = <span class="type">ComputationResult</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">IntResult</span> = <span class="type">ComputationResult</span>&lt;<span class="type">Int</span>&gt;</span><br></pre></td></tr></table></figure><p>再说一遍，类型别名允许我们编写更少的代码并简化代码中的定义。</p><h3 id="像函数一样的元组"><a href="#像函数一样的元组" class="headerlink" title="像函数一样的元组"></a>像函数一样的元组</h3><p>同样，可以使用泛型和元组来定义类型，而不是必须用结构体。下面，我们设想了一种遗传算法的数据类型，它可以在多代中修改其值 <code>T</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Generation</span>&lt;<span class="type">T</span>: <span class="type">Numeric</span>&gt; = (initial: <span class="type">T</span>, seed: <span class="type">T</span>, <span class="built_in">count</span>: <span class="type">Int</span>, current: <span class="type">T</span>)</span><br></pre></td></tr></table></figure><p>如果定义这样的类型别名，则实际上可以像初始化一个结构体那样对其进行初始化：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstGeneration = <span class="type">Generation</span>(initial: <span class="number">10</span>, seed: <span class="number">42</span>, <span class="built_in">count</span>: <span class="number">0</span>, current: <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>尽管它看起来确实像一个结构体，但它只是一个元组的类型别名。</p><h3 id="组合协议"><a href="#组合协议" class="headerlink" title="组合协议"></a>组合协议</h3><p>有时，你会遇到一种情况，你有多个协议，而且需要使用一个特定类型来把这些协议都实现。这种情况通常发生在当你定义了一个协议层来提高灵活性时。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CanRead</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CanWrite</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CanAuthorize</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CanCreateUser</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Administrator</span> = <span class="type">CanRead</span> &amp; <span class="type">CanWrite</span> &amp; <span class="type">CanAuthorize</span> &amp; <span class="type">CanCreateUser</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">User</span> = <span class="type">CanRead</span> &amp; <span class="type">CanWrite</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Consumer</span> = <span class="type">CanRead</span></span><br></pre></td></tr></table></figure><p>在这里，我们定义了权限层。管理员可以做所有事情，用户可以读写，而消费者只能读。</p><h3 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h3><p>这超出了本文的范围，但是协议的关联类型也可以通过类型别名来定义：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"> <span class="keyword">associatedtype</span> <span class="type">Payload</span>: <span class="type">Numeric</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Implementation</span>: <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">Payload</span> = <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>尽管类型别名是一个非常有用的功能，但它们有一个小缺点：如果你不熟悉代码库，那么对下面这两个定义的理解会有很大区别。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">first</span><span class="params">(action: <span class="params">(Int, Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">second</span><span class="params">(action: Success)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>第二个不是立即就能明白的。<code>Success</code> 是什么类型？如何构造它？你必须在 Xcode 中按住 Option 单击它，以了解它的功能和工作方式。这会带来额外的工作量。如果使用了许多类型别名，则将花费更多的时间。这没有很好的解决方案，（通常）只能依赖于用例。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我希望你能喜欢这篇关于类型别名可能性的小总结。如果你有任何反馈意见，<a href="https://twitter.com/terhechte" target="_blank" rel="noopener">可以在 Twitter 上找到我</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文描述了类型别名的巧妙用途
    
    </summary>
    
      <category term="APPVENTURE" scheme="https://swift.gg/categories/APPVENTURE/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>NSPredicate</title>
    <link href="https://swift.gg/2019/11/19/nspredicate-objective-c/"/>
    <id>https://swift.gg/2019/11/19/nspredicate-objective-c/</id>
    <published>2019-11-18T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jordan Morgan，<a href="https://www.swiftjectivec.com/nspredicate-objective-c/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-05-18<br>译者：<a href="https://github.com/alejx" target="_blank" rel="noopener">石榴</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://nemocdz.github.io/" target="_blank" rel="noopener">Nemocdz</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>Swift 刚出现的时候，我们因它比 Objective-C 简洁而着迷。接着它很快打开了面向协议编程的大门。并且，让我们忘掉引用类型和类，还有很多。</p><p>确实，这些东西都是很棒的工具，都有优秀的用例。但我感觉它们经常被捧作银弹，在决定架构时缺乏足够的考虑。</p><a id="more"></a><p>因此在 2018 年，技术博客中充斥着各种 Swift 黑魔法（我的博客也不例外🤷🏻‍♂️），会议演讲也都在讨论 Swift 的函数式编程未来（没错，我也做了这种演讲🙋🏻‍♂️）。</p><p>所有人都对在 Swift 中使用集合感到激动，<strong>但是</strong>我们从 iOS 3 开始就可以用 Objective-C 来做<em>相似</em>的事了。所以今天我会讨论 <code>NSPredicate</code> 的威力，以及如何用🦖筛选集合。</p><p>有必要提一下：我们最近看到了一些开发者一开始学了 Swift，后来又得回去维护 Objective-C 的代码。如果说的就是你，那你很可能正在发愁如何优雅地在 Objective-C 中处理集合。</p><p>这里讲的东西可能对你有用。</p><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>近几年来，Objective-C 的集合有了长足的进步。还在几年以前，我们还必须教这愚蠢的编译器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *aString = (NSString *)[anArray indexOfObject:0];</span><br></pre></td></tr></table></figure><p>感谢老天、库比提诺[^1]和朋友们©终于用类型擦除的方式添加了泛型。这是一个很大的进步：</p><p>[^1]: 译者注：Cupertino, CA，苹果总部所在城市。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *anArray = @[@&quot;Sup&quot;];</span><br><span class="line">NSString *aString = [anArray firstObject];</span><br></pre></td></tr></table></figure><p>但无论是不是泛型，我们经常通过与下面类似的方法与 Objective-C 集合中的内容交互：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (NSString *str in anArray)</span><br><span class="line">&#123;</span><br><span class="line">    if ([str isEqualToString:@&quot;The Key&quot;])</span><br><span class="line">    &#123;</span><br><span class="line">        // 做些什么</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多情况下，这样写是可以接受的。但是当需求越来越复杂，关系更加多种多样，代码就会变得不确定。如果你遵从代码更少更稳定更容易维护的观念，那么这种简单的查询集合操作也可能成为困扰。</p><p>Predicate 可以改善这个状况。不是要在代码中耍些小聪明，而是写出简洁和实用的代码。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><code>NSPredicate</code> 的核心用途是限制或定义对内存中的数据过滤，或进行取回时的参数。当它和 Core Data 一起使用的时候才会如虎添翼。它和 SQL 很像，只不过没那么糟糕*。</p><blockquote><p>开个玩笑，只是我对基于集合的操作都无感🙃。</p></blockquote><p>你给它提供逻辑条件，然后就会返回符合条件的东西。这意味着它可以提供基础比较、复合 predicate、KeyPath 集合查询、子查询、合计以及更多的支持。</p><p>因为它用来筛选集合，它可以获得 Foundation 类的原生支持。使用可变版本时支持用结果直接修改，不可变版本会返回一个新实例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 修改原数组</span><br><span class="line">[mutableArray filterUsingPredicate:/*NSPredicate*/];</span><br><span class="line"></span><br><span class="line">// 返回新的数组</span><br><span class="line">[mutableArray filteredArrayUsingPredicate:/*NSPredicate*/];</span><br></pre></td></tr></table></figure><p>虽然 predicate 可以从 <code>NSExpression</code>、<code>NSCompoundPredicate</code> 或 <code>NSComparsionPredicate</code> 中实例化，但它还可以用一个字符串的语法生成。这和可视化格式语言类似，我们可以用它定义排版约束。</p><p>在这里我们主要关注能用字符串语法生成的能力。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>为了更好的说明，文章的剩余部分以下面的代码为前提。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line">Person:NSObject</span><br><span class="line">Identifier:NSString</span><br><span class="line">Name:NSString</span><br><span class="line">PayGrade:NSNumber</span><br><span class="line"></span><br><span class="line">// 某个含有 Person 实例的属性</span><br><span class="line">NSArray *employees</span><br></pre></td></tr></table></figure><h2 id="查询⚡️"><a href="#查询⚡️" class="headerlink" title="查询⚡️"></a>查询⚡️</h2><p>本文剩下都在用直接的例子来介绍如何用字符串格式语法来配置查询。</p><p>我们可以从一个简单的搜索的情景开始。先假设我们有一个含有表示 <code>Person</code> 对象标识符的数组：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    @&quot;erersdg32453tr&quot;,  </span><br><span class="line">    @&quot;dfs8rw093jrkls&quot;,  </span><br><span class="line">    // etc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们想通过这些识别符从一个现存的 <code>Person</code> 数组中获取 <code>Person</code> 对象。可以使用一个双层嵌套的 <code>for</code> 循环来解决这个问题：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 假设 &quot;employees&quot; 是一个存有 Person 对象的数组</span><br><span class="line">NSArray  *morningEventAttendees = @[/*上面的人的识别符*/];</span><br><span class="line">NSMutableArray  *peopleAttendingMorningEvent = [NSMutableArray new];</span><br><span class="line"></span><br><span class="line">for (NSString *userID in morningEventAttendees)  </span><br><span class="line">&#123;  </span><br><span class="line">    for (Person *person in employees)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if ([person.identifier isEqualToString:userID])  </span><br><span class="line">        &#123;  </span><br><span class="line">            [peopleAttending addObject:person];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 现在 peopleAttendingMorningEvent 里面就有我们想要的东西了</span><br></pre></td></tr></table></figure><p>我们也可以使用 predicate 来达到完全一样的效果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSPredicate *morningAttendees = [NSPredicate predicateWithFormat:@&quot;SELF.identifier IN %@&quot;, peopleAttendingMorningEvent];</span><br><span class="line"></span><br><span class="line">NSArray *peopleAttendingMorningEvent = [employees filteredArrayUsingPredicate:morningAttendees];</span><br></pre></td></tr></table></figure><p>💫。</p><p>Predicate 的语法允许我们使用 SELF，它在这里发挥了很大的作用。它表示数组里正在被操作的对象，在这里就是 <code>Person</code> 对象。</p><blockquote><p>另一个额外的好处是我们不用把数组定义成可变的了。</p></blockquote><p>正是因为这个原因，我们可以访问与 SELF 所表示对象关联的 KeyPath。在上面的代码中，引用了 <code>identifier</code> 属性。</p><p>如果你喜欢的话，任何 KeyPath 可以用放在 “%K” 位置的变量来表示。这个版本和上面的效果一样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[NSPredicate predicateWithFormat:@&quot;SELF.%K IN %@&quot;, @&quot;identifier&quot;, peopleAttendingMorningEvent];</span><br></pre></td></tr></table></figure><h2 id="复合-Predicate"><a href="#复合-Predicate" class="headerlink" title="复合 Predicate"></a>复合 Predicate</h2><p>合并多个比较很简单。假设我们还需要像上面一样找到所有参加活动的人，但还要满足他们的工资水平在 50000 到 60000 之间。</p><p>如果使用传统的方法，我们的 if 语句只会越写越长：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 和上面的代码一样</span><br><span class="line">if ([person.identifier isEqualToString:userID] &amp;&amp; (person.paygrade.integerValue &gt;= 5 &amp;&amp; person.paygrade.integerValue &lt;= 10))  </span><br><span class="line">&#123;  </span><br><span class="line">    [peopleAttending addObject:person];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但使用一个重构过的 predicate 可以让我们用一种更符合语言习惯的方式来解决问题：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSPredicate *morningAttendees = [NSPredicate predicateWithFormat:@&quot;SELF.identifier IN %@ &amp;&amp; SELF.paygrade.integerValue BETWEEN &#123;50000, 60000&#125;&quot;, peopleAttendingMorningEvent];</span><br></pre></td></tr></table></figure><p>它允许用不同的操作符表示同样的作用，可以根据你的偏好来提升可读性。比如：</p><ul><li>“&amp;&amp;” 或 “AND”</li><li>“||” 或 “OR”</li><li>“!” 或 “NOT”</li></ul><p>如你所想，它们经常会在基本比较操作之间出现，聚合在一个 predicate 里。</p><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>我们经常会处理一些基于字符串比较的匹配。大家都知道 Objective-C 对冗余代码的无止尽追求，在处理 NSString 的时候也丝毫不减：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *name = @&quot;Jordan&quot;;</span><br><span class="line">name = [name stringByAppendingString:[NSString stringWithFormat:@&quot;%@ %@&quot;, @&quot;Wesley&quot;, @&quot;Morgan&quot;]];</span><br></pre></td></tr></table></figure><p>……而 Swift 则一边偷笑，一边低调地把字符串们连接起来。幸亏我们在用 <code>NSPredicate</code> 来比较字符串时不会写出上面那么冗余的代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 假设 mutablePersonAr 是一个 Person 数组，里面有 &quot;Karl&quot; 和 &quot;Jordan&quot;</span><br><span class="line">NSPredicate *namesStartingWithK = [NSPredicate predicateWithFormat:@&quot;SELF.name BEGINSWITH &apos;K&apos;&quot;];</span><br><span class="line">// 现在只有 Karl 了</span><br><span class="line">[mutablePersonAr filterUsingPredicate:namesStartingWithK];</span><br></pre></td></tr></table></figure><p>实际上任何比较都可以用 predicate 语法中的 <code>CONTAINS</code>、<code>BEGINSWITH</code>、<code>ENDSWITH</code> 和 <code>LIKE</code> 来实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 假设 mutablePersonAr 是一个 Person 数组，里面有 &quot;Karl&quot; 和 &quot;Kathryn&quot;</span><br><span class="line">NSPredicate *namesStartingWithK = [NSPredicate predicateWithFormat:@&quot;SELF.name LIKE &apos;Kar*&apos;&quot;];</span><br><span class="line"></span><br><span class="line">// 现在只有 Karl 了</span><br><span class="line">[mutablePersonAr filterUsingPredicate:namesStartingWithK];</span><br></pre></td></tr></table></figure><blockquote><p>你可能已经注意到上面的星号了；和很多的 DSL 一样，这个星号代表一个通配符。</p></blockquote><p>当你在一个查询里结合多个比较运算符时，这种简洁用法的重要性就会体现出来了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *predicateFormat = @&quot;(SELF.name LIKE &apos;Kar*&apos;) AND (SELF.paygrade.intValue &gt;= 10)&quot;;</span><br><span class="line"></span><br><span class="line">NSPredicate *namesStringWithK = [NSPredicate predicateWithFormat:predicateFormat];</span><br><span class="line"></span><br><span class="line">// 现在只有 Karl 了</span><br><span class="line">[mutablePersonAr filterUsingPredicate:namesStartingWithK];</span><br></pre></td></tr></table></figure><p>更进一步，它还支持用 <code>MATCHES</code> 语法实现 NSPredicate 的类 SQL 语法与正则表达式混用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[NSPredicate predicateWithFormat:@&quot;SELF.phoneNumber MATCHES %@&quot;, phoneNumberRegex];</span><br></pre></td></tr></table></figure><p>然而是时候该指出一点，predicate 语法十分严格。它就是一个字符串。除非你是 Mavis Beacon[^2], 否则你总会一遍又一遍地不小心打错字。</p><p>[^2]: 译者注：<em>Mavis Beacon Teaches Typing</em>，一款在 1987 年发售的教盲打的软件。</p><p>好消息是你会很快的发现问题 — 运行时的异常在等着你。我们获得了能力和灵活性，但在某种程度上失去了静态检查的安全性。</p><p>为了说明这一点，这段从上面代码稍微修改而来的代码会导致崩溃。你能看出来是为什么吗？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *predicateFormat = @&quot;SELF.name LIKE &apos;Kar*&apos;) AND (SELF.paygrade.intValue &gt;= 10)&quot;</span><br><span class="line"></span><br><span class="line">NSPredicate *namesStartingWithK = [NSPredicate predicateWithFormat:predicateFormat];</span><br><span class="line"></span><br><span class="line">// 现在只有 Karl 了 </span><br><span class="line">[mutablePersonAr filterUsingPredicate:namesStartingWithK];</span><br></pre></td></tr></table></figure><p>为了减轻这些问题，我经常把 predicate 和 <code>NSStringFromSelector()</code> 结合在一起用，以此应对错别字和为以后的重构提供多一层安全保障。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *predicateFormat = @&quot;(SELF.%@ LIKE &apos;Kar*&apos;) AND (SELF.paygrade.intValue &gt;= 10)&quot;</span><br><span class="line"></span><br><span class="line">NSString *kpName = NSStringFromSelector(@selector(identifier));  </span><br><span class="line">NSString *kpPaygrade = NSStringFromSelector(@selector(paygrade));</span><br><span class="line"></span><br><span class="line">NSPredicate *namesStartingWithK = [NSPredicate predicateWithFormat:predicateFormat, kpName, kpPaygrade];</span><br><span class="line"></span><br><span class="line">// 现在只有 Karl 了</span><br><span class="line">[mutablePersonAr filterUsingPredicate:namesStartingWithK];</span><br></pre></td></tr></table></figure><p>有点复杂了？确实。更安全了？毫无疑问。</p><h2 id="KeyPath-集合查询"><a href="#KeyPath-集合查询" class="headerlink" title="KeyPath 集合查询"></a>KeyPath 集合查询</h2><p>由于基于 KeyPath 的用法，<code>NSPredicate</code> 拥有一全套工具去操作它们，以提供一个更好的搜索。考虑下面的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 假设一个 Person 对象现在有一个下面的属性：</span><br><span class="line">// NSArray *previousPay</span><br><span class="line"></span><br><span class="line">// 找到所有满足过去工资的平均值大于 10 的人</span><br><span class="line">NSString *predicateFormat = @&quot;SELF.previousPay.@avg.doubleValue &gt; 10&quot;;</span><br><span class="line">NSPredicate *previousPayOverTen = [NSPredicate predicateWithFormat:predicateFormat];</span><br><span class="line"></span><br><span class="line">// 所有过去工资的平均值大于 10 的人</span><br><span class="line">[mutablePersonAr filterUsingPredicate:previousPayOverTen];</span><br></pre></td></tr></table></figure><p>你可以把 <code>@avg</code> 换成：  </p><ul><li><code>@sum</code></li><li><code>@max</code></li><li><code>@min</code></li><li><code>@count</code></li></ul><p>想象下如果不使用 predicate 情况下完成同样的工作，就不得不写大量尽管很简单的代码。你可以开始将这些技巧用在你日常的工具链里。</p><h2 id="对数组的深究"><a href="#对数组的深究" class="headerlink" title="对数组的深究"></a>对数组的深究</h2><p>和 KeyPath 查询很像，predicate 也支持以更细的维度检查数组：</p><ul><li><code>array[FIRST]</code></li><li><code>array[LAST]</code></li><li><code>array[SIZE]</code></li><li><code>array[index]</code></li></ul><p>应用在上面的代码样例上，我们就可以这样查询：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 找到所有过去有三份不同工资的人</span><br><span class="line">NSString *predicateFormat = @&quot;previousPay[SIZE] == 3&quot;;</span><br><span class="line"></span><br><span class="line">NSPredicate *threePreviousSalaries = [NSPredicate predicateWithFormat:predicateFormat];</span><br><span class="line"></span><br><span class="line">// 这些 Person 对象过去有三份不同的工资</span><br><span class="line">[mutablePersonAr filterUsingPredicate:threePreviousSalaries];</span><br></pre></td></tr></table></figure><p>和在上面提到的一样，我们也可以应用多个条件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 找到所有过去有三个不同的工资以及第一份工资大于 8 的人</span><br><span class="line">NSString *predicateFormat = @&quot;(previousPay[SIZE] == 3) AND (previousPay[FIRST].intValue &gt; 8)&quot;;</span><br><span class="line"></span><br><span class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:predicateFormat];</span><br><span class="line">[mutablePersonAr filterUsingPredicate:predicate];</span><br></pre></td></tr></table></figure><p>更加深入，你可以使用下面的操作符来实现更复杂的操作：</p><ul><li><code>@distinctUnionOfArrays</code></li><li><code>@unionOfArrays</code></li><li><code>@unionOfObjects</code></li><li><code>@distinctUnionOfObjects</code></li></ul><p>假设我们有一个含有 <code>Person</code> 对象的数组，我们需要的是找出在所有数组中识别符不同的 <code>Person</code> 实例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 假设 p1/2/3/4 都是 Person 对象</span><br><span class="line">NSArray  *&gt; *previousEmployees = @[@[p1],@[p2,p1,p2],@[p1],@[p4,p2],@[p4],@[p4],@[p1]];</span><br><span class="line"></span><br><span class="line">// 获取所有不同的 ID</span><br><span class="line">NSArray *unqiuePreviousEmployeeIDs = [previousEmployees valueForKeyPath:@&quot;@distinctUnionOfObjects.identifier&quot;];</span><br><span class="line"></span><br><span class="line">// 现在数组里应该只含有不同的 ID</span><br></pre></td></tr></table></figure><p>厉害吧！</p><p>还有更好玩的呢，还支持子查询：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 假设 Person 对象有了一个新的属性表示他们的队伍：</span><br><span class="line">// NSArray  *team;</span><br><span class="line">  </span><br><span class="line">// 从雇员数组中找出这样的人，他们的团队中有人满足这个条件：没有历史工资数据并且工资大于 1</span><br><span class="line">NSString *predicateFormat = @&quot;SUBQUERY(team, $teamMember, $teamMember.paygrade.intValue &gt; 1 AND $teamMember.previousPay == nil).@count &gt; 0&quot;;</span><br><span class="line"></span><br><span class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:predicateFormat];</span><br><span class="line">[employeeAr filterUsingPredicate:predicate];</span><br></pre></td></tr></table></figure><p>当你发现你需要在一个含有对象的数组里搜索，而这些对象含有的属性本身就是一个集合的时候，子查询十分有用。所以在上面的例子里，我们有一个 <code>Person</code> 对象的数组，并且查询它的 <code>teamMember</code> 数组。</p><h2 id="便捷才是关键-3"><a href="#便捷才是关键-3" class="headerlink" title="便捷才是关键[^3]"></a>便捷才是关键[^3]</h2><p>[^3]: 译者注：此处原作者用了双关。原文是 “Convenience is Key(Path)”，既有便捷是关键的意思，又在暗指这里的关键其实是 Key Path。</p><p>尽管 <code>NSPredicate</code> 是为了搜索而设计出来的，但如果你不把它用在和原本设计<em>稍微</em>偏离的地方那它就不是 Objective-C 了。这里也不例外。</p><p>当你想到 predicate，你想到的是从一个集合里筛选 — 也就是说它的返回值（或更改过的原来数组）还含有相同的东西。</p><p>但是也可以让他们含有<em>不</em>同的东西。其实我们在之前的代码中已经这样操作过了。上面的二维数组被用来返回一个识别符的数组 — <code>NSString</code> 实例。KeyPath 让这些变得可能。</p><p>这有一个更直接的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 我们得到一个长度大于 10 的识别符字符串的数组</span><br><span class="line">NSString *predicateFormat = @&quot;SELF.identifier.length &gt; 10&quot;;</span><br><span class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:predicateFormat];</span><br><span class="line">NSArray  *longEmployeeIDs = [[employeeArray filteredArrayUsingPredicate:predicate] valueForKey:@&quot;identifier&quot;];</span><br><span class="line"></span><br><span class="line">// 现在 longEmployeeIDs 已经不含有 Person 对象了，只有字符串</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>马上在 Objective-C 的集合里使用这些语法糖，这样就可以不使用嵌套循环从一个特定的子集中提取数据。使用 <code>NSPredicate</code> 可以让眼睛轻松很多。</p><p>虽然 Swift 从语言级别支持对集合进行切片操作，但使用创建的 NSPredicate 对象来解决相同的问题也不难。如果你发现你在维护一个成熟的代码库，或是需要用上古时代 Objective-C 的新项目，随心所欲的使用 predicate 吧。</p><p>下次见吧✌️。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Jordan Morgan，&lt;a href=&quot;https://www.swiftjectivec.com/nspredicate-objective-c/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-05-18&lt;br&gt;译者：&lt;a href=&quot;https://github.com/alejx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;石榴&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://nemocdz.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nemocdz&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/Pancf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pancf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 刚出现的时候，我们因它比 Objective-C 简洁而着迷。接着它很快打开了面向协议编程的大门。并且，让我们忘掉引用类型和类，还有很多。&lt;/p&gt;
&lt;p&gt;确实，这些东西都是很棒的工具，都有优秀的用例。但我感觉它们经常被捧作银弹，在决定架构时缺乏足够的考虑。&lt;/p&gt;
    
    </summary>
    
      <category term="swiftjectivec" scheme="https://swift.gg/categories/swiftjectivec/"/>
    
    
      <category term="Objective-C" scheme="https://swift.gg/tags/Objective-C/"/>
    
      <category term="NSPredicate" scheme="https://swift.gg/tags/NSPredicate/"/>
    
  </entry>
  
  <entry>
    <title>调试内存不足问题：使用运行时魔法捕获布局反馈循环</title>
    <link href="https://swift.gg/2019/11/11/layout-feedback-loop/"/>
    <id>https://swift.gg/2019/11/11/layout-feedback-loop/</id>
    <published>2019-11-10T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ruslan Serebriakov，<a href="https://www.appcoda.com/layout-feedback-loop/" target="_blank" rel="noopener">原文链接</a>，原文日期：2019-01-10<br>译者：Sunset Wan；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://nemocdz.github.io/" target="_blank" rel="noopener">Nemocdz</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>让我们想象这样一个场景：你有一个很成功的应用程序，这个应用程序有大量的日活用户并且崩溃率为 0。你很开心并且认为生活很美好。但是某天开始，你在应用商店上看到关于应用程序总是崩溃的负面评价。检查 Fabric 也没有起到任何帮助————没有出现新的崩溃记录。那么，这个现象可能是什么原因呢？</p><p>答案是内存不足（Out Of Memory），从而导致应用程序运行终止。<br><a id="more"></a></p><p>当你在终端用户的设备上使用 RAM 时，操作系统可以决定是否为其他进程而回收该内存，并终止你的应用程序。我们把它称作内存不足异常终止。<br>可能有各种原因：</p><ul><li>循环引用;</li><li>竞争条件;</li><li>废弃的线程;</li><li>死锁;</li><li>布局反馈循环。</li></ul><p>Apple 提供了很多方法来解决这类问题：</p><ul><li>Instruments 里的 Allocations 和 Leaks 工具用于解决循环引用和 <a href="https://developer.apple.com/videos/play/wwdc2015/230/" target="_blank" rel="noopener">其他类型的泄漏</a></li><li>在 Xcode 8 中引入的 <a href="https://developer.apple.com/videos/play/wwdc2016/410/" target="_blank" rel="noopener">Memory Debugger</a> 代替了 Allocations 和 Leaks 的一部分功能</li><li><a href="https://developer.apple.com/videos/play/wwdc2016/412/" target="_blank" rel="noopener">Thread Sanitizer</a> 帮助你找到竞争条件、废弃的线程或者死锁</li></ul><h2 id="布局反馈循环"><a href="#布局反馈循环" class="headerlink" title="布局反馈循环"></a>布局反馈循环</h2><p>下面我们来讨论下布局反馈循环。它不是一个频繁出现的问题，一旦遇到了，可能让你很头痛。</p><blockquote><p>当视图正在运行它们的布局代码，但某种方法导致它们再一次开始布局传递，此时布局反馈循环就会出现。这可能是因为某个视图正在改变某个父视图的大小，或者因为你有一个模棱两可的布局。无论哪种原因，这个问题的表现是你的 CPU 使用被占满和 RAM 使用量稳步上升，因为你的视图正在一次又一次地运行它们的布局代码，却没有返回。<br>- <a href="https://www.hackingwithswift.com/articles/59/debugging-auto-layout-feedback-loops" target="_blank" rel="noopener">来自 HackingWithSwift 的 Paul Hudson</a></p></blockquote><p>幸运的是，在 WWDC 16 中 Apple 花了整整 15 分钟（！）来介绍“布局反馈循环调试器”。这个调试器有助于识别在调试过程中发生循环的时间点。这就是一个符号断点，它的工作方式非常简单：它会计算在单个 run loop 迭代中调用每个视图上的 <code>layoutSubviews()</code> 方法的次数。一旦这个计数值超过某个临界值（比如，100），这个应用程序将会停在这个断点并打印出日志，来帮助你找到根本原因。<a href="https://www.hackingwithswift.com/articles/59/debugging-auto-layout-feedback-loops" target="_blank" rel="noopener">这篇文章</a> 快速地介绍如何使用这个调试器。</p><p>这个方法在你可以重现问题的情况下十分有效。但是如果你有几十个屏幕，几百个视图，但应用商店中你的应用程序的评价仅仅是：“这个应用程序糟透了，总是崩溃，再也不用了！”。你希望可以将这些人带到办公室并为他们设置布局反馈循环调试器。虽然因为通用数据保护条例（GDPR），这部分无法完全实现，但是你可以尝试把 <code>UIViewLayoutFeedbackLoopDebuggingThreshold</code> 的代码复制到生产代码中。</p><p>让我们回顾一下符号断点是如何工作的：它会计算 <code>layoutSubviews()</code> 的调用次数并在单个 run loop 迭代中超过某个临界值时发送一个事件。听起来很简单，对吧？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TrackableView: UIView &#123;</span><br><span class="line">    var counter: Int = 0</span><br><span class="line"> </span><br><span class="line">    override func layoutSubviews() &#123;</span><br><span class="line">        super.layoutSubviews()</span><br><span class="line"> </span><br><span class="line">        counter += 1;</span><br><span class="line">        if (counter == 100) &#123;</span><br><span class="line">            YourAnalyticsFramework.event(name: &quot;loop&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个视图，这段代码运行正常。但是现在你想要在另一个视图上实现它。当然，你可以创建一个 <code>UIView</code> 的子类，在这里实现它并使你项目中的所有视图都继承这个子类。然后为 <code>UITableView</code>，<code>UIScrollView</code>，<code>UIStackView</code> 等做同样的事情。</p><p>你希望可以将此逻辑注入你想要的任何类，而无需编写大量重复的代码。这时候就可以借助运行时编程了。</p><p>我们会做同样的事情——创建一个子类，重写 <code>layoutSubviews()</code> 方法并计算其调用次数。唯一的区别是所有这些都将在运行时完成，而不是在项目中创建重复的类。</p><p>让我们开始吧——我们将创建自定义子类，并将原始视图的类更改为新的子类：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct LayoutLoopHunter &#123;</span><br><span class="line"> </span><br><span class="line">    struct RuntimeConstants &#123;</span><br><span class="line">        static let Prefix = “runtime”</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static func setUp(for view: UIView, threshold: Int = 100, onLoop: @escaping () -&gt; ()) &#123;</span><br><span class="line">        // 我们根据功能的前缀和原始类名为新类创建名称。</span><br><span class="line">        let classFullName = “\(RuntimeConstants.Prefix)_\(String(describing: view.self))”</span><br><span class="line">        let originalClass = type(of: view)</span><br><span class="line"> </span><br><span class="line">        if let trackableClass = objc_allocateClassPair(originalClass, classFullName, 0) &#123;</span><br><span class="line">            // 在当前运行时会话期间尚未创建此类。</span><br><span class="line">            // 注册这个类，并且用原始视图的类来和它交换。</span><br><span class="line">            objc_registerClassPair(trackableClass)</span><br><span class="line">            object_setClass(view, trackableClass)</span><br><span class="line">        &#125; else if let trackableClass = NSClassFromString(classFullName) &#123;</span><br><span class="line">            // 我们之前在此运行时会话中分配了一个具有相同名称的类。</span><br><span class="line">            // 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换。</span><br><span class="line">            object_setClass(view, trackableClass)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objc_allocateClassPair()</code> 方法的文档告诉我们这个方法何时失败：</p><blockquote><p>新类，或者如果无法创建类，则为 Nil （例如，所需名称已被使用）。</p></blockquote><p>这就意味着不能拥有两个同名的类。我们的策略是为单个视图类创建一个单独的运行时类。这就是我们在原始类名前加上前缀来形成新类的名称的原因。</p><p>现在添加一个计数器到子类中。理论上，有两种方法可以做到这一点。</p><ol><li>添加一个保存计数器的属性。</li><li>为这个类创建一个关联对象（Associated object）。</li></ol><p>但是目前，<strong>只有一个方法奏效</strong>。你可以想象属性是存储在分配给类的内存里的东西，然而关联对象则储存在一个完全不同的地方。因为分配给已存在对象的内存是固定的，所以我们在自定义类上新添加的属性将会从其他资源里“窃取”内存。它可能导致意料之外的行为和难以调试的程序崩溃（点击 <a href="https://stackoverflow.com/questions/3346427/object-setclass-to-bigger-class" target="_blank" rel="noopener">这里</a> 查看更多信息）。但是在使用关联对象的情况下，它们将会存储在运行时创建的一个哈希表里，这是完全安全的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static var CounterKey = &quot;_counter&quot;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">objc_setAssociatedObject(trackableClass, &amp;RuntimeConstants.CounterKey, 0, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br></pre></td></tr></table></figure><p>当新的子类被创建时，计数器初值设置为 0。接下来，让我们实现这个新的<code>layoutSubviews()</code> 方法，并将它添加到我们的类中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let layoutSubviews: @convention(block) (Any?) -&gt; () = &#123; nullableSelf in</span><br><span class="line">    guard let _self = nullableSelf else &#123; return &#125;</span><br><span class="line"> </span><br><span class="line">    if let counter = objc_getAssociatedObject(_self, &amp;RuntimeConstants.CounterKey) as? Int &#123;</span><br><span class="line">        if counter == threshold &#123;</span><br><span class="line">            onLoop()</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        objc_setAssociatedObject(trackableClass, &amp;RuntimeConstants.CounterKey, counter+1, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, &quot;v@:&quot;)</span><br></pre></td></tr></table></figure><p>为了理解上面这段代码实际上在干什么，让我们看一下这个来自 <code>&lt;objc/runtime.h&gt;</code> 的结构体：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name;</span><br><span class="line">    char *method_types;</span><br><span class="line">    IMP method_imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管我们再也不会在 Swift 中直接使用这个结构体，但它很清楚地解释了一个方法实际上是由什么组成的：</p><ul><li>方法的实现，这是调用方法时要执行的实际函数。它的前两个形参总是方法接收者和消息选择器。</li><li>包含方法签名的方法类型字符串。你可以在 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">这里</a> 详细了解其格式。但是在现在的情况下，需要明确说明的字符串是 <code>“v@:”</code>。作为返回类型，<code>v</code> 代表 <code>void</code>，而 <code>@</code> 和 <code>:</code> 分别代表接收者和消息选择器。</li><li>选择器作为键，用于在运行时查找方法的实现。</li></ul><p>你可以把 Witness Table（在其他编程语言中，它也被称作方法派发表）想象成一个简单的字典数据结构。那么选择器为键，且实现部分则为对应的值。<br>在下面这行代码中:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class_addMethod(trackableClass,#selector(originalClass.layoutSubviews), implementation, &quot;v@:&quot;)</span><br></pre></td></tr></table></figure></p><p>我们所做的是给 <code>layoutSubviews()</code> 方法对应的键分配新值。    </p><p>这个方法直截了当。我们获得这个计数器，使它的计数值加一。如果计数值超过临界值，我们会发送分析事件，其中包含类名和想要的任何数据体。</p><p>让我们回顾一下如何对关联对象实现和使用键：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static var CounterKey = “_counter”</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">objc_setAssociatedObject(trackableClass, &amp;RuntimeConstants.CounterKey, counter+1, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br></pre></td></tr></table></figure><p>为什么我们使用 <code>var</code> 来修饰计数器的键这个静态属性并在传递到其他地方时使用引用？答案隐藏在 Swift 语言基础——字符串之中。字符串像其他所有的值类型一样，是按值传递的。那么，当你把它传入这个闭包时，这个字符串将会被复制到一个不同的地址，这会导致在关联对象表中产生一个完全不同的键。<code>&amp;</code> 符号总是保证将相同的地址作为键参数的值。你可以尝试以下代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func printAddress(_ string: UnsafeRawPointer) &#123;</span><br><span class="line">    print(&quot;\(string)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let str = &quot;test&quot;</span><br><span class="line"></span><br><span class="line">printAddress(str)</span><br><span class="line">printAddress(str)</span><br><span class="line">let closure = &#123;</span><br><span class="line">    printAddress(str)</span><br><span class="line">    printAddress(str)</span><br><span class="line">&#125;</span><br><span class="line">closure()</span><br><span class="line">// 最后两个函数调用的地址将始终不同</span><br></pre></td></tr></table></figure><p>用引用的方式来传递键的主意总是好的，因为有时，即使你没有使用闭包，变量的地址仍可能因内存管理而更改。在我们例子中，如果你把上面的代码运行多次，即使是前两个 printAddress() 的调用也可能会输出不同的地址。</p><p>让我们回到运行时的魔法里来。在新 <code>layoutSubviews()</code> 的实现里，还有一件很重要的事情没有完成。这件事是每次重写父类的方法时通常都会做的事情——调用父类实现。<code>layoutSubviews()</code> 的文档里提到：</p><blockquote><p>在 iOS 5.1 及更早版本中，这个方法的默认实现不执行任何操作。而之后的默认实现会使用你设置的任何约束来确定任何子视图的大小和位置。</p></blockquote><p>为了避免发生一些难以预料的布局行为，我们得调用父类的实现，但这不像平常那样简单明了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let selector = #selector(originalClass.layoutSubviews)</span><br><span class="line">let originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">// @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span><br><span class="line">// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span><br><span class="line">// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span><br><span class="line">typealias ObjCVoidVoidFn = @convention(c) (Any, Selector) -&gt; Void</span><br><span class="line">let originalLayoutSubviews = unsafeBitCast(originalImpl, to: ObjCVoidVoidFn.self)</span><br><span class="line">originalLayoutSubviews(view, selector)</span><br></pre></td></tr></table></figure><p>这里实际发生的是：我们检索方法所需的实现部分，并直接从代码中调用它，而不是用常见的方式来调用方法（即执行一个会在 Witness Table 中寻找对应实现的选择器）。</p><p>目前为止，让我们看看实现部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static func setUp(for view: UIView, threshold: Int = 100, onLoop: @escaping () -&gt; ()) &#123;</span><br><span class="line">    // 我们根据功能的前缀和原始类名为新类创建名称</span><br><span class="line">    let classFullName = “\(RuntimeConstants.Prefix)_\(String(describing: view.self))”</span><br><span class="line">    let originalClass = type(of: view)</span><br><span class="line"></span><br><span class="line">    if let trackableClass = objc_allocateClassPair(originalClass, classFullName, 0) &#123;</span><br><span class="line">        // 在当前运行时会话期间尚未创建此类</span><br><span class="line">        // 注册这个类并将其与原始视图的类交换</span><br><span class="line">        objc_registerClassPair(trackableClass)</span><br><span class="line">        object_setClass(view, trackableClass)</span><br><span class="line"></span><br><span class="line">        // 现在可以创建关联对象</span><br><span class="line">        objc_setAssociatedObject(view, &amp;RuntimeConstants.CounterKey, 0, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line"></span><br><span class="line">        // 添加我们自己 layoutSubviews 的实现</span><br><span class="line">        let layoutSubviews: @convention(block) (Any?) -&gt; () = &#123; nullableSelf in</span><br><span class="line">            guard let _self = nullableSelf else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">            let selector = #selector(originalClass.layoutSubviews)</span><br><span class="line">            let originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">            // @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span><br><span class="line">            // 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span><br><span class="line">            // 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span><br><span class="line">            typealias ObjCVoidVoidFn = @convention(c) (Any, Selector) -&gt; Void</span><br><span class="line">            let originalLayoutSubviews = unsafeBitCast(originalImpl, to: ObjCVoidVoidFn.self)</span><br><span class="line">            originalLayoutSubviews(view, selector)</span><br><span class="line"></span><br><span class="line">            if let counter = objc_getAssociatedObject(_self, &amp;RuntimeConstants.CounterKey) as? Int &#123;</span><br><span class="line">                if counter == threshold &#123;</span><br><span class="line">                    onLoop()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                objc_setAssociatedObject(view, &amp;RuntimeConstants.CounterKey, counter+1, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">        class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, “v@:“)</span><br><span class="line">    &#125; else if let trackableClass = NSClassFromString(classFullName) &#123;</span><br><span class="line">        // 我们之前在此运行时会话中分配了一个具有相同名称的类</span><br><span class="line">        // 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换</span><br><span class="line">        object_setClass(view, trackableClass)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们为视图创建模拟布局循环，并为其设置计数器来进行测试：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line"> </span><br><span class="line">        LayoutLoopHunter.setUp(for: view) &#123;</span><br><span class="line">            print(&quot;Hello, world&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    override func viewDidLayoutSubviews() &#123;</span><br><span class="line">        super.viewDidLayoutSubviews()</span><br><span class="line">        view.setNeedsLayout() // loop creation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是忘记了什么事情？让我们再次回顾一下 <code>UIViewLayoutFeedbackLoopDebuggingThreshold</code> 断点的工作原理：</p><blockquote><p>在确认为反馈循环之前，定义某个视图的子视图在单个 run loop 里必须布局的次数</p></blockquote><p>我们从未把“单个 run loop ”这一条件考虑进来。如果视图在屏幕上停留了相当长的时间，并经常被反复布局，计数器迟早会超过临界值。但这可不是因为内存的问题。</p><p>我们该怎么解决这个问题呢？只需在每次 run loop 迭代时重置计数器。为了做到这一点，我们可以创建一个 <a href="https://www.appcoda.com/grand-central-dispatch/" target="_blank" rel="noopener"><strong>DispatchWorkItem</strong></a>，它重置计数器，并在主队列上异步传递它。通过这种方式，它会在 run loop 下一次进入主线程时被调用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static var ResetWorkItemKey = “_resetWorkItem”</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">if let previousResetWorkItem = objc_getAssociatedObject(view, &amp;RuntimeConstants.ResetWorkItemKey) as? DispatchWorkItem &#123;</span><br><span class="line">    previousResetWorkItem.cancel()</span><br><span class="line">&#125;</span><br><span class="line">let currentResetWorkItem = DispatchWorkItem &#123; [weak view] in</span><br><span class="line">    guard let strongView = view else &#123; return &#125;</span><br><span class="line">    objc_setAssociatedObject(strongView, &amp;RuntimeConstants.CounterKey, 0, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">&#125;</span><br><span class="line">DispatchQueue.main.async(execute: currentResetWorkItem)</span><br><span class="line">objc_setAssociatedObject(view, &amp;RuntimeConstants.ResetWorkItemKey, currentResetWorkItem, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br></pre></td></tr></table></figure><p>最终的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct LayoutLoopHunter &#123;</span><br><span class="line"> </span><br><span class="line">    struct RuntimeConstants &#123;</span><br><span class="line">        static let Prefix = “runtime”</span><br><span class="line"> </span><br><span class="line">        // Associated objects keys</span><br><span class="line">        // 关联对象键</span><br><span class="line">        static var CounterKey = “_counter”</span><br><span class="line">        static var ResetWorkItemKey = “_resetWorkItem”</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static func setUp(for view: UIView, threshold: Int = 100, onLoop: @escaping () -&gt; ()) &#123;</span><br><span class="line">        // 我们根据功能的前缀和原始类名为新类创建名称。</span><br><span class="line">        let classFullName = “\(RuntimeConstants.Prefix)_\(String(describing: view.self))”</span><br><span class="line">        let originalClass = type(of: view)</span><br><span class="line"> </span><br><span class="line">        if let trackableClass = objc_allocateClassPair(originalClass, classFullName, 0) &#123;</span><br><span class="line">            // 在当前运行时会话期间尚未创建此类。</span><br><span class="line">            // 注册这个类，并且用原始视图的类来和它交换。</span><br><span class="line">            objc_registerClassPair(trackableClass)</span><br><span class="line">            object_setClass(view, trackableClass)</span><br><span class="line"> </span><br><span class="line">            // 现在可以创建关联对象</span><br><span class="line">            objc_setAssociatedObject(view, &amp;RuntimeConstants.CounterKey, 0, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line"> </span><br><span class="line">            // 添加我们自己 layoutSubviews 的实现</span><br><span class="line">            let layoutSubviews: @convention(block) (Any?) -&gt; () = &#123; nullableSelf in</span><br><span class="line">                guard let _self = nullableSelf else &#123; return &#125;</span><br><span class="line"> </span><br><span class="line">                let selector = #selector(originalClass.layoutSubviews)</span><br><span class="line">                let originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"> </span><br><span class="line">                // @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span><br><span class="line">                // 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span><br><span class="line">                // 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span><br><span class="line">                typealias ObjCVoidVoidFn = @convention(c) (Any, Selector) -&gt; Void</span><br><span class="line">                let originalLayoutSubviews = unsafeBitCast(originalImpl, to: ObjCVoidVoidFn.self)</span><br><span class="line">                originalLayoutSubviews(view, selector)</span><br><span class="line"> </span><br><span class="line">                if let counter = objc_getAssociatedObject(_self, &amp;RuntimeConstants.CounterKey) as? Int &#123;</span><br><span class="line">                    if counter == threshold &#123;</span><br><span class="line">                        onLoop()</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    objc_setAssociatedObject(view, &amp;RuntimeConstants.CounterKey, counter+1, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                // 为重置计数器，在每个新的 run loop 遍历中分发 work item</span><br><span class="line">                if let previousResetWorkItem = objc_getAssociatedObject(view, &amp;RuntimeConstants.ResetWorkItemKey) as? DispatchWorkItem &#123;</span><br><span class="line">                    previousResetWorkItem.cancel()</span><br><span class="line">                &#125;</span><br><span class="line">                let counterResetWorkItem = DispatchWorkItem &#123; [weak view] in</span><br><span class="line">                    guard let strongView = view else &#123; return &#125;</span><br><span class="line">                    objc_setAssociatedObject(strongView, &amp;RuntimeConstants.CounterKey, 0, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">                &#125;</span><br><span class="line">                DispatchQueue.main.async(execute: counterResetWorkItem)</span><br><span class="line">                objc_setAssociatedObject(view, &amp;RuntimeConstants.ResetWorkItemKey, counterResetWorkItem, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">            &#125;</span><br><span class="line">            let implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">            class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, “v@:“)</span><br><span class="line">        &#125; else if let trackableClass = NSClassFromString(classFullName) &#123;</span><br><span class="line">            // 我们之前在此运行时会话中分配了一个具有相同名称的类。</span><br><span class="line">            // 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换。</span><br><span class="line">            object_setClass(view, trackableClass)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>是的！现在你可以为所有可疑的视图设置分析事件了，发布应用程序，并找到这个问题的确切出处。你可以把这个问题的范围缩小到某个特定的视图，并在用户不知情的情况下借助于他们来解决这个问题。</p><p>最后要提到的一件事是：能力越大责任越大。运行时编程非常容易出错，因此很容易在不知情的情况下为应用程序引入另一个严重的问题。这就是为什么总是建议将应用程序中的所有危险代码包装在某种可停止开关中，因为你可以在发现代码导致问题时从后端触发开关禁用该功能。这有一篇介绍 Firebase 的 Feature Flags 的 <a href="https://medium.com/@rwbutler/feature-flags-a-b-testing-mvt-on-ios-718339ac7aa1" target="_blank" rel="noopener">好文章</a></p><p>完整代码可以从这个 <a href="https://github.com/rsrbk/LayoutLoopHunter" target="_blank" rel="noopener">GitHub 仓库</a> 里获取，并且也将会发布到 CocoPods 上，以跟踪项目中的布局循环。</p><p>附：我想特别感谢 <a href="https://github.com/sanekgusev" target="_blank" rel="noopener">Aleksandr Gusev</a> 帮助审阅并且为本文提供了很多意见。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文详细讲解了如何利用在运行时编程来帮助开发者调试布局反馈循环。
    
    </summary>
    
      <category term="AppCoda" scheme="https://swift.gg/categories/AppCoda/"/>
    
    
      <category term="教程" scheme="https://swift.gg/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分析复杂度</title>
    <link href="https://swift.gg/2019/11/06/analyzing-complexity/"/>
    <id>https://swift.gg/2019/11/06/analyzing-complexity/</id>
    <published>2019-11-05T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2018/12/analyzing-complexity/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-12-17<br>译者：<a href="https://www.roczhang.com/" target="_blank" rel="noopener">RocZhang</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>在 Dave Abraham 的 WWDC 演讲 <a href="https://developer.apple.com/videos/play/wwdc2018/223/#" target="_blank" rel="noopener">Embracing Algorithms（拥抱算法）</a>中，谈到了要发现通用的算法，并将其提取到通用且可测试的函数中。在这个方向上，我发现一些对集合类型的多次操作可以被聚齐起来，合并成单次操作。并且通常情况下，这些操作被合并之后还能带来性能上的收获。</p><a id="more"></a><p>第一个例子是 Swift 3 添加的一个方法:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当你看到:</span></span><br><span class="line">myArray.<span class="built_in">filter</span>(&#123; <span class="comment">/* some test */</span> &#125;).first</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你应该把它改成:</span></span><br><span class="line">myArray.first(<span class="keyword">where</span>: &#123; <span class="comment">/* some test */</span> &#125;)</span><br></pre></td></tr></table></figure><p>这里两种写法的断言描述闭包和操作结果都完全相同，但下面的写法更简短，语义更清晰，而且性能更好。因为它不会进行新数组的分配，也不需要对数组中每一个元素是否能够通过测试都进行判断，只需要找出第一个就好了。</p><p>另一个例子是 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0220-count-where.md" target="_blank" rel="noopener">我帮助添加到 Swift 5</a> 中的 <code>count(where:)</code> 函数:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当你看到:</span></span><br><span class="line">myArray.<span class="built_in">filter</span>(&#123; <span class="comment">/* some test */</span> &#125;).<span class="built_in">count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你应该把它改成:</span></span><br><span class="line">myArray.<span class="built_in">count</span>(<span class="keyword">where</span>: &#123; <span class="comment">/* some test */</span> &#125;)</span><br></pre></td></tr></table></figure><p>这又是一个更短、更清晰而且更快的例子。没有额外要被分配的数组，也没有多余的操作。</p><p>在我们的一个项目中，有一个通用的范式，需要先将集合进行 <code>sort</code>，随后再进行 <code>prefix</code> 操作。例如下述的示例代码，需要找出前 20 张最新创建的图像：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> images</span><br><span class="line">    .sorted(by: &#123; $<span class="number">0</span>.createdAt &gt; $<span class="number">1</span>.createdAt &#125;)</span><br><span class="line">    .<span class="keyword">prefix</span>(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>同样，也可以想象成在排行榜中找到前 5 位得分最高的用户，也需要使用这类范式。</p><p>我盯着这段代码直到我的眼睛开始流血，感到这段代码可能存在问题。我首先想到的是分析它的时间复杂度。如果把原始数组的长度用 n 表示，再把最后想要得到的元素的数目用 m 表示，在分析代码之后可以得出，排序的复杂度是 O(nlogn)，取前子集合的操作则更快，时间复杂度为 O(1)（取前子集合操作本身最慢时可能会达到 O(m)，但对这里我们要处理的数组而言，由于它是可随机访问的集合，因此取前子集合操作能在常数时间中完成）。</p><p>这正是让我感到困惑的地方：获取一个序列的最小元素（使用 <code>min()</code> 函数）只需要单次遍历所有元素，或者说时间复杂度为 O(n)。将其所有元素进行完整排序需要的时间复杂度是 O(nlogn)。而从集合中获取 m 个数，当 m 比 n 小时，时间复杂度应该位于它们之间。且当 m 比 n 小非常多时，时间复杂度应该更接近 O(n)。</p><p>在我们的例子里，图片的数量会非常大（n 约为 55000），而我们想得到的元素数量却很小（m 为 20）。因此，这里应该存在有优化的空间。我们是否能够优化排序，使其仅排序出前 m 个元素？</p><p>答案是肯定的，我们能够在这个方向上进行一些优化。我将此函数命名为 <code>smallest(_:by:)</code>，它接收 <code>sort</code> 和 <code>prefix</code> 函数的所有参数，也就是上面提到的 m 和用于排序做比较的闭包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">smallest</span><span class="params">(<span class="number">_</span> m: Int, by areInIncreasingOrder: <span class="params">(Element, Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Element</span>] &#123;</span><br></pre></td></tr></table></figure><p>首先从排序前 m 个元素开始（因为 m 比序列的总长度要小很多，所以此操作会进行的很快）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">self</span>.<span class="keyword">prefix</span>(m).sorted(by: areInIncreasingOrder)</span><br></pre></td></tr></table></figure><p>然后我们再遍历所有剩下的元素：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span>.<span class="built_in">dropFirst</span>(m) &#123;</span><br></pre></td></tr></table></figure><p>对集合中剩下的每一个元素，我们需要找到 <code>result</code> 中第一个比它大的项的索引。通过 <code>areInIncreasingOrder</code> 函数，我们把 <code>element</code> 作为第一个参数传入，再把 <code>result</code> 中的元素作为第二个参数传入。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> insertionIndex = result.index(<span class="keyword">where</span>: &#123; areInIncreasingOrder(element, $<span class="number">0</span>) &#125;) &#123; <span class="comment">// 译者注：此方法在 Swift 4.2 后已更名为 `firstIndex(where:)`</span></span><br></pre></td></tr></table></figure><p>如果能够找到符合条件的索引值，这就表示存在有比我们 <code>result</code> 数组中的元素更小的值。我们把新的值插入到计算出的索引的位置，它便会被正确的排序：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">result.insert(element, at: insertionIndex)</span><br></pre></td></tr></table></figure><p>再将最后一个元素移除（因为我们只需要 m 个元素）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">result.removeLast()</span><br></pre></td></tr></table></figure><p>如果没有找到满足条件的索引，我们就可以忽略这个值。最后，当 <code>for</code> 循环完成，便可将 <code>result</code> 返回。</p><p>完整的函数如下所示：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">smallest</span><span class="params">(<span class="number">_</span> m: Int, by areInIncreasingOrder: <span class="params">(Element, Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">self</span>.<span class="keyword">prefix</span>(m).sorted(by: areInIncreasingOrder)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> <span class="keyword">self</span>.<span class="built_in">dropFirst</span>(n) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> insertionIndex = result.index(<span class="keyword">where</span>: &#123; areInIncreasingOrder(e, $<span class="number">0</span>) &#125;) &#123;</span><br><span class="line">                result.insert(e, at: insertionIndex)</span><br><span class="line">                result.removeLast()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这让你想起了之前在计算机科学中学过的课程，那就再好不过了。实际上这里的算法就类似于选择排序的过程（但它们并非完全相同，因为这里会预先排序一部分元素，而选择排序则不同，是可变序列算法（mutating algorithm））。</p><p>这里的时间复杂度分析起来可能会有些困难，但是我们还是可以尝试进行分析。初始部分的排序是 O(mlogm)，外层的循环是 O(n)。每次的循环中，会分别调用时间复杂度都为 O(m) 的 <code>index(where:)</code> 和 <code>insert(_:at:)</code>（插入操作的时间复杂度是 O(m) 的原因在于，它可能需要将所有的元素后移，为新元素腾出空间）。因此，总时间复杂度应为 O(mlogm + n * (m + m))，或者说 O(mlogm + 2nm)。常数项被移除后，留下的则是 O(mlogm + nm)。</p><p>当 m 比 n 小得多时，m 项会接近于常数，最终我们得到的会是 O(n)。相较于之前的 O(nlogn) 而言，这是一个巨大的改进。对应到之前提到的 55000 张图片的例子，这可能会是多达 5 倍的性能提升。</p><p>大体上来说，这里的函数是对 <code>prefix</code> + <code>sort</code> 函数的优化。但我还想要再讨论两处更细小一些的优化。</p><p>一处唾手可得的优化是：我们是在 55000 个元素的数组中查找 20 个最小的元素，其中我们检查的大部分（几乎是全部）元素不会落入到最后的 <code>result</code> 数组中。因此我们可以去检查元素是否比 <code>result</code> 数组中的最后一个元素要大，如果是，它就完全可以被跳过。因为当元素比 <code>result</code> 中的最后一个还要大时，再去查找插入的索引就没有任何意义了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> last = result.last, areInIncreasingOrder(last, e) &#123; <span class="keyword">continue</span> &#125;</span><br></pre></td></tr></table></figure><p>在测试中，此处增加的判断可以减少线性搜索 <code>result</code> 数组 99.5% 的时间，算法整体上又会加快十倍左右。感谢 <a href="https://twitter.com/gregtitus" target="_blank" rel="noopener">Greg Titus</a> 告诉我此处可以优化──之前我完全没有想到这一点。</p><p>如果想更近一步的话，还可以做另一处（稍微难实现一些）的优化。此优化基于两处事实：第一，我们使用 <code>index(where:)</code> 来找出应在 <code>result</code> 数组中进行插入的位置；第二，<code>result</code> 数组总是保持有序的。<code>index(where:)</code> 通常情况下是一项线性操作，但如果是在一个已经排好序的数组中进行搜索，我们可以将线性搜索替换成二分搜索。我对此进行了尝试。</p><p>为了能够更好的理解这些优化会如何影响算法的性能，Nate Cook 帮助我了解了 Karoy Lorentey 的 <a href="https://github.com/attaswift/Attabench" target="_blank" rel="noopener">Attabench 工具</a>，它能够对这些解决方案进行基准测试。因为截止目前，我们对复杂度的分析都是停留在理论层面的，在真正对代码进行实际测试之前（最理想的情况应该是在真实的设备上），所有的结论都只是有根据的推测。例如，通常来说排序的复杂度为 O(nlogn)，但不同的算法处理不同类型的数据时，其表现也会有所不同。具体来说，已经排好序的数据在特定的算法中可能会变得更快或更慢。</p><p>Attabench 的执行结果如下：</p><p><img src="http://khanlou.com/images/SmallestNProfile.png" alt></p><p>（我还添加了一个 <a href="https://gist.github.com/timvermeulen/2174f84ade2d1f97c4d994b7a3156454" target="_blank" rel="noopener">由 Time Vermuelen 所写的优先队列/堆解决方案</a>，因为有些人好奇它与其他方案比较起来表现如何。）</p><p>首先，我对在数组中进行单次搜索比对数组进行完整排序要快的猜测是正确的。尤其是在实际问题中序列可能会很长，排序的性能则会变得更差，但我们的“简单优化”（图中的 “Naive Optimization”）却能保持在常数水平上（Y 轴表示的是单个元素上所花的时间，而不是总时间。这意味着 O(n) 的算法在图中会是一条直线）。</p><p>第二，对最后一个元素的检查（图中的 “Last Check”）和二分搜索优化在独立运行时具有几乎完全相同的性能表现（实际上你可能没法看到橘色和黄色的线，因为它们被绿线挡住了），把它们放在一起使用时也是一样。但是由于二分搜索难以编写，<a href="https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html" target="_blank" rel="noopener">甚至更难把它写对</a>，你也可以说把它加上是不值得的。</p><p>对我而言，这里传递出的关键信息是测量和优化很难。虽然分析复杂度这件事听起来有些学术：“我什么时候会在自己的职业生涯上用到这个？” 有人会问。但理解你的算法的时间和空间复杂度能够帮助你决定向哪个方向进行探索。在这个例子中，理解排序的时间复杂度引导我们对问题产生了概括性的认知，得到成果。最后，通过使用各种数据进行的进一步的基准测试与分析，能告诉我们代码在生产环境下将如何运作的最准确的信息。</p><p>下一次再看到 <code>sort</code> 后面紧跟着一个 <code>prefix</code> 时，不妨考虑将它替换成 <code>smallest(_: by:)</code>？ </p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了在 Swift 中如何对一些集合类型的操作进行性能分析与优化。
    
    </summary>
    
      <category term="khanlou" scheme="https://swift.gg/categories/khanlou/"/>
    
      <category term="iOS" scheme="https://swift.gg/categories/khanlou/iOS/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="Algorithm" scheme="https://swift.gg/tags/Algorithm/"/>
    
      <category term="Complexity" scheme="https://swift.gg/tags/Complexity/"/>
    
  </entry>
  
  <entry>
    <title>图像渲染优化技巧</title>
    <link href="https://swift.gg/2019/11/01/image-resizing/"/>
    <id>https://swift.gg/2019/11/01/image-resizing/</id>
    <published>2019-10-31T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/image-resizing/" target="_blank" rel="noopener">原文链接</a>，原文日期：2019-05-06<br>译者：ericchuhong；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>长期以来，iOS 开发人员一直被一个奇怪的问题困扰着：</p><p><em>“如何对一张图像进行渲染优化？”</em></p><p>这个令人困扰的问题，是由于开发者和平台的相互不信任引起的。各种各样的代码示例充斥着 Stack Overflow，每个人都声称只有自己的方法是真正的解决方案 —— 而别人的是错的。</p><a id="more"></a><p>在本周的文章中，我们将介绍 5 种不同的 iOS 图像渲染优化技巧（在 MacOS 上时适当地将 <code>UIImage</code> 转换成 <code>NSImage</code>）。相比于对每一种情况都规定一种方法，我们将从人类工程学和性能表现方面进行衡量，以便你更好地理解什么时该用哪一种，不该用哪一些。</p><blockquote><p>你可以自己下载、构建和运行 <a href="https://github.com/NSHipster/Image-Resizing-Example" target="_blank" rel="noopener">示例项目代码</a> 来试验这些图像渲染优化技巧。</p></blockquote><hr><h2 id="图像渲染优化的时机和理由"><a href="#图像渲染优化的时机和理由" class="headerlink" title="图像渲染优化的时机和理由"></a>图像渲染优化的时机和理由</h2><p>在开始之前，让我们先讨论一下<em>为什么</em>需要对图像进行渲染优化。毕竟，<code>UIImageView</code> 会自动根据 <a href="https://developer.apple.com/documentation/uikit/uiview/1622619-contentmode" target="_blank" rel="noopener"><code>contentmode</code> 属性</a> 规定的行为缩放和裁剪图像。在绝大多数情况下，<code>.scaleAspectFit</code>、<code>.scaleAspectFill</code> 或 <code>.scaleToFill</code> 已经完全满足你的所需。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">imageView.contentMode = .scaleAspectFit</span><br><span class="line">imageView.image = image</span><br></pre></td></tr></table></figure><hr><p>那么，什么时候对图像进行渲染优化才有意义呢？<br><br><strong>当它明显大于</strong> <strong><code>UIImageView</code></strong> <strong>显示尺寸的时候</strong></p><hr><p>看看来自 <a href="https://visibleearth.nasa.gov" target="_blank" rel="noopener">NASA 视觉地球相册集锦</a> 的这张 <a href="https://visibleearth.nasa.gov/view.php?id=78314" target="_blank" rel="noopener">令人赞叹的图片</a>：</p><p><img src="https://nshipster.com/assets/image-resizing-earth-5eaad58ee8c9b4f79595ef7271d19afa50f2240f128465746b3c930c1d420524.jpg" alt="image-resizing-earth"></p><p>想要完整渲染这张宽高为 12,000 px 的图片，需要高达 20 MB 的空间。对于当今的硬件来说，你可能不会在意这么少兆字节的占用。但那只是它压缩后的尺寸。要展示它，<code>UIImageView</code> 首先需要把 JPEG 数据解码成位图（bitmap），如果要在一个 <code>UIImageView</code> 上按原样设置这张全尺寸图片，你的应用内存占用将会激增到<strong>几百兆</strong>，对用户明显没有什么好处（毕竟，屏幕能显示的像素有限）。但只要在设置 <code>UIImageView</code> 的 <code>image</code> 属性之前，将图像渲染的尺寸调整成 <code>UIImageView</code> 的大小，你用到的内存就会少一个数量级：</p><table><thead><tr><th></th><th>内存消耗 <em>(MB)</em></th></tr></thead><tbody><tr><td>无下采样</td><td>220.2</td></tr><tr><td>下采样</td><td>23.7</td></tr></tbody></table><p>这个技巧就是众所周知的<em>下采样（downsampling）</em>，在这些情况下，它可以有效地优化你应用的性能表现。如果你想了解更多关于下采样的知识或者其它图形图像的最佳实践，请参照 <a href="https://developer.apple.com/videos/play/wwdc2018/219/" target="_blank" rel="noopener">来自 WWDC 2018 的精彩课程</a>。</p><p>而现在，很少有应用程序会尝试一次性加载这么大的图像了，但是也跟我从设计师那里拿到的图片资源不会差<em>太</em>多。<em>（认真的吗？一张颜色渐变的</em> <em>PNG</em> <em>图片要</em> <em>3</em> <em>MB?）</em> 考虑到这一点，让我们来看看有什么不同的方法，可以让你用来对图像进行优化或者下采样。</p><blockquote><p>不用说，这里所有从 URL 加载的示例图像都是针对<strong>本地</strong>文件。记住，在应用的主线程同步使用网络请求图像<strong>绝不</strong>是什么好主意。</p></blockquote><hr><h2 id="图像渲染优化技巧"><a href="#图像渲染优化技巧" class="headerlink" title="图像渲染优化技巧"></a>图像渲染优化技巧</h2><p>优化图像渲染的方法有很多种，每种都有不同的功能和性能特性。我们在本文看到的这些例子，架构层次跨度上从底层的 Core Graphics、vImage、Image I/O 到上层的 Core Image 和 UIKit 都有。</p><ol><li><a href="#technique-1-drawing-to-a-uigraphicsimagerenderer">绘制到 UIGraphicsImageRenderer 上</a></li><li><a href="#technique-2-drawing-to-a-core-graphics-context">绘制到 Core Graphics Context 上</a></li><li><a href="#technique-3-creating-a-thumbnail-with-image-io">使用 Image I/O 创建缩略图像</a></li><li><a href="#technique-4-lanczos-resampling-with-core-image">使用 Core Image 进行 Lanczos 重采样</a></li><li><a href="#technique-5-image-scaling-with-vimage">使用 vImage 优化图片渲染</a></li></ol><p>为了统一调用方式，以下的每种技术共用一个公共接口方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resizedImage</span><span class="params">(at url: URL, <span class="keyword">for</span> size: CGSize)</span></span> -&gt; <span class="type">UIImage?</span> &#123; &lt;#...#&gt; &#125;</span><br><span class="line"></span><br><span class="line">imageView.image = resizedImage(at: url, <span class="keyword">for</span>: size)</span><br></pre></td></tr></table></figure><p>这里，<code>size</code> 的计量单位不是用 <code>pixel</code>，而是用 <code>point</code>。想要计算出你调整大小后图像的等效尺寸，用主 <code>UIScreen</code> 的 <code>scale</code>，等比例放大你 <code>UIImageView</code> 的 <code>size</code> 大小：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> scaleFactor = <span class="type">UIScreen</span>.main.scale</span><br><span class="line"><span class="keyword">let</span> scale = <span class="type">CGAffineTransform</span>(scaleX: scaleFactor, y: scaleFactor)</span><br><span class="line"><span class="keyword">let</span> size = imageView.bounds.size.applying(scale)</span><br></pre></td></tr></table></figure><blockquote><p>如果你是在异步加载一张大图，使用一个过渡动画让图像逐渐显示到 <code>UIImageView</code> 上。例如:</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"Blue Marble West"</span>,</span><br><span class="line">                                withExtension: <span class="string">"tiff"</span>)!</span><br><span class="line"></span><br><span class="line">        <span class="type">DispatchQueue</span>.global(qos: .userInitiated).async &#123;</span><br><span class="line">            <span class="keyword">let</span> image = resizedImage(at: url, <span class="keyword">for</span>: <span class="keyword">self</span>.imageView.bounds.size)</span><br><span class="line"></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line">                <span class="type">UIView</span>.transition(with: <span class="keyword">self</span>.imageView,</span><br><span class="line">                                duration: <span class="number">1.0</span>,</span><br><span class="line">                                options: [.curveEaseOut, .transitionCrossDissolve],</span><br><span class="line">                                animations: &#123;</span><br><span class="line">                                    <span class="keyword">self</span>.imageView.image = image</span><br><span class="line">                                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a name="technique-1-drawing-to-a-uigraphicsimagerenderer"></a></p><h3 id="技巧-1-绘制到-UIGraphicsImageRenderer-上"><a href="#技巧-1-绘制到-UIGraphicsImageRenderer-上" class="headerlink" title="技巧 #1: 绘制到 UIGraphicsImageRenderer 上"></a>技巧 #1: 绘制到 UIGraphicsImageRenderer 上</h3><p>图像渲染优化的最上层 API 位于 UIKit 框架中。给定一个 <code>UIImage</code>，你可以绘制到 <code>UIGraphicsImageRenderer</code> 的上下文（context）中以渲染缩小版本的图像：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">// 技巧 #1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resizedImage</span><span class="params">(at url: URL, <span class="keyword">for</span> size: CGSize)</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> image = <span class="type">UIImage</span>(contentsOfFile: url.path) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> renderer = <span class="type">UIGraphicsImageRenderer</span>(size: size)</span><br><span class="line">    <span class="keyword">return</span> renderer.image &#123; (context) <span class="keyword">in</span></span><br><span class="line">        image.draw(<span class="keyword">in</span>: <span class="type">CGRect</span>(origin: .zero, size: size))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/uikit/uigraphicsimagerenderer" target="_blank" rel="noopener"><code>UIGraphicsImageRenderer</code></a> 是一项相对较新的技术，在 iOS 10 中被引入，用以取代旧版本的 <code>UIGraphicsBeginImageContextWithOptions</code> / <code>UIGraphicsEndImageContext</code> API。你通过指定以 <code>point</code> 计量的 <code>size</code> 创建了一个 <code>UIGraphicsImageRenderer</code>。<code>image</code> 方法带有一个闭包参数，返回的是一个经过闭包处理后的位图。最终，原始图像便会在缩小到指定的范围内绘制。</p><blockquote><p>在不改变图像原始纵横比（aspect ratio）的情况下，缩小图像原始的尺寸来显示通常很有用。<a href="https://developer.apple.com/documentation/avfoundation/1390116-avmakerect" target="_blank" rel="noopener"><code>AVMakeRect(aspectRatio:insideRect:)</code></a> 是在 AVFoundation 框架中很方便的一个函数，负责帮你做如下的计算：</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> func AVFoundation.AVMakeRect</span><br><span class="line"><span class="keyword">let</span> rect = <span class="type">AVMakeRect</span>(aspectRatio: image.size, insideRect: imageView.bounds)</span><br></pre></td></tr></table></figure><p><a name="technique-2-drawing-to-a-core-graphics-context"></a></p><h3 id="技巧-2：绘制到-Core-Graphics-Context-中"><a href="#技巧-2：绘制到-Core-Graphics-Context-中" class="headerlink" title="技巧 #2：绘制到 Core Graphics Context 中"></a>技巧 #2：绘制到 Core Graphics Context 中</h3><p>Core Graphics / Quartz 2D 提供了一系列底层 API 让我们可以进行更多高级的配置。</p><p>给定一个 <code>CGImage</code> 作为暂时的位图上下文，使用 <code>draw(_:in:)</code> 方法来绘制缩放后的图像：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> CoreGraphics</span><br><span class="line"></span><br><span class="line"><span class="comment">// 技巧 #2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resizedImage</span><span class="params">(at url: URL, <span class="keyword">for</span> size: CGSize)</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> imageSource = <span class="type">CGImageSourceCreateWithURL</span>(url <span class="keyword">as</span> <span class="type">NSURL</span>, <span class="literal">nil</span>),</span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">CGContext</span>(data: <span class="literal">nil</span>,</span><br><span class="line">                            width: <span class="type">Int</span>(size.width),</span><br><span class="line">                            height: <span class="type">Int</span>(size.height),</span><br><span class="line">                            bitsPerComponent: image.bitsPerComponent,</span><br><span class="line">                            bytesPerRow: image.bytesPerRow,</span><br><span class="line">                            space: image.colorSpace ?? <span class="type">CGColorSpace</span>(name: <span class="type">CGColorSpace</span>.sRGB)!,</span><br><span class="line">                            bitmapInfo: image.bitmapInfo.rawValue)</span><br><span class="line">    context?.interpolationQuality = .high</span><br><span class="line">    context?.draw(image, <span class="keyword">in</span>: <span class="type">CGRect</span>(origin: .zero, size: size))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> scaledImage = context?.makeImage() <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: scaledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>CGContext</code> 初始化方法接收了几个参数来构造一个上下文，包括了必要的宽高参数，还有在给出的色域范围内每个颜色通道所需要的内存大小。在这个例子中，这些参数都是通过 <code>CGImage</code> 这个对象获取的。下一步，设置 <code>interpolationQuality</code> 属性为 <code>.high</code> 指示上下文在保证一定的精度上填充像素。<code>draw(_:in:)</code> 方法则是在给定的宽高和位置绘制图像，可以让图片在特定的边距下裁剪，也可以适用于一些像是人脸识别之类的图像特性。最后 <code>makeImage()</code> 从上下文获取信息并且渲染到一个 <code>CGImage</code> 值上（之后会用来构造 <code>UIImage</code> 对象）。</p><p><a name="technique-3-creating-a-thumbnail-with-image-io"></a></p><h3 id="技巧-3：使用-Image-I-O-创建缩略图像"><a href="#技巧-3：使用-Image-I-O-创建缩略图像" class="headerlink" title="技巧 #3：使用 Image I/O 创建缩略图像"></a>技巧 #3：使用 Image I/O 创建缩略图像</h3><p>Image I/O 是一个强大（却鲜有人知）的图像处理框架。抛开 Core Graphics 不说，它可以读写许多不同图像格式，访问图像的元数据，还有执行常规的图像处理操作。这个框架通过先进的缓存机制，提供了平台上最快的图片编码器和解码器，甚至可以增量加载图片。</p><p>这个重要的 <code>CGImageSourceCreateThumbnailAtIndex</code> 提供了一个带有许多不同配置选项的 API，比起在 Core Graphics 中等价的处理操作要简洁得多：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ImageIO</span><br><span class="line"></span><br><span class="line"><span class="comment">// 技巧 #3</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resizedImage</span><span class="params">(at url: URL, <span class="keyword">for</span> size: CGSize)</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> options: [<span class="type">CFString</span>: <span class="type">Any</span>] = [</span><br><span class="line">        kCGImageSourceCreateThumbnailFromImageIfAbsent: <span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceCreateThumbnailWithTransform: <span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceShouldCacheImmediately: <span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceThumbnailMaxPixelSize: <span class="built_in">max</span>(size.width, size.height)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> imageSource = <span class="type">CGImageSourceCreateWithURL</span>(url <span class="keyword">as</span> <span class="type">NSURL</span>, <span class="literal">nil</span>),</span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, options <span class="keyword">as</span> <span class="type">CFDictionary</span>)</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定一个 <code>CGImageSource</code> 和一系列配置选项，<code>CGImageSourceCreateThumbnailAtIndex(_:_:_:)</code> 函数创建了一个图像的缩略图。优化尺寸大小的操作是通过 <code>kCGImageSourceThumbnailMaxPixelSize</code> 完成的，它根据图像原始宽高比指定的最大尺寸来缩放图像。通过设定 <code>kCGImageSourceCreateThumbnailFromImageIfAbsent</code> 或 <code>kCGImageSourceCreateThumbnailFromImageAlways</code> 选项，Image I/O 可以自动缓存优化后的结果以便后续调用。</p><p><a name="technique-4-lanczos-resampling-with-core-image"></a></p><h3 id="技巧-4：使用-Core-Image-进行-Lanczos-重采样"><a href="#技巧-4：使用-Core-Image-进行-Lanczos-重采样" class="headerlink" title="技巧 #4：使用 Core Image 进行 Lanczos 重采样"></a>技巧 #4：使用 Core Image 进行 Lanczos 重采样</h3><p>Core Image 内置了 <a href="https://en.wikipedia.org/wiki/Lanczos_resampling" target="_blank" rel="noopener">Lanczos 重采样（resampling）</a> 功能，它是以 <code>CILanczosScaleTransform</code> 的同名滤镜命名的。虽然可以说它是在 UIKit 层级之上的 API，但无处不在的 key-value 编写方式导致它使用起来很不方便。</p><p>即便如此，它的处理模式还是一致的。</p><p>创建转换滤镜，对滤镜进行配置，最后渲染输出图像，这样的步骤和其他任何 Core Image 的工作流没什么不同。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> CoreImage</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sharedContext = <span class="type">CIContext</span>(options: [.useSoftwareRenderer : <span class="literal">false</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 技巧 #4</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resizedImage</span><span class="params">(at url: URL, scale: CGFloat, aspectRatio: CGFloat)</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> image = <span class="type">CIImage</span>(contentsOf: url) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">filter</span> = <span class="type">CIFilter</span>(name: <span class="string">"CILanczosScaleTransform"</span>)</span><br><span class="line">    <span class="built_in">filter</span>?.setValue(image, forKey: kCIInputImageKey)</span><br><span class="line">    <span class="built_in">filter</span>?.setValue(scale, forKey: kCIInputScaleKey)</span><br><span class="line">    <span class="built_in">filter</span>?.setValue(aspectRatio, forKey: kCIInputAspectRatioKey)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> outputCIImage = <span class="built_in">filter</span>?.outputImage,</span><br><span class="line">        <span class="keyword">let</span> outputCGImage = sharedContext.createCGImage(outputCIImage,</span><br><span class="line">                                                        from: outputCIImage.extent)</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: outputCGImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个名叫 <code>CILanczosScaleTransform</code> 的 Core Image 滤镜分别接收了 <code>inputImage</code>、<code>inputScale</code> 和 <code>inputAspectRatio</code> 三个参数，每一个参数的意思也都不言自明。</p><p>更有趣的是，<code>CIContext</code> 在这里被用来创建一个 <code>UIImage</code>（间接通过 <code>CGImageRef</code> 表示），因为 <code>UIImage(CIImage:)</code> 经常不能按我们本意使用。创建 <code>CIContext</code> 是一个代价很昂贵的操作，所以使用上下文缓存以便重复的渲染工作。</p><blockquote><p>一个 <code>CIContext</code> 可以使用 GPU 或者 CPU（慢很多）渲染创建出来。通过指定构造方法中的 <code>.useSoftwareRenderer</code> 选项来选择使用哪个硬件。<em>（提示：用更快的那个，你觉得呢？）</em></p></blockquote><p><a name="technique-5-image-scaling-with-vimage"></a></p><h3 id="技巧-5-使用-vImage-优化图片渲染"><a href="#技巧-5-使用-vImage-优化图片渲染" class="headerlink" title="技巧 #5: 使用 vImage 优化图片渲染"></a>技巧 #5: 使用 vImage 优化图片渲染</h3><p>最后一个了，它是古老的 <a href="https://developer.apple.com/documentation/accelerate" target="_blank" rel="noopener">Accelerate 框架</a> —— 更具体点来说，它是 <code>vImage</code> 的图像处理子框架。</p><p>vImage 附带有 <a href="https://developer.apple.com/documentation/accelerate/vimage/vimage_operations/image_scaling" target="_blank" rel="noopener">一些不同的功能</a>，可以用来裁剪图像缓冲区大小。这些底层 API 保证了高性能同时低能耗，但会导致你对缓冲区的管理操作增加（更不用说要编写更多的代码了）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> Accelerate.vImage</span><br><span class="line"></span><br><span class="line"><span class="comment">// 技巧 #5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resizedImage</span><span class="params">(at url: URL, <span class="keyword">for</span> size: CGSize)</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">    <span class="comment">// 解码源图像</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> imageSource = <span class="type">CGImageSourceCreateWithURL</span>(url <span class="keyword">as</span> <span class="type">NSURL</span>, <span class="literal">nil</span>),</span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">nil</span>),</span><br><span class="line">        <span class="keyword">let</span> properties = <span class="type">CGImageSourceCopyPropertiesAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">nil</span>) <span class="keyword">as</span>? [<span class="type">CFString</span>: <span class="type">Any</span>],</span><br><span class="line">        <span class="keyword">let</span> imageWidth = properties[kCGImagePropertyPixelWidth] <span class="keyword">as</span>? vImagePixelCount,</span><br><span class="line">        <span class="keyword">let</span> imageHeight = properties[kCGImagePropertyPixelHeight] <span class="keyword">as</span>? vImagePixelCount</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义图像格式</span></span><br><span class="line">    <span class="keyword">var</span> format = vImage_CGImageFormat(bitsPerComponent: <span class="number">8</span>,</span><br><span class="line">                                      bitsPerPixel: <span class="number">32</span>,</span><br><span class="line">                                      colorSpace: <span class="literal">nil</span>,</span><br><span class="line">                                      bitmapInfo: <span class="type">CGBitmapInfo</span>(rawValue: <span class="type">CGImageAlphaInfo</span>.first.rawValue),</span><br><span class="line">                                      version: <span class="number">0</span>,</span><br><span class="line">                                      decode: <span class="literal">nil</span>,</span><br><span class="line">                                      renderingIntent: .defaultIntent)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> error: vImage_Error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化源缓冲区</span></span><br><span class="line">    <span class="keyword">var</span> sourceBuffer = vImage_Buffer()</span><br><span class="line">    <span class="keyword">defer</span> &#123; sourceBuffer.data.deallocate() &#125;</span><br><span class="line">    error = vImageBuffer_InitWithCGImage(&amp;sourceBuffer,</span><br><span class="line">                                         &amp;format,</span><br><span class="line">                                         <span class="literal">nil</span>,</span><br><span class="line">                                         image,</span><br><span class="line">                                         vImage_Flags(kvImageNoFlags))</span><br><span class="line">    <span class="keyword">guard</span> error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化目标缓冲区</span></span><br><span class="line">    <span class="keyword">var</span> destinationBuffer = vImage_Buffer()</span><br><span class="line">    error = vImageBuffer_Init(&amp;destinationBuffer,</span><br><span class="line">                              vImagePixelCount(size.height),</span><br><span class="line">                              vImagePixelCount(size.width),</span><br><span class="line">                              format.bitsPerPixel,</span><br><span class="line">                              vImage_Flags(kvImageNoFlags))</span><br><span class="line">    <span class="keyword">guard</span> error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化缩放图像</span></span><br><span class="line">    error = vImageScale_ARGB8888(&amp;sourceBuffer,</span><br><span class="line">                                 &amp;destinationBuffer,</span><br><span class="line">                                 <span class="literal">nil</span>,</span><br><span class="line">                                 vImage_Flags(kvImageHighQualityResampling))</span><br><span class="line">    <span class="keyword">guard</span> error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从目标缓冲区创建一个 CGImage 对象</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> resizedImage =</span><br><span class="line">        vImageCreateCGImageFromBuffer(&amp;destinationBuffer,</span><br><span class="line">                                      &amp;format,</span><br><span class="line">                                      <span class="literal">nil</span>,</span><br><span class="line">                                      <span class="literal">nil</span>,</span><br><span class="line">                                      vImage_Flags(kvImageNoAllocate),</span><br><span class="line">                                      &amp;error)?.takeRetainedValue(),</span><br><span class="line">        error == kvImageNoError</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: resizedImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 Accelerate API 进行的明确操作，比起目前为止讨论到的其他优化方法更加底层。但暂时不管这些不友好的类型申明和函数名称的话，你会发现这个方法相当直接了当。</p><ul><li>首先，根据你传入的图像创建一个输入的源缓冲区，</li><li>接着，创建一个输出的目标缓冲区来接受优化后的图像，</li><li>然后，在源缓冲区裁剪图像数据，然后传给目标缓冲区，</li><li>最后，从目标缓冲区中根据处理完后的图像创建 <code>UIImage</code> 对象。</li></ul><hr><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>那么这些不同的方法是如何相互对比的呢？</p><p><a href="https://github.com/NSHipster/Image-Resizing-Example" target="_blank" rel="noopener">这个项目</a> 是一些 <a href="https://nshipster.com/benchmarking/" target="_blank" rel="noopener">性能对比</a> 结果，运行环境是 iPhone 7 iOS 12.2。</p><p><img src="https://nshipster.com/assets/image-resizing-app-screenshot-02998a420a75691f6b5c8de44ba24d6119853776bd78bb9e1bfa3a36cdd7d48d.png" alt="image-resizing-app-screenshot"></p><p>下面的这些数字是多次迭代加载、优化、渲染之前那张 <a href="https://visibleearth.nasa.gov/view.php?id=78314" target="_blank" rel="noopener">超大地球图片</a> 的平均时间：</p><table><thead><tr><th></th><th>耗时 <em>(seconds)</em></th></tr></thead><tbody><tr><td>技巧 #1: <code>UIKit</code></td><td>0.1420</td></tr><tr><td>技巧 #2: <code>Core Graphics</code> <sup>1</sup></td><td>0.1722</td></tr><tr><td>技巧 #3: <code>Image I/O</code></td><td>0.1616</td></tr><tr><td>技巧 #4: <code>Core Image</code> <sup>2</sup></td><td>2.4983</td></tr><tr><td>技巧 #5: <code>vImage</code></td><td>2.3126</td></tr></tbody></table><p><sup>1</sup> &nbsp;<br>设置不同的 <code>CGInterpolationQuality</code> 值出来的结果是一致的，在性能上的差异可以忽略不计。</p><p><sup>2</sup> &nbsp;<br>若在 <code>CIContext</code> 创建时设置 <code>kCIContextUseSoftwareRenderer</code> 的值为 <code>true</code>，会导致耗时相比基础结果慢一个数量级。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>UIKit</strong>, <strong>Core</strong> <strong>Graphics</strong>, 和 <strong>Image</strong> <strong>I/O</strong> 都能很好地用于大部分图片的优化操作。如果（在 iOS 平台，至少）要选择一个的话，<code>UIGraphicsImageRenderer</code> 是你最佳的选择。</li><li><strong>Core</strong> <strong>Image</strong> 在图像优化渲染操作方面性能表现优越。实际上，根据 Apple 官方 <a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/Conceptual/CoreImaging/ci_performance/ci_performance.html#//apple_ref/doc/uid/TP30001185-CH10-SW1" target="_blank" rel="noopener"><em>Core</em> <em>Image</em> <em>编程规范中的性能最佳实践单元</em></a>，你应该使用 Core Graphics 或 Image I/O 对图像进行裁剪和下采样，而不是用 Core Image。</li><li>除非你已经在使用 <strong><code>vImage</code></strong>，否则在大多数情况下用到底层的 Accelerate API 所需的额外工作可能是不合理的。</li></ul><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      长期以来，iOS 开发人员就为一个奇怪的问题所困扰：‘如何对一张图像进行渲染优化？’本文试图为这个由来已久的问题提供一个明确的答案。
    
    </summary>
    
      <category term="Miscellaneous" scheme="https://swift.gg/categories/Miscellaneous/"/>
    
    
      <category term="图像" scheme="https://swift.gg/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>每一点进步都是快乐：无处不在的扩展</title>
    <link href="https://swift.gg/2019/10/29/extensions-everywhere/"/>
    <id>https://swift.gg/2019/10/29/extensions-everywhere/</id>
    <published>2019-10-28T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Russ Bishop，<a href="http://www.russbishop.net/take-delight-in-small-joys" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-11-08<br>译者：俊东；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>这篇文章记录了我所收获的小惊喜。在 Swift 中写扩展让人感觉非常自然。</p><p>我认为 <code>UnsafeMutableRawBufferPointer.baseAddress</code> 是可选项这回事非常不合理。在实践中它会使代码变得丑陋。我也不喜欢在分配时指定对齐方式；在大多数平台上，合理的默认值都是 <code>Int.bitWidth / 8</code>。</p><p>通过扩展，我们可以很容易地解决这些问题。这样的解决方案能像标准库一样自然地使用。<br><a id="more"></a></p><p>首先，我们需要在调试版本中进行简单的健全性检查，以确保不会产生无意义的对齐计算。这里提一个有关正整数的小技巧：一个 2 的 n 次幂数只有一个比特位是有值的。减去 1 时就是把后面的所有比特位设置为 1，如 8（<code>0b1000</code>）- 1 得到 7（<code>0b0111</code>）。这两个数字没有共同的位，因此按位取与应该产生零。由于这规律在零上无效，所以需要单独检查。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BinaryInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isPositivePowerOf2: <span class="type">Bool</span> &#123;</span><br><span class="line">        @inline(__always)</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">self</span> &amp; (<span class="keyword">self</span> - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; <span class="keyword">self</span> != <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让 allocate 方法默认使用自然整数宽度对齐。设置对齐参数可能有点多余，不过它几乎能处理我们想要存储在缓冲区中的任何数据。虽然断言仅在调试环境中有效，但这已经够应付我们的使用；已知 Swift 支持的平台上这个断言都会是 true。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UnsafeMutableRawBufferPointer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">allocate</span><span class="params">(byteCount: Int)</span></span> -&gt; <span class="type">UnsafeMutableRawBufferPointer</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> alignment = <span class="type">Int</span>.bitWidth / <span class="number">8</span></span><br><span class="line">        <span class="built_in">assert</span>(alignment.isPositivePowerOf2, <span class="string">"expected power of two"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allocate(byteCount: byteCount, alignment: alignment)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再提一个点，我们可以添加一个隐式强制解包的 <code>base</code> 属性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UnsafeMutableRawBufferPointer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base: <span class="type">UnsafeMutableRawPointer</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseAddress!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UnsafeRawBufferPointer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base: <span class="type">UnsafeRawPointer</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseAddress!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切如此简单。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Swift 扩展的应用
    
    </summary>
    
      <category term="Russ Bishop" scheme="https://swift.gg/categories/Russ-Bishop/"/>
    
    
      <category term="iOS" scheme="https://swift.gg/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Xcode Build 配置文件</title>
    <link href="https://swift.gg/2019/10/25/nshipster-xcconfig/"/>
    <id>https://swift.gg/2019/10/25/nshipster-xcconfig/</id>
    <published>2019-10-24T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/xcconfig/" target="_blank" rel="noopener">原文链接</a>，原文日期：2019-05-13<br>译者：<a href="https://github.com/mobilefellow" target="_blank" rel="noopener">雨谨</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>软件开发最佳实践 <a href="https://12factor.net/config" target="_blank" rel="noopener">规定了</a> 配置与代码的严格分离。然而，苹果平台上的开发人员常常难以将这些指导原则与 Xcode 繁重的项目工作流程结合起来。</p><p>了解每个项目设置的功能以及它们之间如何交互，是一项需要多年磨练的技能。但 Xcode 将大部分的这类信息都都深埋在其图形化界面中，这对我们没有任何好处。<br><a id="more"></a><br>导航到项目编辑器的 “Build Settings” tab，你会看到分布在 project、target 和 configuration 上的 <em>数百条</em> Build Setting（构建配置） —— <em>更别说其他六个 tab 了!</em></p><p><img src="https://nshipster.com/assets/xcconfig-project-build-settings--light-f7043782f0b56d637bec89eefa0d37939b38ef33f55c293e326d3fecbc06df49.png" alt></p><p>幸运的是，有一个更好的办法，不必点击迷宫般的 tab 和箭头，就可以管理所有的配置。</p><p>这一周，我们将向你展示如何在 Xcode 之外，通过修改基于文本的 <code>xcconfig</code> 文件，让你的项目更加紧凑、易懂、强大。</p><hr><p><a href="https://help.apple.com/xcode/mac/8.3/#/dev745c5c974" target="_blank" rel="noopener">Xcode Build 配置文件</a>，即大家所熟知的 <code>xcconfig</code> 文件，允许我们在不使用 Xcode 的情况下声明和管理 APP 的 Build Setting。它们是纯文本，这意味着它们对代码管理系统更加友好，而且可以被任意编辑器修改。</p><p>从根本上说，每个配置文件都由一系列键值对组成，其语法如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#BUILD_SETTING_NAME#&gt; = &lt;#value#&gt;</span><br></pre></td></tr></table></figure><p>例如，你可以使用下面这样的 <code>SWIFT_VERSION</code> Build Setting，指定项目的 Swift 语言版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SWIFT_VERSION = 5.0</span><br></pre></td></tr></table></figure><blockquote><p>根据 <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08" target="_blank" rel="noopener"><abbr title="Portable Operating System Interface">POSIX</abbr> 标准</a>，环境变量的名字由全大写字母、数字和下划线（<code>_</code>）组成 —— 经典例子就是 <code>SCREAMING_SNAKE_CASE</code> 🐍🗯。</p></blockquote><hr><p>乍一看，<code>xcconfig</code> 文件与 <code>.env</code> 文件有惊人的相似之处，它们的语法都很简单，都以换行分隔。但是，Xcode Build 配置文件的内容比表面上看到的要多。<em>看哪!</em></p><h3 id="保留现有值"><a href="#保留现有值" class="headerlink" title="保留现有值"></a>保留现有值</h3><p>要追加新内容，而不是替换现有定义时，可以像这样使用 <code>$(inherited)</code> 变量:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#BUILD_SETTING_NAME#&gt; = $(inherited)&lt;#additional value#&gt;</span><br></pre></td></tr></table></figure><p>这么做通常是为了搭建一些值的列表，比如编译器的 framework 头文件的搜索路径(<code>FRAMEWORK_SEARCH_PATHS</code>):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FRAMEWORK_SEARCH_PATHS = $(inherited) $(PROJECT_DIR)</span><br></pre></td></tr></table></figure><p>Xcode 按下面的顺序对 <code>inherited</code> 进行赋值（优先级从低到高）：</p><ul><li>平台默认值（Platform Defaults）</li><li>Xcode 项目文件的 Build Setting（Xcode Project File Build Settings）</li><li>Xcode 项目的 xcconfig 文件（xcconfig File for the Xcode Project）</li><li>Active Target 的 Build Setting（Active Target Build Settings）</li><li>Active Target 的 xcconfig 文件（xcconfig File for the Active Target）</li></ul><blockquote><p>空格用于分隔字符串和路径列表中的项。指定包含空格的项时，必须用引号(<code>&quot;</code>)括起来。</p></blockquote><h3 id="引用其他值"><a href="#引用其他值" class="headerlink" title="引用其他值"></a>引用其他值</h3><p>你可以按照下面的语法，通过其他设置的名字引用它们的值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#BUILD_SETTING_NAME#&gt; = $(&lt;#ANOTHER_BUILD_SETTING_NAME#&gt;)</span><br></pre></td></tr></table></figure><p>这种引用既可以用于根据现有值定义新变量，也可以用于以内联方式动态构建新值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OBJROOT = $(SYMROOT)</span><br><span class="line">CONFIGURATION_BUILD_DIR = $(BUILD_DIR)/$(CONFIGURATION)-$(PLATFORM_NAME)</span><br></pre></td></tr></table></figure><h3 id="条件约束"><a href="#条件约束" class="headerlink" title="条件约束"></a>条件约束</h3><p>使用以下语法，你可以按 SDK（<code>sdk</code>）、架构（<code>arch</code>）和 / 或配置（<code>config</code>）对 Build Setting 进行条件约束：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#BUILD_SETTING_NAME#&gt;[sdk=&lt;#sdk#&gt;] = &lt;#value for specified sdk#&gt;</span><br><span class="line">&lt;#BUILD_SETTING_NAME#&gt;[arch=&lt;#architecture#&gt;] = &lt;#value for specified architecture#&gt;</span><br><span class="line">&lt;#BUILD_SETTING_NAME#&gt;[config=&lt;#configuration#&gt;] = &lt;#value for specified configuration#&gt;</span><br></pre></td></tr></table></figure><p>如果需要在同一 Build Setting 的多个定义之间进行选择，编译器将根据条件约束进行解析。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;#BUILD_SETTING_NAME#&gt;[sdk=&lt;#sdk#&gt;][arch=&lt;#architecture#&gt;] = &lt;#value for specified sdk and architectures#&gt;</span><br><span class="line">&lt;#BUILD_SETTING_NAME#&gt;[sdk=*][arch=&lt;#architecture#&gt;] = &lt;#value for all other sdks with specified architecture#&gt;</span><br></pre></td></tr></table></figure><p>例如，你可以使用下面这条 Build Setting 指定仅编译 active architecture，从而提升本地 Build 的速度。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ONLY_ACTIVE_ARCH[config=Debug][sdk=*][arch=*] = YES</span><br></pre></td></tr></table></figure><h3 id="引用其他配置文件中的设置"><a href="#引用其他配置文件中的设置" class="headerlink" title="引用其他配置文件中的设置"></a>引用其他配置文件中的设置</h3><p>跟 <code>C</code> 语言的 <code>#include</code> 指令一样，Build 配置文件也可以使用这种语法来引用其他配置文件中的设置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;&lt;#path/to/File.xcconfig#&gt;&quot;</span><br></pre></td></tr></table></figure><p>正如我们将在本文后面看到的，你可以利用这一点，以非常强大的方式搭建起 Build Setting 的级联列表。</p><blockquote><p>正常来说，当遇到一个无法解析的 <code>#include</code> 指令时，编译器会报错。但是 <code>xcconfig</code> 文件同时也支持 <code>#include?</code> 指令，在该指令下，若文件无法找到，编译器不会报错。</p></blockquote><blockquote><p>根据文件是否存在而改变编译时行为的情况并不多；毕竟，Build 最好是可预见的。但是你可以把它用在可选的开发工具上，比如 <a href="https://revealapp.com/" target="_blank" rel="noopener">Reveal</a> 需要以下的配置：</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; # Reveal.xcconfig</span><br><span class="line">&gt; OTHER_LDFLAGS = $(inherited) -weak_framework RevealServer</span><br><span class="line">&gt; FRAMEWORK_SEARCH_PATHS = $(inherited) /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="创建-Build-配置文件"><a href="#创建-Build-配置文件" class="headerlink" title="创建 Build 配置文件"></a>创建 Build 配置文件</h2><p>要创建 Build 配置文件，请选择 “File &gt; New File…” 菜单项（<kbd>⌘</kbd><kbd>N</kbd>），下拉到 “Other” 部分，选中 Configuration Settings File 模板。将它保存到你的项目目录，并确保它在你期望的 target 上。</p><p><img src="https://nshipster.com/assets/xcconfig-new-file--light-1569134f8ecaeaee6640f28e544443da0136ff72b00f9343126147934ac134d4.png" alt></p><p>创建好 <code>xcconfig</code> 文件后，你就可以将它分配给对应 target 的一个或多个 Build 配置。</p><p><img src="https://nshipster.com/assets/xcconfig-project-configurations--light-a82440e27f27e3b139ab51c7317780c6b4a017dfcc56532972da5d521f1f0988.png" alt></p><hr><p>现在我们已经介绍了 Xcode Build 配置文件使用的基础知识，那么让我们来看几个示例，看看如何使用它们来管理 development、stage 和 production 环境。</p><hr><h2 id="为内部版本提供自定义的-APP-名称和图标"><a href="#为内部版本提供自定义的-APP-名称和图标" class="headerlink" title="为内部版本提供自定义的 APP 名称和图标"></a>为内部版本提供自定义的 APP 名称和图标</h2><p>开发 iOS 应用程序时，通常需要在模拟器和测试设备上安装各种内部版本（同时也会安装应用程序商店的最新版本，以供参考）。</p><p>使用 <code>xcconfig</code> 文件，你可以轻松地为每个配置分配一个不同的名称和 APP 图标。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Development.xcconfig</span><br><span class="line">PRODUCT_NAME = $(inherited) α</span><br><span class="line">ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon-Alpha</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// Staging.xcconfig</span><br><span class="line">PRODUCT_NAME = $(inherited) β</span><br><span class="line">ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon-Beta</span><br></pre></td></tr></table></figure><h2 id="管理不同环境下的常量"><a href="#管理不同环境下的常量" class="headerlink" title="管理不同环境下的常量"></a>管理不同环境下的常量</h2><p>如果你的后端开发人员也遵循前面提到的 <a href="https://12factor.net/config" target="_blank" rel="noopener">12 Factor App</a> 理论，那么他们将为 development、stage 和 production 环境提供单独的接口。</p><p>iOS 上最常见的环境管理方式可能就是使用条件编译语句 + <code>DEBUG</code> 这样的 Build Setting 了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line"><span class="keyword">let</span> apiBaseURL = <span class="type">URL</span>(string: <span class="string">"https://api.example.dev"</span>)!</span><br><span class="line"><span class="keyword">let</span> apiKey = <span class="string">"9e053b0285394378cf3259ed86cd7504"</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="keyword">let</span> apiBaseURL = <span class="type">URL</span>(string: <span class="string">"https://api.example.com"</span>)!</span><br><span class="line"><span class="keyword">let</span> apiKey = <span class="string">"4571047960318d233d64028363dfa771"</span></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>这只是完成了任务，但是与代码 / 配置分离的标准相冲突。</p><p>另一个方案是将这些与环境相关的值放到它们该待的地方 —— <code>xcconfig</code> 文件中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Development.xcconfig</span><br><span class="line">API_BASE_URL = api.example.dev</span><br><span class="line">API_KEY = 9e053b0285394378cf3259ed86cd7504</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// Production.xcconfig</span><br><span class="line">API_BASE_URL = api.example.com</span><br><span class="line">API_KEY = 4571047960318d233d64028363dfa771</span><br></pre></td></tr></table></figure><blockquote><p>不幸的是，<code>xcconfig</code> 将所有 <code>//</code> 都当成注释分隔符，不管它们是否包括在引号中。如果你用反斜线 <code>\/\/</code> 进行转义，那么这些反斜线也将被直接展示出现，使用时必须从结果中移除。在指定每个环境的 URL 常量时，这尤其不方便。</p></blockquote><blockquote><p>如果不想处理这种麻烦的事情，你可以在 <code>xcconfig</code> 中忽略 scheme，然后在代码中添加 <code>https://</code>。<em>（你是在使用 https……对吧？）</em></p></blockquote><p>然而，要以编程方式获取这些值，我们还需要一个额外的步骤:</p><h3 id="在-Swift-中访问-Build-Setting"><a href="#在-Swift-中访问-Build-Setting" class="headerlink" title="在 Swift 中访问 Build Setting"></a>在 Swift 中访问 Build Setting</h3><p>由 Xcode 项目文件、<code>xcconfig</code> 文件和环境变量定义的 Build Setting 只在 Build 时可用。当你运行一个已经编译的 APP 时，所有相关的上下文都是不可见的。<em>（谢天谢地！）</em></p><p>但是等一下——你不记得之前在其他 tab 中看到过一些 Build Setting 吗？Info，是吗？</p><p>实际上，Info tab 只是 target 的 <code>Info.plist</code> 文件的一个马甲。Build 时，这个 <code>Info.plist</code> 文件会根据 Build Setting 的配置进行编译，然后复制到最终 APP 的 <a href="https://nshipster.com/bundles-and-packages/" target="_blank" rel="noopener">bundle</a> 中。因此，添加 <code>$(API_BASE_URL)</code> 和 <code>$(API_KEY)</code> 的引用后，你可以通过 Foundation <code>Bundle</code> API 的 <code>infoDictionary</code> 属性访问这些值。完美！</p><p><img src="https://nshipster.com/assets/xcconfig-project-info-plist--light-5561d8abf4dca9722875ff1f62b5975c3361f5ea3dfd584b655f3da7d3ceb94b.png" alt></p><p>按照这种方法，我们可以做如下工作：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">value</span>&lt;T&gt;<span class="params">(<span class="keyword">for</span> key: String)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> value = <span class="type">Bundle</span>.main.infoDictionary?[key] <span class="keyword">as</span>? <span class="type">T</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Invalid or missing Info.plist key: \(key)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">API</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> baseURL: <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"https://"</span> + <span class="type">Configuration</span>.value(<span class="keyword">for</span>: <span class="string">"API_BASE_URL"</span>))!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> key: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Configuration</span>.value(<span class="keyword">for</span>: <span class="string">"API_KEY"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从调用的角度考虑，我们发现这种方法与我们的最佳实践完美地在结合一起 —— 没有出现一个硬编码的常量!</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: path, relativeTo: <span class="type">API</span>.baseURL)!</span><br><span class="line"><span class="keyword">var</span> request = <span class="type">URLRequest</span>(url: url)</span><br><span class="line">request.httpMethod = method</span><br><span class="line">request.addValue(<span class="type">API</span>.key, forHTTPHeaderField: <span class="string">"X-API-KEY"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>不要把私密的东西写在代码中。相反，应该将它们安全地存储在密码管理器或类似的东西中。</p></blockquote><blockquote><p>为了防止你的私密被泄漏到 GitHub 上，请将下列配置添加到你的 <code>.gitignore</code> 文件中（根据需要）：</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; # .gitignore</span><br><span class="line">&gt; Development.xcconfig</span><br><span class="line">&gt; Staging.xcconfig</span><br><span class="line">&gt; Production.xcconfig</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>一些开发人员喜欢使用包含了所需 key 的占位符文件（例如 Development.sample.xcconfig）代替这些文件。拉取代码时，开发人员再将该文件复制到非占位符位置，并相应地填充它。</p></blockquote><hr><hr><p>Xcode 项目是庞大、脆弱的和不透明的。它们是团队成员合作时摩擦的来源，也常常是工作的累赘。</p><p>幸运的是，<code>xcconfig</code> 文件很好地解决了这些痛点。将配置从 Xcode 移到 <code>xcconfig</code> 文件带来了很多好处，可以让你的项目与 Xcode 的细节保持一定距离，不受苹果公司的掣肘。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mattt，&lt;a href=&quot;https://nshipster.com/xcconfig/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2019-05-13&lt;br&gt;译者：&lt;a href=&quot;https://github.com/mobilefellow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;雨谨&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/WAMaker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WAMaker&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/Pancf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pancf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;软件开发最佳实践 &lt;a href=&quot;https://12factor.net/config&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;规定了&lt;/a&gt; 配置与代码的严格分离。然而，苹果平台上的开发人员常常难以将这些指导原则与 Xcode 繁重的项目工作流程结合起来。&lt;/p&gt;
&lt;p&gt;了解每个项目设置的功能以及它们之间如何交互，是一项需要多年磨练的技能。但 Xcode 将大部分的这类信息都都深埋在其图形化界面中，这对我们没有任何好处。&lt;br&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5 字符串插值-AttributedStrings</title>
    <link href="https://swift.gg/2019/10/18/swift5-stringinterpolation-part2/"/>
    <id>https://swift.gg/2019/10/18/swift5-stringinterpolation-part2/</id>
    <published>2019-10-17T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/2018/12/16/swift5-stringinterpolation-part2" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-12-16<br>译者：<a href="https://nemocdz.github.io/" target="_blank" rel="noopener">Nemocdz</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><hr> <!--此处开始正文--><p>我们已经在 <a href="https://swift.gg/2019/04/22/swift5-stringinterpolation-part1/">前文</a> 里介绍了 Swift 5 全新的 StringInterpolation 设计。在这第二部分中，我会着眼于 <code>ExpressibleByStringInterpolation</code> 其中一种应用，让 <code>NSAttributedString</code> 变得更优雅。</p> <a id="more"></a><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在看到 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0228-fix-expressiblebystringinterpolation.md" target="_blank" rel="noopener">Swift 5 这个全新的 StringInterpolation 设计</a> 时，我马上想到的应用之一就是简化 <code>NSAttributedString</code> 的生成。</p><p>我的目标是做到用类似下面的语法创建一个 attributed 字符串：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">"AliGator"</span></span><br><span class="line"><span class="keyword">let</span> str: <span class="type">AttrString</span> = <span class="string">"""</span></span><br><span class="line"><span class="string">  Hello \(username, .color(.red)), isn't this \("cool", .color(.blue), .oblique, .underline(.purple, .single))?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  \(wrap: """</span></span><br><span class="line">    \(<span class="string">" Merry Xmas! "</span>, .font(.systemFont(ofSize: <span class="number">36</span>)), .color(.red), .bgColor(.yellow))</span><br><span class="line">    \(image: #imageLiteral(resourceName: <span class="string">"santa.jpg"</span>), scale: <span class="number">0.2</span>)</span><br><span class="line">    <span class="string">""", .alignment(.center))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Go there to \("learn more about String Interpolation", .link("https://github.com/apple/swift-evolution/blob/master/proposals/0228-fix-expressiblebystringinterpolation.md"), .underline(.blue, .single))!</span></span><br><span class="line"><span class="string">  """</span></span><br></pre></td></tr></table></figure><p>这一大串字符串不仅使用了多行字符串的字面量语法（<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0168-multi-line-string-literals.md" target="_blank" rel="noopener">顺带一提，这个特性是在 Swift4 中新增的，以免你错过了</a>） ——而且在其中一个多行字符串字面量中包含了另一个(见 <code>\(wrap: ...)</code> 段落）！- 甚至还包含了给一部分字符添加一些样式的插值……所以由大量 Swift 新特性组合而成！</p><p>这个 <code>NSAttributedString</code> 如果在一个 <code>UILabel</code> 或者 <code>NSTextView</code> 中渲染，结果是这个样子的：</p><p><img src="http://alisoftware.github.io/assets/StringInterpolation-AttrString.png" alt="image"></p><p>☝️ 是的，上面的文字和图片……真的<strong>只</strong>是一个 <code>NSAttributedString</code>(而不是一个复杂的视图布局或者其他)！ 🤯</p><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>所以，从哪里开始实现？当然和第一部分中如何实现 <code>GitHubComment</code> 差不多！</p><p>好的，在实际解决字符串插值之前，我们先从声明特有类型开始。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AttrString</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> attributedString: <span class="type">NSAttributedString</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AttrString</span>: <span class="title">ExpressibleByStringLiteral</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>(stringLiteral: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.attributedString = <span class="type">NSAttributedString</span>(string: stringLiteral)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AttrString</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(describing: <span class="keyword">self</span>.attributedString)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挺简单的吧？仅仅给 <code>NSAttributedString</code> 封装了一下。现在，让我们添加 <code>ExpressibleByStringInterpolation</code> 的支持，来同时支持字面量和带 <code>NSAttributedString</code> 属性注释的字符串。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AttrString</span>: <span class="title">ExpressibleByStringInterpolation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>(stringInterpolation: <span class="type">StringInterpolation</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.attributedString = <span class="type">NSAttributedString</span>(attributedString: stringInterpolation.attributedString)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">StringInterpolation</span>: <span class="title">StringInterpolationProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> attributedString: <span class="type">NSMutableAttributedString</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(literalCapacity: <span class="type">Int</span>, interpolationCount: <span class="type">Int</span>) &#123;</span><br><span class="line">      <span class="keyword">self</span>.attributedString = <span class="type">NSMutableAttributedString</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">appendLiteral</span><span class="params">(<span class="number">_</span> literal: String)</span></span> &#123;</span><br><span class="line">      <span class="keyword">let</span> astr = <span class="type">NSAttributedString</span>(string: literal)</span><br><span class="line">      <span class="keyword">self</span>.attributedString.append(astr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(<span class="number">_</span> string: String, attributes: [NSAttributedString.Key: <span class="keyword">Any</span>])</span></span> &#123;</span><br><span class="line">      <span class="keyword">let</span> astr = <span class="type">NSAttributedString</span>(string: string, attributes: attributes)</span><br><span class="line">      <span class="keyword">self</span>.attributedString.append(astr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，已经可以用下面这种方式简单地构建一个 <code>NSAttributedString</code> 了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="string">"AliSoftware"</span></span><br><span class="line"><span class="keyword">let</span> str: <span class="type">AttrString</span> = <span class="string">"""</span></span><br><span class="line"><span class="string">  Hello \(user, attributes: [.foregroundColor: NSColor.blue])!</span></span><br><span class="line"><span class="string">  """</span></span><br></pre></td></tr></table></figure><p>这看起来已经优雅多了吧？</p><h2 id="方便的样式添加"><a href="#方便的样式添加" class="headerlink" title="方便的样式添加"></a>方便的样式添加</h2><p>但用字典 <code>[NAttributedString.Key: Any]</code> 的方式处理属性不够优雅。特别是由于 <code>Any</code> 没有明确类型，要求了解每一个键值的明确类型……</p><p>所以可以通过创建特有的 <code>Style</code> 类型让它变得更优雅，并帮助我们构建属性的字典：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AttrString</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Style</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> attributes: [<span class="type">NSAttributedString</span>.<span class="type">Key</span>: <span class="type">Any</span>]</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">font</span><span class="params">(<span class="number">_</span> font: NSFont)</span></span> -&gt; <span class="type">Style</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">Style</span>(attributes: [.font: font])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">color</span><span class="params">(<span class="number">_</span> color: NSColor)</span></span> -&gt; <span class="type">Style</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">Style</span>(attributes: [.foregroundColor: color])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">bgColor</span><span class="params">(<span class="number">_</span> color: NSColor)</span></span> -&gt; <span class="type">Style</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">Style</span>(attributes: [.backgroundColor: color])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">link</span><span class="params">(<span class="number">_</span> link: String)</span></span> -&gt; <span class="type">Style</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> .link(<span class="type">URL</span>(string: link)!)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">link</span><span class="params">(<span class="number">_</span> link: URL)</span></span> -&gt; <span class="type">Style</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">Style</span>(attributes: [.link: link])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> oblique = <span class="type">Style</span>(attributes: [.obliqueness: <span class="number">0.1</span>])</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">underline</span><span class="params">(<span class="number">_</span> color: NSColor, <span class="number">_</span> style: NSUnderlineStyle)</span></span> -&gt; <span class="type">Style</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">Style</span>(attributes: [</span><br><span class="line">        .underlineColor: color,</span><br><span class="line">        .underlineStyle: style.rawValue</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">alignment</span><span class="params">(<span class="number">_</span> alignment: NSTextAlignment)</span></span> -&gt; <span class="type">Style</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> ps = <span class="type">NSMutableParagraphStyle</span>()</span><br><span class="line">      ps.alignment = alignment</span><br><span class="line">      <span class="keyword">return</span> <span class="type">Style</span>(attributes: [.paragraphStyle: ps])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这允许使用 <code>Style.color(.blue)</code> 来简单地创建一个封装了 <code>[.foregroundColor: NSColor.blue]</code> 的 <code>Style</code>。</p><p>可别止步于此，现在让我们的 <code>StringInterpolation</code> 可以处理下面这样的 <code>Style</code> 属性！</p><p>这个想法是可以做到像这样写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="type">AttrString</span> = <span class="string">"""</span></span><br><span class="line"><span class="string">  Hello \(user, .color(.blue)), how do you like this?</span></span><br><span class="line"><span class="string">  """</span></span><br></pre></td></tr></table></figure><p>是不是更优雅？而我们仅仅需要为它正确实现 <code>appendInterpolation</code> 而已！</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AttrString</span>.<span class="title">StringInterpolation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(<span class="number">_</span> string: String, <span class="number">_</span> style: AttrString.Style)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> astr = <span class="type">NSAttributedString</span>(string: string, attributes: style.attributes)</span><br><span class="line">    <span class="keyword">self</span>.attributedString.append(astr)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后就完成了！但……这样一次只支持一个 <code>Style</code>。为什么不允许它传入多个 <code>Style</code> 作为形参呢？这可以用一个 <code>[Style]</code> 形参来实现，但这要求调用侧将样式列表用括号括起来……不如让它使用可变形参？</p><p>让我们用这种方式来代替之前的实现：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AttrString</span>.<span class="title">StringInterpolation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(<span class="number">_</span> string: String, <span class="number">_</span> style: AttrString.Style...)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> attrs: [<span class="type">NSAttributedString</span>.<span class="type">Key</span>: <span class="type">Any</span>] = [:]</span><br><span class="line">    style.forEach &#123; attrs.merge($<span class="number">0</span>.attributes, uniquingKeysWith: &#123;$<span class="number">1</span>&#125;) &#125;</span><br><span class="line">    <span class="keyword">let</span> astr = <span class="type">NSAttributedString</span>(string: string, attributes: attrs)</span><br><span class="line">    <span class="keyword">self</span>.attributedString.append(astr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以将多种样式混合起来了！</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="type">AttrString</span> = <span class="string">"""</span></span><br><span class="line"><span class="string">  Hello \(user, .color(.blue), .underline(.red, .single)), how do you like this?</span></span><br><span class="line"><span class="string">  """</span></span><br></pre></td></tr></table></figure><h2 id="支持图像"><a href="#支持图像" class="headerlink" title="支持图像"></a>支持图像</h2><p><code>NSAttributedString</code> 的另一种能力是使用 <code>NSAttributedString(attachment: NSTextAttachment)</code> 添加图像，让它成为字符串的一部分。要实现它，仅需要实现 <code>appendInterpolation(image: NSImage)</code> 并调用它。</p><p>我希望为这个特性顺便加上缩放图像的能力。由于我是在 macOS 的 playground 上尝试的，它的图形上下文是翻转的，所以也得将图像翻转回来（注意这个细节可能会和 iOS 上实现对 UIImage 的支持时不一样）。这里是我的做法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AttrString</span>.<span class="title">StringInterpolation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(image: NSImage, scale: CGFloat = <span class="number">1.0</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> attachment = <span class="type">NSTextAttachment</span>()</span><br><span class="line">    <span class="keyword">let</span> size = <span class="type">NSSize</span>(</span><br><span class="line">      width: image.size.width * scale,</span><br><span class="line">      height: image.size.height * scale</span><br><span class="line">    )</span><br><span class="line">    attachment.image = <span class="type">NSImage</span>(size: size, flipped: <span class="literal">false</span>, drawingHandler: &#123; (rect: <span class="type">NSRect</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">      <span class="type">NSGraphicsContext</span>.current?.cgContext.translateBy(x: <span class="number">0</span>, y: size.height)</span><br><span class="line">      <span class="type">NSGraphicsContext</span>.current?.cgContext.scaleBy(x: <span class="number">1</span>, y: -<span class="number">1</span>)</span><br><span class="line">      image.draw(<span class="keyword">in</span>: rect)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">self</span>.attributedString.append(<span class="type">NSAttributedString</span>(attachment: attachment))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="样式嵌套"><a href="#样式嵌套" class="headerlink" title="样式嵌套"></a>样式嵌套</h2><p>最后，有时候你会希望应用一个样式在一大段文字上，但里面可能也包含了子段落的样式。就像 HTML 里的 <code>&quot;&lt;b&gt;Hello &lt;i&gt;world&lt;/i&gt;&lt;/b&gt;&quot;</code>，整段是粗体但包含了一部分斜体的。</p><p>现在我们的 API 还不支持这样，所以让我们来加上它。思路是允许将一串 <code>Style…</code> 不止应用在 <code>String</code> 上，还能应用在已经存在属性的 <code>AttrString</code> 上。</p><p>这个实现和 <code>appendInterpolation(_ string: String, _ style: Style…)</code> 相似，但会修改 <code>AttrString.attributedString</code> 来<em>添加</em>属性到上面，而不是单纯用 <code>String</code> 创建一个全新的 <code>NSAttributedString</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AttrString</span>.<span class="title">StringInterpolation</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(wrap string: AttrString, <span class="number">_</span> style: AttrString.Style...)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> attrs: [<span class="type">NSAttributedString</span>.<span class="type">Key</span>: <span class="type">Any</span>] = [:]</span><br><span class="line">    style.forEach &#123; attrs.merge($<span class="number">0</span>.attributes, uniquingKeysWith: &#123;$<span class="number">1</span>&#125;) &#125;</span><br><span class="line">    <span class="keyword">let</span> mas = <span class="type">NSMutableAttributedString</span>(attributedString: string.attributedString)</span><br><span class="line">    <span class="keyword">let</span> fullRange = <span class="type">NSRange</span>(mas.string.startIndex..&lt;mas.string.endIndex, <span class="keyword">in</span>: mas.string)</span><br><span class="line">    mas.addAttributes(attrs, range: fullRange)</span><br><span class="line">    <span class="keyword">self</span>.attributedString.append(mas)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这些全部完成之后，目标就达成了，终于可以用单纯的字符串加上插值创建一个 AttributedString：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">"AliGator"</span></span><br><span class="line"><span class="keyword">let</span> str: <span class="type">AttrString</span> = <span class="string">"""</span></span><br><span class="line"><span class="string">  Hello \(username, .color(.red)), isn't this \("cool", .color(.blue), .oblique, .underline(.purple, .single))?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  \(wrap: """</span></span><br><span class="line">    \(<span class="string">" Merry Xmas! "</span>, .font(.systemFont(ofSize: <span class="number">36</span>)), .color(.red), .bgColor(.yellow))</span><br><span class="line">    \(image: #imageLiteral(resourceName: <span class="string">"santa.jpg"</span>), scale: <span class="number">0.2</span>)</span><br><span class="line">    <span class="string">""", .alignment(.center))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Go there to \("learn more about String Interpolation", .link("https://github.com/apple/swift-evolution/blob/master/proposals/0228-fix-expressiblebystringinterpolation.md"), .underline(.blue, .single))!</span></span><br><span class="line"><span class="string">  """</span></span><br></pre></td></tr></table></figure><p><img src="http://alisoftware.github.io/assets/StringInterpolation-AttrString.png" alt="imgage"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>期待你享受这一系列 <code>StringInterpolation</code> 文章，并且能从中瞥到这个新设计威力的冰山一角。</p><p>你可以 <a href="http://alisoftware.github.io/assets/StringInterpolation.playground.zip" target="_blank" rel="noopener">在这下载我的 Playground 文件</a>，里面有 <code>GitHubComment</code>(见 <a href="http://alisoftware.github.io/swift/2018/12/15/swift5-stringinterpolation-part1/" target="_blank" rel="noopener">第一部分</a>)，<code>AttrString</code> 的全部实现，说不定还能从我简单实现 <code>RegEX</code> 的尝试中得到一些灵感。</p><p>这里还有更多更好的思路去使用 Swift 5 中新的 <code>ExpressibleByStringInterpolation</code> API - 包括 <a href="https://ericasadun.com/2018/12/12/the-beauty-of-swift-5-string-interpolation/" target="_blank" rel="noopener">Erica Sadun 博客里这篇</a>、<a href="https://ericasadun.com/2018/12/14/more-fun-with-swift-5-string-interpolation-radix-formatting/" target="_blank" rel="noopener">这篇</a> 和 <a href="https://ericasadun.com/2018/12/16/swift-5-interpolation-part-3-dates-and-number-formatters/" target="_blank" rel="noopener">这篇</a> - 还在犹豫什么，阅读更多……从中感受乐趣吧！</p><hr><ol><li>这篇文章和 Playground 里的代码，需要使用 Swift 5。在写作时，最新的 Xcode 版本是 10.1，Swift 4.2，所以如果你想尝试这些代码，需要遵循官方指南去下载开发中的 Swift 5 快照。安装 Swift 5 工具链并在 Xcode 偏好设置里启用并不困难(见官方指南)。</li><li>当然，这里仅作为 Demo，只实现了一部分样式。未来可以延伸思路让 <code>Style</code> 类型支持更多的样式，在理想情况下，可以覆盖所有存在 <code>NSAttributedString.Key</code>。</li></ol><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Olivier Halligon，&lt;a href=&quot;http://alisoftware.github.io/swift/2018/12/16/swift5-stringinterpolation-part2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-12-16&lt;br&gt;译者：&lt;a href=&quot;https://nemocdz.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nemocdz&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/WAMaker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WAMaker&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/Pancf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pancf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
 &lt;!--此处开始正文--&gt;
&lt;p&gt;我们已经在 &lt;a href=&quot;https://swift.gg/2019/04/22/swift5-stringinterpolation-part1/&quot;&gt;前文&lt;/a&gt; 里介绍了 Swift 5 全新的 StringInterpolation 设计。在这第二部分中，我会着眼于 &lt;code&gt;ExpressibleByStringInterpolation&lt;/code&gt; 其中一种应用，让 &lt;code&gt;NSAttributedString&lt;/code&gt; 变得更优雅。&lt;/p&gt;
    
    </summary>
    
      <category term="Crunchy Development" scheme="https://swift.gg/categories/Crunchy-Development/"/>
    
    
      <category term="Swift 进阶，Swift" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6%EF%BC%8CSwift/"/>
    
  </entry>
  
  <entry>
    <title>Chris Lattner 讲述 Swift 起源故事</title>
    <link href="https://swift.gg/2019/10/16/chris-lattner-swift-origins/"/>
    <id>https://swift.gg/2019/10/16/chris-lattner-swift-origins/</id>
    <published>2019-10-15T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/2019/chris-lattner-swift-origins/" target="_blank" rel="noopener">原文链接</a>，原文日期：2019-02-18<br>译者：<a href="https://dingtz.com/" target="_blank" rel="noopener">jojotov</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>在 <a href="https://www.swiftcommunitypodcast.org/episodes/1" target="_blank" rel="noopener">新推出的 Swift 社区播客第一集</a> 中，<a href="http://nondot.org/sabre/" target="_blank" rel="noopener">Chris Lattner</a>, <a href="https://garricn.com/" target="_blank" rel="noopener">Garric Nahapetian</a>, 和 <a href="https://www.swiftbysundell.com/" target="_blank" rel="noopener">John Sundell</a> 讲述了关于 Swift 起源的故事和 Swift 社区的现状。</p><p>本文是我整理出的一些比较有趣的东西（为了能更好地阅读而做了部分修改）。你可以看到我主要引用了 Chris Lattner 的讲话，因为我认为他对于 Swift 是如何被创造出来的描述是最值得保留下去的。但这并不代表 John 和 Garric 所说的东西没那么有趣。你真的应该去完整地收听整集播客——反正所花的时间和阅读本文相差无几。</p><a id="more"></a><p><a href="https://www.swiftcommunitypodcast.org/" target="_blank" rel="noopener">Swift 社区播客</a> 本身也非常值得关注。作为一个让你可以通过各种方式进行贡献的项目，它非常符合我们的预期（上面提到的三位嘉宾在第一集中谈到了更多细节）。在本文的完成过程中，我的工作主要在 <a href="https://github.com/SwiftCommunityPodcast/podcast/issues/15" target="_blank" rel="noopener">creating the transcript</a> 这个 Issue 上进行，甚至在代码格式部分和编辑机器生成的文本部分收到了许多来自于社区的帮助。在此对所有提供过帮助的人表示感谢！</p><p>你可以在 GitHub 上找到 <a href="https://github.com/SwiftCommunityPodcast/podcast/blob/master/Shownotes/Episode1-Transcript.vtt" target="_blank" rel="noopener">完整的记录副本</a>（<a href="https://en.wikipedia.org/wiki/WebVTT" target="_blank" rel="noopener">WebVTT 格式</a>）。所有的播客都是由 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC-BY 4.0</a> 授权。</p><hr><h2 id="Swift-的起源"><a href="#Swift-的起源" class="headerlink" title="Swift 的起源"></a>Swift 的起源</h2><p><em>（开始于 16:59）</em></p><blockquote><p><strong>Crhis Lattner:</strong> 关于这件事，我必须从 <a href="https://en.wikipedia.org/wiki/Apple_Worldwide_Developers_Conference" target="_blank" rel="noopener">WWDC</a> 2010 开始讲起。当时我们刚刚上线了 <a href="https://en.wikipedia.org/wiki/Clang" target="_blank" rel="noopener">Clang</a> 对 <a href="https://en.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="noopener">C++</a> 的支持，非常多的人在这件事上面花费了极其巨大的精力。我对这件事感到非常开心的同时，也有一些烦躁，因为我们做了太多的细节工作。而且你很难不经过思考直接编写 C++ 代码，“天呐，应该有比现在更好的实现方法吧！”</p><p>因此，我与一个叫 <a href="https://en.wikipedia.org/wiki/Bertrand_Serlet" target="_blank" rel="noopener">Bertrand Serlet</a> 的哥们儿进行了许多次讨论。Bertrand 当时是软件团队的老大，同时也是一位出类拔萃的工程师。他是一个令人惊叹的人，并且在语言方面有点极客范。当时他正在推进对 <a href="https://en.wikipedia.org/wiki/Objective-C" target="_blank" rel="noopener">Objective-C</a> 的优化工作。我和他进行了许多次一对一的白板会议。</p><blockquote><p>At the time, Swift was called ‘Shiny’.<br>在那时，Swift 还叫 ‘Shiny’</p></blockquote><p>Bertrand 负责苹果公司所有的软件项目，因此他基本没什么时间。但他总是会让我在工作结束时顺便拜访一下他，看他是不是有空。他经常会呆到很晚，然后我们会在白板上进行非常认真的讨论。我们会谈论非常非常多的东西：新语言要达成的目标、一些奇怪的细节如类型系统，并且我们最终都会把这些讨论变成一份计划书。因此我为他做了这份计划书并演变成构建一个新语言的想法。那时这个新语言还叫做 “Shiny”，寓意着你正在建造一个 <a href="https://www.youtube.com/watch?v=8q_lsRLJhcA" target="_blank" rel="noopener">很酷的</a> 新东西。[^1] 当然我也是 Firefly 电视节目的粉丝之一。（译者注：”Shiny” 的梗源自 2002 年美国电视节目 <a href="https://en.wikipedia.org/wiki/Firefly_(TV_series" target="_blank" rel="noopener">Firefly</a>)，意思相当于真实世界中的 “cool”。）</p><p><strong>John Sundell:</strong> 当时的文件后缀是 <code>.shiny</code> 吗？</p><p><strong>Chris Lattner:</strong> 确实如此。你知道在那个时候，这还是个很小型的项目。真的就只有我和 Bertrand 在讨论这件事。另外就只有一个同样非常出色的工程师 <a href="https://github.com/davezarzycki" target="_blank" rel="noopener">Dave Zarzycki</a> 参与了早期的一些概念上的讨论。</p><p>一开始，我们就自然而然地展开了关于内存管理的讨论。当时，我们都确信一点就是：必须要有一个好的方法来解决或改善内存管理，并且我们需要确保 <a href="https://docs.swift.org/swift-book/LanguageGuide/MemorySafety.html" target="_blank" rel="noopener">内存安全</a>。因而，你必须有一个自动内存管理功能。</p><blockquote><p>为了达到自动内存管理的目标，我们有史以来第一次以 Swift 的内部设计讨论为起点，并最终在 Objective-C 中实现了此特性。</p></blockquote><p>首先想到的一个关键功能就是 <a href="https://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="noopener">ARC</a>，同时我们需要让编译器自身支持这个功能，而不是通过运行时来实现。Objective-C 当时使用 <a href="https://opensource.apple.com/source/libauto/libauto-77.1/README.html" target="_blank" rel="noopener">libauto</a> 垃圾回收系统，但它有着一大堆问题。因此为了达到自动内存管理的目标，我们有史以来第一次以 Swift 的内部设计讨论为起点，并最终在 Objective-C 中实现了此特性。随后有许多的东西都是这样产生的，包括 ARC 和 <a href="https://clang.llvm.org/docs/Modules.html" target="_blank" rel="noopener">modules</a> 甚至 <a href="https://clang.llvm.org/docs/ObjectiveCLiterals.html" target="_blank" rel="noopener">literals</a> 及更多类似的功能，它们的确都是由 Swift 的幕后开发主导的。[^2]</p><p><strong>John Sundell:</strong> 所以在当时，你脑海里已经有许多关于 Shiny 的特性，最后它们都在 Swift 中实现了。但你曾经说过，“我们并不想一直等待新语言开发完成。我们应该把这些非常吸引人的特性加入到 Objective-C 中。”</p><blockquote><p>在构建一个新的语言时，你必须一直问自己，‘为什么不直接优化现有的语言’，这是幕后构思过程的一部分。</p></blockquote><p><strong>Chris Lattner:</strong> 或许现在看来，Swift 的出现是必然的，但如果你从另一个角度思考这个问题，在当时并不是所有人都能认识到这一点，甚至连我也不能确定。Bertrand 从过去到现在都一直非常的棒，他一直给予我们极大的鼓励。而且他总是能在质疑中前进。Bertrand 有点类似科学家，他仅仅只是想通过各种途径寻找真相。的确，当时我们有许多疑虑，但同时也有许多好的想法。包括 Bertrand 在内的很多人一直在推进这项工作。在构建一个新的语言时，你必须一直问自己，‘为什么不直接优化现有的语言’，这是幕后构思过程的一部分。而这个问题的答案是，“很显然，我们应该把现有的优化好”。这也是为什么诸如 ARC 的功能会出现。</p><p>但是，在 Swift 中，最需要解决的问题是内存安全。在 Objective-C 中，除非去除 C 相关的东西，不然是不可能达到绝对的内存安全。但去除了 C 的 Objective-C 会失去太多的东西， 而它也不再是 Objective-C 了。</p><p><strong>Garric Nahapetian:</strong> 没错。因此，把一些 Swift 的特性添加到 Objective-C 中就像是 <a href="https://zh.wikipedia.org/zh/特洛伊木馬" target="_blank" rel="noopener">特洛伊木马</a> 一样，可以让大家更容易地信任 Swift ，因为你已经完成了 Objective-C 方面的工作，是这样吗？</p><p><strong>Chris Lattner:</strong> （这里面）其实有许多有趣的内部动力。我觉得我们非常专注地优化 Objective-C 及其相关的平台。对于开发 Swift 而言，这是一种降低风险的办法。如果说，“我们要把所有东西都一次性推到重做”，而且不经过任何测试的话，肯定会有巨大的风险。但如果你只把“少部分”的东西单独推倒重做，比如一个全新的内存管理系统，然后对它进行迭代、调试并结合社区的力量进行开发的话，就只会产生有限的风险。不过有一点我要说的是，不管是外部的社区还是苹果内部的社区，貌似都在对我们说，“为什么你要优先考虑这个？我们就好像是概率论中的 <a href="https://zh.wikipedia.org/wiki/隨機漫步" target="_blank" rel="noopener">随机漫步</a> 一样。为什么你要做这个而不是其他的？”因此，这也成为了一个有趣的动力。</p></blockquote><hr><h2 id="初始团队的成长"><a href="#初始团队的成长" class="headerlink" title="初始团队的成长"></a>初始团队的成长</h2><p><em>（开始于 22:49）</em></p><blockquote><p><strong>Chris Lattner:</strong> 苹果拥有着一支非常强大的工程师队伍。那时有非常多的人一起维护 Objective-C，这其实是有点固执的一件事，但同时这也让我们在动态库、应用和其他类似的东西上拥有了十足的深度和背景。正因如此，那时有许多关于优化 Objective-C 的想法涌现。自从乔布斯离开并创立 <a href="https://en.wikipedia.org/wiki/NeXT" target="_blank" rel="noopener">NeXT</a> 之后，许多杰出的人物都一直参与这项工作并写下了大量相关的白皮书。因此，Objective-C 背后有一个极其庞大的社区在推动着。</p><p>当时，我和 Bertrand 以及 Dave 讨论过一些想法，我也开始着手编写一个编译器的原型。不过结果很显然，我很难靠自己去构建出所有的东西。所以最后的事情也理所当然地发生了——大约在 2011 年四月的时候我们与管理层讨论了关于 Swift 的事情，然后也获得批准去调动一小部分人员。<a href="https://twitter.com/tkremenek" target="_blank" rel="noopener">Ted Kremenek</a>、<a href="https://twitter.com/dgregor79" target="_blank" rel="noopener">Doug Gregor</a>、<a href="https://twitter.com/pathofshrines" target="_blank" rel="noopener">John McCall</a> 以及一些其他的杰出工程师都是在那时调入 Swift 项目的。现在回头看看，其实挺有意思的，因为当时是第一次有一些语言和设计专家对 Swift 做了批判性的评价。他们反馈了很多严厉的批判。虽然他们的本意并不是打击我们，但他们的确说的很对——这个语言当时实在是糟透了。</p><p>能让这一切顺利进行有一个关键原因，就是我们有机会拉拢一位泛型领域的世界级专家，以及一支构建过 Clang 编译器的团队。同时这支团队也参与过许多不同的有意思的项目，并能够尽可能地发挥他们的工程天赋。虽然他们只是帮助推进和开发构建的一部分人员，但却至关重要。</p><p><strong>John Sundell:</strong> 在那时 Swift 语言的状况是怎样的？比如，语言的语法是什么样子？编译器的哪部分基础设施已经搭建完成了？它是不是已经接近于原型的阶段甚至更进一步呢？</p><p><strong>Chris Lattner:</strong> 那时 Swift 已经非常接近原型阶段了。这些资料都是完全公开的，因为在 GitHub 上，<a href="https://github.com/apple/swift/commits/master" target="_blank" rel="noopener">变更历史是完全公开</a> 的。<a href="https://github.com/apple/swift/blob/master/CHANGELOG.md" target="_blank" rel="noopener">变更日志</a> 虽然不能完全追溯所有的历史变更，但已经足够了。</p><p>在 Doug 加入之前，Swift 并没有泛型系统。当时我们很想做一个泛型系统，但我不是很有自信能独自设计出来，Doug 却做到了。我记得在很早的时候，John 曾经接手过一个项目，让一个类似语法分析器的东西变得可以真正生成代码。Doug 所做的事情大概就是这样。</p><p>有很多零碎的事情我不太记得了，但有些东西我却一直记忆犹新。我记得 <code>var</code> 和 <code>func</code> 就是从最初就制定好的。早期的 Swift 中很多基本语法都和现在的 Swift 语法非常接近。</p><blockquote><p>当你构建一样新东西的时候，通常想法是领先于文档的，而文档又先于代码。我们当时情况也非常类似。到现在，想法已经领先于代码非常之多了，这都是无可避免的。</p></blockquote><p>当时的 Swift 已经十分接近于一个原型了。但仍有许许多多的想法未实现。当你构建一样新东西的时候，通常想法是先于文档的，而文档又是先于代码。我们当时情况也非常类似。到现在，想法已经领先于代码非常之多了，这都是无可避免的。</p></blockquote><hr><h2 id="关于-Craig-Federighi"><a href="#关于-Craig-Federighi" class="headerlink" title="关于 Craig Federighi"></a>关于 Craig Federighi</h2><p><em>（开始于 26:10）</em></p><blockquote><p><strong>Chris Lattner:</strong> 对于社区非常重要的另一位伙伴名叫 <a href="https://en.wikipedia.org/wiki/Craig_Federighi" target="_blank" rel="noopener">Craig Federighi</a>。Craig 在苹果社区中非常出名。在 2011 年早些时候，他加入了这个项目。那时正好 Bertrand 从苹果退休，Craig 便接手了他的工作。</p><p>说到 Craig，他是一个非常、非常有趣的人。无论在台上还是台下，他都着非凡的个人魅力。大多数人们都不了解他到底有多么的聪明。他还在许多方面都有着极其深入的研究。我完全没想到，他在语言方面懂得很多。他曾为 <a href="http://groovy-lang.org/" target="_blank" rel="noopener">Groovy</a> 和许多其他类型的语言作为正式参与者工作过，有些语言我甚至还没接触过。而且，他并不像是一位只会谈论策略的高层人员。他同样关心许多细节的事情，例如闭包语法、关键字和其他东西。</p><p>Craig 真的是一位非常严格的任务推动者，同时他也推动着 Swift 的实现以及 Swift 与 Objective-C 的联动。不仅如此，他还关心着 Objective-C 本身的维护；关心着 API；关心着 Objective-C 的 API <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md" target="_blank" rel="noopener">导入到 Swift</a> 后的形态，还有相关的一切。Craig 在积极给予反馈的同时，一直保持着在团队和项目上出乎意料的卓越态度。他的帮助对 Swift 的现状影响很大。</p><p><strong>Garric Nahapetian:</strong> 这真的很酷，因为他刚好是在 WWDC 2014 的讲台上第一位发表演讲的人。</p><p><strong>Chris Lattner:</strong> 没错。</p><p><strong>John Sundell:</strong> 然后他就介绍你出场了，对吧？我还记得那句经典的标语：“没有 C 的 Objective-C”。</p><blockquote><p>我对那句“没有 C 的 Objective-C”标语有着复杂的感觉，因为其实我想表达的并不是这样。</p></blockquote><p><strong>Chris Lattner:</strong> 说实话，我对那句标语有着复杂的感觉，因为其实我想表达的并不是这样。</p><p><strong>John Sundell:</strong> 那是句很棒的标语。</p><p><strong>Chris Lattner:</strong> 在那个时候，以这种方式向社区宣传是很正确的选择。</p><p>（……）</p><blockquote><p>在项目的一开始，我的目标其实是构建一个全栈系统。</p></blockquote><p><strong>Chris Lattner:</strong> 至于说为什么我当时很矛盾，因为在项目的一开始，我的目标其实是构建一个全栈系统——分析市面上现有的系统，取其精华，弃其糟粕。而且当时的目标是构建一个可以编写固件、编写脚本、编写移动应用和服务端应用甚至是更底层系统代码的语言，同时在语言层面上并非只是通过随意堆砌来实现，我要让它在上面说的所有方面都能表现出色。</p><p>所以在当时而言，这个方向绝对是正确的。虽然目前 Swift 还没能达到预期，但欣慰的是它的发展将会使它能够在未来拥有这些的能力。</p></blockquote><hr><h2 id="文档的重要性"><a href="#文档的重要性" class="headerlink" title="文档的重要性"></a>文档的重要性</h2><p><em>（开始于 30:32）</em></p><blockquote><p><strong>Chris Lattner:</strong> （在这里）我还要最后提到一支团队。你目前所看到的 Swift，它是一个<a href="https://en.wikipedia.org/wiki/Compiler" target="_blank" rel="noopener">编译器</a>，是一门语言，是<a href="https://developer.apple.com/documentation/swift/swift_standard_library" target="_blank" rel="noopener">一系列 API 的集合</a>，也是一个 IDE。但让这些事情能够成真，并让 Swift 走向大众，离不开开发者发布团队的工作。他们是 Apple 的科技编辑，负责编写如 <a href="https://developer.apple.com/documentation/swift/swift_standard_library" target="_blank" rel="noopener">Swift 编程语言书籍</a> 之类的东西。Swift 的成功和快速适应市场离不开当时第一时间发布的高质量文档和书籍。直到今天，他们仍在维护这些文档，真的非常不可思议。</p><blockquote><p>我们直接把这些科技编辑拉入了设计讨论会</p></blockquote><p>我记得当时我们直接把这些科技编辑拉入了设计讨论会。像 <a href="https://twitter.com/timisted" target="_blank" rel="noopener">Tim Isted</a>、Brian Lanier 和 Alex Martini 这些人，他们在周会上花了大量的时间争论着一些细节问题——“我们是否应该使用点语法？”“我们应该使用这个关键字还是那个关键字？”或者是“我们是应该把 <code>func</code> 改为 <code>def</code> 吗？”同时还讨论着——类型系统的深度以及 <a href="https://en.wikipedia.org/wiki/Code_generation_(compiler" target="_blank" rel="noopener">代码生成</a>) 算法应如何工作；我们如何达到较好的性能？<a href="https://developer.apple.com/documentation/swift/string" target="_blank" rel="noopener">字符串</a> 应如何运作？还有各种各样的问题。</p><blockquote><p>如果你能在设计阶段就考虑到如何像大家解释这门语言的话，工作会进行得更顺利。</p></blockquote><p>我见过很多次这种事情，当你构建完一个系统后你还要尝试着解释它。然后当你开始解释这个系统时，真的会陷入一个尴尬的处境，比如：“天啊，我竟然还要去解释这个东西是如何工作的”。如果你可以在设计阶段就处理好反馈信息，并引入文档，引入这些关于如何向大家解释的工作，你会进行得更顺利。</p></blockquote><hr><h2 id="Swift-的开发工作是一个团队效应"><a href="#Swift-的开发工作是一个团队效应" class="headerlink" title="Swift 的开发工作是一个团队效应"></a>Swift 的开发工作是一个团队效应</h2><p><em>（开始于 34:58）</em></p><blockquote><p><strong>Chris Lattner:</strong> 我想说的是，很多人会说“Chris 发明了 Swift”。虽然我的确在很多年的时间里一直用不同的方法推动着 Swift 的开发，也算是带领着整个项目，但事实上其实他们都忽略了一点，有数以百计的人为 Swift 的许多关键问题作出了贡献。例如构建调试器、构建 <a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener">IDE</a>、构建 <a href="https://help.apple.com/xcode/mac/current/#/dev188e45167" target="_blank" rel="noopener">Playgrounds</a>、构建教育相关的内容、构建各种东西以及相关的社区。</p><p>我在许多地方都不如他们优秀。他们几乎组成了一个不仅是在 Apple 内部，同时活跃于 Apple 之外的社区，并一起推动着 Swift 相关功能的构建，并以他们自己的方式做着贡献。这就是为什么 Swift 能发展的如今的规模，我认为这也是 Swift 能一直成长下去的原因。</p><p><strong>Garric Nahapetian:</strong> 这也是我们录制这集播客的原因之一——让这些在幕后做过贡献的人可以站在聚光灯下。</p></blockquote><hr><h2 id="不要像编译器开发者一样写-Swift"><a href="#不要像编译器开发者一样写-Swift" class="headerlink" title="不要像编译器开发者一样写 Swift"></a>不要像编译器开发者一样写 Swift</h2><p><em>（开始于 42:15）</em></p><blockquote><p><strong>Chris Lattner:</strong> 有件事我觉得很神奇，你们两个写的 Swift 代码比我写的还多。我可能对 Swift 的内部实现、它为什么会是这样的、它是如何做到某些事的，以及它是如何运作的比较了解，但你们却拥有着真正以 Swift 来构建产品的经验</p><p><strong>John Sundell:</strong> 是的，这很有趣。有许多许多人在为 Swift 项目工作，为它的编译器工作，而且他们大部分时间都在写 C++。我想顺便问一下，这种感觉是怎样的？你设计了这门非常酷的语言，大家也逐渐开始使用它了，但你却还在使用 C++。</p><p><strong>Chris Lattner:</strong> （大笑） 这让我痛不欲生。这真的太可怕了。就像老天开的玩笑一样，强制我一直在写 C++。</p></blockquote><hr><h2 id="关于社区反馈"><a href="#关于社区反馈" class="headerlink" title="关于社区反馈"></a>关于社区反馈</h2><p><em>（开始于 43:11）</em></p><blockquote><p><strong>Chris Lattner:</strong> 为什么 Swift 现在能发展得这么好，拥有一个庞大的的社区，而且大家都习惯于在上面写博客，这肯定是都主要原因之一对吧？社区的反馈的确影响了 Swift 1 和 2 。那些抱怨就像是提醒我们的信号一样，“这根本不合理”，“我在这上面遇到了问题，还有那个和另外的都遇到了问题”。这些的确帮了我们很多，特别是在优化、排期和推动最终的 Swift 版本方面。</p><blockquote><p>早期的社区反馈的确影响了 Swift 1 和 2。</p></blockquote><p>比较意外，也可以说是我们有意为之的是，在 Swift 1 中没有加入错误处理机制。同时我们也没有加入协议扩展，这些能力我们绝对是希望 Swift 能够拥有的，但只是错过了发布日程。因此我们很清楚必须要去构建这些功能，但在第一两年间这些东西却是直接由社区最终推动完成的。然后<a href="https://developer.apple.com/swift/blog/?id=34" target="_blank" rel="noopener">当 Swift 开源</a>，<a href="https://github.com/apple/swift-evolution" target="_blank" rel="noopener">Swift Evolution</a> 变成了一个伟大的项目。这个项目可能在人们的时间效率优化方面表现并不理想，但它却是让 Swift 非比寻常的重要因素。我想这项荣誉属于所有在社区中花时间为 Swift 的功能优化和工作推进提供帮助的人。</p><p><strong>John Sundell:</strong> 我所想到的就是，不仅是那些文章和内容，同时包括开源在内的所有东西，都是如何大量反哺了 Swift 自身。例如，类似 <a href="https://developer.apple.com/documentation/swift/swift_standard_library/encoding_decoding_and_serialization" target="_blank" rel="noopener"><code>Codable</code></a> 功能，在它未完成之前人们会开发数以千计的 JSON 映射库。我也是其中之一。我曾经构建了 <a href="https://github.com/JohnSundell/Unbox" target="_blank" rel="noopener">Unbox</a> ，因为在 Objective-C 中你不需要在这方面花费许多时间和精力。你只需要说，这是个字典，那我们就访问它的某个 Key 然后假设返回结果永远是字符串。但一旦你坐下来把同样的代码以 Swift 实现的话，你就会发现需要用到大量的 <code>if let</code>。因此我能想象到这些大家都尝试解决的东西，绝对会以不同的方式反哺 Swift 自身的设计进程。</p><p><strong>Chris Lattner:</strong> 是的，这无可厚非。而且 <code>Codable</code> 的设计来自于 Apple 的一支非 Swift 核心开发团队的动态库团队。他们对这个工作真的很有耐心，他们实现并推动着它，并且一直支持着它上线。</p><blockquote><p>很难想象到底社区影响了 Swift 多少。</p></blockquote><p>社区呈现了各种各样的东西对吧？比如 <a href="https://developer.apple.com/documentation/swift/result" target="_blank" rel="noopener"><code>Result</code></a>。为什么 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0235-add-result.md" target="_blank" rel="noopener"><code>Result</code> 要加入到 Swift 5 中</a>？因为我们一次又一次地构造了它。即使 <a href="https://swift.org/community/#core-team" target="_blank" rel="noopener">核心团队</a> 不希望有一个 <code>Result</code> 类型，因为这仿佛是语言的失败体现；即使我们一致认为 <code>Result</code> 类型不是必要的。但社区中却一直有清晰且强烈的声音，“你们看，我们需要它。不管在长期看来它是否理想，但我们现在的确需要。”因此社区真的影响了很多东西。而且你可能难以想象到底社区影响了 Swift 多少。</p></blockquote><hr><h2 id="关于初始预期"><a href="#关于初始预期" class="headerlink" title="关于初始预期"></a>关于初始预期</h2><p><em>（开始于 46:07）</em></p><blockquote><p><strong>John Sundell:</strong> 对于 Swift 的现状，以及你发布 Swift 后它的改变，这些是否都符合你的预期呢？经过了这些年，对于你在最初阶段的想法，Swift 现在有多少是符合的？</p><blockquote><p>当 Swift 1 发布时，我们也有一些疑问，我们是否可以在 Objective-C 的社区中获得一席之地？我们是否能在 iOS 的生态系统中获得一席之地，或者是将会分成几派？</p></blockquote><p><strong>Chris Lattner:</strong> 这么说吧，我觉得预期也会随时间改变。如果回到 2010-2011 年，我并没有预想着它会有多成功。我承认当时我只是觉得这是个有趣的业余项目。这原本就是个填补夜晚和周末时间的东西。你知道，在整日的工作后再去做一个业余项目是很有趣也很具挑战性的。当它越来越接近完成，并直到 Swift 1 发布时，我们都一些疑问——我们是否可以在 Objective-C 的社区中获得一席之地？我们是否能在 iOS 的生态系统中获得一席之地，或者是将会分成几派？我们当时的确有这样的疑虑。现在我可以说我会感到很欣慰，因为我觉得社区中绝大多数人都对 Swift 持乐观态度。</p><p><strong>Chris Lattner:</strong> 不过现在依然有新的领域等待探索。Swift 在服务端的表现一直越来越好，但仍有大量的工作需要完成。在外部，也有许多不同的社区活跃着。我对数字和 <a href="https://github.com/tensorflow/swift" target="_blank" rel="noopener">机器学习的社区</a> 特别感兴趣，这些对全世界都有重要的意义。在这些社区中，有着许多有趣的人，我觉得 Swift 在这里可以发展得很好。</p><blockquote><p>Swift 的全球制霸只是一个开玩笑的目标，但它来源于使用和热爱 Swift 的人们的信念。</p></blockquote><p>我有时会开玩笑地说，我们的目标是 <a href="https://oleb.net/blog/2017/06/chris-lattner-wwdc-swift-panel/#in-which-fields-would-you-like-to-see-swift-in-the-future" target="_blank" rel="noopener">Swift 全球制霸</a>。这只是一个玩笑目标，但它来源于使用和热爱 Swift 的人们的信念。如果真是这样的话，我会非常愿意把这份愉悦带给人们，并帮助改善整个世界。现实中仍有许多让人头痛的系统对吧？仍有许多人还在写着 C 语言代码。就那些 <a href="https://oleb.net/blog/2017/06/chris-lattner-wwdc-swift-panel/#in-which-fields-would-you-like-to-see-swift-in-the-future" target="_blank" rel="noopener">bug 和安全脆弱性</a> 来说，真是让人感觉十分不幸。同时，我们还要面对生态系统的问题，以及许多其他的挑战要征服，这都是我们作为一个社区可以完成的。在这方面，我认为有着无限的可能。</p></blockquote><hr><h2 id="在-Apple-社区以外推广-Swift"><a href="#在-Apple-社区以外推广-Swift" class="headerlink" title="在 Apple 社区以外推广 Swift"></a>在 Apple 社区以外推广 Swift</h2><p><em>（开始于 50:18）</em></p><blockquote><p><strong>Chris Lattner:</strong> 尽管人们现在都是以积极、乐观的态度来讨论 Swift，可 Swift 仍有许多问题。我觉得我们必须保持开放的态度来讨论这个，并把它看作一个解决问题的练习。主要的问题集中在 Linux 生态系统上面，与之相比，<a href="https://dev.azure.com/compnerd/windows-swift" target="_blank" rel="noopener">Windows 生态系统</a> 的问题简直不值一提。为了让 Swift 的受众更广泛，我们真的还有许多工作要做。</p><blockquote><p>Swift 仍有许多问题。主要的问题集中在  Linux 生态系统上面。Swift 在 <a href="https://dev.azure.com/compnerd/windows-swift" target="_blank" rel="noopener">Windows 生态系统</a> 的问题简直不值一提。</p></blockquote><p><strong>Chris Lattner:</strong> 我们的目标是打造一个不排外的社区。可事与愿违的是，如果你不是一名 Apple 开发者，你可能会在搜索 Swift 相关的东西时感到融入不了社区，因为搜索结果都是一些 iOS 相关的讨论。</p><blockquote><p>如果你不是一名 Apple 开发者，你可能会在搜索 Swift 相关的东西时感到融入不了社区，因为搜索结果都是一些 iOS 相关的讨论。</p></blockquote><p><strong>John Sundell:</strong> 完全正确。比如“这是如何在 <code>UIViewController</code> 中完成它的方法。”</p><p><strong>Chris Lattner:</strong> 没错。这会让你觉得自己是个外来者，但这并不是我们的初衷。我认为这不是有意为之的，但它却是真实存在的。这正是我们社区所面对的一大挑战。我目前还不知道有没有比较完美解决方案，不过我想我们总会找到的。</p></blockquote><hr><h2 id="关于-Swift-的演进"><a href="#关于-Swift-的演进" class="headerlink" title="关于 Swift 的演进"></a>关于 Swift 的演进</h2><p><em>（开始于 55:12）</em></p><blockquote><p><strong>Chris Lattner:</strong> （关于 Swift 的演进）这是个非常复杂的事情，我大概要好几个小时才能全部讲完。如果简短地说一下我的想法——开放要好于封闭。如果你能让更多人参与，那么你肯定能得到一个更好的结果。我想 <a href="(https://github.com/apple/swift-evolution">Swift Evolution</a>) 的项目进展有很多问题，Garric 也列举了一些。但这不妨碍它是一个很好的东西。同时有一点我认为是有益的，就是它很好地减缓了语言的演进。因为小心谨慎地发展一个语言总比过快地发展好。</p><p>我觉得强制地推动一系列文档进展也是一件很好的事情，因为文档是十分重要的。Swift Evolution 项目引领了苹果与社区在某种规范下，以不同的方式进行合作，这不仅有趣，也是非常棒的一件事。</p><p>我不认为 Swift Evolution 项目是一成不变的。在这几年的时间里，它在不同方面都发生了改变。同时，我们一直在艰难地权衡着它的目的——到底是为社区输出设计规范还是帮助社区确定优先级？对我们来说，这是个具有挑战性的问题，因为当你把它完全交给社区去执行时，你可能会失去一些细节的东西。但在一些大方向上，整个 Swift 的世界都是认同的——比如 <a href="https://forums.swift.org/t/concurrency-async-await-actors/6499" target="_blank" rel="noopener">并发性</a>。</p><p>这是我们的一次非常大的尝试，而且通过一个自底向上的社区流程来实现它不是一件容易的事。因此很多事对我来说都是未知的。我觉得 Swift Evolution 是一个很棒的项目。我也很开心我们现在拥有这个项目。尽管我同意它不是我们所唯一拥有的，也不应该是唯一的，但我仍觉得它绝对是业界标杆之一。</p><p>（……）</p><blockquote><p>我一直在寻找 Swift 包管理生态系统的催化剂，到底应该以服务端 Swift 的社区为起点，还是以机器学习社区为起点。</p></blockquote><p>从某种意义上来说，Swift 的每一个变动，都需要一段时间来消化。当一个大的新能力出现时，社区都需要一段时间来弄明白它、应用它、找出它的使用场景和它如何与其他功能兼容。因此，花费的这些时间都是值得的。我从 Swift Evolution 所认识到的最重要的事，就是社区的合理推动所带来的力量。Swift Evolution 真的为我们聚集了许多来自社区的语言极客，让他们同时关注 Swift 项目一个特定方面。我一直在寻找 Swift 包管理生态系统发展的催化剂，到底应该以服务端 Swift 的社区为起点，还是把机器学习社区聚集起来干点大事。</p><p>我们如何去寻找这种催化剂——让大家在合适的地方聚在一起，通过他们自己的力量构建一个项目，发挥他们的能力和天赋，让大家协作工作？</p></blockquote><p>[^1]:  <a href="https://twitter.com/uint_min/status/1098628355539124224" target="_blank" rel="noopener">Jordan Rose 分享了一则与 Shiny 这个名字相关的佚事</a> ：.swiftmodule 文件中的“魔法数字”是 E2 9C A8 0E。它的前三个字节是 ✨ 的 UTF-8 字符（U+2728 SPARKLES）。</p><p>[^2]:  <a href="https://twitter.com/gparker/status/1099251522422992896" target="_blank" rel="noopener">Greg Parker 声称</a> ARC 只是间接地从 Swift 的开发过程中产生：ARC 的实现早于 Swift 的实现。但在幕后的工作中，Swift 早期的设想的确推进了管理层提供必要的资源去构建和部署 ObjC 的 ARC。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/2019/chris-lattner-swift-origins/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2019-02-18&lt;br&gt;译者：&lt;a href=&quot;https://dingtz.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jojotov&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/WAMaker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WAMaker&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/Pancf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pancf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在 &lt;a href=&quot;https://www.swiftcommunitypodcast.org/episodes/1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;新推出的 Swift 社区播客第一集&lt;/a&gt; 中，&lt;a href=&quot;http://nondot.org/sabre/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chris Lattner&lt;/a&gt;, &lt;a href=&quot;https://garricn.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Garric Nahapetian&lt;/a&gt;, 和 &lt;a href=&quot;https://www.swiftbysundell.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;John Sundell&lt;/a&gt; 讲述了关于 Swift 起源的故事和 Swift 社区的现状。&lt;/p&gt;
&lt;p&gt;本文是我整理出的一些比较有趣的东西（为了能更好地阅读而做了部分修改）。你可以看到我主要引用了 Chris Lattner 的讲话，因为我认为他对于 Swift 是如何被创造出来的描述是最值得保留下去的。但这并不代表 John 和 Garric 所说的东西没那么有趣。你真的应该去完整地收听整集播客——反正所花的时间和阅读本文相差无几。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
      <category term="Swift" scheme="https://swift.gg/categories/Ole-Begemann/Swift/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="Ole Begemann" scheme="https://swift.gg/tags/Ole-Begemann/"/>
    
  </entry>
  
  <entry>
    <title>图像优化</title>
    <link href="https://swift.gg/2019/10/09/optimizing-images/"/>
    <id>https://swift.gg/2019/10/09/optimizing-images/</id>
    <published>2019-10-08T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jordan Morgan，<a href="https://www.swiftjectivec.com/optimizing-images/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-12-11<br>译者：<a href="https://nemocdz.github.io/" target="_blank" rel="noopener">Nemocdz</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><hr><!--此处开始正文--><p>俗话说得好，最好的相机是你身边的那个。那么毫无疑问 - iPhone 可以说是这个星球最重要的的相机。而这在业界也已经达成共识。</p><p>在度假？不偷偷拍几张记录在你的 Instagram 故事里？不存在的。</p><p>出现爆炸新闻？查看 Twitter，就可以知道是哪些媒体正在报道，通过他们揭露事件的实时照片。</p><p>等等……</p><p>正因为图像在平台上无处不在，如果管理不当，很容易出现性能和内存问题。稍微了解下 UIKit，搞清楚它处理图像的机制，可以节省大量时间，避免做无用功。</p><a id="more"></a><h3 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h3><p>快问快答 - 这是一张我漂亮（且时髦）女儿的照片，大小为 266KB，在一个 iOS 应用中展示它需要多少内存？</p><p><img src="https://www.swiftjectivec.com/assets/images/baylor.jpg" alt></p><p>剧透警告 - 答案不是 266KB，也不是 2.66MB，而是接近 14MB。</p><p>为啥呢？</p><p>iOS 实际上是从一幅图像的<em>尺寸</em>计算它占用的内存 - 实际的文件大小会比这小很多。这张照片的尺寸是 1718 像素宽和 2048 像素高。假设每个像素会消耗我们 4 个比特：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1718 * 2048 * 4 / 1000000 = 14.07 MB 占用</span><br></pre></td></tr></table></figure><p>假设你有一个用户列表 table view，并且在每一行左边使用常见的圆角头像来展示他们的照片。如果你认为这些图像会像洁食（犹太人的食品，比喻事情完美无瑕）一样，每个都被类似 ImageOptim 的工具压缩过，那可就大错特错了。即使每个头像的大小只有 256x256，也会占用相当一部分内存。</p><h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><p>综上所述 - 了解幕后原理是值得的。当你加载一张图片时，会执行以下三个步骤：</p><p>1）<strong>加载</strong> - iOS 获取压缩的图像并加载到 266KB 的内存（在我们这个例子中）。这一步没啥问题。</p><p>2）<strong>解码</strong> - 这时，iOS 获取图像并转换成 GPU 能读取和理解的方式。这里会解压图片，像上面提到那样占用 14MB。</p><p>3）<strong>渲染</strong> - 顾名思义，图像数据已经准备好以任意方式渲染。即使只是在一个 60x60pt 的 image view 中。</p><p>解码阶段是消耗最大的。在这个阶段，iOS 会创建一块缓冲区 - 具体来说是一块图像缓冲区，也就是图像在内存中的表示。这解释了为啥内存占用大小和图像尺寸有关，而不是文件大小。因此也可以理解，为什么在处理图片时，尺寸如此重要。</p><p>具体到 <code>UIImage</code>，当我们传入从网络或者其它来源读取的图像数据时，它会将数据解码到缓冲区，但不会考虑数据的编码方式（比如 PNG 或者 JPG）。然而，缓冲区实际上会保存到 <code>UIImage</code> 中。由于渲染不是一瞬间的操作，<code>UIImage</code> 会执行一次解码操作，然后一直保留图像缓冲区。</p><p>接着往下说 - 任何 iOS 应用中都有一整块的帧缓冲区。它会保存内容的渲染结果，也就是你在屏幕上看到的东西。每个 iOS 设备负责显示的硬件都用这里面单个像素信息逐个点亮物理屏幕上合适的像素点。</p><p>处理速度非常重要。为了达到黄油般顺滑的每秒 60 帧滑动，在信息发生变化时（比如给一个 image view 赋值一幅图像），帧缓冲区需要让 UIKit 渲染 app 的 window 以及它里面所有层级的子视图。一旦延迟，就会丢帧。</p><blockquote><p><em>觉得 1/60 秒太短不够用？Pro Motion 设备已经将上限拉到了 1/120 秒。</em></p></blockquote><h3 id="尺寸正是问题所在"><a href="#尺寸正是问题所在" class="headerlink" title="尺寸正是问题所在"></a>尺寸正是问题所在</h3><p>我们可以很简单地将这个过程和内存的消耗可视化。我创建了一个简单的应用，可以在一个 image view 上展示需要的图像，这里用的是我女儿的照片：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> filePath = <span class="type">Bundle</span>.main.path(forResource:<span class="string">"baylor"</span>, ofType: <span class="string">"jpg"</span>)!</span><br><span class="line"><span class="keyword">let</span> url = <span class="type">NSURL</span>(fileURLWithPath: filePath)</span><br><span class="line"><span class="keyword">let</span> fileImage = <span class="type">UIImage</span>(contentsOfFile: filePath)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Image view</span></span><br><span class="line"><span class="keyword">let</span> imageView = <span class="type">UIImageView</span>(image: fileImage)</span><br><span class="line">imageView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">imageView.contentMode = .scaleAspectFit</span><br><span class="line">imageView.widthAnchor.constraint(equalToConstant: <span class="number">300</span>).isActive = <span class="literal">true</span></span><br><span class="line">imageView.heightAnchor.constraint(equalToConstant: <span class="number">400</span>).isActive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">view.addSubview(imageView)</span><br><span class="line">imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></span><br><span class="line">imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p><em>实践中请注意强制解包。这里只是一个简单的场景。</em></p></blockquote><p>完成之后就会是这个样子：</p><p><img src="https://www.swiftjectivec.com/assets/images/baylorPhone.jpg" alt></p><p>虽然展示图片的 image view 尺寸很小，但是用 LLDB 就可以看到图像的真正尺寸。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;UIImage: 0x600003d41a40&gt;, &#123;1718, 2048&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是 - 这里的单位是<em>点</em>。所以当我在 3x 或 2x 设备时，可能还需要额外乘上这个数字。我们可以用 vmmap 来确认这张图像是否占用了 14 MB：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmmap --summary baylor.memgraph</span><br></pre></td></tr></table></figure><p>一部分输出（省略一些内容以便展示）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Physical footprint:         69.5M</span><br><span class="line">Physical footprint (peak):  69.7M</span><br></pre></td></tr></table></figure><p>我们看到这个数字接近 70MB，这可以作为基准来确认针对性优化的成果。如果我们用 grep 命令查找 Image IO，或许会看到一部分图像消耗:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmmap --summary baylor.memgraph | grep "Image IO"</span><br><span class="line"></span><br><span class="line">Image IO  13.4M   13.4M   13.4M    0K  0K  0K   0K  2</span><br></pre></td></tr></table></figure><p>啊哈 - 这里有大约 14MB 的脏内存，和我们前面的估算一致。如果你不清楚每一列表示什么，可以看下面这个截图：</p><p><img src="https://www.swiftjectivec.com/assets/images/vmmap.jpg" alt></p><p>通过这个例子可以清楚地看到，哪怕展示在 300x400 image view 中，图像也需要完整的内存消耗。图像尺寸很重要，但是尺寸并不是唯一的问题。</p><h3 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h3><p>能确定的是，有一部分内存消耗来源于另一个重要因素 - 色彩空间。在上面的例子中，我们的计算基于以下假设 - 图像使用 sRGB 格式，但大部分 iPhone 不符合这种情况。sRGB 每个像素有 4 个字节，分别表示红、蓝、绿、透明度。</p><p>如果你用支持宽色域的设备进行拍摄（比如 iPhone 8+ 或 iPhone X），那么内存消耗将变成两倍，反之亦然。Metal 会用仅有一个 8 位透明通道的 Alpha 8 格式。</p><p>这里有很多可以把控和值得思考的地方。这也是为什么你应该用 <a href="https://www.swiftjectivec.com/uigraphicsimagerenderer/" target="_blank" rel="noopener">UIGraphicsImageRenderer</a> 代替 <code>UIGraphicsBeginImageContextWithOptions</code> 的原因之一。后者<em>总是</em>会使用 sRGB，因此无法使用宽色域，也无法在不需要的时候节省空间。在 iOS 12 中，<code>UIGraphicsImageRenderer</code> 会为你做正确的选择。</p><p>不要忘了，很多图像并不是真正的摄影作品，只是一些绘图操作。如果你错过了我最近的文章，可以再阅读一遍下面的内容：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> circleSize = <span class="type">CGSize</span>(width: <span class="number">60</span>, height: <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">UIGraphicsBeginImageContextWithOptions</span>(circleSize, <span class="literal">true</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draw a circle</span></span><br><span class="line"><span class="keyword">let</span> ctx = <span class="type">UIGraphicsGetCurrentContext</span>()!</span><br><span class="line"><span class="type">UIColor</span>.red.setFill()</span><br><span class="line">ctx.setFillColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line">ctx.addEllipse(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: circleSize.width, height: circleSize.height))</span><br><span class="line">ctx.drawPath(using: .fill)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circleImage = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line"><span class="type">UIGraphicsEndImageContext</span>()</span><br></pre></td></tr></table></figure><p>上面的圆形图像用的是每个像素 4 个字节的格式。如果换用 <code>UIGraphicsImageRenderer</code>，通过渲染器自动选择正确的格式，让每个像素使用 1 个字节，可以节省高达 75％ 的内存：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> circleSize = <span class="type">CGSize</span>(width: <span class="number">60</span>, height: <span class="number">60</span>)</span><br><span class="line"><span class="keyword">let</span> renderer = <span class="type">UIGraphicsImageRenderer</span>(bounds: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: circleSize.width, height: circleSize.height))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circleImage = renderer.image&#123; ctx <span class="keyword">in</span></span><br><span class="line">    <span class="type">UIColor</span>.red.setFill()</span><br><span class="line">    ctx.cgContext.setFillColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line">    ctx.cgContext.addEllipse(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: circleSize.width, height: circleSize.height))</span><br><span class="line">    ctx.cgContext.drawPath(using: .fill)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缩小图片-vs-向下采样"><a href="#缩小图片-vs-向下采样" class="headerlink" title="缩小图片 vs 向下采样"></a>缩小图片 vs 向下采样</h3><p>现在我们从简单的绘图场景回到现实世界 - 许多图片其实并不是艺术作品，只是自拍或者风景照。</p><p>因此有些人可能会假设（并且确实相信）通过 <code>UIImage</code> 简单地缩小图片就够了。但我们前面已经解释过，缩小尺寸并不管用。而且根据 Apple 工程师 kyle Howarth 的说法，由于内部坐标转换的原因，缩小图片的优化效果并不太好。</p><p><code>UIImage</code> 导致性能问题的根本原因，我们在渲染流程里已经讲过，它会解压<em>原始图像</em>到内存中。理想情况下，我们需要一个方法来减少图像缓冲区的尺寸。</p><p>庆幸的是，我们可以修改图像尺寸，来减少内存占用。很多人以为图像会自动执行这类优化，但实际上并没有。</p><p>让我们尝试用底层的 API 来对它进行向下采样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> imageSource = <span class="type">CGImageSourceCreateWithURL</span>(url, <span class="literal">nil</span>)!</span><br><span class="line"><span class="keyword">let</span> options: [<span class="type">NSString</span>:<span class="type">Any</span>] = [kCGImageSourceThumbnailMaxPixelSize:<span class="number">400</span>,</span><br><span class="line">                               kCGImageSourceCreateThumbnailFromImageAlways:<span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> scaledImage = <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, options <span class="keyword">as</span> <span class="type">CFDictionary</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> imageView = <span class="type">UIImageView</span>(image: <span class="type">UIImage</span>(cgImage: scaledImage))</span><br><span class="line">    </span><br><span class="line">    imageView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    imageView.contentMode = .scaleAspectFit</span><br><span class="line">    imageView.widthAnchor.constraint(equalToConstant: <span class="number">300</span>).isActive = <span class="literal">true</span></span><br><span class="line">    imageView.heightAnchor.constraint(equalToConstant: <span class="number">400</span>).isActive = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    view.addSubview(imageView)</span><br><span class="line">    imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></span><br><span class="line">    imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种取巧的展示方法，会获得和以前完全相同的结果。不过在这里，我们使用了 <code>CGImageSourceCreateThumbnailAtIndex()</code>，而不是直接将原始图片放进 image view。再次使用 vmmap 来确认优化是否有回报（同样，省略部分内容以便展示）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmmap -summary baylorOptimized.memgraph</span><br><span class="line"></span><br><span class="line">Physical footprint:         56.3M</span><br><span class="line">Physical footprint (peak):  56.7M</span><br></pre></td></tr></table></figure><p>效果很明显。之前是 69.5M，现在是 56.3M，节省了 13.2M。这个节省<em>相当大</em>，几乎和图片本身一样大。</p><p>更进一步，你可以在自己的案例中尝试更多可能的选项来进行优化。在 WWDC 18 的 Session 219，“Images and Graphics Best Practices“中，苹果工程师 Kyle Sluder 展示了一种有趣的方式，通过 <code>kCGImageSourceShouldCacheImmediately</code> 标志位来控制解码时机，：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downsampleImage</span><span class="params">(at URL:NSURL, maxSize:Float)</span></span> -&gt; <span class="type">UIImage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> sourceOptions = [kCGImageSourceShouldCache:<span class="literal">false</span>] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    <span class="keyword">let</span> source = <span class="type">CGImageSourceCreateWithURL</span>(<span class="type">URL</span> <span class="keyword">as</span> <span class="type">CFURL</span>, sourceOptions)!</span><br><span class="line">    <span class="keyword">let</span> downsampleOptions = [kCGImageSourceCreateThumbnailFromImageAlways:<span class="literal">true</span>,</span><br><span class="line">                             kCGImageSourceThumbnailMaxPixelSize:maxSize</span><br><span class="line">                             kCGImageSourceShouldCacheImmediately:<span class="literal">true</span>,</span><br><span class="line">                             kCGImageSourceCreateThumbnailWithTransform:<span class="literal">true</span>,</span><br><span class="line">                             ] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> downsampledImage = <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(source, <span class="number">0</span>, downsampleOptions)!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 Core Graphics 不会开始图片解码，直到你请求缩略图。另外要注意的是，两个例子都传入了 <code>kCGImageSourceCreateThumbnailMaxPixelSize</code>，如果不这样做，就会获得和原图同样尺寸的缩略图。根据文档所示：</p><blockquote><p>“…如果没指定最大尺寸，返回的缩略图将会是完整图像的尺寸，这可能并不是你想要的。”</p></blockquote><p>所以上面发生了什么？简而言之，我们将缩放的结果放入缩略图中，从而创建的是比之前小很多的图像解码缓冲区。回顾之前提到的渲染流程，在第一个环节（加载）中，我们给 UIImage 传入的缓冲区是需要绘制的图片尺寸，不是图片的真实尺寸。</p><p>如何用一句话总结本文？想办法对图像进行向下采样，而不是使用 UIImage 去缩小尺寸。</p><h3 id="附赠内容"><a href="#附赠内容" class="headerlink" title="附赠内容"></a>附赠内容</h3><p>除了向下采样，我自己还经常使用 iOS 11 引入的 <a href="https://developer.apple.com/documentation/uikit/uitableviewdatasourceprefetching?language=swift" target="_blank" rel="noopener">预加载 API</a>。请记住，我们是在解码图像，哪怕是放在 Cell 展示之前执行，也会消耗大量 CPU 资源。</p><p>如果应用持续耗电，iOS 可以优化电量消耗。但是我们做的向下采样一般不会持续执行，所以最好在一个队列中执行采样操作。与此同时，你的解码过程也实现了后台执行，一石多鸟。</p><p>做好准备，下面即将为您呈现的是——我自己业余项目里的 Objective-C 代码示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 不要用全局异步队列，使用你自己的队列，从而避免潜在的线程爆炸问题</span><br><span class="line">- (void)tableView:(UITableView *)tableView prefetchRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths</span><br><span class="line">&#123;</span><br><span class="line">    if (self.downsampledImage != nil || </span><br><span class="line">        self.listItem.mediaAssetData == nil) return;</span><br><span class="line">    </span><br><span class="line">    NSIndexPath *mediaIndexPath = [NSIndexPath indexPathForRow:0</span><br><span class="line">                                                     inSection:SECTION_MEDIA];</span><br><span class="line">    if ([indexPaths containsObject:mediaIndexPath])</span><br><span class="line">    &#123;</span><br><span class="line">        CGFloat scale = tableView.traitCollection.displayScale;</span><br><span class="line">        CGFloat maxPixelSize = (tableView.width - SSSpacingJumboMargin) * scale;</span><br><span class="line">        </span><br><span class="line">        dispatch_async(self.downsampleQueue, ^&#123;</span><br><span class="line">            // Downsample</span><br><span class="line">            self.downsampledImage = [UIImage downsampledImageFromData:self.listItem.mediaAssetData</span><br><span class="line">                               scale:scale</span><br><span class="line">                        maxPixelSize:maxPixelSize];</span><br><span class="line">            </span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^ &#123;</span><br><span class="line">                self.listItem.downsampledMediaImage = self.downsampledImage;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>建议使用 asset catalog 来管理原始图像资源，它已经实现了缓冲区优化（以及更多功能）。</p></blockquote><p>想成为内存和图像处理专家？不要错过 WWDC 18 这些信息量巨大的 session：</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2018/416/?time=1074" target="_blank" rel="noopener">iOS Memory Deep Dive</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2018/219/" target="_blank" rel="noopener">Images and Graphics Best Practices</a></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>学无止境。如果选择了编程，你就必须每小时跑一万英里才能跟得上这个领域创新和变化的步伐……换句话说，一定会有很多你根本不知道的 API、框架、模式或者优化技巧。</p><p>在图像领域也是如此。大多数时候，你初始化一个了大小合适的 UIImageView 就不管了。我当然知道摩尔定律。现在手机确实很快，内存也很大，但是你要知道 - 将人类送上月球的计算机只有不到 100KB 内存。</p><p>长期和魔鬼共舞（译者注：比喻不管内存问题），它总有露出獠牙的那天。等到一张自拍就占掉 1G 内存的时候，后悔也来不及了。希望上述的知识和技术能帮你节省一些 debug 时间。</p><p>下次再见 ✌️。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Jordan Morgan，&lt;a href=&quot;https://www.swiftjectivec.com/optimizing-images/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-12-11&lt;br&gt;译者：&lt;a href=&quot;https://nemocdz.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nemocdz&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/WAMaker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WAMaker&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/Pancf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pancf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;俗话说得好，最好的相机是你身边的那个。那么毫无疑问 - iPhone 可以说是这个星球最重要的的相机。而这在业界也已经达成共识。&lt;/p&gt;
&lt;p&gt;在度假？不偷偷拍几张记录在你的 Instagram 故事里？不存在的。&lt;/p&gt;
&lt;p&gt;出现爆炸新闻？查看 Twitter，就可以知道是哪些媒体正在报道，通过他们揭露事件的实时照片。&lt;/p&gt;
&lt;p&gt;等等……&lt;/p&gt;
&lt;p&gt;正因为图像在平台上无处不在，如果管理不当，很容易出现性能和内存问题。稍微了解下 UIKit，搞清楚它处理图像的机制，可以节省大量时间，避免做无用功。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
    
      <category term="Swift，iOS 开发" scheme="https://swift.gg/tags/Swift%EF%BC%8CiOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>宏定义与可选括号</title>
    <link href="https://swift.gg/2019/09/27/preprocessor-abuse-and-optional-parentheses/"/>
    <id>https://swift.gg/2019/09/27/preprocessor-abuse-and-optional-parentheses/</id>
    <published>2019-09-26T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-03-20-preprocessor-abuse-and-optional-parentheses.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-03-20<br>译者：俊东；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://nemocdz.github.io/" target="_blank" rel="noopener">Nemocdz</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>前几天我遇到了一个有趣的问题：如何编写一个 C 语言预处理器的宏，删除包围实参的括号？</p><p>今天的文章，将为大家分享我的解决方案。<br><a id="more"></a></p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>C 语言预处理器是一个相当盲目的文本替换引擎，它并不理解 C 代码，更不用说 Objective-C 了。它的工作原理还算不错，可以应付大部分情况，但偶尔也会出现判断失误。</p><p>这里举个典型的例子：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">XCTAssertEqualObjects</span>(someArray, @[ <span class="string">@"one"</span>, <span class="string">@"two"</span> ], <span class="string">@"Array is not as expected"</span>);</span><br></pre></td></tr></table></figure><p>这会无法编译，并且会出现非常古怪的错误提示。预处理器查找分隔宏参数的逗号时，没能将数组结构 <code>@ [...]</code> 中的东西理解为一个单一的元素。结果代码尝试比较 <code>someArray</code> 和 <code>@[@&quot;one&quot;</code>。断言失败消息 <code>@&quot;two&quot;]</code> 和 <code>@&quot;Array is not as expected&quot;</code> 是另外的实参。这些半成品部分用于 <code>XCTAssertEqualObjects</code> 的宏扩展中，生成的代码当然错得离谱。</p><p>要解决这个问题也很容易：添加括号就行。预编译器不能识别 <code>[]</code>，但它<em>确实</em>知道 <code>()</code> 并且能够理解应该忽略里面的逗号。下面的代码就能正常运行：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">XCTAssertEqualObjects</span>(someArray, (@[ <span class="string">@"one"</span>, <span class="string">@"two"</span> ]), <span class="string">@"Array is not as expected"</span>);</span><br></pre></td></tr></table></figure><p>在 C 语言的许多场景下，你添加多余的括号也不会有任何区别。宏扩展开之后，生成的代码虽然在数组文字周围有括号，但没有异常。你可以写搞笑的多层括号表达式，编译器会愉快地帮你解析到最里面一层：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,((((((((((<span class="number">42</span>)))))))))));</span><br></pre></td></tr></table></figure><p>甚至将 <code>NSLog</code> 这样处理也行：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">((((((((((<span class="built_in">NSLog</span>))))))))))(<span class="string">@"%d"</span>,<span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>在 C 中有一个地方你不能随意添加括号：类型（types）。例如：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f(<span class="keyword">void</span>); <span class="comment">// 合法</span></span><br><span class="line">(<span class="keyword">int</span>) f(<span class="keyword">void</span>); <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure><p>什么时候会发生这种情况呢？这种情况并不常见，但如果你有一个使用类型的宏，并且类型包含的逗号不在括号内，则会出现这种情况。宏可以做很多事情，当一个类型遵循多个协议时，在 Objective-C 中可能出现一些类型带有未加括号的逗号;当使用带有多个模板参数的模板化类型时，在 C++ 中也可能出现。举个例子，这有一个简单的宏，创建从字典中提供静态类型值的 <code>getter</code>：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define GETTER(type,name) \</span></span><br><span class="line">- (type)name &#123; \</span><br><span class="line"><span class="keyword">return</span> [_dictionary objectForKey: @<span class="meta">#name]; \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你能这样使用它：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line"><span class="built_in">NSDictionary</span> *_dictionary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GETTER(<span class="built_in">NSView</span> *,view)</span><br><span class="line">GETTER(<span class="built_in">NSString</span> *,name)</span><br><span class="line">GETTER(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;,someCopyableThing)</span><br></pre></td></tr></table></figure><p>到目前为止没问题。现在假设我们想要创建一个遵循<em>两个</em>协议的类型：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">GETTER(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>,<span class="built_in">NSCoding</span>&gt;,someCopyableAndCodeableThing)</span><br></pre></td></tr></table></figure><p>哎呀！宏不起作用了。而且添加括号也无济于事：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">GETTER((<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>,<span class="built_in">NSCoding</span>&gt;),someCopyableAndCodeableThing)</span><br></pre></td></tr></table></figure><p>这会产生非法代码。这时我们需要一个删除可选括号的 UNPAREN 宏。将 <code>GETTER</code> 宏重写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define GETTER(type,name) \</span><br><span class="line">- (UNPAREN(type))name &#123; \</span><br><span class="line">return [_dictionary objectForKey: @#name]; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们该怎么做呢？</p><h2 id="必须的括号"><a href="#必须的括号" class="headerlink" title="必须的括号"></a>必须的括号</h2><p>删除括号很容易：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define UNPAREN(...) __VA_ARGS__</span></span><br><span class="line"><span class="meta">#define GETTER(type,name) \</span></span><br><span class="line">- (UNPAREN type)name &#123; \</span><br><span class="line"><span class="keyword">return</span> [_dictionary objectForKey: @<span class="meta">#name]; \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然看上去很扯，但这的确能运行。预编译器将 <code>type</code> 扩展为 <code>(id &lt;NSCopying，NSCoding&gt;)</code>，生成 <code>UNPAREN (id&lt;NSCopying, NSCoding&gt;)</code>。然后它会将 <code>UNPAREN</code> 宏扩展为 <code>id &lt;NSCopying，NSCoding&gt;</code>。括号，消失！</p><p>但是，之前使用的 <code>GETTER</code> 失败了。例如，<code>GETTER(NSView *，view)</code> 在宏扩展中生成 <code>UNPAREN NSView *</code>。不会进一步扩展就直接提供给编译器。结果自然会报编译器错误，因为 <code>UNPAREN NSView *</code> 是无法编译的。这虽然可以通过编写 <code>GETTER((NSView *)，view)</code> 来解决，但是被迫添加这些括号很烦人。这样的结果可不是我们想要的。</p><h2 id="宏不能被重载"><a href="#宏不能被重载" class="headerlink" title="宏不能被重载"></a>宏不能被重载</h2><p>我立刻想到了如何摆脱剩余的 <code>UNPAREN</code>。当你想要一个标识符消失时，你可以使用一个空的 <code>#define</code>，如下所示：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define UNPAREN</span></span><br></pre></td></tr></table></figure><p>有了这个，<code>a UNPAREN b</code> 的序列变为 <code>a b</code>。完美解决问题！但是，如果已经存在带参数的另一个定义，则预处理器会拒绝此操作。即使预处理器可能选择其中一个，它也不会同时存在两种形式。如果可行的话，这能有效解决我们的问题，但可惜的是并不允许：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define UNPAREN(...) __VA_ARGS__</span></span><br><span class="line"><span class="meta">#define UNPAREN</span></span><br><span class="line"><span class="meta">#define GETTER(type,name) \</span></span><br><span class="line">- (UNPAREN type)name &#123; \</span><br><span class="line"><span class="keyword">return</span> [_dictionary objectForKey: @<span class="meta">#name]; \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这无法通过预处理器，它会由于 <code>UNPAREN</code> 的重复 <code>#define</code> 而报错。不过，它引导我们走上了成功的道路。现在的瓶颈是怎么找出一种方法来实现相同的效果，而不会使两个宏具有相同的名称。</p><h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><p>最终目标是让 <code>UNPAREN(x)</code> 和 <code>UNPAREN((x))</code> 结果都是 <code>x</code>。朝着这个目标迈出的第一步是制作一些宏，其中传递 <code>x</code> 和 <code>(x)</code> 产生相同的输出，即使它并不确定 <code>x</code> 是什么。这可以通过将宏名称放在宏扩展中来实现，如下所示：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define EXTRACT(...) EXTRACT __VA_ARGS__</span></span><br></pre></td></tr></table></figure><p>现在如果你写 <code>EXTRACT(x)</code>，结果是 <code>EXTRACT x</code>。当然，如果你写 <code>EXTRACT x</code>，结果也是 <code>EXTRACT x</code>，就像没有宏扩展的情况。这仍然给我们留下一个 <code>EXTRACT</code>。虽然不能用 <code>#define</code> 直接解决，但这已经进步了。</p><h2 id="标识符粘合"><a href="#标识符粘合" class="headerlink" title="标识符粘合"></a>标识符粘合</h2><p>预处理器有一个操作符 <code>##</code>，它将两个标识符粘合在一起。例如，<code>a ## b</code> 变为 <code>ab</code>。这可以用于从片段构造标识符，但也可以用于调用宏。例如：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define AA 1</span></span><br><span class="line"><span class="meta">#define AB 2</span></span><br><span class="line"><span class="meta">#define A(x) A ## x</span></span><br></pre></td></tr></table></figure><p>从这里可以看到，<code>A(A)</code> 产生 <code>1</code>，<code>A(B)</code> 产生 <code>2</code>。</p><p>让我们将这个运算符与上面的 <code>EXTRACT</code> 宏结合起来，尝试生成一个 <code>UNPAREN</code> 宏。由于 <code>EXTRACT(...)</code> 使用前缀 <code>EXTRACT</code> 生成实参，因此我们可以使用标识符粘合来生成以 <code>EXTRACT</code> 结尾的其他标记。如果我们 <code>#define</code> 那个新标记为空，那就搞定了。</p><p>这是一个以 <code>EXTRACT</code> 结尾的宏，它不会产生任何结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define NOTHING_EXTRACT</span></span><br></pre></td></tr></table></figure><p>这是对 <code>UNPAREN</code> 宏的尝试，它将所有内容放在一起：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define UNPAREN(x) NOTHING_ ## EXTRACT x</span></span><br></pre></td></tr></table></figure><p>不幸的是，这并不能实现我们的目标。问题在操作顺序上。如果我们写 <code>UNPAREN((int))</code>，我们将会得到：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">UNPAREN((<span class="keyword">int</span>))</span><br><span class="line">NOTHING_ <span class="meta">## EXTRACT (int)</span></span><br><span class="line">NOTHING_EXTRACT (<span class="keyword">int</span>)</span><br><span class="line">(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>标示符粘合太早起作用，<code>EXTRACT</code> 宏永远不会有机会扩展开。</p><p>可以使用间接的方式强制预处理器用不同的顺序判断事件。我们可以制作一个 <code>PASTE</code> 宏，而不是直接使用 <code>##</code>：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define PASTE(x,...) x ## __VA_ARGS__</span></span><br></pre></td></tr></table></figure><p>然后我们将根据它编写 <code>UNPAREN</code>：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define UNPAREN(x)  PASTE(NOTHING_,EXTRACT x)</span></span><br></pre></td></tr></table></figure><p>这<em>仍然</em>不起作用。情况如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">UNPAREN((<span class="keyword">int</span>))</span><br><span class="line">PASTE(NOTHING_,EXTRACT (<span class="keyword">int</span>))</span><br><span class="line">NOTHING_ <span class="meta">## EXTRACT (int)</span></span><br><span class="line">NOTHING_EXTRACT (<span class="keyword">int</span>)</span><br><span class="line">(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>但更接近我们的目标了。序列 <code>EXTRACT(int)</code> 显然没有触发标示符粘合操作符。我们必须让预处理器在它看到 <code>##</code> 之前解析它。可以通过另一种方式间接强制解析它。让我们定义一个只包装 <code>PASTE</code> 的 <code>EVALUATING_PASTE</code> 宏：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define EVALUATING_PASTE(x,...) PASTE(x,__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><p>现在让我们用<em>它</em>写 <code>UNPAREN</code>：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define UNPAREN(x) EVALUATING_PASTE(NOTHING_,EXTRACT x)</span></span><br></pre></td></tr></table></figure><p>这是展开之后：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">UNPAREN((<span class="keyword">int</span>))</span><br><span class="line">EVALUATING_PASTE(NOTHING_,EXTRACT (<span class="keyword">int</span>))</span><br><span class="line">PASTE(NOTHING_,EXTRACT <span class="keyword">int</span>)</span><br><span class="line">NOTHING_ <span class="meta">## EXTRACT int</span></span><br><span class="line">NOTHING_EXTRACT <span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>即使没有额外加括号也能正常运行，因为额外的赋值并没有影响：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">UNPAREN(<span class="keyword">int</span>)</span><br><span class="line">EVALUATING_PASTE(NOTHING_,EXTRACT <span class="keyword">int</span>)</span><br><span class="line">PASTE(NOTHING_,EXTRACT <span class="keyword">int</span>)</span><br><span class="line">NOTHING_ <span class="meta">## EXTRACT int</span></span><br><span class="line">NOTHING_EXTRACT <span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>成功了！我们现在编写 <code>GETTER</code> 时可以不需要围绕类型的括号了：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define GETTER(type,name) \</span></span><br><span class="line">- (UNPAREN(type))name &#123; \</span><br><span class="line"><span class="keyword">return</span> [_dictionary objectForKey: @<span class="meta">#name]; \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="奖励宏"><a href="#奖励宏" class="headerlink" title="奖励宏"></a>奖励宏</h2><p>在选择一些宏来证明这个结构时，我构建了一个很好的 <code>dispatch_once</code> 宏来制作延迟初始化的常量。实现如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define ONCE(type,name,...) \</span></span><br><span class="line">UNPAREN(type) name() &#123; \</span><br><span class="line"><span class="keyword">static</span> UNPAREN(type) static_ <span class="meta">## name; \</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate; \</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;predicate,^&#123; \</span><br><span class="line">static_ <span class="meta">## name = (&#123; __VA_ARGS__; &#125;); \</span></span><br><span class="line">&#125;); \</span><br><span class="line"><span class="keyword">return</span> static_ <span class="meta">## name; \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用案例：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ONCE(<span class="built_in">NSSet</span> *,AllowedFileTypes,[<span class="built_in">NSSet</span> setWithArray:@[ <span class="string">@"mp3"</span>,<span class="string">@"m4a"</span>,<span class="string">@"aiff"</span> ]])</span><br></pre></td></tr></table></figure><p>然后，你可以调用 <code>AllowedFileTypes()</code> 来获取集合，并根据需要高效创建集合。如果类型不巧包括括号，添加括号就能运行。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>仅仅写这个宏，我就发现了很多艰涩的知识。我希望接触这些知识也不会影响你的思维。请谨慎使用这些知识。</p><p>今天就这样。以后还会有更多令人兴奋的探索，可能比这还要再不可思议。在此之前，如果你对此主题有任何建议，请发送给 <a href="mike@mikeash.com">我们</a>！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Objective-C 中 C 语言宏定义扩展
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS" scheme="https://swift.gg/tags/iOS/"/>
    
      <category term="macro" scheme="https://swift.gg/tags/macro/"/>
    
  </entry>
  
  <entry>
    <title>Swift Import 声明</title>
    <link href="https://swift.gg/2019/09/23/swift-import/"/>
    <id>https://swift.gg/2019/09/23/swift-import/</id>
    <published>2019-09-22T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/import/" target="_blank" rel="noopener">原文链接</a>，原文日期：2019-01-07<br>译者：<a href="https://github.com/mobilefellow" target="_blank" rel="noopener">雨谨</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>作为软件开发人员，我们学到的第一课是如何将概念和功能组织成独立的单元。在最小的层级上，这意味着思考类型、方法和属性。这些东西构成了模块（module）的基础，而模块又可以被打包成为 library 或者 framework。</p><p>在这种方式中，import 声明是将所有内容组合在一起的粘合剂。</p><a id="more"></a><p>尽管 import 声明非常重要，但大部分 Swift 开发者都只熟悉它的最基本用法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;#module#&gt;</span><br></pre></td></tr></table></figure><p>本周的 NSHipster 中，我们将探索 Swift 这个最重要的功能的其他用法。</p><hr><p>import 声明允许你的代码访问其他文件中声明的符号。但是，如果多个模块都声明了一个同名的函数或类型，那么编译器将无法判断你的代码到底想调用哪个。</p><p>为了演示这个问题，考虑 <a href="https://zh.wikipedia.org/wiki/三项全能" target="_blank" rel="noopener">铁人三项（Triathlon）</a> 和 <a href="https://zh.wikipedia.org/wiki/现代五项" target="_blank" rel="noopener">铁人五项（Pentathlon）</a> 这两个代表多运动比赛的模块:</p><p><dfn>铁人三项</dfn> 包括三个项目：游泳、自行车和跑步。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 铁人三项模块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swim</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🏊‍ Swim 1.5 km"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bike</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🚴 Cycle 40 km"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🏃‍ Run 10 km"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><dfn>铁人五项</dfn> 模块由五个项目组成：击剑、游泳、马术、射击和跑步。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 铁人五项模块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fence</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🤺 Bout with épées"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swim</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🏊‍ Swim 200 m"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ride</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🏇 Complete a show jumping course"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shoot</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🎯 Shoot 5 targets"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🏃‍ Run 3 km cross-country"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们单独 import 其中一个模块，我们可以通过它们的 <dfn>非限定（unqualified）</dfn>名称引用它们的每个函数，而不会出现问题。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Triathlon</span><br><span class="line"></span><br><span class="line">swim() <span class="comment">// 正确，调用 Triathlon.swim</span></span><br><span class="line">bike() <span class="comment">// 正确，调用 Triathlon.bike</span></span><br><span class="line">run() <span class="comment">// 正确，调用 Triathlon.run</span></span><br></pre></td></tr></table></figure><p>但是如果同时 import 两个模块，我们不能全部使用非限定函数名。铁人三项和五项都包括游泳和跑步，所以对 <code>swim()</code> 的引用是模糊的。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Triathlon</span><br><span class="line"><span class="keyword">import</span> Pentathlon</span><br><span class="line"></span><br><span class="line">bike() <span class="comment">// 正确，调用 Triathlon.bike</span></span><br><span class="line">fence() <span class="comment">// 正确，调用 Pentathlon.fence</span></span><br><span class="line">swim() <span class="comment">// 错误，模糊不清</span></span><br></pre></td></tr></table></figure><p>如何解决这个问题？一种策略是使用 <dfn>全限定名称（fully-qualified name）</dfn> 来处理任何不明确的引用。通过包含模块名称，程序是要在游泳池中游几圈，还是在开放水域中游一英里，就不存在混淆了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Triathlon</span><br><span class="line"><span class="keyword">import</span> Pentathlon</span><br><span class="line"></span><br><span class="line"><span class="type">Triathlon</span>.swim() <span class="comment">// 正确，指向 Triathlon.swim 的全限定引用</span></span><br><span class="line"><span class="type">Pentathlon</span>.swim() <span class="comment">// 正确，指向 Pentathlon.swim 的全限定引用</span></span><br></pre></td></tr></table></figure><p>解决 API 名称冲突的另一种方法是更改 import 声明，使其更加严格地挑选需要包含每个模块哪些的内容。</p><h2 id="import-单个声明"><a href="#import-单个声明" class="headerlink" title="import 单个声明"></a>import 单个声明</h2><p>import 声明提供了一种样式，可以指定引入定义在顶层（top-level）的单个结构体、类、枚举、协议和类型别名，以及函数、常量和变量。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;#kind#&gt; &lt;#module.symbol#&gt;</span><br></pre></td></tr></table></figure><p>这里，<code>&lt;#kind#&gt;</code> 可以为如下的任何关键字：</p><table><thead><tr><th>Kind</th><th>Description</th></tr></thead><tbody><tr><td><code>struct</code></td><td>结构体</td></tr><tr><td><code>class</code></td><td>类</td></tr><tr><td><code>enum</code></td><td>枚举</td></tr><tr><td><code>protocol</code></td><td>协议</td></tr><tr><td><code>typealias</code></td><td>类型别名</td></tr><tr><td><code>func</code></td><td>函数</td></tr><tr><td><code>let</code></td><td>常量</td></tr><tr><td><code>var</code></td><td>变量</td></tr></tbody></table><p>例如，下面的 import 声明只添加了 <code>Pentathlon</code> 模块的 <code>swim()</code> 函数:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> func Pentathlon.swim</span><br><span class="line"></span><br><span class="line">swim() <span class="comment">// 正确，调用 Pentathlon.swim</span></span><br><span class="line">fence() <span class="comment">// 错误，无法解析的标识</span></span><br></pre></td></tr></table></figure><h3 id="解决符号名称冲突"><a href="#解决符号名称冲突" class="headerlink" title="解决符号名称冲突"></a>解决符号名称冲突</h3><p>当代码中多个符号被同一个名字被引用时，Swift 编译器参考以下信息，按优先级顺序解析该引用:</p><ol><li>本地的声明</li><li>单个导入（import）的声明</li><li>整体导入的模块</li></ol><p>如果任何一个优先级有多个候选项，Swift 将无法解决歧义，进而引发编译错误。</p><p>例如，整体导入的 <code>Triathlon</code> 模块会提供 <code>swim()</code>、<code>bike()</code> 和 <code>run()</code> 方法，但从 <code>Pentathlon</code> 中单个导入的 <code>swim()</code> 函数声明会覆盖 <code>Triathlon</code> 模块中的对应函数。同样，本地声明的 <code>run()</code> 函数会覆盖 <code>Triathlon</code> 中的同名符号，也会覆盖任何单个导入的函数声明。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Triathlon</span><br><span class="line"><span class="keyword">import</span> func Pentathlon.swim</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地的函数会遮住整体导入的 Triathlon 模块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🏃‍ Run 42.195 km"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swim() <span class="comment">// 正确，调用 Pentathlon.swim</span></span><br><span class="line">bike() <span class="comment">// 正确，调用 Triathlon.bike</span></span><br><span class="line">run() <span class="comment">//  正确，调用本地的 run</span></span><br></pre></td></tr></table></figure><p>那这个代码的运行结果是？一个古怪的多运动比赛，包括在一个泳池里游几圈的游泳，一个适度的自行车骑行，和一个马拉松跑。<em>(@ 我们, 钢铁侠)</em></p><blockquote><p>如果本地或者导入的声明，与模块的名字发生冲突，编译器首先查找声明，然后在模块中进行限定查找。</p></blockquote><blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">import</span> Triathlon</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">enum</span> <span class="title">Triathlon</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">case</span> sprint, olympic, ironman</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="type">Triathlon</span>.olympic <span class="comment">// 引用本地的枚举 case</span></span><br><span class="line">&gt; <span class="type">Triathlon</span>.swim() <span class="comment">// 引用模块的函数</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Swift编译器不会通知开发者，也无法协调模块和本地声明之间的命名冲突，因此使用依赖项时，你应该了解这种可能性。</p></blockquote><h3 id="澄清和缩小范围"><a href="#澄清和缩小范围" class="headerlink" title="澄清和缩小范围"></a>澄清和缩小范围</h3><p>除了解决命名冲突之外，import 声明还可以作为澄清程序员意图的一种方法。</p><p>例如，如果只使用 AppKit 这样大型框架中的一个函数，那么你可以在 import 声明中单独指定这个函数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> func AppKit.NSUserName</span><br><span class="line"></span><br><span class="line"><span class="type">NSUserName</span>() <span class="comment">// "jappleseed"</span></span><br></pre></td></tr></table></figure><p>顶层常量和变量的来源通常比其他的导入符号更难识别，在导入它们时，这个技术尤其有用。</p><p>例如，Darwin framework 提供的众多功能中，包含一个顶层的 <code>stderr</code> 变量。这里的一个显式 import 声明可以在代码评审时，提前避免该变量来源的任何疑问。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> func Darwin.fputs</span><br><span class="line"><span class="keyword">import</span> var Darwin.stderr</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StderrOutputStream</span>: <span class="title">TextOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(<span class="number">_</span> string: String)</span></span> &#123;</span><br><span class="line">        fputs(string, stderr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> standardError = <span class="type">StderrOutputStream</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Error!"</span>, to: &amp;standardError)</span><br></pre></td></tr></table></figure><h2 id="import-子模块"><a href="#import-子模块" class="headerlink" title="import 子模块"></a>import 子模块</h2><p>最后一种 import 声明样式，提供了另一种限制 API 暴露的方式。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;#module.submodule#&gt;</span><br></pre></td></tr></table></figure><p>你很可能在 AppKit 和 Accelerate 等大型的系统 framework 中遇到子模块。虽然这种 <dfn><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-97623-BAJJHAJC" target="_blank" rel="noopener">伞架构（umbrella framework）</a></dfn> 不再是一种最佳实践，但它们在 20 世纪初苹果向 Cocoa 过渡的过程中发挥了重要作用。</p><p>例如，你可以仅 import <a href="developer.apple.com/documentation/coreservices">Core Services framework</a> 的 <a href="/dictionary-services/">DictionaryServices</a> 子模块，从而将你的代码与无数已废弃的 API（如 Carbon Core）隔离开来。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CoreServices.DictionaryServices</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">define</span><span class="params">(<span class="number">_</span> word: String)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> nsstring = word <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">    <span class="keyword">let</span> cfrange = <span class="type">CFRange</span>(location: <span class="number">0</span>, length: nsstring.length)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> definition = <span class="type">DCSCopyTextDefinition</span>(<span class="literal">nil</span>, nsstring, cfrange) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(definition.takeUnretainedValue())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define(<span class="string">"apple"</span>) <span class="comment">// "apple | ˈapəl | noun 1 the round fruit of a tree..."</span></span><br></pre></td></tr></table></figure><p>事实上，单独导入的声明和子模块，除了澄清程序员的意图，并不能带来任何真正的好处。这种方式并不会让你的代码编译地更快。由于大部分的子模块似乎都会重新导入它们的伞头文件（umbrella header），因此这种方式也没法减少自动补全列表上的噪音。</p><hr><p>与许多晦涩难懂的高级主题一样，你之所以没有听说过这些 import 声明样式，很可能的是因为你不需要了解它们。如果你已经在没有它们的情况下开发了很多 APP，那么你完全有理由可以相信，你不需要开始使用它们。</p><p>相反，这里比较有价值的收获是理解 Swift 编译器如何解决命名冲突。为此，理解 import 声明是非常重要的。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      作为软件开发人员，我们学到的第一课是如何将概念和功能组织成独立的单元。但是，当命名空间冲突和声明隐藏在阴影时，会发生什么呢？
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>用结构体和元组构建更整洁的类</title>
    <link href="https://swift.gg/2019/09/20/2019-02-24-anonymous-tuple-structs/"/>
    <id>https://swift.gg/2019/09/20/2019-02-24-anonymous-tuple-structs/</id>
    <published>2019-09-19T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Benedikt Terhechte，<a href="https://appventure.me/posts/2019-02-24-anonymous-tuple-structs.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2019-02-24<br>译者：<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://bignerdcoding.com/" target="_blank" rel="noopener">BigNerdCoding</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>假设你正在开发一款社交网络应用，其中包含了一个带有关注按钮和点赞按钮的用户图片展示组件。同时，为了满足单一功能原则（single responsibility principle）和视图控制器的构成，<strong>点赞</strong>和<strong>关注</strong>的实现应该另有它处。社交网络不仅有高级账户，也有企业账户，因此 <code>InteractiveUserImageController</code>（命名从来不是我的强项） 要能满足一系列的配置选项。以下是这个类一个可能的实现（为作展示，示例代码保留了不少可改进的地方）：<br><a id="more"></a><br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InteractiveUserImageController</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 是否需要展示高级布局</span></span><br><span class="line">    <span class="keyword">var</span> isPremium: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 账户类型</span></span><br><span class="line">    <span class="keyword">var</span> accountType: <span class="type">AccountType</span></span><br><span class="line">    <span class="comment">/// 点击视图是否高亮</span></span><br><span class="line">    <span class="keyword">var</span> isHighlighted: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 用户名</span></span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line">    <span class="comment">/// 用户头像</span></span><br><span class="line">    <span class="keyword">var</span> profileImage: <span class="type">UIImage</span></span><br><span class="line">    <span class="comment">/// 当前用户是否能点赞该用户</span></span><br><span class="line">    <span class="keyword">var</span> canLike: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 当前用户是否能关注该用户</span></span><br><span class="line">    <span class="keyword">var</span> canFollow: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 大赞按钮是否能使用</span></span><br><span class="line">    <span class="keyword">var</span> bigLikeButton: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 针对一些内容使用特殊的背景色</span></span><br><span class="line">    <span class="keyword">var</span> alternativeBackgroundColor: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(...) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，我们就有了不少参数。随着应用体量的增长，会有更多的参数被加进类里。将这些参数通过职能进行划分和重构固然可行，但有时保持了单一功能后仍会有大量的参数存在。要如何才能更好的组织代码呢？</p><h2 id="Swift-结构体结构"><a href="#Swift-结构体结构" class="headerlink" title="Swift 结构体结构"></a>Swift 结构体结构</h2><p>Swift 的 <code>struct</code> 类型在这种情况能发挥巨大的作用。依据参数的类型将它们装进<strong>一次性</strong>结构体：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InteractiveUserImageController</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DisplayOptions</span> </span>&#123;</span><br><span class="line">        <span class="comment">/// 大赞按钮是否能使用</span></span><br><span class="line">        <span class="keyword">var</span> bigLikeButton: <span class="type">Bool</span></span><br><span class="line">        <span class="comment">/// 针对一些内容使用特殊的背景色</span></span><br><span class="line">        <span class="keyword">var</span> alternativeBackgroundColor: <span class="type">Bool</span></span><br><span class="line">        <span class="comment">/// 是否需要展示高级布局</span></span><br><span class="line">        <span class="keyword">var</span> isPremium: <span class="type">Bool</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UserOptions</span> </span>&#123;</span><br><span class="line">        <span class="comment">/// 账户类型</span></span><br><span class="line">        <span class="keyword">var</span> accountType: <span class="type">AccountType</span></span><br><span class="line">        <span class="comment">/// 用户名</span></span><br><span class="line">        <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line">        <span class="comment">/// 用户头像</span></span><br><span class="line">        <span class="keyword">var</span> profileImage: <span class="type">UIImage</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        <span class="comment">/// 点击视图是否高亮</span></span><br><span class="line">        <span class="keyword">var</span> isHighlighted: <span class="type">Bool</span></span><br><span class="line">        <span class="comment">/// 当前用户是否能点赞该用户</span></span><br><span class="line">        <span class="keyword">var</span> canLike: <span class="type">Bool</span></span><br><span class="line">        <span class="comment">/// 当前用户是否能关注该用户</span></span><br><span class="line">        <span class="keyword">var</span> canFollow: <span class="type">Bool</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> displayOptions = <span class="type">DisplayOptions</span>(...)</span><br><span class="line">    <span class="keyword">var</span> userOptions = <span class="type">UserOptions</span>(...)</span><br><span class="line">    <span class="keyword">var</span> state = <span class="type">State</span>(...)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(...) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所见，我们把这些状态放入了独立的 <code>struct</code> 类型中。不仅让类更整洁，也便于新上手的开发者找到相关联的选项。</p><p>已经是一个不错的改进了，但我们能做得更好！</p><p>我们面临的问题是查找一个参数需要额外的操作。</p><p>由于使用了一次性结构体类型，我们需要在某处定义它们（例如：<code>struct DisplayOptions</code>），也需要将它们实例化（例如：<code>let displayOptions = DisplayOptions(...)</code>）。大体上来说<strong>没什么问题</strong>，但在更大的类中，为确定 <code>displayOptions</code> 的类型仍旧需要一次额外的查询。然而，与 C 语言不同，像下面这样的匿名 <code>struct</code> 在 Swift 里并不存在：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> displayOptions = <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 大赞按钮是否能使用</span></span><br><span class="line">    <span class="keyword">var</span> bigLikeButton: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 针对一些内容使用特殊的背景色</span></span><br><span class="line">    <span class="keyword">var</span> alternativeBackgroundColor: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 是否需要展示高级布局</span></span><br><span class="line">    <span class="keyword">var</span> isPremium: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元组-–-匿名结构体在-Swift-中的实现"><a href="#元组-–-匿名结构体在-Swift-中的实现" class="headerlink" title="元组 – 匿名结构体在 Swift 中的实现"></a>元组 – 匿名结构体在 Swift 中的实现</h2><p>实际上，Swift 中还真有这么一个类型。它就是我们的老朋友，<code>tuple</code>。自己看吧：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> displayOptions: (</span><br><span class="line">  bigLikeButton: <span class="type">Bool</span>,</span><br><span class="line">  alternativeBackgroundColor: <span class="type">Bool</span>,</span><br><span class="line">  isPremium: <span class="type">Bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里定义了一个新的类型 <code>displayOptions</code>，带有三个参数（<code>bigLikeButton</code>，<code>alternativeBackgroundColor</code>，<code>isPremium</code>），它能像前面的 <code>struct</code> 一样被访问：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">user.displayOptions.alternativeBackgroundColor = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>更好的是，参数定义不需要做额外的初始化，一切都井然有序。</p><h2 id="强制不可变性"><a href="#强制不可变性" class="headerlink" title="强制不可变性"></a>强制不可变性</h2><p>最后，<code>tuple</code> 既可以是 <code>可变的</code> 也可以是 <code>不可变的</code>。正如你在第一行所看到的那样：我们定义的是 <code>var displayOptions</code> 而不是 <code>var</code> 或 <code>let</code> <code>bigLikeButton</code>。<code>bigLikeButton</code> 和 <code>displayOptions</code> 一样也是 <code>var</code>。这样做的好处在于强制把静态常量（例如行高，头部高度）放入一个不同的（<code>let</code>）组。</p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>当需要用一些值初始化参数时，你也能很好的利用这个特性，这是一个加分项：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> displayOptions = (</span><br><span class="line">  bigLikeButton: <span class="literal">true</span>,</span><br><span class="line">  alternativeBackgroundColor: <span class="literal">false</span>,</span><br><span class="line">  isPremium: <span class="literal">false</span>,</span><br><span class="line">  defaultUsername: <span class="string">"Anonymous"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>与之前的代码类似，这里定义了一个元组的选项集，同时将它们正确进行了初始化。</p><h2 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h2><p>相比于使用结构体而言，使用了元组的选项集能更轻易的简化代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserFollowComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> displayOptions = (</span><br><span class="line">        likeButton: (</span><br><span class="line">            bigButton: <span class="literal">true</span>,</span><br><span class="line">            alternativeBackgroundColor: <span class="literal">true</span></span><br><span class="line">            ),</span><br><span class="line">        imageView: (</span><br><span class="line">            highlightLineWidth: <span class="number">2.0</span>,</span><br><span class="line">            defaultColor: <span class="string">"#33854"</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我希望这篇文章会对你有帮助。我大量应用这些简单的模式来让代码更具结构化。即便是只对 2 - 3 个参数做这样的处理，也能从中获益。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文描述了如何巧妙利用结构体与元组来结构化类。
    
    </summary>
    
      <category term="APPVENTURE" scheme="https://swift.gg/categories/APPVENTURE/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>千呼万唤始出来☑️：SwiftWebUI</title>
    <link href="https://swift.gg/2019/09/12/swiftwebui/"/>
    <id>https://swift.gg/2019/09/12/swiftwebui/</id>
    <published>2019-09-11T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：The Always Right Institute，<a href="http://www.alwaysrightinstitute.com/swiftwebui/" target="_blank" rel="noopener">原文链接</a>，原文日期：2019-06-30<br>译者：<a href="https://github.com/Ji4n1ng" target="_blank" rel="noopener">Ji4n1ng</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><hr><!--此处开始正文--><p>六月初，Apple 在 <a href="https://developer.apple.com/wwdc19/" target="_blank" rel="noopener">WWDC 2019</a> 上发布了 <a href="https://developer.apple.com/xcode/swiftui/" target="_blank" rel="noopener">SwiftUI</a>。SwiftUI 是一个“跨平台的”、“声明式”框架，用于构建 tvOS、macOS、watchOS 和 iOS 上的用户界面。<a href="https://github.com/SwiftWebUI/SwiftWebUI" target="_blank" rel="noopener">SwiftWebUI</a> 则将它带到了 Web 平台上✔️。</p><a id="more"></a><p><strong>免责声明</strong>：这是一个玩具项目！不要用于生产。使用 SwiftWebUI 是为了了解更多关于 SwiftUI 本身及其内部工作原理的信息。</p><h2 id="SwiftWebUI"><a href="#SwiftWebUI" class="headerlink" title="SwiftWebUI"></a>SwiftWebUI</h2><p>那么究竟什么是 <a href="https://github.com/SwiftWebUI/SwiftWebUI" target="_blank" rel="noopener">SwiftWebUI</a>？它允许你编写可以在 Web 浏览器中显示的 SwiftUI 的 <a href="https://developer.apple.com/documentation/swiftui/view" target="_blank" rel="noopener">视图</a>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftWebUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MainPage</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  @<span class="type">State</span> <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">countUp</span><span class="params">()</span></span> &#123; counter += <span class="number">1</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">      <span class="type">Text</span>(<span class="string">"🥑🍞 #\(counter)"</span>)</span><br><span class="line">        .padding(.all)</span><br><span class="line">        .background(.green, cornerRadius: <span class="number">12</span>)</span><br><span class="line">        .foregroundColor(.white)</span><br><span class="line">        .tapAction(<span class="keyword">self</span>.countUp)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/AvocadoCounter/AvocadoCounter.gif" alt></p><p>与其他一些工作不同，SwiftWebUI 不仅仅是将 SwiftUI 视图渲染为 HTML，而且还在浏览器和 Swift 服务器中托管的代码之间建立了一个连接，这样就可以实现各种交互功能——按钮、选择器、步进器、列表、导航等，这些都可以做到！</p><p>换句话说：<a href="https://github.com/SwiftWebUI/SwiftWebUI" target="_blank" rel="noopener">SwiftWebUI</a> 是针对浏览器的 SwiftUI API（很多部分但不是所有）的一种实现。</p><p>再次进行<strong>免责声明</strong>：这是一个玩具项目！不要用于生产。使用 SwiftWebUI 是为了了解更多关于 SwiftUI 本身及其内部工作原理的信息。</p><h2 id="学习一次，随处使用"><a href="#学习一次，随处使用" class="headerlink" title="学习一次，随处使用"></a>学习一次，随处使用</h2><p>SwiftUI 的既定目标不是“<a href="https://en.wikipedia.org/wiki/Write_once,_run_anywhere" target="_blank" rel="noopener">编写一次，随处运行</a>”，而是“<a href="https://developer.apple.com/videos/play/wwdc2019/216" target="_blank" rel="noopener">学习一次，随处使用</a>”。不要期望在 iOS 上开发了一个漂亮的 SwiftUI 应用程序，然后将它的代码放入 SwiftWebUI 项目中，并让它在浏览器中呈现完全相同的内容。这不是我们的重点。</p><p>关键是能够重用 SwiftUI 的原理并使其在不同平台之间共享。在这种情况下，SwiftWebUI 就达到目的了✔️。</p><p>但是先让我们深入了解一下细节，并编写一个简单的 SwiftWebUI 应用程序。本着“学习一次，随处使用”的精神，首先观看这两个 WWDC 演讲：<a href="https://developer.apple.com/videos/play/wwdc2019/204/" target="_blank" rel="noopener">介绍 SwiftUI</a> 和 <a href="https://developer.apple.com/videos/play/wwdc2019/216" target="_blank" rel="noopener">SwiftUI 要点</a>。本文不会过多的深入数据流有关的内容，但这篇演讲同样推荐观看（这些概念在 SwiftWebUI 中被广泛支持）：<a href="https://developer.apple.com/videos/play/wwdc2019/226" target="_blank" rel="noopener">SwiftUI 中的数据流</a>。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>到目前为止，SwiftWebUI 需要安装 <a href="https://www.apple.com/macos/catalina-preview/" target="_blank" rel="noopener">macOS Catalina</a> 来运行（“Swift ABI”🤦‍♀️）。幸运的是，将 <a href="https://support.apple.com/en-us/HT208891" target="_blank" rel="noopener">Catalina 安装在单独的 APFS 卷</a> 上非常容易。并且需要安装 <a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener">Xcode 11</a> 才能获得在 SwiftUI 中大量使用的 Swift 5.1 新功能。明白了吗？很好！</p><blockquote><p>Linux 呢？这个项目确实准备在 Linux 上运行，但尚未完成。唯一还没完成的事情是对 <a href="https://developer.apple.com/documentation/combine/passthroughsubject" target="_blank" rel="noopener">Combine PassthroughSubject</a> 的简单实现以及围绕它的一些基础设施。准备：<a href="https://github.com/SwiftWebUI/SwiftWebUI/blob/master/Sources/SwiftWebUI/Misc/NoCombine.swift" target="_blank" rel="noopener">NoCombine</a>。欢迎来提 PR！</p></blockquote><blockquote><p>Mojave 呢？有一个可以在 Mojave 和 Xcode 11 上运行的办法。你需要创建一个 iOS 13 模拟器项目并在其中运行整个项目。</p></blockquote><h2 id="开始第一个应用程序"><a href="#开始第一个应用程序" class="headerlink" title="开始第一个应用程序"></a>开始第一个应用程序</h2><h3 id="创建-SwiftWebUI-项目"><a href="#创建-SwiftWebUI-项目" class="headerlink" title="创建 SwiftWebUI 项目"></a>创建 SwiftWebUI 项目</h3><p>启动 Xcode 11，选择“File &gt; New &gt; Project…”或按 Cmd-Shift-N：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/1-new-project.png" alt></p><p>选择“macOS / Command Line Tool”项目模板:</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/2-new-cmdline-tool.png" alt></p><p>给它取个好听的名字，用“AvocadoToast”吧：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/3-swift-project-name.png" alt></p><p>然后，添加 <a href="https://github.com/SwiftWebUI/SwiftWebUI" target="_blank" rel="noopener">SwiftWebUI</a> 作为 Swift Package Manager 的依赖项。该选项隐藏在“File / Swift Packages”菜单中：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/4-add-pkg-dep.png" alt></p><p>输入 <code>https://github.com/SwiftWebUI/SwiftWebUI.git</code> 作为包的 URL：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/5-add-swui-dep-large.png" alt></p><p>使用“Branch” <code>master</code> 选项，以便于总能获得最新和最好的版本（也可以使用修订版或 <code>develop</code> 分支）:</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/6-branch-select-large.png" alt></p><p>最后，将 SwiftWebUI 库添加到你的工具的 <code>target</code> 中:</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/7-target-select-large.png" alt></p><p>这就完成了创建。你现在有了一个可以导入 SwiftWebUI 的工具项目。（Xcode 可能需要一些时间来获取和构建依赖。）</p><h3 id="SwiftWebUI-Hello-World"><a href="#SwiftWebUI-Hello-World" class="headerlink" title="SwiftWebUI Hello World"></a>SwiftWebUI Hello World</h3><p>让我们开始使用 SwiftWebUI。打开 <code>main.swift</code> 文件，将其内容替换为：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftWebUI</span><br><span class="line"></span><br><span class="line"><span class="type">SwiftWebUI</span>.serve(<span class="type">Text</span>(<span class="string">"Holy Cow!"</span>))</span><br></pre></td></tr></table></figure><p>在 Xcode 中编译并运行该应用程序，打开 Safari，然后访问 <a href="http://localhost:1337/" target="_blank" rel="noopener"><code>http://localhost:1337/</code></a>：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/HolyCow/holycow.png" alt></p><p>这里发生了什么：首先导入 SwiftWebUI 模块（不要意外导入 macOS SwiftUI 😀）。</p><p>然后我们调用了 <code>SwiftWebUI.serve</code>，它要么接受一个返回视图的闭包，要么就直接是一个视图——如下所示：一个 <a href="https://developer.apple.com/documentation/swiftui/text" target="_blank" rel="noopener"><code>Text</code></a> 视图（也称为“UILabel”，它可以显示纯文本或格式化的文本）。</p><h4 id="幕后发生的事情"><a href="#幕后发生的事情" class="headerlink" title="幕后发生的事情"></a>幕后发生的事情</h4><p>在内部，<a href="https://github.com/SwiftWebUI/SwiftWebUI/blob/master/Sources/SwiftWebUI/ViewHosting/Serve.swift#L66" target="_blank" rel="noopener"><code>serve</code></a> 函数创建一个非常简单的 <a href="https://github.com/apple/swift-nio" target="_blank" rel="noopener">SwiftNIO</a> HTTP 服务器，它将会监听 1337 端口。当浏览器访问该服务器时，它会创建一个 <a href="https://github.com/SwiftWebUI/SwiftWebUI/blob/master/Sources/SwiftWebUI/ViewHosting/NIOHostingSession.swift" target="_blank" rel="noopener">session</a>（会话）并将（Text）视图传递给该会话。</p><p>最后，SwiftWebUI 在服务器上根据这个视图来创建一个“Shadow DOM”，将其渲染为 HTML 并将结果发送到浏览器。“Shadow DOM”（和状态对象保持在一起）存储在会话中。</p><blockquote><p>这是 SwiftWebUI 应用程序与 watchOS 或 iOS SwiftUI 应用程序之间的区别。单个 SwiftWebUI 应用程序为一组用户提供服务，而不仅仅是一个用户。</p></blockquote><h3 id="添加一些交互"><a href="#添加一些交互" class="headerlink" title="添加一些交互"></a>添加一些交互</h3><p>第一步，更好地组织代码。在项目中创建一个新的 Swift 文件，并将其命名为 <code>MainPage.swift</code>。然后向其中添加一个简单的 SwiftUI 视图的定义：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftWebUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MainPage</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Holy Cow!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>main.swift</code> 来让 SwiftWebUI 作用于我们的定制视图:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SwiftWebUI</span>.serve(<span class="type">MainPage</span>())</span><br></pre></td></tr></table></figure><p>现在，可以把 <code>main.swift</code> 放到一边，在自定义视图中完成所有工作。添加一些交互：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MainPage</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  @<span class="type">State</span> <span class="keyword">var</span> counter = <span class="number">3</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">countUp</span><span class="params">()</span></span> &#123; counter += <span class="number">1</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Count is: \(counter)"</span>)</span><br><span class="line">      .tapAction(<span class="keyword">self</span>.countUp)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/view" target="_blank" rel="noopener"><code>视图</code></a> 有了一个名为 counter 的持久 <a href="https://developer.apple.com/documentation/swiftui/state" target="_blank" rel="noopener">状态</a> 变量（不知道这是什么？再看一下 SwiftUI 的介绍）。还有一个可以使计数器加一的小函数。</p><p>然后，使用 SwiftUI <a href="https://developer.apple.com/documentation/swiftui/text/3086357-tapaction" target="_blank" rel="noopener"><code>tapAction</code></a> 修饰符将事件处理程序附加到 <code>Text</code>。最后，在标签中显示当前值：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/HolyCow/ClickCounter.gif" alt></p><p>🧙<em>魔法</em>🧙</p><h4 id="幕后发生的事情-1"><a href="#幕后发生的事情-1" class="headerlink" title="幕后发生的事情"></a>幕后发生的事情</h4><p>这是如何运作的？当浏览器访问端点时，SwiftWebUI 在其中创建了会话和“Shadow DOM”。然后将描述视图的 HTML 发送到浏览器。<code>tapAction</code> 通过向 HTML 添加 <code>onclick</code> 处理程序来工作。SwiftWebUI 还向浏览器发送 JavaScript（少量，没有大的 JavaScript 框架！），处理点击并将其转发到 Swift 服务器。</p><p>然后 SwiftUI 的魔法开始生效。SwiftWebUI 将 click 事件与“Shadow DOM”中的事件处理程序相关联，并调用 <code>countUp</code> 函数。该函数通过修改 <code>counter</code> <a href="https://developer.apple.com/documentation/swiftui/state" target="_blank" rel="noopener"><code>状态</code></a> 变量，使视图的渲染无效。SwiftWebUI 开始工作，并对“Shadow DOM”中的变更进行差异比较。然后将这些变更发送回浏览器。</p><blockquote><p>“变更”作为 JSON 数组发送，页面中的小型 JavaScript 可以处理这些数组。如果整个子树发生了变化（例如，如果用户导航到一个全新的视图），则变更可以是应用于 <code>innerHTML</code> 或 <code>outerHTML</code> 的更大的 HTML 片段。</p><p>但通常情况下，这些变更都很小，例如 <code>添加类</code>，<code>设置 HTML 属性</code> 等（即浏览器 DOM 修改）。</p></blockquote><h2 id="🥑🍞-Avocado-Toast"><a href="#🥑🍞-Avocado-Toast" class="headerlink" title="🥑🍞 Avocado Toast"></a>🥑🍞 Avocado Toast</h2><p>太好了，基础的部分可以正常工作了。让我们引入更多的交互。以下是基于 <a href="https://developer.apple.com/videos/play/wwdc2019/216" target="_blank" rel="noopener">SwiftUI 要点</a> 演讲中演示 SwiftUI 的“Avocado Toast App”。没看过吗？你应该看看，讲的是美味的吐司。</p><blockquote><p>HTML / CSS 样式不漂亮也不完美。你知道，我们不是网页设计师，而且需要帮助。欢迎来提交 PR！</p></blockquote><p>想要跳过细节，观看应用程序的 GIF 并在 GitHub 上下载：<a href="http://www.alwaysrightinstitute.com/swiftwebui/#the--finished-app" target="_blank" rel="noopener">🥑🍞</a>。</p><h3 id="🥑🍞订单"><a href="#🥑🍞订单" class="headerlink" title="🥑🍞订单"></a>🥑🍞订单</h3><p>谈话从这（~6:00）开始，可以将这些代码添加到新的 <code>OrderForm.swift</code> 文件中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> includeSalt            = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> includeRedPepperFlakes = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> quantity               = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OrderForm</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> order = <span class="type">Order</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">submitOrder</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">      <span class="type">Text</span>(<span class="string">"Avocado Toast"</span>).font(.title)</span><br><span class="line">      </span><br><span class="line">      <span class="type">Toggle</span>(isOn: $order.includeSalt) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Include Salt"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Toggle</span>(isOn: $order.includeRedPepperFlakes) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Include Red Pepper Flakes"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Stepper</span>(value: $order.quantity, <span class="keyword">in</span>: <span class="number">1</span>...<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Quantity: \(order.quantity)"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="type">Button</span>(action: submitOrder) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Order"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>main.swift</code> 中直接用 <code>SwiftWebUI.serve()</code> 测试新的 <code>OrderForm</code> 视图。</p><p>这就是浏览器中的样子：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/AvocadoOrder/orderit.gif" alt></p><blockquote><p><a href="https://semantic-ui.com/" target="_blank" rel="noopener">SemanticUI</a> 用于在 SwiftWebUI 中设置一些样式。SemanticUI 并不是必须的，这里只是用它的控件来美化界面。</p><p>注意：仅使用 CSS 和字体，而不是 JavaScript 组件。</p></blockquote><h3 id="幕间休息：一些-SwiftUI-布局"><a href="#幕间休息：一些-SwiftUI-布局" class="headerlink" title="幕间休息：一些 SwiftUI 布局"></a>幕间休息：一些 SwiftUI 布局</h3><p>在 <a href="https://developer.apple.com/videos/play/wwdc2019/216" target="_blank" rel="noopener">SwiftUI 要点</a> 演讲的 16:00 左右，他们将介绍 SwiftUI 布局和视图修改器排序：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">  <span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"🥑🍞"</span>)</span><br><span class="line">      .background(.green, cornerRadius: <span class="number">12</span>)</span><br><span class="line">      .padding(.all)</span><br><span class="line">    </span><br><span class="line">    <span class="type">Text</span>(<span class="string">" =&gt; "</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="type">Text</span>(<span class="string">"🥑🍞"</span>)</span><br><span class="line">      .padding(.all)</span><br><span class="line">      .background(.green, cornerRadius: <span class="number">12</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下，请注意修饰符的排序是如何相关的：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/AvocadoLayout.png" alt></p><blockquote><p>SwiftWebUI 尝试复制常见的 SwiftUI 布局，但还没有完全成功。毕竟它必须处理浏览器提供的布局系统。需要帮助，欢迎弹性盒布局相关的专家！</p></blockquote><h3 id="🥑🍞订单历史"><a href="#🥑🍞订单历史" class="headerlink" title="🥑🍞订单历史"></a>🥑🍞订单历史</h3><p>回到应用程序，演讲（~19:50）介绍了 <a href="https://developer.apple.com/documentation/swiftui/list" target="_blank" rel="noopener">列表</a> 视图，用于显示 Avocado toast 订单历史记录。这就是它在 Web 上的外观：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/OrderHistory/OrderHistory1.png" alt></p><p><code>列表</code> 视图遍历已完成订单的数组，并为每个订单创建一个子视图（<code>OrderCell</code>），并传入列表中的当前项。</p><p>这是我们使用的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OrderHistory</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> previousOrders : [ <span class="type">CompletedOrder</span> ]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">List</span>(previousOrders) &#123; order <span class="keyword">in</span></span><br><span class="line">      <span class="type">OrderCell</span>(order: order)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OrderCell</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> order : <span class="type">CompletedOrder</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">HStack</span> &#123;</span><br><span class="line">      <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">        <span class="type">Text</span>(order.summary)</span><br><span class="line">        <span class="type">Text</span>(order.purchaseDate)</span><br><span class="line">          .font(.subheadline)</span><br><span class="line">          .foregroundColor(.secondary)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Spacer</span>()</span><br><span class="line">      <span class="keyword">if</span> order.includeSalt &#123;</span><br><span class="line">        <span class="type">SaltIcon</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">      <span class="keyword">if</span> order.includeRedPepperFlakes &#123;</span><br><span class="line">        <span class="type">RedPepperFlakesIcon</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SaltIcon</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> body = <span class="type">Text</span>(<span class="string">"🧂"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedPepperFlakesIcon</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> body = <span class="type">Text</span>(<span class="string">"🌶"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Model</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CompletedOrder</span>: <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id           : <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> summary      : <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> purchaseDate : <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> includeSalt            = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> includeRedPepperFlakes = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SwiftWebUI 列表视图效率很低，它总是呈现整个子集合。没有单元格重用，什么都没有😎。在一个网络应用程序中有各种各样的方法来处理这个问题，例如使用分页或更多客户端逻辑。</p></blockquote><p>你不必手动输入演讲中的样本数据，我们为你提供了这些数据：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> previousOrders : [ <span class="type">CompletedOrder</span> ] = [</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">1</span>, summary: <span class="string">"Rye with Almond Butter"</span>,  purchaseDate: <span class="string">"2019-05-30"</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">2</span>, summary: <span class="string">"Multi-Grain with Hummus"</span>, purchaseDate: <span class="string">"2019-06-02"</span>,</span><br><span class="line">        includeRedPepperFlakes: <span class="literal">true</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">3</span>, summary: <span class="string">"Sourdough with Chutney"</span>,  purchaseDate: <span class="string">"2019-06-08"</span>,</span><br><span class="line">        includeSalt: <span class="literal">true</span>, includeRedPepperFlakes: <span class="literal">true</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">4</span>, summary: <span class="string">"Rye with Peanut Butter"</span>,  purchaseDate: <span class="string">"2019-06-09"</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">5</span>, summary: <span class="string">"Wheat with Tapenade"</span>,     purchaseDate: <span class="string">"2019-06-12"</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">6</span>, summary: <span class="string">"Sourdough with Vegemite"</span>, purchaseDate: <span class="string">"2019-06-14"</span>,</span><br><span class="line">        includeSalt: <span class="literal">true</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">7</span>, summary: <span class="string">"Wheat with Féroce"</span>,       purchaseDate: <span class="string">"2019-06-31"</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">8</span>, summary: <span class="string">"Rhy with Honey"</span>,          purchaseDate: <span class="string">"2019-07-03"</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">9</span>, summary: <span class="string">"Multigrain Toast"</span>,        purchaseDate: <span class="string">"2019-07-04"</span>,</span><br><span class="line">        includeSalt: <span class="literal">true</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id: <span class="number">10</span>, summary: <span class="string">"Sourdough with Chutney"</span>,  purchaseDate: <span class="string">"2019-07-06"</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="🥑🍞涂抹酱选择器"><a href="#🥑🍞涂抹酱选择器" class="headerlink" title="🥑🍞涂抹酱选择器"></a>🥑🍞涂抹酱选择器</h3><p>选择器控件以及如何将它与枚举一起使用将在（~43:00）进行演示。首先是各种吐司选项的枚举：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AvocadoStyle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> sliced, mashed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BreadType</span>: <span class="title">CaseIterable</span>, <span class="title">Hashable</span>, <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> wheat, white, rhy</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"\(self)"</span>.capitalized &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Spread</span>: <span class="title">CaseIterable</span>, <span class="title">Hashable</span>, <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">none</span>, almondButter, peanutButter, honey</span><br><span class="line">  <span class="keyword">case</span> almou, tapenade, hummus, mayonnaise</span><br><span class="line">  <span class="keyword">case</span> kyopolou, adjvar, pindjur</span><br><span class="line">  <span class="keyword">case</span> vegemite, chutney, cannedCheese, feroce</span><br><span class="line">  <span class="keyword">case</span> kartoffelkase, tartarSauce</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(self)"</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span>.isUppercase ? <span class="string">" \($0)"</span> : <span class="string">"\($0)"</span> &#125;</span><br><span class="line">           .joined().capitalized</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将这些代码添加到 <code>Order</code> 结构体中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> includeSalt            = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> includeRedPepperFlakes = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> quantity               = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> avocadoStyle           = <span class="type">AvocadoStyle</span>.sliced</span><br><span class="line">  <span class="keyword">var</span> spread                 = <span class="type">Spread</span>.<span class="keyword">none</span></span><br><span class="line">  <span class="keyword">var</span> breadType              = <span class="type">BreadType</span>.wheat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用不同的选择器类型来显示它们。如何循环枚举值非常简单：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Form</span> &#123;</span><br><span class="line">  <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"Avocado Toast"</span>).font(.title)) &#123;</span><br><span class="line">    <span class="type">Picker</span>(selection: $order.breadType, label: <span class="type">Text</span>(<span class="string">"Bread"</span>)) &#123;</span><br><span class="line">      <span class="type">ForEach</span>(<span class="type">BreadType</span>.allCases) &#123; breadType <span class="keyword">in</span></span><br><span class="line">        <span class="type">Text</span>(breadType.name).tag(breadType)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .pickerStyle(.radioGroup)</span><br><span class="line">    </span><br><span class="line">    <span class="type">Picker</span>(selection: $order.avocadoStyle, label: <span class="type">Text</span>(<span class="string">"Avocado"</span>)) &#123;</span><br><span class="line">      <span class="type">Text</span>(<span class="string">"Sliced"</span>).tag(<span class="type">AvocadoStyle</span>.sliced)</span><br><span class="line">      <span class="type">Text</span>(<span class="string">"Mashed"</span>).tag(<span class="type">AvocadoStyle</span>.mashed)</span><br><span class="line">    &#125;</span><br><span class="line">    .pickerStyle(.radioGroup)</span><br><span class="line">    </span><br><span class="line">    <span class="type">Picker</span>(selection: $order.spread, label: <span class="type">Text</span>(<span class="string">"Spread"</span>)) &#123;</span><br><span class="line">      <span class="type">ForEach</span>(<span class="type">Spread</span>.allCases) &#123; spread <span class="keyword">in</span></span><br><span class="line">        <span class="type">Text</span>(spread.name).tag(spread) <span class="comment">// there is no .name?!</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/AvocadoOrder/picker.png" alt></p><blockquote><p>同样，这需要一些对 CSS 的热爱来让它看起来更好看…</p></blockquote><h3 id="完成后的🥑🍞应用"><a href="#完成后的🥑🍞应用" class="headerlink" title="完成后的🥑🍞应用"></a>完成后的🥑🍞应用</h3><p>不，我们与原版略有不同，也没有真正完成应用。它看起来并不那么棒，但毕竟只是一个演示示例😎。</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/AvocadoOrder/AvocadoToast.gif" alt></p><p>完成后的应用程序可在GitHub：<a href="https://github.com/SwiftWebUI/AvocadoToast" target="_blank" rel="noopener">AvocadoToast</a> 上获取。</p><h2 id="HTML-和-SemanticUI"><a href="#HTML-和-SemanticUI" class="headerlink" title="HTML 和 SemanticUI"></a>HTML 和 SemanticUI</h2><p><a href="https://developer.apple.com/documentation/swiftui/uiviewrepresentable" target="_blank" rel="noopener"><code>UIViewRepresentable</code></a> 在 SwiftWebUI 中对应的实现，是直接使用原始 HTML。</p><p>它提供了两种变体，一种是 HTML 按原样输出字符串，另一种是通过 HTML 转义内容：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyHTMLView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">      <span class="type">HTML</span>(<span class="string">"&lt;blink&gt;Blinken Lights&lt;/blink&gt;"</span>)</span><br><span class="line">      <span class="type">HTML</span>(<span class="string">"42 &gt; 1337"</span>, escape: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个原语，基本上可以构建所需的任何 HTML。</p><p>还有一种更高级的用法是 HTMLContainer，SwiftWebUI 内部也用到了它。例如，这是步进器控件的实现：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">  <span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">HTMLContainer</span>(classes: [ <span class="string">"ui"</span>, <span class="string">"icon"</span>, <span class="string">"buttons"</span>, <span class="string">"small"</span> ]) &#123;</span><br><span class="line">      <span class="type">Button</span>(<span class="keyword">self</span>.decrement) &#123;</span><br><span class="line">        <span class="type">HTMLContainer</span>(<span class="string">"i"</span>, classes: [ <span class="string">"minus"</span>, <span class="string">"icon"</span> ], body: &#123;<span class="type">EmptyView</span>()&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Button</span>(<span class="keyword">self</span>.increment) &#123;</span><br><span class="line">        <span class="type">HTMLContainer</span>(<span class="string">"i"</span>, classes: [ <span class="string">"plus"</span>, <span class="string">"icon"</span> ], body: &#123;<span class="type">EmptyView</span>()&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    label</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTMLContainer 是“响应式的”，即如果类、样式或属性发生变化，它将触发（emit）常规 DOM 变更（而不是重新渲染整个内容）。</p><h3 id="SemanticUI"><a href="#SemanticUI" class="headerlink" title="SemanticUI"></a>SemanticUI</h3><p>SwiftWebUI 还附带了一些预先设置的 <a href="https://semantic-ui.com/" target="_blank" rel="noopener">SemanticUI</a> 控件：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">  <span class="type">SUILabel</span>(<span class="type">Image</span>(systemName: <span class="string">"mail"</span>)) &#123; <span class="type">Text</span>(<span class="string">"42"</span>) &#125;</span><br><span class="line">  <span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">SUILabel</span>(<span class="type">Image</span>(...)) &#123; <span class="type">Text</span>(<span class="string">"Joe"</span>) &#125; ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">SUILabel</span>(<span class="type">Image</span>(...)) &#123; <span class="type">Text</span>(<span class="string">"Joe"</span>) &#125; ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">SUILabel</span>(<span class="type">Image</span>(...), <span class="type">Color</span>(<span class="string">"blue"</span>), </span><br><span class="line">             detail: <span class="type">Text</span>(<span class="string">"Friend"</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">Text</span>(<span class="string">"Veronika"</span>)</span><br><span class="line">    &#125; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>……渲染为如下内容：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/SemanticUI/labels.png" alt></p><blockquote><p>请注意，SwiftWebUI 还支持一些 SFSymbols 图像名称（通过 <code>Image(systemName:)</code> 来使用）。这些都得到了 SemanticUI <a href="https://semantic-ui.com/elements/icon.html" target="_blank" rel="noopener">对 Font Awesome 的支持</a>。</p></blockquote><p>还有 <code>SUISegment</code>，<code>SUIFlag</code> 和 <code>SUICARD</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SUICards</span> &#123;</span><br><span class="line">  <span class="type">SUICard</span>(<span class="type">Image</span>.unsplash(size: <span class="type">UXSize</span>(width: <span class="number">200</span>, height: <span class="number">200</span>),</span><br><span class="line">                         <span class="string">"Zebra"</span>, <span class="string">"Animal"</span>),</span><br><span class="line">          <span class="type">Text</span>(<span class="string">"Some Zebra"</span>),</span><br><span class="line">          meta: <span class="type">Text</span>(<span class="string">"Roaming the world since 1976"</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"A striped animal."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">SUICard</span>(<span class="type">Image</span>.unsplash(size: <span class="type">UXSize</span>(width: <span class="number">200</span>, height: <span class="number">200</span>),</span><br><span class="line">                         <span class="string">"Cow"</span>, <span class="string">"Animal"</span>),</span><br><span class="line">          <span class="type">Text</span>(<span class="string">"Some Cow"</span>),</span><br><span class="line">          meta: <span class="type">Text</span>(<span class="string">"Milk it"</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Holy cow!."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>……渲染为这些内容：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/SemanticUI/cards.png" alt></p><p>添加此类视图非常简单，也非常有趣。可以使用 <del>WOComponent</del> 的 SwiftUI 视图来快速构建相当复杂和美观的布局。</p><blockquote><p><code>Image.unsplash</code> 根据 <code>http://source.unsplash.com</code> 上运行的 Unsplash API 来构建图像的查询。只需给它一些查询词、大小和可选范围。</p><p>注意：有时，特定的 Unsplash 服务似乎有点慢且不可靠。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这就是我们的演示示例。我们希望你能喜欢！但要再次进行<strong>免责声明</strong>：这是一个玩具项目！不要用于生产。使用 SwiftWebUI 是为了了解更多关于 SwiftUI 本身及其内部工作原理的信息。</p><p>我们认为它是一个很好的玩具，可能也是一个有价值的工具，以便于更多地了解 SwiftUI 的内部工作原理。</p><h2 id="技术随记"><a href="#技术随记" class="headerlink" title="技术随记"></a>技术随记</h2><p>这些只是关于该技术的各个方面的一些笔记。可以跳过，这个不是那么的有趣😎。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>SwiftWebUI 有很多问题，有些是在 GitHub 上提出的：<a href="https://github.com/SwiftWebUI/SwiftWebUI/issues" target="_blank" rel="noopener">Issues</a>。欢迎来提更多问题。</p><p>相当多的 HTML 布局的东西有问题（例如 <code>ScrollView</code> 并不总是滚动的），还有一些像 Shapes 这样的正在讨论方案的功能也有问题（可能通过 SVG 和 CSS 很容易做到）。</p><p>哦，还有一个例子是 If-ViewBuilder 不能正常工作。不明白为什么：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">  <span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">      <span class="type">SomeView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// currently need an empty else: `else &#123;&#125;` to make it compile.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要帮忙！欢迎来提交 PR！</p><h3 id="与原来的-SwiftUI-相比"><a href="#与原来的-SwiftUI-相比" class="headerlink" title="与原来的 SwiftUI 相比"></a>与原来的 SwiftUI 相比</h3><p>本文的实现非常简单且效率低下。在现实情况下，必须以更高的速率来处理状态修改事件，以 60Hz 的帧速率做所有的动画等等。</p><p>我们侧重于使基本操作正确，例如状态和绑定如何工作，视图如何以及何时更新等等。很可能本文的实现在某些方面并不正确，可能是因为 Apple 忘了将原始资源作为 Xcode 11 的一部分发送给我们。</p><h3 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h3><p>我们目前使用 AJAX 将浏览器连接到服务器。使用 WebSockets 有多种优势：</p><ul><li>保证了事件的顺序（AJAX 请求可能不同步到达）</li><li>非用户发起的服务器端 DOM 更新（定时器、推送）</li><li>会话超时指示器</li></ul><p>这会让实现一个聊天客户端的演示示例变得非常容易。</p><p>添加 WebSockets 实际上非常简单，因为事件已经作为 JSON 发送了。我们只需要客户端和服务器端的垫片（shims）。所有这些都已经在 <a href="https://github.com/NozeIO/swift-nio-irc-webclient" target="_blank" rel="noopener">swift-nio-irc-webclient</a> 中试用过了，只需要移植一下。</p><h3 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h3><p>SwiftWebUI 的当前版本是一个连接到有状态后端服务器的 SPA（单页面应用程序）。</p><p>还有其他方法可以做到这一点，例如，当用户通过正常的链接遍历应用程序时，保持树的状态。又名 WebObjects。;-)</p><p>一般来说，最好能更好地控制 DOM ID 生成、链接生成以及路由等等。这和 <a href="http://swiftobjects.org/" target="_blank" rel="noopener">SwiftObjects</a> 所提供的方式类似。</p><p>但是最终用户将不得不放弃很多本可以“学习一次，随处使用”的功能，因为 SwiftUI 操作处理程序通常是围绕着捕捉任意状态的事实来构建的。</p><p>我们将会期待基于 Swift 的服务器端框架提出什么更好的东西来👽。</p><h3 id="WASM"><a href="#WASM" class="headerlink" title="WASM"></a>WASM</h3><p>一旦我们找到合适的 Swift WASM（WebAssembly），SwiftWebUI 就会更有用处。期待 WASM！</p><h3 id="WebIDs"><a href="#WebIDs" class="headerlink" title="WebIDs"></a>WebIDs</h3><p>有些像 <code>ForEach</code> 这样的 SwiftUI 视图需要 <code>Identifiable</code> 对象，其中的 <code>id</code> 可以是任何 <code>Hashable</code>。这在 DOM 中不太好，因为我们需要基于字符串的 ID 来识别节点。</p><p>这是通过将 ID 映射到全局映射中的字符串来解决的。这在技术上是无界的（一个类引用的特定问题）。</p><p>总结：对于 web 代码，最好使用字符串或整型来标识个体。</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>表单需要做得更好：<a href="https://github.com/SwiftWebUI/SwiftWebUI/issues/10" target="_blank" rel="noopener">Issue</a>。</p><p>SemanticUI 有一些很好的表单布局，我们可能参照这些布局重写子树。有待商榷。</p><h2 id="面向-Swift-的-WebObjects-6"><a href="#面向-Swift-的-WebObjects-6" class="headerlink" title="面向 Swift 的 WebObjects 6"></a>面向 Swift 的 WebObjects 6</h2><p>花了点时间在文章中嵌入了下面这个可点击的 Twitter 控件。（译者注：由于某些原因，这里没办法像原文一样嵌入 Twitter 控件，只能放链接。）</p><p><a href="https://twitter.com/helje5/status/1137092138104233987/photo/1?ref_src=twsrc^tfw|twcamp^tweetembed|twterm^1137092138104233987&amp;ref_url=http%3A%2F%2Fwww.alwaysrightinstitute.com%2Fswiftwebui%2F" target="_blank" rel="noopener">https://twitter.com/helje5/status/1137092138104233987/photo/1?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1137092138104233987&amp;ref_url=http%3A%2F%2Fwww.alwaysrightinstitute.com%2Fswiftwebui%2F</a></p><p>苹果确实给了我们一个“Swift 风格”的 WebObjects 6！</p><p>下一篇：直面 Web 和一些 Swift 化的 EOF（又名 CoreData 又名 ZeeQL）。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>GitHub：<a href="https://github.com/SwiftWebUI/SwiftWebUI" target="_blank" rel="noopener">SwiftWebUI</a></li><li>SwiftUI<ul><li><a href="https://developer.apple.com/videos/play/wwdc2019/204/" target="_blank" rel="noopener">介绍 SwiftUI</a>（204）</li><li><a href="https://developer.apple.com/videos/play/wwdc2019/216" target="_blank" rel="noopener">SwiftUI 要点</a> （216）</li><li><a href="https://developer.apple.com/videos/play/wwdc2019/226" target="_blank" rel="noopener">SwiftUI 中的数据流</a>（226）</li><li><a href="https://developer.apple.com/documentation/swiftui" target="_blank" rel="noopener">SwiftUI 框架 API</a></li></ul></li><li><a href="http://swiftobjects.org/" target="_blank" rel="noopener">SwiftObjects</a></li><li>SemanticUI<ul><li><a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome</a></li><li><a href="https://github.com/SwiftWebResources/SemanticUI-Swift" target="_blank" rel="noopener">SemanticUI Swift</a></li></ul></li><li><a href="https://github.com/apple/swift-nio" target="_blank" rel="noopener">SwiftNIO</a></li></ul><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p>嘿，我们希望你能喜欢这篇文章，并且也希望得到你的反馈！</p><p>Twitter（任何一个都可以）：<a href="https://twitter.com/helje5" target="_blank" rel="noopener">@helje5</a>，<a href="https://twitter.com/ar_institute" target="_blank" rel="noopener">@ar_institute</a>。</p><p>电子邮件：<a href="mailto:wrong@alwaysrightinstitute.com" target="_blank" rel="noopener">wrong@alwaysrightinstitute.com</a></p><p>Slack：在 SwiftDE、swift-server、noze、ios-developers 上找到我们。</p><p><em>写于 2019 年 6 月 30 日</em></p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文是关于 SwiftWebUI 的介绍。SwiftWebUI 将 SwiftUI 带到了 Web 平台上。
    
    </summary>
    
      <category term="The Always Right Institute" scheme="https://swift.gg/categories/The-Always-Right-Institute/"/>
    
    
      <category term="Swift 跨平台" scheme="https://swift.gg/tags/Swift-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的面向协议编程：引言</title>
    <link href="https://swift.gg/2019/09/05/protocol-oriented-programming/"/>
    <id>https://swift.gg/2019/09/05/protocol-oriented-programming/</id>
    <published>2019-09-04T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://www.appcoda.com/protocol-oriented-programming/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-03-20<br>译者：<a href="https://github.com/dzyding" target="_blank" rel="noopener">灰s</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>对于开发者来说，复杂性是最大的敌人，因此我会去了解那些可以帮助我管理混乱的新技术。Swift 中的“面向协议编程”（POP）是最近（至少自2015年以来）引起广泛关注的“热门”方法之一。在这里我们将使用 Swift 4。在我自己编写代码时，发现 POP 很有前途。更吸引人的是，Apple 宣称 <a href="https://developer.apple.com/videos/play/wwdc2015/408/?time=868" target="_blank" rel="noopener"><strong>“Swift 的核心是面对协议的”</strong></a>。我想在一个正式的报告中分享关于 POP 的经验，一篇关于这个新兴技术清晰而简洁的教程。  </p><p>我将解释关键概念，提供大量代码示例，无法避免的将 POP 和 OOP （面向对象编程）进行比较，并对面向流行编程（FOP?）的人群所声称的 POP 是解决所有问题的灵丹妙药这一说法进行泼冷水。  </p><p>面向协议编程是一个很棒的新工具，值得<em>添加到你现有的编程工具库中</em>，但是<strong>没有什么</strong>可以代替那些经久不衰的基本功，就像将大的函数拆分成若干个小函数，将大的代码文件拆分成若干个小的文件，使用有意义的变量名，在敲代码之前花时间设计架构，合理而一致的使用间距和缩进，将相关的属性和行为分配到类和结构体中 - 遵循这些常识可以让世界变得不同。如果你编写的代码无法被同事理解，那它就是无用的代码。  </p><p>学习和采用像 POP 这样的新技术并不需要绝对的唯一。POP 和 OOP 不仅可以共存，还可以互相协助。对于大多数开发者包括我自己，掌握 POP 需要时间和耐心。因为 POP 真的很重要，所以我将教程分成两篇文章。本文将主要介绍和解释 Swift 的协议和 POP。第二篇文章将深入研究 POP 的高级应用方式（比如从协议开始构建应用程序的功能），范型协议，从引用类型到值类型转变背后的动机，列举 POP 的利弊，列举 OOP 的利弊，比较 OOP 和 POP，阐述为什么“Swift 是面向协议的”，并且深入研究一个被称为 <a href="https://developer.apple.com/videos/play/wwdc2016/419/?time=41" target="_blank" rel="noopener"><strong>“局部推理”</strong></a> 的概念，它被认为是通过使用 POP 增强的。这次我们只会粗略涉及一些高级主题。<br><a id="more"></a> </p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>作为软件开发者，<strong>管理复杂性</strong>本质上是我们最应该关注的问题。当我们尝试学习 POP 这项新技术时，你可能无法从时间的投资中看到即时回报。但是，就像你对我的认识有个过程一样，你将会了解 <a href="https://developer.apple.com/videos/play/wwdc2015/408/" target="_blank" rel="noopener"><strong>POP 处理复杂性的方法</strong></a>，同时为你提供另一种工具来控制软件系统中固有的混乱。  </p><p>我听到越来越多关于 POP 的<em>讨论</em>，但是却很少看到使用这种方式编写的产品代码，换句话说，我还没有看到有很多人从协议而不是类开始创建应用程序的功能。这不仅仅是因为人类有抗拒改变的倾向。学习一种全新的范式并将其付诸实践，说起来容易做起来难。在我编写新应用程序时，逐渐发现自己开始使用 POP 来设计和实现功能 — 有组织的且自然而然的。  </p><p>伴随着新潮流带来的刺激，很多人都在谈论用 POP <em>取代</em> OOP。我认为除非像 Swift 这样的 POP 语言被广泛改进，否则这是不可能发生的 — 也或许根本就不会发生。我是个实用主义者，而不是追求时髦的人。在开发新的 Swift 项目时，我发现自己的行为是一种折衷的方法。我在合理的地方利用 OOP，而用 POP 更合适的地方也不会死脑筋的一定要使用 OOP，这样反而了解到这两种模式<strong>并不</strong>相互排斥。我把这两种技术结合在一起。在本期由两部分组成的 POP 教程中，你将了解我在说什么。  </p><p>我投入到 OOP 中已经有很久了。1990 年，我买了一个零售版本的 Turbo Pascal。在使用了 OOP 大约一年后，我开始设计、开发和发布面向对象的应用程序产品。我成了一个忠粉。当我发现可以<strong>扩展</strong>和<strong>增强</strong>自己的类，简直兴奋的飞起。随着时间的推移，Microsoft 和 Apple 等公司开始开发基于 OOP 的大型代码库，如 Microsoft Foundation Classes（MFC）和 .NET，以及 iOS 和 OS X SDK。现在，开发人员在开发新应用程序时很少需要重新造轮子。没有完美的方法，OOP 也有一些缺点，但是优点仍然大于缺点。我们将花一些时间来比较 OOP 和 POP。  </p><h2 id="理解协议"><a href="#理解协议" class="headerlink" title="理解协议"></a>理解协议</h2><p>当开发人员设计一个新的 iOS 应用程序的基本结构时，他们几乎总是从 <code>Foundation</code> 和 <code>UIKit</code> 等框架中的现有 <code>类</code> 开始。我能想到的几乎所有应用程序都需要某种用户界面导航系统。用户需要一些进入应用程序的入口点和引导他们使用应用程序功能的路标。可以浏览一下你的 iPhone 或 iPad 上的应用程序。  </p><p>当这些应用程序打开时，你看到了什么？我打赌你看到的是 <code>UITableViewController</code>，<code>UICollectionViewController</code> 和 <code>UIPageViewController</code> 的子类。  </p><p>当你第一次创建新的 iOS 项目时，所有人都必须认识下面的代码片段，例如，一个新的 iOS 项目基于 Xcode 中的 <code>Single View App（单视图应用）</code> 模板：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>部分开发人员将在这里停下来，创建完全定制的接口，但大多数人将采取另一个步骤。  </p><p>当 iOS 开发者开发新的应用程序时，最常见的特征就是 OOP，那么 POP 在这里扮演什么角色呢？  </p><p>你知道我将怎样继续么？想象大多数开发人员的下一个主要步骤是什么。那就是<strong>遵循协议</strong>（并实现 <a href="https://appcoda.com/swift-delegate/" target="_blank" rel="noopener"><strong>委托，但我们已经讨论过了</strong></a>）。  </p><p>让我给你们看一个例子使其便于理解。我相信你们很多人都用过 <code>UITableView</code>。虽然这不是一个关于 <code>UITableView</code> 的教程，但是你应该知道在 <code>UIViewController</code> 中将其实现时，协议扮演着重要的角色。在向 <code>UIViewController</code> 中添加 <code>UITableView</code>时，<code>UIViewController</code> 必须<strong>遵循</strong> <code>UITableViewDataSource</code> 和 <code>UITableViewDelegate</code> 协议，就像这样：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span></span></span><br></pre></td></tr></table></figure><p>简而言之，遵循 <code>UITableViewDataSource</code> 允许你用数据填充所有的 <code>UITableViewCell</code>，比如给用户提供导航的菜单项名称。采用 <code>UITableViewDelegate</code>，你可以对用户与 <code>UITableView</code> 的交互进行更细粒度的控制，比如在用户点击特定的 <code>UITableViewCell</code> 时执行适当的操作。  </p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>我发现，在进行技术性定义和讨论之前，理解常用的术语定义可以帮助读者更好地理解某个主题。首先，让我们 考虑 <a href="https://en.oxforddictionaries.com/definition/protocol" target="_blank" rel="noopener"><strong>“协议”一词的通俗定义</strong></a>：  </p><blockquote><p>……管理国家事务或外交领域的正式程序或规则体系。……<br>在任何团体、组织或形势下，公认或已制定的程序或行为准则。……<br>进行科学实验时的程序……</p></blockquote><p>Apple 的“Swift 编程语言（Swift 4.0.3）” <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" target="_blank" rel="noopener">文档中的声明</a>：  </p><blockquote><p>协议定义了适合特定任务或功能的方法、属性和其他需求的蓝图。然后，类、结构体或枚举可以遵循该协议来提供这些需求的实际实现。任何满足协议要求的类型都被称为遵循该协议。</p></blockquote><p>协议是最重要的工具之一，我们必须给软件固有的混乱带来一些秩序。协议使我们能够要求一个或多个类和结构体包含特定的最小且必需的属性，和/或提供特定的最小且必需的实现/方法。通过 <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID521" target="_blank" rel="noopener"><strong>协议扩展</strong></a>，我们可以为一些或所有协议的方法提供默认实现。  </p><h3 id="遵循协议"><a href="#遵循协议" class="headerlink" title="遵循协议"></a>遵循协议</h3><p>下面，我们将使自定义的 <code>Person</code> 类<strong>遵循</strong>（<strong>采用</strong>）Apple 自带 <a href="https://developer.apple.com/documentation/swift/equatable" target="_blank" rel="noopener"><code>Equatable</code></a> 协议。  </p><blockquote><p>遵循 Equatable 协议以后可以使用等于运算符（==）来判断是否相等，使用不等于运算符（!=）来判断是否不等。Swift 标准库中的大部分基础类型都遵循了 Equatable 协议……  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Equatable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> weight:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> sex:<span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(weight:<span class="type">Int</span>, name:<span class="type">String</span>, sex:<span class="type">String</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.weight = weight</span><br><span class="line">        <span class="keyword">self</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Person, rhs: Person)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> lhs.weight == rhs.weight &amp;&amp;</span><br><span class="line">            lhs.name == rhs.name &amp;&amp;</span><br><span class="line">            lhs.sex == rhs.sex</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Apple <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" target="_blank" rel="noopener">规定</a>，“自定义类型声明它们采用特定的协议，需要将协议的名称放在类型名称之后，以冒号分隔，作为其定义的一部分。”这也正是我所做的：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Equatable</span></span></span><br></pre></td></tr></table></figure><p>你可以将协议理解为专门针对 <code>class</code>、<code>struct</code> 或 <code>enum</code> 的<strong>约定</strong>或<strong>承诺</strong>。我通过 <code>Equatable</code> 协议使自定义的 <code>Person</code> 类遵守了一个约定，<code>Person</code> 类<strong><em>承诺</em></strong>通过现实 <code>Equatable</code> 协议需要的方法或成员变量来履行该约定，即将其实现。  </p><p><code>Equatable</code> 协议<strong><em>并没有实现任何东西</em></strong>。它只是指明了<strong><em>采用（遵循）</em></strong> <code>Equatable</code> 协议的 <code>class</code>，<code>struct</code>，或者 <code>enum</code> <strong><em>必须实现</em></strong>的方法和/或成员变量。有一些协议通过 <code>extensions</code> 实现了功能，稍后我们会进行讨论。我不会花太多时间来讲述关于 <code>enum</code> 的 POP 用法。我将它作为练习留给你。  </p><h3 id="定义协议"><a href="#定义协议" class="headerlink" title="定义协议"></a>定义协议</h3><p>理解协议最好的方式是通过例子。我将自己构建一个 <code>Equatable</code> 来向你展示协议的用法：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">IsEqual</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> != <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请记住，我的“IsEqual”协议并没有对 <code>==</code> 和 <code>!=</code> 运算符进行实现。“IsEqual”需要协议的遵循者<strong><em>实现他们自己的</em></strong> <code>==</code> 和 <code>!=</code> 运算符。  </p><p>所有定义协议属性和方法的规则都在 <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" target="_blank" rel="noopener"><strong>Apple 的 Swift 文档</strong></a> 中进行了总结。比如，在协议中定义属性永远不要用 <code>let</code> 关键字。只读属性规定使用 <code>var</code> 关键字，并在后面单独跟上 <code>{ get }</code>。如果有一个方法改变了一个或多个属性，你需要标记它为 <code>mutating</code>。你需要知道为什么我重写的 <code>==</code> 和 <code>!=</code> 操作符被定义为 <code>static</code>。如果你不知道，找出原因将会是一个很好的练习。  </p><p>为了向你展示我的 <code>IsEqual</code>（或者 <code>Equatable</code>）这样的协议具有广泛的适用性，我们将使用它在下面构建一个类。但是在我们开始之前，让我们先讨论一下“引用类型”与“值类型”。  </p><h2 id="引用类型与值类型"><a href="#引用类型与值类型" class="headerlink" title="引用类型与值类型"></a>引用类型与值类型</h2><p>在继续之前，您应该阅读 Apple 关于 <a href="https://developer.apple.com/swift/blog/?id=10" target="_blank" rel="noopener"><strong>“值和引用类型”</strong></a> 的文章。它将让你思考引用<em>类型</em>和值<em>类型</em>。我<strong>故意</strong>不在这里讲太多细节，因为我想让你们思考并理解这个非常重要的概念。它太过重要，以至于针对 POP <strong>和</strong> 引用/值类型的讨论<strong>同时</strong>出现在这些地方：  </p><ol><li>WWDC 2015 展示的 <a href="https://developer.apple.com/videos/play/wwdc2015/408/?time=2558" target="_blank" rel="noopener"><strong>“Protocol-Oriented Programming in Swift”</strong></a>  </li><li>WWDC 2015 展示的 <a href="https://developer.apple.com/videos/play/wwdc2015-414/?time=48" target="_blank" rel="noopener"><strong>“Building Better Apps with Value Types in Swift”</strong></a>  </li><li>WWDC 2016 展示的 <a href="https://developer.apple.com/videos/play/wwdc2016-419/?time=340" target="_blank" rel="noopener"><strong>“Protocol and Value Oriented Programming in UIKit Apps”</strong></a>  </li></ol><p>我会给你一个提示和作业……假设你有多个指向同一个类实例的引用，用于修改或“改变”属性。这些引用指向相同的数据块，因此将其称为“共享”数据并不夸张。在某些情况下，共享数据可能会导致问题，如下面的示例所示。这是否表示我们要将所有的代码改成值类型？<strong>并不是！</strong>就像 Apple 的一个工程师指出：<a href="https://developer.apple.com/videos/play/wwdc2015-408/?time=2566" target="_blank" rel="noopener"><strong>“例如，以 Window 为例。复制一个 Window 是什么意思？”</strong></a> 查看下面的代码，并思考这个问题。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>下面的代码片段来自 Xcode playground，在创建对象副本然后更改属性时，会遇到一个有趣的难题。你能找到问题么？我们将在下一篇文章中讨论这个问题。  </p><p>这段代码同时也演示了协议的定义和 <code>extension</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用类型：每个人都使用类很长时间了 </span></span><br><span class="line"><span class="comment">// -- 想想 COCOA 中进行的所有隐式复制。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flightTerminology: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> <span class="comment">// 不需要提供实现，除非我想</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> -&gt; <span class="type">Void</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> myType = <span class="type">String</span>(describing: type(of: <span class="keyword">self</span>))</span><br><span class="line">        <span class="keyword">let</span> flightTerminologyForType = myType + <span class="string">" "</span> + flightTerminology + <span class="string">"\n"</span></span><br><span class="line">        <span class="built_in">print</span>(flightTerminologyForType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> : <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flightTerminology: <span class="type">String</span> = <span class="string">"flies WITH feathers, and flaps wings differently than bats"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bat</span> : <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flightTerminology: <span class="type">String</span> = <span class="string">"flies WITHOUT feathers, and flaps wings differently than birds"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bat = <span class="type">Bat</span>()</span><br><span class="line">bat.fly()</span><br><span class="line"><span class="comment">// "Bat flies WITHOUT feathers, and flaps wings differently than birds"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bird = <span class="type">Bird</span>()</span><br><span class="line">bird.fly()</span><br><span class="line"><span class="comment">// "Bird flies WITH feathers, and flaps wings differently than bats"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> batCopy = bat</span><br><span class="line">batCopy.fly()</span><br><span class="line"><span class="comment">// "Bird flies WITH feathers, and flaps wings differently than bats"</span></span><br><span class="line"></span><br><span class="line">batCopy.flightTerminology = <span class="string">""</span></span><br><span class="line">batCopy.fly()</span><br><span class="line"><span class="comment">// 控制台输出 "Bat"</span></span><br><span class="line"></span><br><span class="line">bat.fly()</span><br><span class="line"><span class="comment">// 控制台输出 "Bat"</span></span><br></pre></td></tr></table></figure><p><strong><em>来自前面代码片段的控制台输出</em></strong>  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bat flies WITHOUT feathers, and flaps wings differently than birds</span><br><span class="line"></span><br><span class="line">Bird flies WITH feathers, and flaps wings differently than bats</span><br><span class="line"></span><br><span class="line">Bird flies WITH feathers, and flaps wings differently than bats</span><br><span class="line"></span><br><span class="line">Bat</span><br><span class="line"></span><br><span class="line">Bat</span><br></pre></td></tr></table></figure><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>在接下来的 Swift 代码片段中，我们使用 <code>struct</code> 替代 <code>class</code>。在这里，代码看起来更安全，而 Apple 似乎在推广值类型和 POP。注意，<a href="https://developer.apple.com/videos/play/wwdc2015/408/?time=2677" target="_blank" rel="noopener"><strong>他们目前还没有放弃 <code>class</code></strong></a>。  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是范式转变的起点，不仅仅是协议，还有值类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flightTerminology: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> <span class="comment">// 不需要提供实现，除非我想</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> -&gt; <span class="type">Void</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> myType = <span class="type">String</span>(describing: type(of: <span class="keyword">self</span>))</span><br><span class="line">        <span class="keyword">let</span> flightTerminologyForType = myType + <span class="string">" "</span> + flightTerminology + <span class="string">"\n"</span></span><br><span class="line">        <span class="built_in">print</span>(flightTerminologyForType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bird</span> : <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flightTerminology: <span class="type">String</span> = <span class="string">"flies WITH feathers, and flaps wings differently than bats"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bat</span> : <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flightTerminology: <span class="type">String</span> = <span class="string">"flies WITHOUT feathers, and flaps wings differently than birds"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bat = <span class="type">Bat</span>()</span><br><span class="line">bat.fly()</span><br><span class="line"><span class="comment">// "Bat flies WITHOUT feathers, and flaps wings differently than birds"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bird = <span class="type">Bird</span>()</span><br><span class="line">bird.fly()</span><br><span class="line"><span class="comment">// "Bird flies WITH feathers, and flaps wings differently than bats"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> batCopy = bat</span><br><span class="line">batCopy.fly()</span><br><span class="line"><span class="comment">// "Bird flies WITH feathers, and flaps wings differently than bats"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我在这里对 Bat 实例所做的事情是显而易见的</span></span><br><span class="line">batCopy.flightTerminology = <span class="string">""</span></span><br><span class="line">batCopy.fly()</span><br><span class="line"><span class="comment">// 控制台输出 "Bat"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，因为我们使用的是值类型，所以 Bat 实例的原始数据并没有因为之前的操作而被篡改。</span></span><br><span class="line">bat.fly()</span><br><span class="line"><span class="comment">// "Bat flies WITHOUT feathers, and flaps wings differently than birds"</span></span><br></pre></td></tr></table></figure><p><strong><em>来自前面代码片段的控制台输出</em></strong>  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bat flies WITHOUT feathers, and flaps wings differently than birds</span><br><span class="line"></span><br><span class="line">Bird flies WITH feathers, and flaps wings differently than bats</span><br><span class="line"></span><br><span class="line">Bat flies WITHOUT feathers, and flaps wings differently than birds</span><br><span class="line"></span><br><span class="line">Bat </span><br><span class="line"></span><br><span class="line">Bat flies WITHOUT feathers, and flaps wings differently than birds</span><br></pre></td></tr></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>我写了一些面向协议的代码。请通读代码，阅读内联注释，阅读附带的文章，跟随我的超链接，并充分理解我在做什么。你将在下一篇关于 POP 的文章中用到它。  </p><h3 id="采用多种协议"><a href="#采用多种协议" class="headerlink" title="采用多种协议"></a>采用多种协议</h3><p>刚开始写这篇文章的时候，我很贪心，想要自定义一个协议，使它能<strong><em>同时</em></strong>体现 Apple 的内置协议 <code>Equatable</code> 和 <code>Comparable</code>：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">IsEqualAndComparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> != <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &gt; <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt; (lhs: Self, rhs: Self) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">static</span> <span class="title">func</span> &gt;= <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;= (lhs: Self, rhs: Self) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>我意识到应该将它们分开，使我的代码尽可能灵活。为什么不呢？Apple 声明同一个类，结构体，枚举可以遵循多个协议，就像接下来我们将看到的一样。下面是我提出的两个协议：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">IsEqual</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> != <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &gt; <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt; (lhs: Self, rhs: Self) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">static</span> <span class="title">func</span> &gt;= <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;= (lhs: Self, rhs: Self) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="记住你的算法"><a href="#记住你的算法" class="headerlink" title="记住你的算法"></a>记住你的算法</h3><p>你需要磨练的一项重要技能是编程的算法，并将它们转换为代码。我保证在将来的某一天，会有人给你一个复杂过程的口头描述并要求你对它进行编码。用人类语言描述某些步骤，之后用软件将其实现，它们之间一般都会有很大的差距。当我想要将 <code>IsEqual</code> 和 <code>Comparable</code> 应用于表示直线（向量）的类时，我意识到了这一点。我记得计算一个直线的长度是基于勾股定理的（参考 <a href="https://orion.math.iastate.edu/dept/links/formulas/form2.pdf" target="_blank" rel="noopener"><strong>这里</strong></a>和 <a href="https://www.mathwarehouse.com/algebra/distance_formula/index.php" target="_blank" rel="noopener"><strong>这里</strong></a>），并且对向量使用 <code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，和 <code>&gt;=</code> 这些运算符进行比较时，直线的长度是必须的。我的 <code>Line</code> 类迟早会派上用场，例如，在一个绘图应用程序或游戏中，用户点击屏幕上的两个位置，在两点之间创建一条线。</p><h3 id="自定义类采用多个协议"><a href="#自定义类采用多个协议" class="headerlink" title="自定义类采用多个协议"></a>自定义类采用多个协议</h3><p>这是我的 <code>Line</code> 类，它采用了两个协议，<code>IsEqual</code> 和 <code>Comparable</code>（如下）。这是多继承的一种形式！  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> : <span class="title">IsEqual</span>, <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> beginPoint:<span class="type">CGPoint</span></span><br><span class="line">    <span class="keyword">var</span> endPoint:<span class="type">CGPoint</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        beginPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>);</span><br><span class="line">        endPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(beginPoint:<span class="type">CGPoint</span>, endPoint:<span class="type">CGPoint</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.beginPoint = <span class="type">CGPoint</span>( x: beginPoint.x, y: beginPoint.y )</span><br><span class="line">        <span class="keyword">self</span>.endPoint = <span class="type">CGPoint</span>( x: endPoint.x, y: endPoint.y )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线长的计算基于勾股定理。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">length</span> <span class="params">()</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> length = sqrt( pow(endPoint.x - beginPoint.x, <span class="number">2</span>) + pow(endPoint.y - beginPoint.y, <span class="number">2</span>) )</span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(leftHandSideLine: Line, rightHandSideLine: Line)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (leftHandSideLine.length() == rightHandSideLine.length())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> != <span class="params">(leftHandSideLine: Line, rightHandSideLine: Line)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (leftHandSideLine.length() != rightHandSideLine.length())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &gt; <span class="params">(leftHandSideLine: Line, rightHandSideLine: Line)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (leftHandSideLine.length() &gt; rightHandSideLine.length())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt; (leftHandSideLine: Line, rightHandSideLine: Line) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (leftHandSideLine.length() &lt; rightHandSideLine.length())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &gt;= <span class="params">(leftHandSideLine: Line, rightHandSideLine: Line)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (leftHandSideLine.length() &gt;= rightHandSideLine.length())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;= (leftHandSideLine: Line, rightHandSideLine: Line) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (leftHandSideLine.length() &lt;= rightHandSideLine.length())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 类的结束行：IsEqual, Comparable</span></span><br></pre></td></tr></table></figure><h3 id="验证你的算法"><a href="#验证你的算法" class="headerlink" title="验证你的算法"></a>验证你的算法</h3><p>我使用电子制表软件 Apple Numbers，并准备了两个向量的可视化表示，对 <code>Line</code> 类的 <code>length()</code> 方法做了一些基本测试：  </p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/03/swift-pop-1.png" alt>  </p><p>这里是我根据上面图表中的点，写的测试代码：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x1 = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> y1 = <span class="type">CGPoint</span>(x: <span class="number">2</span>, y: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> line1 = <span class="type">Line</span>(beginPoint: x1, endPoint: y1)</span><br><span class="line">line1.length()</span><br><span class="line"><span class="comment">// returns 2.82842712474619</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x2 = <span class="type">CGPoint</span>(x: <span class="number">3</span>, y: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> y2 = <span class="type">CGPoint</span>(x: <span class="number">5</span>, y: <span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> line2 = <span class="type">Line</span>(beginPoint: x2, endPoint: y2)</span><br><span class="line">line2.length()</span><br><span class="line"><span class="comment">// returns 2.82842712474619</span></span><br><span class="line"></span><br><span class="line">line1 == line2</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line">line1 != line2</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line">line1 &gt; line2</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line">line1 &lt;= line2</span><br><span class="line"><span class="comment">// returns true</span></span><br></pre></td></tr></table></figure><h3 id="使用-Xcode-“Single-View”-playground-模版测试-原型化-UI"><a href="#使用-Xcode-“Single-View”-playground-模版测试-原型化-UI" class="headerlink" title="使用 Xcode “Single View” playground 模版测试/原型化 UI"></a>使用 Xcode “Single View” playground 模版测试/原型化 UI</h3><p>你是否知道可以使用 Xcode 9 <code>Single View</code> playground 模板来原型化和测试用户界面（UI）？它非常棒 - 可以节省大量时间并快速原型化的工具。为了更好的测试我的 <code>Line</code> 类，我创建了这样一个 playground。<strong>作业：在我解释之前，我想让你自己试一下。</strong>我<strong>将</strong>向你展示我的 playground 代码、模拟器输出和我的 Swift 测试语句。  </p><p>这里是我的 playground 代码：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> PlaygroundSupport</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineDrawingView</span>: <span class="title">UIView</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> currGraphicsContext = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">        currGraphicsContext?.setLineWidth(<span class="number">2.0</span>)</span><br><span class="line">        currGraphicsContext?.setStrokeColor(<span class="type">UIColor</span>.blue.cgColor)</span><br><span class="line">        currGraphicsContext?.move(to: <span class="type">CGPoint</span>(x: <span class="number">40</span>, y: <span class="number">400</span>))</span><br><span class="line">        currGraphicsContext?.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">320</span>, y: <span class="number">40</span>))</span><br><span class="line">        currGraphicsContext?.strokePath()</span><br><span class="line">        </span><br><span class="line">        currGraphicsContext?.setLineWidth(<span class="number">4.0</span>)</span><br><span class="line">        currGraphicsContext?.setStrokeColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line">        currGraphicsContext?.move(to: <span class="type">CGPoint</span>(x: <span class="number">40</span>, y: <span class="number">400</span>))</span><br><span class="line">        currGraphicsContext?.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">320</span>, y: <span class="number">60</span>))</span><br><span class="line">        currGraphicsContext?.strokePath()</span><br><span class="line">        </span><br><span class="line">        currGraphicsContext?.setLineWidth(<span class="number">6.0</span>)</span><br><span class="line">        currGraphicsContext?.setStrokeColor(<span class="type">UIColor</span>.green.cgColor)</span><br><span class="line">        currGraphicsContext?.move(to: <span class="type">CGPoint</span>(x: <span class="number">40</span>, y: <span class="number">400</span>))</span><br><span class="line">        currGraphicsContext?.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">250</span>, y: <span class="number">80</span>))</span><br><span class="line">        currGraphicsContext?.strokePath()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="type">LineDrawingView</span>()</span><br><span class="line">        view.backgroundColor = .white</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.view = view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实时视图窗口中显示视图控制器</span></span><br><span class="line"><span class="type">PlaygroundPage</span>.current.liveView = <span class="type">MyViewController</span>()</span><br></pre></td></tr></table></figure><p>这是我在 playground 模拟器上的视图输出：  </p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/03/swift-pop-2.png" alt>  </p><p>下面是测试我的 <code>Line</code> 类型实例与我在 playground 上所画向量匹配的 Swift 代码：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xxBlue = <span class="type">CGPoint</span>(x: <span class="number">40</span>, y: <span class="number">400</span>)</span><br><span class="line"><span class="keyword">let</span> yyBlue = <span class="type">CGPoint</span>(x: <span class="number">320</span>, y: <span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> lineBlue = <span class="type">Line</span>(beginPoint: xxBlue, endPoint: yyBlue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xxRed = <span class="type">CGPoint</span>(x: <span class="number">40</span>, y: <span class="number">400</span>)</span><br><span class="line"><span class="keyword">let</span> yyRed = <span class="type">CGPoint</span>(x: <span class="number">320</span>, y: <span class="number">60</span>)</span><br><span class="line"><span class="keyword">let</span> lineRed = <span class="type">Line</span>(beginPoint: xxRed, endPoint: yyRed)</span><br><span class="line">lineRed.length()</span><br><span class="line"><span class="comment">// returns 440.454310910905</span></span><br><span class="line"></span><br><span class="line">lineBlue != lineRed</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line">lineBlue &gt; lineRed</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line">lineBlue &gt;= lineRed</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xxGreen = <span class="type">CGPoint</span>(x: <span class="number">40</span>, y: <span class="number">400</span>)</span><br><span class="line"><span class="keyword">let</span> yyGreen = <span class="type">CGPoint</span>(x: <span class="number">250</span>, y: <span class="number">80</span>)</span><br><span class="line"><span class="keyword">let</span> lineGreen = <span class="type">Line</span>(beginPoint: xxGreen, endPoint: yyGreen)</span><br><span class="line">lineGreen.length()</span><br><span class="line"><span class="comment">// returns 382.753184180093</span></span><br><span class="line">lineGreen &lt; lineBlue</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line">lineGreen &lt;= lineRed</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line">lineGreen &gt; lineBlue</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line">lineGreen &gt;= lineBlue</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line">lineGreen == lineGreen</span><br><span class="line"><span class="comment">// returns true</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我希望你喜欢今天的文章，并且非常期待阅读本文的“第二部分”。记住，我们将深入研究使用 POP 的先进应用程序，范型协议，从引用类型到值类型背后的动机，列举 POP 的优缺点，列举 OOP 的优缺点，比较 OOP 和 POP，确定为什么“Swift 是面向协议的”，并深入研究称为“局部推理”的概念。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      对面向协议编程，做了一个简单的引言，为第二篇文章做准备工作。
    
    </summary>
    
      <category term="POP" scheme="https://swift.gg/categories/POP/"/>
    
      <category term="SWIFT" scheme="https://swift.gg/categories/POP/SWIFT/"/>
    
    
      <category term="教程" scheme="https://swift.gg/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Swift 关键字</title>
    <link href="https://swift.gg/2019/08/22/Swift-Keywords/"/>
    <id>https://swift.gg/2019/08/22/Swift-Keywords/</id>
    <published>2019-08-21T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jordan Morgan，<a href="https://www.swiftjectivec.com/swift-keywords-v-3-0-1/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-02-11<br>译者：<a href="https://www.jianshu.com/u/076cc5e18bb8" target="_blank" rel="noopener">郑一一</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>有句话之前我提过，今天还想再说一次。那就是打铁还需自身硬。对于自身能力的严格要求，可以帮助实现我们所有梦寐以求的东西。</p><p>说起来可能有些消极，知识毕竟是永远学不完的。不论如何，今天 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html" target="_blank" rel="noopener">我们先来学习一下 Swift 中的每一个关键字</a>（V3.0.1），在介绍每个关键字的时候，同时会附带一段代码加以说明。</p><p>在这些关键字之中，会有你熟悉或者不熟悉的部分。但为了最好的阅读和学习体验，我把它们全部列出来了。文章篇幅有些长，你准备好了么？</p><p>让我们现在就开始吧。</p><a id="more"></a><h2 id="声明式关键字"><a href="#声明式关键字" class="headerlink" title="声明式关键字"></a>声明式关键字</h2><p><strong>associatedtype</strong>：在协议中，定义一个类型的占位符名称。直到协议被实现，该占位符才会被指定具体的类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Entertainment</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">MediaType</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> : <span class="title">Entertainment</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">MediaType</span> = <span class="type">String</span> <span class="comment">//可以指定任意类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>class</strong>：通用、灵活的结构体，是程序的基础组成部分。与 struct 类似，不同之处在于：</p><ul><li>允许一个类继承另一个类的特性。</li><li>类型转换，允许在运行时检查和指定一个类的实际类型。</li><li>析构方法允许类的实例释放所有资源。</li><li>引用计数允许多个引用指向一个实例。</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>  </span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span>  </span><br><span class="line">    <span class="keyword">var</span> gender:<span class="type">String</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>deinit</strong>：当一个类的实例即将被销毁时，会调用这个方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>  </span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span>  </span><br><span class="line">    <span class="keyword">var</span> gender:<span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//从堆中释放，并释放的资源</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>enum</strong>：定义了包含一组有关联的值的类型，并可以以一种类型安全的方式使用这些值。在 Swift 中，枚举是一等类型，拥有在其它语言中只有 class 才会支持的特性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Gender</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> male  </span><br><span class="line">    <span class="keyword">case</span> female  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>extension</strong>：允许给已有的类、结构体、枚举、协议类型，添加新功能。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span> = <span class="string">""</span>  </span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span> = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">var</span> gender:<span class="type">String</span> = <span class="string">""</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"My name is \(name), I'm \(age) years old and I'm a \(gender)."</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fileprivate</strong>：访问控制权限，只允许在定义源文件中访问。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> jobTitle:<span class="type">String</span> = <span class="string">""</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//当 extension 和 class 在同一个文件中时，允许访问</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printJobTitle</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"My job is (jobTitle)"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>func</strong>：包含用于执行特定任务的代码块。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNumbers</span><span class="params">(num1:Int, num2:Int)</span></span> -&gt; <span class="type">Int</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> num1+num2  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>import</strong>：引入一个以独立单元构建的框架或者应用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用 UIKit 框架下的所有代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>init</strong>：类、结构体、枚举的实例的初始化准备过程。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">init</span>()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//设置默认值，实例准备被使用</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>inout</strong>：将一个值传入函数，并可以被函数修改，然后将值传回到调用处，来替换初始值。适用于引用类型和值类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dangerousOp</span><span class="params">(<span class="number">_</span> error:<span class="keyword">inout</span> NSError?)</span></span>  </span><br><span class="line">&#123;  </span><br><span class="line">    error = <span class="type">NSError</span>(domain: <span class="string">""</span>, code: <span class="number">0</span>, userInfo: [<span class="string">""</span>:<span class="string">""</span>])  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> potentialError:<span class="type">NSError?</span></span><br><span class="line">dangerousOp(&amp;potentialError)</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码运行到这里，potentialError 不再是 nil，而是已经被初始化</span></span><br></pre></td></tr></table></figure><p><strong>internal</strong>：访问控制权限，允许同一个模块下的所有源文件访问，如果在不同模块下则不允许访问。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> jobTitle:<span class="type">String</span> = <span class="string">""</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.jobTitle = <span class="string">"This can set anywhere in the application"</span></span><br></pre></td></tr></table></figure><p><strong>let</strong>：定义一个不可变的变量。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> constantString = <span class="string">"This cannot be mutated going forward"</span></span><br></pre></td></tr></table></figure><p><strong>open</strong>：访问控制权限，允许在定义的模块外也可以访问源文件里的所有类，并进行子类化。对于类成员，允许在定义的模块之外访问和重写。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> foo:<span class="type">String?</span> <span class="comment">//这个属性允许在 app 内或 app 外重写和访问。在开发框架的时候，会应用到这个访问修饰符。</span></span><br></pre></td></tr></table></figure><p><strong>operator</strong>：特殊符号，用于检查、修改、组合值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一元运算符 "-"，改变值的符号</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">5</span>  </span><br><span class="line"><span class="keyword">let</span> anotherFoo = -foo <span class="comment">//anotherFoo 等于 -5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二元运算符 "+" 将两个值相加</span></span><br><span class="line"><span class="keyword">let</span> box = <span class="number">5</span> + <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑运算符 "&amp;&amp;" 将两个布尔值进行组合运算</span></span><br><span class="line"><span class="keyword">if</span> didPassCheckOne &amp;&amp; didPassCheckTwo</span><br><span class="line"></span><br><span class="line"><span class="comment">//三元运算符需要使用三个值</span></span><br><span class="line"><span class="keyword">let</span> isLegalDrinkingAgeInUS:<span class="type">Bool</span> = age &gt;= <span class="number">21</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>private</strong>：访问控制权限，只允许实体在定义的类以及相同源文件内的 extension 中访问。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> jobTitle:<span class="type">String</span> = <span class="string">""</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 extension 和 class 不在同一个源文件时</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 无法编译通过，只有在同一个源文件下才可以访问</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printJobTitle</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"My job is (jobTitle)"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>protocol</strong>：定义了一组方法、属性或其它要求，用于满足特定任务和一系列功能。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Blog</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> wordCount:<span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printReaderStats</span><span class="params">()</span></span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TTIDGPost</span> : <span class="title">Blog</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> wordCount:<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(wordCount:<span class="type">Int</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">self</span>.wordCount = wordCount  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printReaderStats</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//打印 post 的数据  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>public</strong>：访问控制权限，允许在定义的模块外也可以访问源文件里的所有类，但只有在同一个模块内可以进行子类化。对于类成员，允许在同个模块下访问和重写。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> foo:<span class="type">String?</span> <span class="comment">//只允许在 app 内重写和访问。</span></span><br></pre></td></tr></table></figure><p><strong>static</strong>：用于定义类方法，在类型本身进行调用。此外还可以定义静态成员。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> jobTitle:<span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">assignRandomName</span><span class="params">(<span class="number">_</span> aPerson:Person)</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        aPerson.jobTitle = <span class="string">"Some random job"</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> somePerson = <span class="type">Person</span>()  </span><br><span class="line"><span class="type">Person</span>.assignRandomName(somePerson)  </span><br><span class="line"><span class="comment">//somePerson.jobTitle 的值是 "Some random job"</span></span><br></pre></td></tr></table></figure><p><strong>struct</strong>：通用、灵活的结构体，是程序的基础组成部分，并提供了默认初始化方法。与 class 不同，当 struct 在代码中被传递时，是被拷贝的，并不使用引用计数。除此之外，struct 没有下面的这些功能：</p><ul><li>使用继承。</li><li>运行时的类型转换。</li><li>使用析构方法。</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>  </span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span>  </span><br><span class="line">    <span class="keyword">var</span> gender:<span class="type">String</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>subscript</strong>：访问集合、列表、序列中成员元素的快捷方式。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postMetrics = [<span class="string">"Likes"</span>:<span class="number">422</span>, <span class="string">"ReadPercentage"</span>:<span class="number">0.58</span>, <span class="string">"Views"</span>:<span class="number">3409</span>]  </span><br><span class="line"><span class="keyword">let</span> postLikes = postMetrics[<span class="string">"Likes"</span>]</span><br></pre></td></tr></table></figure><p><strong>typealias</strong>：给代码中已经存在的类，取别名。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">JSONDictionary</span> = [<span class="type">String</span>: <span class="type">AnyObject</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseJSON</span><span class="params">(<span class="number">_</span> deserializedData:JSONDictionary)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>var</strong>：定义可变变量。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutableString = <span class="string">""</span>  </span><br><span class="line">mutableString = <span class="string">"Mutated"</span></span><br></pre></td></tr></table></figure><h2 id="语句中的关键词"><a href="#语句中的关键词" class="headerlink" title="语句中的关键词"></a>语句中的关键词</h2><p><strong>break</strong>：终止程序中循环的执行，比如 if 语句、switch 语句。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>...<span class="number">3</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> idx % <span class="number">2</span> == <span class="number">0</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//当 idx 等于偶数时，退出 for 循环  </span></span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>case</strong>：该语句在 switch 语句中列出，在每个分支可以进行模式匹配。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> box = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> box  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 0"</span>)  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 1"</span>)  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box doesn't equal 0 or 1"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>continue</strong>：用于终止循环的当前迭代，并进入下一次迭代，而不会停止整个循环的执行。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>...<span class="number">3</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> idx % <span class="number">2</span> == <span class="number">0</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//直接开始循环的下一次迭代</span></span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This code never fires on even numbers"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>default</strong>：用于涵盖在 switch 语句中，所有未明确列出的枚举成员。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> box = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> box  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 0"</span>)  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 1"</span>)  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Covers any scenario that doesn't get addressed above."</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>defer</strong>：用于在程序离开当前作用域之前，执行一段代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cleanUpIO</span><span class="params">()</span></span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">defer</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This is called right before exiting scope"</span>)  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件流等。  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>do</strong>：用于表示处理错误代码段的开始。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">try</span> expression  </span><br><span class="line">    <span class="comment">//语句</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span> someError ex  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>else</strong>：与 if 语句结合使用。当条件为 true，执行一段代码。当条件为 false，执行另一段代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> val &gt; <span class="number">1</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"val is greater than 1"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"val is not greater than 1"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fallthrough</strong>：显式地允许从当前 case 跳转到下一个相邻 case 继续执行代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> box = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> box  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 0"</span>)  </span><br><span class="line">    <span class="keyword">fallthrough</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 0 or 1"</span>)  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box doesn't equal 0 or 1"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>for</strong>：在序列上迭代，比如一组特定范围内的数字，数组中的元素，字符串中的字符。*与关键字 in 成对使用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">3</span> &#123; <span class="built_in">print</span> (<span class="string">"This prints 3 times"</span>) &#125;</span><br></pre></td></tr></table></figure><p><strong>guard</strong>：当有一个以上的条件不满足要求时，将离开当前作用域。同时还提供解包可选类型的功能。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">printRecordFromLastName</span><span class="params">(userLastName: String?)</span></span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name = userLastName, name != <span class="string">"Null"</span> <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//userLastName = "Null"，需要提前退出</span></span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续执行代码</span></span><br><span class="line">    <span class="built_in">print</span>(dataStore.findByLastName(name))  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>if</strong>：当条件满足时，执行代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1</span> &gt; <span class="number">2</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This will never execute"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>in</strong>：在序列上迭代，比如一组特定范围内的数字，数组中的元素，字符串中的字符。*与关键字 key 搭配使用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">3</span> &#123; <span class="built_in">print</span> (<span class="string">"This prints 3 times"</span>) &#125;</span><br></pre></td></tr></table></figure><p><strong>repeat</strong>：在使用循环的判断条件之前，先执行一次循环中的代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repeat</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Always executes at least once before the condition is considered"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span> &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>return</strong>：立刻终止当前上下文，离开当前作用域，此外在返回时可以额外携带一个值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doNothing</span><span class="params">()</span></span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="comment">//直接离开当前上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> anInt = <span class="number">0</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This never prints (anInt)"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnName</span><span class="params">()</span></span> -&gt; <span class="type">String?</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.userName <span class="comment">//离开，并返回 userName 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>switch</strong>：将给定的值与分支进行比较。执行第一个模式匹配成功的分支代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> box = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> box  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 0"</span>)  </span><br><span class="line">    <span class="keyword">fallthrough</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 0 or 1"</span>)  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box doesn't equal 0 or 1"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>where</strong>：要求关联类型必须遵守特定协议，或者类型参数和关联类型必须保持一致。也可以用于在 case 中提供额外条件，用于满足控制表达式。</p><blockquote><p>where 从句可以应用于多种场景。以下例子指明了 where 的主要应用场景，泛型中的模式匹配。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Nameable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createdFormattedName</span><span class="params">(<span class="number">_</span> namedEntity:T)</span></span> -&gt; <span class="type">String</span> <span class="keyword">where</span> <span class="type">T</span>:<span class="type">Equatable</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//只有当实体同时遵守 Nameable 和 Equatable 协议的时候，才允许调用这个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This things name is "</span> + namedEntity.name  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>…<span class="number">3</span> <span class="keyword">where</span> i % <span class="number">2</span> == <span class="number">0</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">//打印 0 和 2  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>while</strong>：循环执行特定的一段语句，直到条件不满足时，停止循环。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> foo != bar  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Keeps going until the foo == bar"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式和类型中的关键字"><a href="#表达式和类型中的关键字" class="headerlink" title="表达式和类型中的关键字"></a>表达式和类型中的关键字</h2><p><strong>Any</strong>：用于表示任意类型的实例，包括函数类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anything = [<span class="type">Any</span>]()</span><br><span class="line"></span><br><span class="line">anything.append(<span class="string">"Any Swift type can be added"</span>)  </span><br><span class="line">anything.append(<span class="number">0</span>)  </span><br><span class="line">anything.append(&#123;(foo: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="string">"Passed in (foo)"</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>as</strong>：类型转换运算符，用于尝试将值转成其它类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anything = [<span class="type">Any</span>]()</span><br><span class="line"></span><br><span class="line">anything.append(<span class="string">"Any Swift type can be added"</span>)  </span><br><span class="line">anything.append(<span class="number">0</span>)  </span><br><span class="line">anything.append(&#123;(foo: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="string">"Passed in (foo)"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> intInstance = anything[<span class="number">1</span>] <span class="keyword">as</span>? <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anything = [<span class="type">Any</span>]()</span><br><span class="line"></span><br><span class="line">anything.append(<span class="string">"Any Swift type can be added"</span>)  </span><br><span class="line">anything.append(<span class="number">0</span>)  </span><br><span class="line">anything.append(&#123;(foo: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="string">"Passed in (foo)"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> anything  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">switch</span> thing  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Int</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"It's zero and an Int type"</span>)  </span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> someInt <span class="keyword">as</span> <span class="type">Int</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"It's an Int that's not zero but (someInt)"</span>)  </span><br><span class="line">        <span class="keyword">default</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Who knows what it is"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>catch</strong>：如果在 do 中抛出一个错误，catch 会尝试进行匹配，并决定如何处理错误。<a href="https://swiftjectivec.com/swift-error-handling" target="_blank" rel="noopener">*我写的一篇 Swift 错误处理的博客节选</a>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">try</span> haveAWeekend(<span class="number">4</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span> <span class="type">WeekendError</span>.<span class="type">Overtime</span>(<span class="keyword">let</span> hoursWorked)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"You worked (hoursWorked) more than you should have"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span> <span class="type">WeekendError</span>.<span class="type">WorkAllWeekend</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"You worked 48 hours :-0"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Gulping the weekend exception"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>false</strong>：Swift 用于表示布尔值的两个常量值之一，true 的相反值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> alwaysFalse = <span class="literal">false</span>  </span><br><span class="line"><span class="keyword">let</span> alwaysTrue = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> alwaysFalse &#123; <span class="built_in">print</span>(<span class="string">"Won't print, alwaysFalse is false 😉"</span>)&#125;</span><br></pre></td></tr></table></figure><p><strong>is</strong>：类型检查运算符，用于确定实例是否为某个子类类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> : <span class="title">Person</span> </span>&#123;&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nurse</span> : <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> people = [<span class="type">Programmer</span>(), <span class="type">Nurse</span>()]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> aPerson <span class="keyword">in</span> people  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> aPerson <span class="keyword">is</span> <span class="type">Programmer</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This person is a dev"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> aPerson <span class="keyword">is</span> <span class="type">Nurse</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This person is a nurse"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nil</strong>：在 Swift 中表示任意类型的无状态值。</p><blockquote><p>与 Objective-C 中的 nil 不同，Objective-C 中的 nil 表示指向不存在对象的指针。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Place</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任何 Swift 类型或实例可以为 nil</span></span><br><span class="line"><span class="keyword">var</span> statelessPerson:<span class="type">Person?</span> = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">var</span> statelessPlace:<span class="type">Place?</span> = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">var</span> statelessInt:<span class="type">Int?</span> = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">var</span> statelessString:<span class="type">String?</span> = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p><strong>rethrows</strong>：指明当前函数只有当参数抛出 error 时，才会抛出 error。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">networkCall</span><span class="params">(onComplete:<span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) <span class="keyword">rethrows</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">try</span> onComplete()  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">catch</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="type">SomeError</span>.error  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>super</strong>：在子类中，暴露父类的方法、属性、下标。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printName</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Printing a name. "</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> : <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">printName</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">super</span>.printName()  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Hello World!"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aDev = <span class="type">Programmer</span>()  </span><br><span class="line">aDev.printName() <span class="comment">//打印 Printing a name. Hello World!</span></span><br></pre></td></tr></table></figure><p><strong>self</strong>：任何类型的实例都拥有的隐式属性，等同于实例本身。此外还可以用于区分函数参数和成员属性名称相同的情况。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printSelf</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This is me: (self)"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.printSelf() <span class="comment">//打印 "This is me: Person"</span></span><br></pre></td></tr></table></figure><p><strong>Self</strong>：在协议中，表示遵守当前协议的实体类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Printable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printTypeTwice</span><span class="params">(otherMe:<span class="keyword">Self</span>)</span></span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> : <span class="title">Printable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printTypeTwice</span><span class="params">(otherMe: Foo)</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I am me plus (otherMe)"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aFoo = <span class="type">Foo</span>()  </span><br><span class="line"><span class="keyword">let</span> anotherFoo = <span class="type">Foo</span>()</span><br><span class="line"></span><br><span class="line">aFoo.printTypeTwice(otherMe: anotherFoo) <span class="comment">//打印 I am me plus Foo()</span></span><br></pre></td></tr></table></figure><p><strong>throw</strong>：用于在当前上下文，显式抛出 error。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WeekendError</span>: <span class="title">Error</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Overtime</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">WorkAllWeekend</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workOvertime</span> <span class="params">()</span></span> <span class="keyword">throws</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="type">WeekendError</span>.<span class="type">Overtime</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>throws</strong>：指明在一个函数、方法、初始化方法中可能会抛出 error。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WeekendError</span>: <span class="title">Error</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Overtime</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">WorkAllWeekend</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workOvertime</span> <span class="params">()</span></span> <span class="keyword">throws</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="type">WeekendError</span>.<span class="type">Overtime</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//"throws" 表明在调用方法时，需要使用 try，try?，try!</span></span><br><span class="line"><span class="keyword">try</span> workOvertime()</span><br></pre></td></tr></table></figure><p><strong>true</strong>：Swift 用于表示布尔值的两个常量值之一，表示为真。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> alwaysFalse = <span class="literal">false</span>  </span><br><span class="line"><span class="keyword">let</span> alwaysTrue = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> alwaysTrue &#123; <span class="built_in">print</span>(<span class="string">"Always prints"</span>)&#125;</span><br></pre></td></tr></table></figure><p><strong>try</strong>：表明接着调用的函数可能会抛出 error。有三种不同的使用方式：try，try?， try!。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aResult = <span class="keyword">try</span> dangerousFunction() <span class="comment">//处理 error，或者继续传递 error  </span></span><br><span class="line"><span class="keyword">let</span> aResult = <span class="keyword">try</span>! dangerousFunction() <span class="comment">//程序可能会闪退  </span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> aResult = <span class="keyword">try</span>? dangerousFunction() <span class="comment">//解包可选类型。</span></span><br></pre></td></tr></table></figure><h2 id="模式中的关键字"><a href="#模式中的关键字" class="headerlink" title="模式中的关键字"></a>模式中的关键字</h2><p><strong>_</strong>：用于匹配或省略任意值的通配符。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">3</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Just loop 3 times, index has no meaning"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种用法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="number">_</span> = <span class="type">Singleton</span>() <span class="comment">//忽略不使用的变量</span></span><br></pre></td></tr></table></figure><h2 id="以-开头的关键字"><a href="#以-开头的关键字" class="headerlink" title="以#开头的关键字"></a>以#开头的关键字</h2><p><strong>#available</strong>：基于平台参数，通过 <strong>if</strong>，<strong>while</strong>，<strong>guard</strong> 语句的条件，在运行时检查 API 的可用性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">10</span>, *)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"iOS 10 APIs are available"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>#colorLiteral</strong>：在 playground 中使用的字面表达式，用于创建颜色选取器，选取后赋值给变量。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aColor = #colorLiteral <span class="comment">//创建颜色选取器</span></span><br></pre></td></tr></table></figure><p><strong>#column</strong>：一种特殊的字面量表达式，用于获取字面量表示式的起始列数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Some person info - on column (#column)"</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.printInfo() <span class="comment">//Some person info - on column 53</span></span><br></pre></td></tr></table></figure><p><strong>#else</strong>：条件编译控制语句，用于控制程序在不同条件下执行不同代码。与 <strong>#if</strong> 语句结合使用。当条件为 true，执行对应代码。当条件为 false，执行另一段代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> os(iOS)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Compiled for an iOS device"</span>)  </span><br><span class="line">#<span class="keyword">else</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Not on an iOS device"</span>)  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><strong>#elseif</strong>：条件编译控制语句，用于控制程序在不同条件下执行代码。与 <strong>#if</strong> 语句结合使用。当条件为 true，执行对应代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> os(iOS)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Compiled for an iOS device"</span>)  </span><br><span class="line">#elseif os(macOS)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Compiled on a mac computer"</span>)  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><strong>#endif</strong>：条件编译控制语句，用于控制程序在不同条件下执行代码。用于表明条件编译代码的结尾。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> os(iOS)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Compiled for an iOS device"</span>)  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><strong>#file</strong>：特殊字面量表达式，返回当前代码所在源文件的名称。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Some person info - inside file (#file)"</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.printInfo() <span class="comment">//Some person info - inside file /*代码所在 playground 文件路径*/</span></span><br></pre></td></tr></table></figure><p><strong>#fileReference</strong>：playground 字面量语法，用于创建文件选取器，选取并返回 NSURL 实例。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fontFilePath = #fileReference <span class="comment">//创建文件选取器</span></span><br></pre></td></tr></table></figure><p><strong>#function</strong>：特殊字面量表达式，返回函数名称。在方法中，返回方法名。在属性的 getter 或者 setter 中，返回属性名。在特殊的成员中，比如 init 或 subscript 中，返回关键字名称。在文件的最顶层时，返回当前所在模块名称。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Some person info - inside function (#function)"</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.printInfo() <span class="comment">//Some person info - inside function printInfo()</span></span><br></pre></td></tr></table></figure><p><strong>#if</strong>：条件编译控制语句，用于控制程序在不同条件下编译代码。通过判断条件，决定是否执行代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> os(iOS)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Compiled for an iOS device"</span>)  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><strong>#imageLiteral</strong>：playground 字面量语法，创建图片选取器，选择并返回 UIImage 实例。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anImage = #imageLiteral <span class="comment">//在 playground 文件中选取图片</span></span><br></pre></td></tr></table></figure><p><strong>#line</strong>：特殊字面量表达式，用于获取当前代码的行数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Some person info - on line number (#line)"</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.printInfo() <span class="comment">//Some person info - on line number 5</span></span><br></pre></td></tr></table></figure><p><strong>#selector</strong>：用于创建 Objective-C selector 的表达式，可以静态检查方法是否存在，并暴露给 Objective-C。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态检查，确保 doAnObjCMethod 方法存在  </span></span><br><span class="line">control.sendAction(#selector(doAnObjCMethod), to: target, forEvent: event)</span><br></pre></td></tr></table></figure><p><strong>#sourceLocation</strong>：行控制语句，可以指定与原先完全不同的行数和源文件名。通常在 Swift 诊断、debug 时使用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#sourceLocation(file:<span class="string">"foo.swift"</span>, line:<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印新值</span></span><br><span class="line"><span class="built_in">print</span>(#file)  </span><br><span class="line"><span class="built_in">print</span>(#line)</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置行数和文件名</span></span><br><span class="line">#sourceLocation()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(#file)  </span><br><span class="line"><span class="built_in">print</span>(#line)</span><br></pre></td></tr></table></figure><h2 id="特定上下文中的关键字"><a href="#特定上下文中的关键字" class="headerlink" title="特定上下文中的关键字"></a>特定上下文中的关键字</h2><blockquote><p>这些关键字，在处于对应上下文之外时，可以用作标识符。</p></blockquote><p><strong>associativity</strong>：指明同一优先级的运算符，在缺少大括号的情况，按什么顺序结合。使用 <strong>left</strong>、<strong>right</strong>、<strong>none</strong>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ~ &#123; <span class="keyword">associativity</span> <span class="keyword">right</span> <span class="keyword">precedence</span> <span class="number">140</span> &#125;  </span><br><span class="line"><span class="number">4</span> ~ <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>convenience</strong>：次等的便利构造器，最后会调用指定构造器初始化实例。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> name:<span class="type">String</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">self</span>.name = name  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="string">"No Name"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> me = <span class="type">Person</span>()  </span><br><span class="line"><span class="built_in">print</span>(me.name)<span class="comment">//打印 "No Name"</span></span><br></pre></td></tr></table></figure><p><strong>dynamic</strong>：指明编译器不会对类成员或者函数的方法进行内联或虚拟化。这意味着对这个成员的访问是使用 Objective-C 运行时进行动态派发的（代替静态调用）。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="comment">//隐式指明含有 "objc" 属性</span></span><br><span class="line">    <span class="comment">//这对依赖于 Objc-C 黑魔法的库或者框架非常有用</span></span><br><span class="line">    <span class="comment">//比如 KVO、KVC、Swizzling</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> name:<span class="type">String?</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>didSet</strong>：属性观察者，当值存储到属性后马上调用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">didSet</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        tableView.reloadData()  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>final</strong>：防止方法、属性、下标被重写。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> : <span class="title">Person</span> </span>&#123;&#125; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p><strong>get</strong>：返回成员的值。还可以用在计算型属性上，间接获取其它属性的值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.name &#125;  </span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">self</span>.name = newValue&#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> indirectSetName:<span class="type">String</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> aFullTitle = <span class="keyword">self</span>.fullTitle  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">return</span> aFullTitle  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> (newTitle)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//如果没有定义 newTitle，可以使用 newValue</span></span><br><span class="line">            <span class="keyword">self</span>.fullTitle = <span class="string">"(self.name) :(newTitle)"</span>  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>infix</strong>：指明一个用于两个值之间的运算符。如果一个全新的全局运算符被定义为 infix，还需要指定优先级。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> twoIntsAdded = <span class="number">2</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>indirect</strong>：指明在枚举类型中，存在成员使用相同枚举类型的实例作为关联值的情况。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">Entertainment</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> eventType(<span class="type">String</span>)  </span><br><span class="line">    <span class="keyword">case</span> oneEvent(<span class="type">Entertainment</span>)  </span><br><span class="line">    <span class="keyword">case</span> twoEvents(<span class="type">Entertainment</span>, <span class="type">Entertainment</span>)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dinner = <span class="type">Entertainment</span>.eventType(<span class="string">"Dinner"</span>)  </span><br><span class="line"><span class="keyword">let</span> movie = <span class="type">Entertainment</span>.eventType(<span class="string">"Movie"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dateNight = <span class="type">Entertainment</span>.twoEvents(dinner, movie)</span><br></pre></td></tr></table></figure><p><strong>lazy</strong>：指明属性的初始值，直到第一次被使用时，才进行初始化。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> personalityTraits = &#123;  </span><br><span class="line">        <span class="comment">//昂贵的数据库开销  </span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"Nice"</span>, <span class="string">"Funny"</span>]  </span><br><span class="line">    &#125;()  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.personalityTraits <span class="comment">//当 personalityTraits 首次被访问时，数据库才开始工作</span></span><br></pre></td></tr></table></figure><p><strong>left</strong>：指明运算符的结合性是从左到右。在没有使用大括号时，可以用于正确判断同一优先级运算符的执行顺序。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"-" 运算符的结合性是从左到右</span></span><br><span class="line"><span class="number">10</span>-<span class="number">2</span>-<span class="number">4</span> <span class="comment">//根据结合性，可以看做 (10-2) - 4</span></span><br></pre></td></tr></table></figure><p><strong>mutating</strong>：允许在方法中修改结构体或者枚举实例的属性值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> job = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">assignJob</span><span class="params">(newJob:String)</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">self</span> = <span class="type">Person</span>(job: newJob)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.job <span class="comment">//""</span></span><br><span class="line"></span><br><span class="line">aPerson.assignJob(newJob: <span class="string">"iOS Engineer at Buffer"</span>)  </span><br><span class="line">aPerson.job <span class="comment">//iOS Engineer at Buffer</span></span><br></pre></td></tr></table></figure><p><strong>none</strong>：是一个没有结合性的运算符。不允许这样的运算符相邻出现。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"&lt;" 是非结合性的运算符</span></span><br><span class="line"><span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span> <span class="comment">//编译失败</span></span><br></pre></td></tr></table></figure><p><strong>nonmutating</strong>：指明成员的 setter 方法不会修改实例的值，但可能会有其它后果。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Paygrade</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Junior</span>, <span class="type">Middle</span>, <span class="type">Senior</span>, <span class="type">Master</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> experiencePay:<span class="type">String?</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            database.payForGrade(<span class="type">String</span>(describing:<span class="keyword">self</span>))  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">nonmutating</span> <span class="keyword">set</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newPay = newValue  </span><br><span class="line">            &#123;  </span><br><span class="line">                database.editPayForGrade(<span class="type">String</span>(describing:<span class="keyword">self</span>), newSalary:newPay)  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentPay = <span class="type">Paygrade</span>.<span class="type">Middle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 Middle pay 更新为 45k, 但不会修改 experiencePay 值</span></span><br><span class="line">currentPay.experiencePay = <span class="string">"$45,000"</span></span><br></pre></td></tr></table></figure><p><strong>optional</strong>：用于指明协议中的可选方法。遵守该协议的实体类可以不实现这个方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Foo</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">requiredFunction</span><span class="params">()</span></span>  </span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">optionalFunction</span><span class="params">()</span></span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Foo</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">requiredFunction</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Conformance is now valid"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>override</strong>：指明子类会提供自定义实现，覆盖父类的实例方法、类型方法、实例属性、类型属性、下标。如果没有实现，则会直接继承自父类。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I'm just a person!"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> : <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I'm a person who is a dev!"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line"><span class="keyword">let</span> aDev = <span class="type">Programmer</span>()</span><br><span class="line"></span><br><span class="line">aPerson.printInfo() <span class="comment">//打印 I'm just a person!  </span></span><br><span class="line">aDev.printInfo() <span class="comment">//打印 I'm a person who is a dev!</span></span><br></pre></td></tr></table></figure><p><strong>postfix</strong>：位于值后面的运算符。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalStr:<span class="type">String?</span> = <span class="string">"Optional"</span>  </span><br><span class="line"><span class="built_in">print</span>(optionalStr!)</span><br></pre></td></tr></table></figure><p><strong>precedence</strong>：指明某个运算符的优先级高于别的运算符，从而被优先使用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ~ &#123; <span class="keyword">associativity</span> <span class="keyword">right</span> <span class="keyword">precedence</span> <span class="number">140</span> &#125;  </span><br><span class="line"><span class="number">4</span> ~ <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>prefix</strong>：位于值前面的运算符。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anInt = <span class="number">2</span>  </span><br><span class="line">anInt = -anInt <span class="comment">//anInt 等于 -2</span></span><br></pre></td></tr></table></figure><p><strong>required</strong>：确保编译器会检查该类的所有子类，全部实现了指定的构造器方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="number">_</span> name:<span class="type">String</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">self</span>.name = name  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> : <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="comment">//如果不实现这个方法，编译不会通过</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="number">_</span> name: <span class="type">String</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>right</strong>：指明运算符的结合性是从右到左的。在没有使用大括号时，可以用于正确判断同一优先级运算符的顺序。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"??" 运算符结合性是从右到左</span></span><br><span class="line"><span class="keyword">var</span> box:<span class="type">Int?</span>  </span><br><span class="line"><span class="keyword">var</span> sol:<span class="type">Int?</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo:<span class="type">Int</span> = box ?? sol ?? <span class="number">0</span> <span class="comment">//Foo 等于 2</span></span><br></pre></td></tr></table></figure><p><strong>set</strong>：通过获取的新值来设置成员的值。同样可以用于计算型属性来间接设置其它属性。如果计算型属性的 setter 没有定义新值的名称，可以使用默认的 newValue。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.name &#125;  </span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">self</span>.name = newValue&#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> indirectSetName:<span class="type">String</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> aFullTitle = <span class="keyword">self</span>.fullTitle  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">return</span> aFullTitle  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> (newTitle)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//如果没有定义 newTitle，可以使用 newValue</span></span><br><span class="line">            <span class="keyword">self</span>.fullTitle = <span class="string">"(self.name) :(newTitle)"</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Type</strong>：表示任意类型的类型，包括类类型、结构类型、枚举类型、协议类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> : <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aDev:<span class="type">Programmer</span>.<span class="type">Type</span> = <span class="type">Programmer</span>.<span class="keyword">self</span></span><br></pre></td></tr></table></figure><p><strong>unowned</strong>：让循环引用中的实例 A 不要强引用实例 B。前提条件是实例 B 的生命周期要长于 A 实例。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> occupation:<span class="type">Job?</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当 Person 实例不存在时，job 也不会存在。job 的生命周期取决于持有它的 Person。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> employee:<span class="type">Person</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(with employee:<span class="type">Person</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">self</span>.employee = employee  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>weak</strong>：允许循环引用中的实例 A 弱引用实例 B ，而不是强引用。实例 B 的生命周期更短，并会被先释放。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> residence:<span class="type">House?</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> occupant:<span class="type">Person?</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me:<span class="type">Person?</span> = <span class="type">Person</span>()  </span><br><span class="line"><span class="keyword">var</span> myHome:<span class="type">House?</span> = <span class="type">House</span>()</span><br><span class="line"></span><br><span class="line">me!.residence = myHome  </span><br><span class="line">myHome!.occupant = me</span><br><span class="line"></span><br><span class="line">me = <span class="literal">nil</span>  </span><br><span class="line">myHome!.occupant <span class="comment">// myHome 等于 nil</span></span><br></pre></td></tr></table></figure><p><strong>willSet</strong>：属性观察者，在值存储到属性之前调用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String?</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">willSet</span>(newValue) &#123;<span class="built_in">print</span>(<span class="string">"I've got a new name, it's (newValue)!"</span>)&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.name = <span class="string">"Jordan"</span> <span class="comment">//在赋值之前，打印 "I've got a new name, it's Jordan!"</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>哇噢！</p><p>这真是一次有趣的创作。我学会了好多在写之前没想到的东西。但我认为这里的诀窍并不是要把它记住，而是把它当做一份可以用于测验的定义清单。</p><p>相反地，我建议你把这份清单放在手边，并时不时地回顾一下。如果你能这样做的话，下一次在不同场景下需要使用特定的关键字，你肯定就能马上回想起来并使用它啦。</p><p>下回再见咯。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Jordan Morgan，&lt;a href=&quot;https://www.swiftjectivec.com/swift-keywords-v-3-0-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-02-11&lt;br&gt;译者：&lt;a href=&quot;https://www.jianshu.com/u/076cc5e18bb8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;郑一一&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/Pancf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pancf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;有句话之前我提过，今天还想再说一次。那就是打铁还需自身硬。对于自身能力的严格要求，可以帮助实现我们所有梦寐以求的东西。&lt;/p&gt;
&lt;p&gt;说起来可能有些消极，知识毕竟是永远学不完的。不论如何，今天 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我们先来学习一下 Swift 中的每一个关键字&lt;/a&gt;（V3.0.1），在介绍每个关键字的时候，同时会附带一段代码加以说明。&lt;/p&gt;
&lt;p&gt;在这些关键字之中，会有你熟悉或者不熟悉的部分。但为了最好的阅读和学习体验，我把它们全部列出来了。文章篇幅有些长，你准备好了么？&lt;/p&gt;
&lt;p&gt;让我们现在就开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="swiftjectivec" scheme="https://swift.gg/categories/swiftjectivec/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>给 UIView 来点烟花</title>
    <link href="https://swift.gg/2019/08/14/add-fireworks-and-sparks-to-a-uiview/"/>
    <id>https://swift.gg/2019/08/14/add-fireworks-and-sparks-to-a-uiview/</id>
    <published>2019-08-13T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/programming-blog/2018/09/add-fireworks-and-sparks-to-a-uiview/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-09<br>译者：<a href="https://github.com/joeytat" target="_blank" rel="noopener">Joeytat</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><a id="more"></a><p>你也很喜欢常用 app 里的那些小细节吧？当我从 <a href="https://dribbble.com/" target="_blank" rel="noopener">dribbble</a> 中寻找灵感时，就发现了这个漂亮的设计：当用户在某个重要的视图中修改设置或者进行了什么操作时，会有烟花在周围绽放。于是我就在想这个东西有多难实现，然后过了一段时间，我完成了 :)</p><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/hero.gif1565786277.3434784" alt="hero"></p><h2 id="烟花的细节"><a href="#烟花的细节" class="headerlink" title="烟花的细节"></a><em>烟花的细节</em></h2><p>下面是对于这个效果的详细描述。烟花应该在视图周围的某个特殊的位置爆开，可能是按钮在点击事件响应时。当点击发生时，烟花应该在按钮的四角爆开，并且爆炸产生的火花应该按照自身的轨迹移动。</p><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/final.jpg1565786278.2018952" alt="final"></p><p><em>超喜欢这个效果! 不仅让我感受到视觉上的愉悦，还让我想要不停地戳这个按钮！ :) 🎉</em></p><p>现在让我们再看一眼这个动画。每次生成的烟花，其整体行为是大致相似的。但还是在火花的轨迹和大小上有一些区别。让我们拆开来说。</p><ul><li>每一次点击都会产生<em>两处烟花</em>，</li><li>每一处烟花会产生 <em>8 个火花</em>，</li><li>每个火花都遵循着自己的<em>轨迹</em>，</li><li>轨迹看起来<em>相似</em>，但其实<em>不完全一样</em>。从爆炸<em>开始</em>的位置来看，有部分朝<em>右</em>，有部分朝<em>左</em>，剩余的朝<em>上</em>或<em>下</em>。</li></ul><h2 id="火花的分布"><a href="#火花的分布" class="headerlink" title="火花的分布"></a><em>火花的分布</em></h2><p>这个烟花特效有着简单的火花分布规则。将爆炸点分为四块「视线区域」来看：上左，上右，下左，下右，每个区域都有两个火花。</p><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/sparks-distribution.jpg1565786278.5224512" alt="sparks distribution"></p><h2 id="火花的轨迹"><a href="#火花的轨迹" class="headerlink" title="火花的轨迹"></a><em>火花的轨迹</em></h2><p>火花的移动有着自己的轨迹。在一处烟花中有 8 个火花，那至少需要 8 道轨迹。理想状态下应该有更多的轨迹，可以增加一些随机性，这样连续爆发烟花的时候，不会看起来和前一个完全一样。</p><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/spark-trajectories.jpg1565786278.861796" alt="spark-trajectories"></p><p>我为每一个区域创建了 4 条轨迹，这样就赋予了两倍于火花数量的随机性。为了方便计算，我统一了每条轨迹的初始点。因为我用了不同的工具来可视化这些轨迹，所以图上的轨迹和我完成的效果略有不同 - 但你能明白我的想法就行 :)</p><h2 id="实现"><a href="#实现" class="headerlink" title="_实现_"></a>_实现_</h2><p>理论足够了。接下来让我们把各个模块拼凑起来。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SparkTrajectory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 存储着定义轨迹所需要的所有的点</span></span><br><span class="line">    <span class="keyword">var</span> points: [<span class="type">CGPoint</span>] &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 用 path 来表现轨迹</span></span><br><span class="line">    <span class="keyword">var</span> path: <span class="type">UIBezierPath</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个用于表示火花轨迹的协议。为了能够更简单地创建各式各样的轨迹，我定义了这个通用接口协议，并且选择基于三阶 <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank" rel="noopener">贝塞尔曲线</a> 来实现轨迹；还添加了一个 <code>init</code> 方法，这样我就可以通过一行代码来创建轨迹了。三阶贝塞尔曲线必须包含四个点。第一个和最后一个点定义了轨迹的开始和结束的位置，中间的两个点用于控制曲线的弯曲度。你可以用在线数学工具 <a href="https://www.desmos.com/calculator/epunzldltu" target="_blank" rel="noopener">desmos</a> 来调整自己的贝塞尔曲线。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 拥有两个控制点的贝塞尔曲线</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CubicBezierTrajectory</span>: <span class="title">SparkTrajectory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> points = [<span class="type">CGPoint</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> x0: <span class="type">CGFloat</span>, <span class="number">_</span> y0: <span class="type">CGFloat</span>,</span><br><span class="line">         <span class="number">_</span> x1: <span class="type">CGFloat</span>, <span class="number">_</span> y1: <span class="type">CGFloat</span>,</span><br><span class="line">         <span class="number">_</span> x2: <span class="type">CGFloat</span>, <span class="number">_</span> y2: <span class="type">CGFloat</span>,</span><br><span class="line">         <span class="number">_</span> x3: <span class="type">CGFloat</span>, <span class="number">_</span> y3: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.points.append(<span class="type">CGPoint</span>(x: x0, y: y0))</span><br><span class="line">        <span class="keyword">self</span>.points.append(<span class="type">CGPoint</span>(x: x1, y: y1))</span><br><span class="line">        <span class="keyword">self</span>.points.append(<span class="type">CGPoint</span>(x: x2, y: y2))</span><br><span class="line">        <span class="keyword">self</span>.points.append(<span class="type">CGPoint</span>(x: x3, y: y3))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> path: <span class="type">UIBezierPath</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">self</span>.points.<span class="built_in">count</span> == <span class="number">4</span> <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"4 points required"</span>) &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>()</span><br><span class="line">        path.move(to: <span class="keyword">self</span>.points[<span class="number">0</span>])</span><br><span class="line">        path.addCurve(to: <span class="keyword">self</span>.points[<span class="number">3</span>], controlPoint1: <span class="keyword">self</span>.points[<span class="number">1</span>], controlPoint2: <span class="keyword">self</span>.points[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/desmos-tool.png1565786279.294991" alt="desmos-tool"></p><p>接下来要实现的是一个能够创建随机轨迹的工厂。前面的图中你可以看到轨迹是根据颜色来分组的。我只创建了上右和下右两块位置的轨迹，然后进行了镜像复制。这对于我们将要发射的烟花来说已经足够了🚀</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SparkTrajectoryFactory</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ClassicSparkTrajectoryFactoryProtocol</span>: <span class="title">SparkTrajectoryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">randomTopRight</span><span class="params">()</span></span> -&gt; <span class="type">SparkTrajectory</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">randomBottomRight</span><span class="params">()</span></span> -&gt; <span class="type">SparkTrajectory</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassicSparkTrajectoryFactory</span>: <span class="title">ClassicSparkTrajectoryFactoryProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> topRight: [<span class="type">SparkTrajectory</span>] = &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.31</span>, -<span class="number">0.46</span>, <span class="number">0.74</span>, -<span class="number">0.29</span>, <span class="number">0.99</span>, <span class="number">0.12</span>),</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.31</span>, -<span class="number">0.46</span>, <span class="number">0.62</span>, -<span class="number">0.49</span>, <span class="number">0.88</span>, -<span class="number">0.19</span>),</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.10</span>, -<span class="number">0.54</span>, <span class="number">0.44</span>, -<span class="number">0.53</span>, <span class="number">0.66</span>, -<span class="number">0.30</span>),</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.19</span>, -<span class="number">0.46</span>, <span class="number">0.41</span>, -<span class="number">0.53</span>, <span class="number">0.65</span>, -<span class="number">0.45</span>),</span><br><span class="line">        ]</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> bottomRight: [<span class="type">SparkTrajectory</span>] = &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.42</span>, -<span class="number">0.01</span>, <span class="number">0.68</span>, <span class="number">0.11</span>, <span class="number">0.87</span>, <span class="number">0.44</span>),</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.35</span>, <span class="number">0.00</span>, <span class="number">0.55</span>, <span class="number">0.12</span>, <span class="number">0.62</span>, <span class="number">0.45</span>),</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.21</span>, <span class="number">0.05</span>, <span class="number">0.31</span>, <span class="number">0.19</span>, <span class="number">0.32</span>, <span class="number">0.45</span>),</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.18</span>, <span class="number">0.00</span>, <span class="number">0.31</span>, <span class="number">0.11</span>, <span class="number">0.35</span>, <span class="number">0.25</span>),</span><br><span class="line">        ]</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">randomTopRight</span><span class="params">()</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.topRight[<span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(<span class="keyword">self</span>.topRight.<span class="built_in">count</span>)))]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">randomBottomRight</span><span class="params">()</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.bottomRight[<span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(<span class="keyword">self</span>.bottomRight.<span class="built_in">count</span>)))]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先创建了用来表示火花轨迹工厂的抽象协议，还有一个我将其命名为<em>经典烟花</em>的火花轨迹的抽象协议，这样的抽象可以方便后续将其替换成其他的轨迹协议。</p><p>如同我前面提到的，我通过 <a href="https://www.desmos.com/calculator/epunzldltu" target="_blank" rel="noopener">desmos</a> 创建了两组轨迹，对应着右上，和右下两块区域。</p><p><strong>重要提醒</strong>：如果在 desmos 上 y 轴所显示的是正数，那么你应该将其转换成负数。因为在 iOS 系统中，越接近屏幕顶部 y 轴的值越小，所以 y 轴的值需要翻转一下。</p><p>并且值得一提的是，为了后面好计算，所有的轨迹初始点都是 (0,0)。</p><p>我们现在创建好了轨迹。接下来创建一些视图来表示火花。对于经典烟花来说，只需要有颜色的圆圈就行。通过抽象可以让我们在未来以更低的成本，创建不同的火花视图。比如小鸭子图片，或者是胖吉猫 :)</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparkView</span>: <span class="title">UIView</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleColorSparkView</span>: <span class="title">SparkView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(color: <span class="type">UIColor</span>, size: <span class="type">CGSize</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(origin: .zero, size: size))</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = color</span><br><span class="line">        <span class="keyword">self</span>.layer.cornerRadius = <span class="keyword">self</span>.frame.width / <span class="number">2.0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> sparkColorSet1: [<span class="type">UIColor</span>] = &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="type">UIColor</span>(red:<span class="number">0.89</span>, green:<span class="number">0.58</span>, blue:<span class="number">0.70</span>, alpha:<span class="number">1.00</span>),</span><br><span class="line">            <span class="type">UIColor</span>(red:<span class="number">0.96</span>, green:<span class="number">0.87</span>, blue:<span class="number">0.62</span>, alpha:<span class="number">1.00</span>),</span><br><span class="line">            <span class="type">UIColor</span>(red:<span class="number">0.67</span>, green:<span class="number">0.82</span>, blue:<span class="number">0.94</span>, alpha:<span class="number">1.00</span>),</span><br><span class="line">            <span class="type">UIColor</span>(red:<span class="number">0.54</span>, green:<span class="number">0.56</span>, blue:<span class="number">0.94</span>, alpha:<span class="number">1.00</span>),</span><br><span class="line">        ]</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了创建火花视图，我们还需要一个工厂数据以填充，需要的数据是火花的大小，以及用来决定火花在哪个烟花的索引（用于增加随机性）。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SparkViewFactoryData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGSize</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> index: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SparkViewFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(with data: SparkViewFactoryData)</span></span> -&gt; <span class="type">SparkView</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleColorSparkViewFactory</span>: <span class="title">SparkViewFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> colors: [<span class="type">UIColor</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>.sparkColorSet1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(with data: SparkViewFactoryData)</span></span> -&gt; <span class="type">SparkView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> color = <span class="keyword">self</span>.colors[data.index % <span class="keyword">self</span>.colors.<span class="built_in">count</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CircleColorSparkView</span>(color: color, size: data.size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看这样抽象了之后，就算再实现一个像胖吉猫的火花也会很简单。接下来让我们来创建<em>经典烟花</em>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">FireworkSpark</span> = (sparkView: <span class="type">SparkView</span>, trajectory: <span class="type">SparkTrajectory</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Firework</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 烟花的初始位置</span></span><br><span class="line">    <span class="keyword">var</span> origin: <span class="type">CGPoint</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 定义了轨迹的大小. 轨迹都是统一大小</span></span><br><span class="line">    <span class="comment">/// 所以需要在展示到屏幕上前将其放大</span></span><br><span class="line">    <span class="keyword">var</span> scale: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 火花的大小</span></span><br><span class="line">    <span class="keyword">var</span> sparkSize: <span class="type">CGSize</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 获取轨迹</span></span><br><span class="line">    <span class="keyword">var</span> trajectoryFactory: <span class="type">SparkTrajectoryFactory</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 获取火花视图</span></span><br><span class="line">    <span class="keyword">var</span> sparkViewFactory: <span class="type">SparkViewFactory</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sparkViewFactoryData</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">SparkViewFactoryData</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sparkView</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">SparkView</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">trajectory</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">SparkTrajectory</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Firework</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 帮助方法，用于返回火花视图及对应的轨迹</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">spark</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">FireworkSpark</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FireworkSpark</span>(<span class="keyword">self</span>.sparkView(at: index), <span class="keyword">self</span>.trajectory(at: index))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是烟花的抽象。为了表示一个烟花需要这些东西:</p><ul><li><em>origin</em></li><li><em>scale</em></li><li><em>sparkSize</em></li><li><em>trajectoryFactory</em></li><li><em>sparkViewFactory</em></li></ul><p>在我们实现协议之前，还有一个我之前没有提到过的叫做<em>按轨迹缩放</em>的概念。当火花处于轨迹 &lt;-1, 1&gt; 或相似的位置时，我们希望它的大小会跟随轨迹变化。我们还需要放大路径以覆盖更大的屏幕显示效果。此外，我们还需要支持水平翻转路径，以方便我们实现经典烟花左侧部分的轨迹，并且还要让轨迹能朝某个指定方向偏移一点（增加随机性）。下面是两个能够帮助我们达到目的的方法，我相信这段代码已经不需要更多描述了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SparkTrajectory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 缩放轨迹使其符合各种 UI 的要求</span></span><br><span class="line">    <span class="comment">/// 在各种形变和 shift: 之前使用</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">scale</span><span class="params">(by value: CGFloat)</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> copy = <span class="keyword">self</span></span><br><span class="line">        (<span class="number">0</span>..&lt;<span class="keyword">self</span>.points.<span class="built_in">count</span>).forEach &#123; copy.points[$<span class="number">0</span>].multiply(by: value) &#125;</span><br><span class="line">        <span class="keyword">return</span> copy</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 水平翻转轨迹</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flip</span><span class="params">()</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> copy = <span class="keyword">self</span></span><br><span class="line">        (<span class="number">0</span>..&lt;<span class="keyword">self</span>.points.<span class="built_in">count</span>).forEach &#123; copy.points[$<span class="number">0</span>].x *= -<span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> copy</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 偏移轨迹，在每个点上生效</span></span><br><span class="line">    <span class="comment">/// 在各种形变和 scale: 和之后使用</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">shift</span><span class="params">(to point: CGPoint)</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> copy = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">let</span> vector = <span class="type">CGVector</span>(dx: point.x, dy: point.y)</span><br><span class="line">        (<span class="number">0</span>..&lt;<span class="keyword">self</span>.points.<span class="built_in">count</span>).forEach &#123; copy.points[$<span class="number">0</span>].add(vector: vector) &#125;</span><br><span class="line">        <span class="keyword">return</span> copy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，接下来就是实现经典烟花。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassicFirework</span>: <span class="title">Firework</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     x     |     x</span></span><br><span class="line"><span class="comment">        x  |   x</span></span><br><span class="line"><span class="comment">           |</span></span><br><span class="line"><span class="comment">     ---------------</span></span><br><span class="line"><span class="comment">         x |  x</span></span><br><span class="line"><span class="comment">       x   |</span></span><br><span class="line"><span class="comment">           |     x</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">FlipOptions</span>: <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> rawValue: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> horizontally = <span class="type">FlipOptions</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> vertically = <span class="type">FlipOptions</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">Quarter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> topRight</span><br><span class="line">        <span class="keyword">case</span> bottomRight</span><br><span class="line">        <span class="keyword">case</span> bottomLeft</span><br><span class="line">        <span class="keyword">case</span> topLeft</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> origin: <span class="type">CGPoint</span></span><br><span class="line">    <span class="keyword">var</span> scale: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">var</span> sparkSize: <span class="type">CGSize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> maxChangeValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> trajectoryFactory: <span class="type">SparkTrajectoryFactory</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ClassicSparkTrajectoryFactory</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> classicTrajectoryFactory: <span class="type">ClassicSparkTrajectoryFactoryProtocol</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.trajectoryFactory <span class="keyword">as</span>! <span class="type">ClassicSparkTrajectoryFactoryProtocol</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sparkViewFactory: <span class="type">SparkViewFactory</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CircleColorSparkViewFactory</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> quarters = [<span class="type">Quarter</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(origin: <span class="type">CGPoint</span>, sparkSize: <span class="type">CGSize</span>, scale: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.origin = origin</span><br><span class="line">        <span class="keyword">self</span>.scale = scale</span><br><span class="line">        <span class="keyword">self</span>.sparkSize = sparkSize</span><br><span class="line">        <span class="keyword">self</span>.quarters = <span class="keyword">self</span>.shuffledQuarters()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sparkViewFactoryData</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">SparkViewFactoryData</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">DefaultSparkViewFactoryData</span>(size: <span class="keyword">self</span>.sparkSize, index: index)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sparkView</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">SparkView</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.sparkViewFactory.create(with: <span class="keyword">self</span>.sparkViewFactoryData(at: index))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">trajectory</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> quarter = <span class="keyword">self</span>.quarters[index]</span><br><span class="line">        <span class="keyword">let</span> flipOptions = <span class="keyword">self</span>.flipOptions(<span class="keyword">for</span>: quarter)</span><br><span class="line">        <span class="keyword">let</span> changeVector = <span class="keyword">self</span>.randomChangeVector(flipOptions: flipOptions, maxValue: <span class="keyword">self</span>.maxChangeValue)</span><br><span class="line">        <span class="keyword">let</span> sparkOrigin = <span class="keyword">self</span>.origin.adding(vector: changeVector)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.randomTrajectory(flipOptions: flipOptions).scale(by: <span class="keyword">self</span>.scale).shift(to: sparkOrigin)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">flipOptions</span><span class="params">(`<span class="keyword">for</span>` quarter: Quarter)</span></span> -&gt; <span class="type">FlipOptions</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> flipOptions: <span class="type">FlipOptions</span> = []</span><br><span class="line">        <span class="keyword">if</span> quarter == .bottomLeft || quarter == .topLeft &#123;</span><br><span class="line">            flipOptions.insert(.horizontally)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> quarter == .bottomLeft || quarter == .bottomRight &#123;</span><br><span class="line">            flipOptions.insert(.vertically)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flipOptions</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">shuffledQuarters</span><span class="params">()</span></span> -&gt; [<span class="type">Quarter</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> quarters: [<span class="type">Quarter</span>] = [</span><br><span class="line">            .topRight, .topRight,</span><br><span class="line">            .bottomRight, .bottomRight,</span><br><span class="line">            .bottomLeft, .bottomLeft,</span><br><span class="line">            .topLeft, .topLeft</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> shuffled = [<span class="type">Quarter</span>]()</span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;quarters.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> idx = <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(quarters.<span class="built_in">count</span>)))</span><br><span class="line">            shuffled.append(quarters[idx])</span><br><span class="line">            quarters.remove(at: idx)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shuffled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">randomTrajectory</span><span class="params">(flipOptions: FlipOptions)</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> trajectory: <span class="type">SparkTrajectory</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> flipOptions.<span class="built_in">contains</span>(.vertically) &#123;</span><br><span class="line">            trajectory = <span class="keyword">self</span>.classicTrajectoryFactory.randomBottomRight()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            trajectory = <span class="keyword">self</span>.classicTrajectoryFactory.randomTopRight()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flipOptions.<span class="built_in">contains</span>(.horizontally) ? trajectory.flip() : trajectory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">randomChangeVector</span><span class="params">(flipOptions: FlipOptions, maxValue: Int)</span></span> -&gt; <span class="type">CGVector</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> values = (<span class="keyword">self</span>.randomChange(maxValue), <span class="keyword">self</span>.randomChange(maxValue))</span><br><span class="line">        <span class="keyword">let</span> changeX = flipOptions.<span class="built_in">contains</span>(.horizontally) ? -values.<span class="number">0</span> : values.<span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> changeY = flipOptions.<span class="built_in">contains</span>(.vertically) ? values.<span class="number">1</span> : -values.<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGVector</span>(dx: changeX, dy: changeY)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">randomChange</span><span class="params">(<span class="number">_</span> maxValue: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGFloat</span>(arc4random_uniform(<span class="type">UInt32</span>(maxValue)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数代码都是 <code>Firework</code> 协议的实现，所以应该很容易理解。我们在各处传递了需要的工厂类，还添加了一个额外的枚举类型来随机地为每个火花指定轨迹。</p><p>有少数几个方法用来为烟花和火花增加随机性。</p><p>还引入了一个 <code>quarters</code> 属性，其中包含了火花的所有的方位。我们通过  <code>shuffledQuarters:</code> 来重新排列，以确保我们不会总是在相同的方位创建相同数量的火花。</p><p>好了，我们创建好了烟花，接下来怎么让火花动起来呢？这就引入了火花动画启动器的概念。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SparkViewAnimator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animate</span><span class="params">(spark: FireworkSpark, duration: TimeInterval)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法接受一个包含火花视图和其对应轨迹的元组 <code>FireworkSpark</code>，以及动画的持续时间。方法的实现取决于我们。我自己的实现蛮多的，但主要做了三件事情：让火花视图跟随轨迹，同时缩放火花（带有随机性），修改其不透明度。简单吧。同时得益于 <code>SparkViewAnimator</code> 的抽象度，我们还可以很简单地将其替换成任何我们想要的动画效果。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ClassicFireworkAnimator</span>: <span class="title">SparkViewAnimator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animate</span><span class="params">(spark: FireworkSpark, duration: TimeInterval)</span></span> &#123;</span><br><span class="line">        spark.sparkView.isHidden = <span class="literal">false</span> <span class="comment">// show previously hidden spark view</span></span><br><span class="line"></span><br><span class="line">        <span class="type">CATransaction</span>.begin()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 火花的位置</span></span><br><span class="line">        <span class="keyword">let</span> positionAnim = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">"position"</span>)</span><br><span class="line">        positionAnim.path = spark.trajectory.path.cgPath</span><br><span class="line">        positionAnim.calculationMode = kCAAnimationLinear</span><br><span class="line">        positionAnim.rotationMode = kCAAnimationRotateAuto</span><br><span class="line">        positionAnim.duration = duration</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 火花的缩放</span></span><br><span class="line">        <span class="keyword">let</span> randomMaxScale = <span class="number">1.0</span> + <span class="type">CGFloat</span>(arc4random_uniform(<span class="number">7</span>)) / <span class="number">10.0</span></span><br><span class="line">        <span class="keyword">let</span> randomMinScale = <span class="number">0.5</span> + <span class="type">CGFloat</span>(arc4random_uniform(<span class="number">3</span>)) / <span class="number">10.0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> fromTransform = <span class="type">CATransform3DIdentity</span></span><br><span class="line">        <span class="keyword">let</span> byTransform = <span class="type">CATransform3DScale</span>(fromTransform, randomMaxScale, randomMaxScale, randomMaxScale)</span><br><span class="line">        <span class="keyword">let</span> toTransform = <span class="type">CATransform3DScale</span>(<span class="type">CATransform3DIdentity</span>, randomMinScale, randomMinScale, randomMinScale)</span><br><span class="line">        <span class="keyword">let</span> transformAnim = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">"transform"</span>)</span><br><span class="line"></span><br><span class="line">        transformAnim.values = [</span><br><span class="line">            <span class="type">NSValue</span>(caTransform3D: fromTransform),</span><br><span class="line">            <span class="type">NSValue</span>(caTransform3D: byTransform),</span><br><span class="line">            <span class="type">NSValue</span>(caTransform3D: toTransform)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        transformAnim.duration = duration</span><br><span class="line">        transformAnim.timingFunction = <span class="type">CAMediaTimingFunction</span>(name: kCAMediaTimingFunctionEaseOut)</span><br><span class="line">        spark.sparkView.layer.transform = toTransform</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 火花的不透明度</span></span><br><span class="line">        <span class="keyword">let</span> opacityAnim = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">"opacity"</span>)</span><br><span class="line">        opacityAnim.values = [<span class="number">1.0</span>, <span class="number">0.0</span>]</span><br><span class="line">        opacityAnim.keyTimes = [<span class="number">0.95</span>, <span class="number">0.98</span>]</span><br><span class="line">        opacityAnim.duration = duration</span><br><span class="line">        spark.sparkView.layer.opacity = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组合动画</span></span><br><span class="line">        <span class="keyword">let</span> groupAnimation = <span class="type">CAAnimationGroup</span>()</span><br><span class="line">        groupAnimation.animations = [positionAnim, transformAnim, opacityAnim]</span><br><span class="line">        groupAnimation.duration = duration</span><br><span class="line"></span><br><span class="line">        <span class="type">CATransaction</span>.setCompletionBlock(&#123;</span><br><span class="line">            spark.sparkView.removeFromSuperview()</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        spark.sparkView.layer.add(groupAnimation, forKey: <span class="string">"spark-animation"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="type">CATransaction</span>.commit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的代码已经足够让我们在特定的视图上展示烟花了。我又更进了一步，创建了一个 <code>ClassicFireworkController</code> 来处理所有的工作，这样用一行代码就能启动烟花。</p><p>这个烟花控制器还做了另一件事。它可以修改烟花的 <code>zPosition</code>，这样我们可以让烟花一前一后地展示，效果更好看一些。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassicFireworkController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sparkAnimator: <span class="type">SparkViewAnimator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ClassicFireworkAnimator</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createFirework</span><span class="params">(at origin: CGPoint, sparkSize: CGSize, scale: CGFloat)</span></span> -&gt; <span class="type">Firework</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ClassicFirework</span>(origin: origin, sparkSize: sparkSize, scale: scale)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 让烟花在其源视图的角落附近爆开</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addFireworks</span><span class="params">(<span class="built_in">count</span> fireworksCount: Int = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      sparks sparksCount: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">                      around sourceView: UIView,</span></span></span><br><span class="line"><span class="function"><span class="params">                      sparkSize: CGSize = CGSize<span class="params">(width: <span class="number">7</span>, height: <span class="number">7</span>)</span></span></span>,</span><br><span class="line">                      scale: <span class="type">CGFloat</span> = <span class="number">45.0</span>,</span><br><span class="line">                      maxVectorChange: <span class="type">CGFloat</span> = <span class="number">15.0</span>,</span><br><span class="line">                      animationDuration: <span class="type">TimeInterval</span> = <span class="number">0.4</span>,</span><br><span class="line">                      canChangeZIndex: <span class="type">Bool</span> = <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> superview = sourceView.superview <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>() &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> origins = [</span><br><span class="line">            <span class="type">CGPoint</span>(x: sourceView.frame.minX, y: sourceView.frame.minY),</span><br><span class="line">            <span class="type">CGPoint</span>(x: sourceView.frame.maxX, y: sourceView.frame.minY),</span><br><span class="line">            <span class="type">CGPoint</span>(x: sourceView.frame.minX, y: sourceView.frame.maxY),</span><br><span class="line">            <span class="type">CGPoint</span>(x: sourceView.frame.maxX, y: sourceView.frame.maxY),</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;fireworksCount &#123;</span><br><span class="line">            <span class="keyword">let</span> idx = <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(origins.<span class="built_in">count</span>)))</span><br><span class="line">            <span class="keyword">let</span> origin = origins[idx].adding(vector: <span class="keyword">self</span>.randomChangeVector(<span class="built_in">max</span>: maxVectorChange))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> firework = <span class="keyword">self</span>.createFirework(at: origin, sparkSize: sparkSize, scale: scale)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> sparkIndex <span class="keyword">in</span> <span class="number">0</span>..&lt;sparksCount &#123;</span><br><span class="line">                <span class="keyword">let</span> spark = firework.spark(at: sparkIndex)</span><br><span class="line">                spark.sparkView.isHidden = <span class="literal">true</span></span><br><span class="line">                superview.addSubview(spark.sparkView)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> canChangeZIndex &#123;</span><br><span class="line">                    <span class="keyword">let</span> zIndexChange: <span class="type">CGFloat</span> = arc4random_uniform(<span class="number">2</span>) == <span class="number">0</span> ? -<span class="number">1</span> : +<span class="number">1</span></span><br><span class="line">                    spark.sparkView.layer.zPosition = sourceView.layer.zPosition + zIndexChange</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    spark.sparkView.layer.zPosition = sourceView.layer.zPosition</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">self</span>.sparkAnimator.animate(spark: spark, duration: animationDuration)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">randomChangeVector</span><span class="params">(<span class="built_in">max</span>: CGFloat)</span></span> -&gt; <span class="type">CGVector</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGVector</span>(dx: <span class="keyword">self</span>.randomChange(<span class="built_in">max</span>: <span class="built_in">max</span>), dy: <span class="keyword">self</span>.randomChange(<span class="built_in">max</span>: <span class="built_in">max</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">randomChange</span><span class="params">(<span class="built_in">max</span>: CGFloat)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGFloat</span>(arc4random_uniform(<span class="type">UInt32</span>(<span class="built_in">max</span>))) - (<span class="built_in">max</span> / <span class="number">2.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个控制器只做了几件事情。随机选择了一个角落展示烟花。在烟花出现的位置，烟花和火花的数量上增加了一些随机性。然后将火花添加到目标视图上，如果需要的话还会调整 <code>zIndex</code>，最后启动了动画。</p><p>几乎所有的参数都设置了默认参数，所以你可以不管他们。直接通过你的控制器调用这个：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.fireworkController.addFireworks(<span class="built_in">count</span>: <span class="number">2</span>, sparks: <span class="number">8</span>, around: button)</span><br></pre></td></tr></table></figure><p>然后，哇!</p><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/classic.gif1565786279.8336995" alt="classic"></p><p>从这一步起，新添加一个像下面这样的烟花就变得非常简单了。你只需要定义新的轨迹，创建一个新的烟花，并且按照你希望的样子来实现即可。将这些代码放入一个控制器可以让你想在哪里启动烟花都很简单 :) 或者你也可以直接使用这个<em>喷泉烟花</em>，我已经把它放在了我的 github 项目 <a href="https://github.com/tomkowz/fireworks" target="_blank" rel="noopener">tomkowz/fireworks</a> 中。</p><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/fountain.gif1565786280.6926286" alt="fountain"></p><h2 id="总结"><a href="#总结" class="headerlink" title="_总结_"></a>_总结_</h2><p>这个动画效果的实现并不简单但也不算很难。通过对问题（在我们的情况下是动画效果）的正确分析，我们可以将其分解成多个小问题，逐个解决然后将其组合在一起。真希望我有机会能够在未来的的项目中使用这个效果🎉</p><p>好啦这就是今天的内容。感谢阅读！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Tomasz Szulc，&lt;a href=&quot;http://szulctomasz.com/programming-blog/2018/09/add-fireworks-and-sparks-to-a-uiview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-09&lt;br&gt;译者：&lt;a href=&quot;https://github.com/joeytat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Joeytat&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/WAMaker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WAMaker&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/Pancf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pancf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
    
    </summary>
    
      <category term="Tomasz Szulc" scheme="https://swift.gg/categories/Tomasz-Szulc/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="教程" scheme="https://swift.gg/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Bundles and Packages</title>
    <link href="https://swift.gg/2019/07/19/nshipster-bundles-and-packages/"/>
    <id>https://swift.gg/2019/07/19/nshipster-bundles-and-packages/</id>
    <published>2019-07-18T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/bundles-and-packages/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-12-17<br>译者：<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://bignerdcoding.com/" target="_blank" rel="noopener">BigNerdCoding</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>在这个给予的季节，让我们停下脚步，思考一个现代计算机系统赐予我们的最棒的礼物：抽象。</p><p>在数百万 CPU 晶体管、SSD 扇区和 LCD 像素共同协作下，全球数十亿人能够日常使用计算机和移动设备而对此全然不知。这一切都应归功于像文件，目录，应用和文档这样的抽象。</p><p>这周的 NSHipster，我们将讨论苹果平台上两个重要的抽象：包与包裹。🎁</p><a id="more"></a><hr><p>尽管是不同的概念，包与包裹这两个术语经常会被替换使用。毫无疑问，造成困惑的部分原因出自它们相似的名称，但或许主要原因是许多包恰好也是包裹（反之亦然）。</p><p>在我们深入之前，先定义一下这两个术语：</p><ul><li>包是指具有已知结构的，包含可执行代码，以及代码所需的资源的目录。</li><li>包裹是指在访达中看起来像是文件的目录。</li></ul><p>下图展示了包与包裹之间的关系，将应用、框架包、插件包和文档分别放入一个或多个分类之中：<br><img src="https://nshipster.com/assets/packages-and-bundles-diagram-a604d818c7decc7430fffc8642f0743728d2f6be4dfae15b274a599655cd3e40.svg" alt="diagram"></p><blockquote><p>如果对两者的区别你依然感到困惑，这个类比或许能帮助你理解：<br>把包裹想象成是一个内容被隐藏的盒子（📦），作为一个独立的实体而存在。这点与包不同，包更像是一个背包（🎒） —— 每一款都有特殊的口袋和隔层用来携带你需要的东西，不同的配置用以决定是带去学校，去工作，还是去健身房。如果某样东西既是包也是包裹，恰似行李（🧳）一般：像盒子一样浑然一体，像背包一样分隔自如。</p></blockquote><h2 id="包（Bundles）"><a href="#包（Bundles）" class="headerlink" title="包（Bundles）"></a>包（Bundles）</h2><p>包为代码和资源的组织提供了特定结构，意在<strong>提升开发者的体验</strong>。这个结构不仅允许预测性的加载代码和资源，同时也支持类似于本地化这样的系统性特性。</p><p>包分属于以下三个类别，每一种都有它自己特殊的结构和要求：</p><ul><li><strong>应用包（App Bundles）</strong>：包含一个能被启动的可执行文件，一个描述可执行文件的 <code>Info.plist</code> 文件，应用图标，启动图片，能被可执行文件调用的接口文件，字符串文件，以及数据文件。</li><li><strong>框架包（Framework Bundles）</strong>：包含动态分享库所需要的代码和资源。</li><li><strong>可加载包（Loadable Bundles）</strong>：类似于插件，包含扩展应用功能的可执行代码和资源。</li></ul><h3 id="访问包内容"><a href="#访问包内容" class="headerlink" title="访问包内容"></a>访问包内容</h3><p>对于应用，playgrounds，以及其它你感兴趣的包来说，都能通过 <code>Bundle.main</code> 进行访问。大多数情况，可以使用 <code>url(forResource:withExtension:)</code>（或它的一种变体）来获取特定资源的路径。</p><p>举例来说，如果应用中包含了一个名叫 <code>Photo.jpg</code> 的文件，用下面的方法能获得访问它的 URL：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Bundle</span>.main.url(forResource: <span class="string">"Photo"</span>, withExtension: <span class="string">"jpg"</span>)</span><br></pre></td></tr></table></figure></p><blockquote><p>如果使用 Asset Catalog，你可以从媒体库（<kbd>⇧</kbd><kbd>⌘</kbd><kbd>M</kbd>）拖拽到编辑器来创建图像。</p></blockquote><p>除此之外，<code>Bundle</code> 提供了一些实例方法和变量来获取标准包内容的位置，返回 URL 或 String 类型的路径：</p><table><thead><tr><th>URL</th><th>Path</th><th>描述</th></tr></thead><tbody><tr><td>executableURL</td><td>executablePath</td><td>可执行文件</td></tr><tr><td>url(forAuxiliaryExecutable:)</td><td>path(forAuxiliaryExecutable:)</td><td>辅助的可执行文件</td></tr><tr><td>resourceURL</td><td>resourcePath</td><td>包含资源的子目录</td></tr><tr><td>sharedFrameworksURL</td><td>sharedFrameworksPath</td><td>包含共享框架的子目录</td></tr><tr><td>privateFrameworksURL</td><td>privateFrameworksPath</td><td>包含私有框架的子目录</td></tr><tr><td>builtInPlugInsURL</td><td>builtInPlugInsPath</td><td>包含插件的子目录</td></tr><tr><td>sharedSupportURL</td><td>sharedSupportPath</td><td>包含共享支援文件的子目录</td></tr><tr><td>appStoreReceiptURL</td><td></td><td>App Store 的收据</td></tr></tbody></table><h3 id="获取应用信息"><a href="#获取应用信息" class="headerlink" title="获取应用信息"></a>获取应用信息</h3><p>所有的应用包都必须有一个包含应用信息的 <code>Info.plist</code> 文件。</p><p><code>bundleURL</code> 和 <code>bundleIdentifier</code> 这样的原数据能够通过 bundle 实例被直接访问。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bundle = <span class="type">Bundle</span>.main</span><br><span class="line"></span><br><span class="line">bundle.bundleURL        <span class="comment">// "/path/to/Example.app"</span></span><br><span class="line">bundle.bundleIdentifier <span class="comment">// "com.nshipster.example"</span></span><br></pre></td></tr></table></figure></p><p>通过下标能从 <code>infoDictionary</code> 变量获得其他信息（如果信息要展示给用户，请使用 <code>localizedInfoDictionary</code>）。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">bundle.infoDictionary[<span class="string">"CFBundleName"</span>] <span class="comment">// "Example"</span></span><br><span class="line">bundle.localizedInfoDictionary[<span class="string">"CFBundleName"</span>] <span class="comment">// "Esempio" (`it_IT` locale)</span></span><br></pre></td></tr></table></figure></p><h3 id="获取本地化字符串"><a href="#获取本地化字符串" class="headerlink" title="获取本地化字符串"></a>获取本地化字符串</h3><p>包的存在让本地化变得容易。强制本地化资源的存放位置后，系统便能将加载哪个版本的文件的逻辑从开发者层面抽象出来。</p><p>举个例子，包负责加载应用的本地化字符串。使用 <code>localizedString(forKey:value:table:)</code> 方法就可以获取到这些值。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bundle = <span class="type">Bundle</span>.main</span><br><span class="line">bundle.localizedString(forKey: <span class="string">"Hello, %@"</span>,</span><br><span class="line">                       value: <span class="string">"Hello, $&#123;username&#125;"</span>,</span><br><span class="line">                       table: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p><p>然而，通常来说用 <code>NSLocalizedString</code> 会更好，像 <code>genstrings</code> 这样的工具能够自动取出键和注释到 <code>.strings</code> 文件中便于翻译。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Terminal</span><br><span class="line">$ find . \( -name &quot;*.swift&quot; !           \ # 找出所有 swift 文件</span><br><span class="line">            ! -path &quot;./Carthage/*&quot;      \ # 无视 Carthage 与 CocoaPods 的依赖</span><br><span class="line">            ! -path &quot;./Pods/*&quot;</span><br><span class="line">         \)    |                        \</span><br><span class="line">  tr &apos;\n&apos; &apos;\0&apos; |                        \ # 替换分隔符</span><br><span class="line">  xargs -0 genstrings -o .              \ # 处理带空格的路径</span><br></pre></td></tr></table></figure></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSLocalizedString</span>(<span class="string">"Hello, %@"</span>, comment: <span class="string">"Hello, $&#123;username&#125;"</span>)</span><br></pre></td></tr></table></figure><h2 id="包裹（Packages）"><a href="#包裹（Packages）" class="headerlink" title="包裹（Packages）"></a>包裹（Packages）</h2><p>包裹把相关资源封装和加固成一个独立单元，意在<strong>提升用户体验</strong>。</p><p>满足以下任意一个条件，目录就会被访达认为是包裹：</p><ul><li>目录有类似于 <code>.app</code>，<code>.playground</code> 或 <code>.plugin</code> 等特殊扩展。</li><li>目录有一个被一个应用注册作为文档类型的扩展。</li><li>目录具有有扩展属性，将其指定为包裹。</li></ul><h3 id="访问包裹中的内容"><a href="#访问包裹中的内容" class="headerlink" title="访问包裹中的内容"></a>访问包裹中的内容</h3><p>在访达中，右键展示选中项目的可操作目录。如果选中项目是包裹，“打开”操作下会出现“显示包内容”选项。<br><img src="https://nshipster.com/assets/show-package-contents-c7cc72f58a573cb2fbe349e6f76a4ef29d14fbada3cd9b8376fc37979da16bf3.png" alt></p><p>点击这个选项会从包裹目录打开一个新的访达窗口。</p><p>当然，也可以通过代码访问包裹中的内容。包裹的类型决定了获取内容的最佳方式：</p><ul><li>如果包裹有包的结构，前文所说的 <code>Bundle</code> 就能轻松胜任。</li><li>如果包裹是一个文档，在 macOS 上使用 <code>NSDocument</code> 或在 iOS 上使用 <code>UIDocument</code> 来访问。</li><li>其他情况下，用 <code>FileWrapper</code> 导航目录，文件和符号链接，用 <code>FileHandler</code> 来读写文件描述。</li></ul><h3 id="判断一个目录是否是包裹"><a href="#判断一个目录是否是包裹" class="headerlink" title="判断一个目录是否是包裹"></a>判断一个目录是否是包裹</h3><p>虽说是由访达决定如何展示文件和目录，大多数的判断会被代理给操作系统以及管理统一类型标识（UTI）的服务。</p><p>如果想要确定一个文件扩展是一个内置系统包裹类型，还是一个被已安装的应用使用的文档类型，调用 Core Services 方法 <code>UTTypeCreatePreferredIdentifierForTag(_:_:_:)</code> 与 <code>UTTypeConformsTo(_:_:)</code> 能满足你的需求：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CoreServices</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">directoryIsPackage</span><span class="params">(<span class="number">_</span> url: URL)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> filenameExtension: <span class="type">CFString</span> = url.pathExtension <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> uti = <span class="type">UTTypeCreatePreferredIdentifierForTag</span>(</span><br><span class="line">                        kUTTagClassFilenameExtension,</span><br><span class="line">                        filenameExtension, <span class="literal">nil</span></span><br><span class="line">                    )?.takeRetainedValue()</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">UTTypeConformsTo</span>(uti, kUTTypePackage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xcode = <span class="type">URL</span>(fileURLWithPath: <span class="string">"/Applications/Xcode.app"</span>)</span><br><span class="line">directoryIsPackage(xcode) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><blockquote><p>我们找不到任何描述如何设置所谓的包裹比特（package bit）的文档，但根据 <a href="https://opensource.apple.com/source/CarbonHeaders/CarbonHeaders-8A428/Finder.h" target="_blank" rel="noopener">CarbonCore/Finder.h</a>，在 <code>com.apple.FindlerInfo</code> 扩展参数中设置 <code>kHasBundle（0x2000）</code> 标示能够实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; $ xattr -wx com.apple.FinderInfo /path/to/package \</span><br><span class="line">&gt;  00 00 00 00 00 00 00 00 20 00 00 00 00 00 00 00 \</span><br><span class="line">&gt;  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><hr><p>正如我们看到的那样，并非只有终端用户从抽象中获益 —— 无论是像 Swift 这样的高级编程语言的安全性和表现力，还是像 Foundation 这样的 API 的便利性，作为开发者也可以利用抽象开发出优秀的软件。</p><p>或许我们会抱怨 <a href="https://en.wikipedia.org/wiki/Leaky_abstraction" target="_blank" rel="noopener">抽象泄漏</a> 与 <a href="https://en.wikipedia.org/wiki/Abstraction_inversion" target="_blank" rel="noopener">抽象反转</a> 带来的问题，但重要的是退一步，了解我们每天处理多少有用的抽象，以及它们带给了我们多少可能性。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mattt，&lt;a href=&quot;https://nshipster.com/bundles-and-packages/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-12-17&lt;br&gt;译者：&lt;a href=&quot;https://github.com/WAMaker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WAMaker&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://bignerdcoding.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigNerdCoding&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在这个给予的季节，让我们停下脚步，思考一个现代计算机系统赐予我们的最棒的礼物：抽象。&lt;/p&gt;
&lt;p&gt;在数百万 CPU 晶体管、SSD 扇区和 LCD 像素共同协作下，全球数十亿人能够日常使用计算机和移动设备而对此全然不知。这一切都应归功于像文件，目录，应用和文档这样的抽象。&lt;/p&gt;
&lt;p&gt;这周的 NSHipster，我们将讨论苹果平台上两个重要的抽象：包与包裹。🎁&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的集合（Set）</title>
    <link href="https://swift.gg/2019/07/09/Sets-in-Swift/"/>
    <id>https://swift.gg/2019/07/09/Sets-in-Swift/</id>
    <published>2019-07-08T16:00:00.000Z</published>
    <updated>2023-08-26T12:25:35.818Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/sets-in-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-09-06<br>译者：<a href="https://github.com/rsenjoyer" target="_blank" rel="noopener">rsenjoyer</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>集合（Set）是 Swift 集合类型（collection types）之一，集合用来存储类型相同且没有确定顺序唯一的值。你可以将集合想象成一盒台球：它们在颜色和数量上独一无二，但在盒内是无序的。</p><p><img src="https://swift.gg/img/articles/Sets-in-Swift/billiard.jpg1562643187.9223473" alt></p><a id="more"></a><p><em>提示：这篇文章使用的是 Swift 4 和 Xcode 10</em></p><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>创建一个集合非常简单：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> setA: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br></pre></td></tr></table></figure><p>在这个例子中，创建一个 <code>String</code> 类型的集合，命名为 <code>setA</code>。它存储着 <code>a</code>、<code>b</code>、<code>c</code> 三个值。与数组相比，集合内元素是无序的。通过编译器的类型推导功能，你也可以像如下方式创建集合：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> setB: <span class="type">Set</span> = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br></pre></td></tr></table></figure><p>同样也可以使用集合的构造器：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> setC = <span class="type">Set</span>([<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>])</span><br></pre></td></tr></table></figure><p>跟数组一样，如果使用 <code>let</code> 来定义一个集合，它就是不可变的。使用 <code>var</code>定义的是一个可变集合。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setD = <span class="type">Set</span>([<span class="string">"a"</span>,<span class="string">"b"</span>])</span><br></pre></td></tr></table></figure><p>稍后我们将了解更多有关可变集合的信息。</p><h2 id="访问集合中的元素"><a href="#访问集合中的元素" class="headerlink" title="访问集合中的元素"></a>访问集合中的元素</h2><p>你可以使用循环来访问集合中的元素：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> setA &#123;</span><br><span class="line">     <span class="built_in">print</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：每次运行代码时，循环中值的顺序可能不同。从表面来看，它们像是随机返回一样。</p><h2 id="集合分析"><a href="#集合分析" class="headerlink" title="集合分析"></a>集合分析</h2><p>首先，你可以检查集合是否为空：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(setA.isEmpty)</span><br></pre></td></tr></table></figure><p>也可以获取集合中元素的个数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(setA.<span class="built_in">count</span>)</span><br></pre></td></tr></table></figure><p>上面的操作对数组同样有效，对集合而言，更加普遍的问题是判断集合中是否包含某个元素。为此，你可以使用 <code>contains</code> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(setA.<span class="built_in">contains</span>(<span class="string">"a"</span>))</span><br></pre></td></tr></table></figure><h2 id="从集合中添加和删除元素"><a href="#从集合中添加和删除元素" class="headerlink" title="从集合中添加和删除元素"></a>从集合中添加和删除元素</h2><p>你可以向可变集合里面添加和删除元素:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">setD.insert(<span class="string">"c"</span>)</span><br><span class="line">setD.remove(<span class="string">"a"</span>)</span><br></pre></td></tr></table></figure><p>由于集合元素的唯一性，因此只能将同一个元素添加到集合中一次。可以多次使用相同的值调用 <code>insert</code> 方法，但集合不会改变。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setE: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"> </span><br><span class="line">setE.insert(<span class="number">5</span>)</span><br><span class="line">setE.insert(<span class="number">5</span>)</span><br><span class="line">setE.insert(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(setE) <span class="comment">//[4,5,1,2,3]</span></span><br></pre></td></tr></table></figure><p>和前面所说的一样，上面代码每次执行时输出的顺序可能不同，因为集合元素无序。</p><h2 id="集合比较"><a href="#集合比较" class="headerlink" title="集合比较"></a>集合比较</h2><p>集合间能进行比较。显然，可以比较两个集合是否相等：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> setA: = [“a”, “b”, “<span class="built_in">c</span>”]</span><br><span class="line"><span class="keyword">let</span> setB: = [“a”, “b”, “<span class="built_in">c</span>”]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> setA == setB &#123;</span><br><span class="line">     <span class="built_in">print</span>(“the sets are <span class="built_in">equal</span>”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，集合是相等的。</p><p>比较两个集合的大小是没有明确的定义，但可以检查一个集合是否是另一个集合的子集：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intSetA: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> intSetB: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">intSetB.isSubset(of: intSetA) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>也可以检查集合是否是另一个集合的真子集。这种情况就是该集合是另一个集合的子集但不想等。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intSetA: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> intSetB: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> intSetC: <span class="type">Set</span> = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"> </span><br><span class="line">intSetB.isSubset(of: intSetA) <span class="comment">//true</span></span><br><span class="line">intSetB.isStrictSubset(of: intSetA) <span class="comment">//false</span></span><br><span class="line">intSetC.isSubset(of: intSetA) <span class="comment">// true</span></span><br><span class="line">intSetC.isStrictSubset(of: intSetA) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>与之相对的概念就是超集：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intSetA: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> intSetC: <span class="type">Set</span> = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">intSetA.isSuperset(of: intSetC) <span class="comment">//true</span></span><br><span class="line">intSetA.isStrictSuperset(of: intSetC) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>如果两个集合没有相同的元素，那么就说这两个集合不相交</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intSetA: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> intSetC: <span class="type">Set</span> = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> intSetD: <span class="type">Set</span> = [<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]</span><br><span class="line"> </span><br><span class="line">intSetA.isDisjoint(with: intSetC) <span class="comment">//false</span></span><br><span class="line">intSetA.isDisjoint(with: intSetD) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="集合结合"><a href="#集合结合" class="headerlink" title="集合结合"></a>集合结合</h2><p>你可以将两个集合合并成为一个新集合，新的集合中包含两个集合中所有的元素：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringSetA: <span class="type">Set</span> = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br><span class="line"><span class="keyword">let</span> stringSetB: <span class="type">Set</span> = [<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unionSetAB = stringSetA.union(stringSetB)</span><br><span class="line"><span class="built_in">print</span>(unionSetAB) <span class="comment">//["d", "b", "c", "a", "e"]</span></span><br></pre></td></tr></table></figure><p>另一方面，交集就是仅包含两个集合中共同的元素：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringSetA: <span class="type">Set</span> = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br><span class="line"><span class="keyword">let</span> stringSetB: <span class="type">Set</span> = [<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> intersectionAB = stringSetA.intersection(stringSetB)</span><br><span class="line"><span class="built_in">print</span>(intersectionAB) <span class="comment">//[“c”]</span></span><br></pre></td></tr></table></figure><h2 id="自定义集合元素类型"><a href="#自定义集合元素类型" class="headerlink" title="自定义集合元素类型"></a>自定义集合元素类型</h2><p>你可以在集合中存储自定义的类型。这种类型可以是类或者结构体。为了能正常使用集合，该类型必须遵循 <code>hashable</code> 协议。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">     <span class="keyword">var</span> year: <span class="type">Int</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">init</span>(title: <span class="type">String</span>, year: <span class="type">Int</span>) &#123;</span><br><span class="line">          <span class="keyword">self</span>.title = title</span><br><span class="line">          <span class="keyword">self</span>.year = year</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Movie, rhs: Movie)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> lhs.title == rhs.title &amp;&amp;</span><br><span class="line">          lhs.year == rhs.year</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> title.hashValue ^ year.hashValue</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> terminator = <span class="type">Movie</span>(title: <span class="string">"Terminator"</span>, year: <span class="number">1980</span>)</span><br><span class="line"><span class="keyword">let</span> backToTheFuture = <span class="type">Movie</span>(title: <span class="string">"Back to the Future"</span>, year: <span class="number">1985</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> movieSetA: <span class="type">Set</span> = [terminator,backToTheFuture]</span><br></pre></td></tr></table></figure><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      关于 Swift 中的集合（Set）
    
    </summary>
    
      <category term="thomashanning" scheme="https://swift.gg/categories/thomashanning/"/>
    
    
      <category term="Swift，iOS开发，Swift进阶" scheme="https://swift.gg/tags/Swift%EF%BC%8CiOS%E5%BC%80%E5%8F%91%EF%BC%8CSwift%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
</feed>
