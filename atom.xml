<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftGG</title>
  
  <subtitle>走心的 Swift 翻译组</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swift.gg/"/>
  <updated>2018-05-18T10:47:19.563Z</updated>
  <id>https://swift.gg/</id>
  
  <author>
    <name>SwiftGG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 的可选型枚举</title>
    <link href="https://swift.gg/2018/05/17/enums-and-optionals/"/>
    <id>https://swift.gg/2018/05/17/enums-and-optionals/</id>
    <published>2018-05-17T00:00:00.000Z</published>
    <updated>2018-05-18T10:47:19.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2018/04/enums-and-optionals/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-11<br>译者：<a href="https://weibo.com/u/1771329710" target="_blank" rel="noopener">ennisk</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>去年我写了一篇关于<a href="http://khanlou.com/2017/03/that-one-optional-property/" target="_blank" rel="noopener">在类中添加普通可选型属性使扩展功能变得更简单</a>的文章，但是从长远来看会对代码库造成一定的损害，本文接上一篇内容。</p><p>假设你正在设计 App 中的认证流程，而且知道这个流程不是简单的线性执行代码，所以想写一些测试代码。</p><a id="more"></a><p>首先列举出流程中的每一步：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AuthFlowStep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> collectUsernameAndPassword</span><br><span class="line">    <span class="keyword">case</span> findFriends</span><br><span class="line">    <span class="keyword">case</span> uploadAvatar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将所有复杂的逻辑放入到一个函数中，该函数接收当前步骤和当前状态，返回流程中的下一个步骤。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepAfter</span><span class="params">(<span class="number">_</span> currentStep: AuthFlowStep, context: UserState)</span></span> -&gt; <span class="type">AuthFlowStep</span></span><br></pre></td></tr></table></figure><p>这应该很容易测试，到目前为止一切正常。</p><p>但是，在认真思考逻辑之后，你会发现有时候不能返回 <code>AuthFlowStep</code> 。一旦用户提交了所有认证需要的数据，你就需要想个办法表示流程已经结束了。在这个函数中，你需要返回一个特殊值。所以要怎么做呢？很简单，把返回类型改为可选值即可：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepAfter</span><span class="params">(<span class="number">_</span> currentStep: AuthFlowStep, context: UserState)</span></span> -&gt; <span class="type">AuthFlowStep</span>?</span><br></pre></td></tr></table></figure><p>这个方法可以解决问题，你可以在 <a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener">coordinator</a> 中调用这个函数，继续实现你的功能：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finished</span><span class="params">(flowStep: AuthFlowStep, state: UserState, from vc: SomeViewController)</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> nextState = stepAfter(flowStep, context: state)</span><br></pre></td></tr></table></figure><p>由于 <code>nextState</code> 是可选值，所以最直接的想法就是用 <code>guard</code> 方法把它变成非可选值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> nextState = stepAfter(flowStep, context: state) <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">self</span>.parentCoordinator.authFlowFinished(on: <span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">switch</span> nextState &#123;</span><br><span class="line">  <span class="keyword">case</span> .collectUsernameAndPassword:</span><br><span class="line"><span class="comment">//build and present next view controller</span></span><br></pre></td></tr></table></figure><p>但是我总觉得这里的写法有点问题。阅读 <a href="http://alisoftware.github.io/swift/pattern-matching/2016/04/24/pattern-matching-3/#syntactic-sugar-on-optionals" target="_blank" rel="noopener">Olivier 的模式匹配指南</a> 之后，我发现可以在 <code>switch</code> 语句中同时处理可选值和枚举值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finished</span><span class="params">(flowStep: AuthFlowStep, state: UserState, from viewController: SomeViewController)</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> nextState = stepAfter(flowStep, context: state) <span class="comment">// Optional&lt;AuthFlowStep&gt;</span></span><br><span class="line"><span class="keyword">switch</span> nextState &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">self</span>.parentCoordinator.authFlowFinished(on: <span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">case</span> .collectUsernameAndPassword?:</span><br><span class="line"><span class="comment">//build and present next view controller</span></span><br></pre></td></tr></table></figure><p>代码里的那个问号可以匹配枚举的可选值。这种写法确实更好，但还是有点不对劲。既然我已经用了 <code>switch</code>，为什么还要做解包操作？<code>nil</code> 在这个上下文中又代表着什么？</p><p>如果你认真读过这篇文章的标题，或许已经猜到了我下面要做什么。我们先来看看可选值的定义。在底层代码中，它和 <code>AuthFlowState</code> 一样是个枚举：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">case</span> some(<span class="type">Wrapped</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把枚举转换成可选类型时，实际上只是向枚举中添加了一个新值。既然我们能直接控制 <code>AuthFlowStep</code>，直接给它添加一个新值就能实现同样的效果。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AuthFlowStep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> collectUsernameAndPassword</span><br><span class="line">    <span class="keyword">case</span> findFriends</span><br><span class="line">    <span class="keyword">case</span> uploadAvatar</span><br><span class="line">    <span class="keyword">case</span> finished</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以从函数返回值类型中删掉 <code>?</code> 了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepAfter</span><span class="params">(<span class="number">_</span> currentStep: AuthFlowStep, context: UserState)</span></span> -&gt; <span class="type">AuthFlowStep</span></span><br></pre></td></tr></table></figure><p>我们的 <code>switch</code> 语句现在可以直接处理所有步骤，不需要对 <code>nil</code> 做特殊处理。</p><p>为什么这样更好？有几个原因：</p><p>首先，现在 <code>nil</code> 对应的情况有了具体的名字。以前，使用该函数的用户可能不清楚函数返回 <code>nil</code> 意味着什么。他们要么去阅读文档求助，要么直接阅读函数代码，分析什么时候会返回 <code>nil</code> 。</p><p>第二，简单才是王道，不需要先用 <code>guard</code> 解包再用 <code>switch</code> 判断，也不需要用 <code>swtich</code> 语句处理两层枚举，一层枚举更容易处理。</p><p>最后，代码更加健壮。<code>return nil</code> 应该留给真正异常情况。下一个开发者可能需要在某些特殊情况发生时退出函数，他想都没想就写了个 <code>return nil</code>。这时 <code>nil</code> 就具备了两种含义，你的代码无法正确处理。</p><p>当你把特殊情况添加到枚举中时，需要想好到底使用什么名字。你有很多选择，挑一个最合适的：<code>.unknow</code>，<code>.none</code>，<code>.finished</code>，<code>.initial</code>，<code>.notFound</code>，<code>.default</code>，<code>.nothing</code>，<code>.unspecified</code> 等等（需要注意，如果你有一个 case 匹配的是 <code>.none</code>，并且匹配的值是可选值，那么 <code>Option.none</code> 和 <code>YourEnum.none</code> 都会引起歧义，所以不要在匹配可选值的时候使用 <code>.none</code> 去表示你自己的状态）。</p><p>这篇文章介绍的是流程状态，但我觉得这种模式也同样适用其他情况 — 如果你想把一个枚举改成可选值，最好先停下来想一想，是否可以给枚举加一个新值来表示特殊情况。</p><p>感谢 <a href="https://irace.me/" target="_blank" rel="noopener">Bryan Irace</a> 提出的反馈和示例代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2018/04/enums-and-optionals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-04-11&lt;br&gt;译者：&lt;a href=&quot;https://weibo.com/u/1771329710&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ennisk&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;去年我写了一篇关于&lt;a href=&quot;http://khanlou.com/2017/03/that-one-optional-property/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在类中添加普通可选型属性使扩展功能变得更简单&lt;/a&gt;的文章，但是从长远来看会对代码库造成一定的损害，本文接上一篇内容。&lt;/p&gt;
&lt;p&gt;假设你正在设计 App 中的认证流程，而且知道这个流程不是简单的线性执行代码，所以想写一些测试代码。&lt;/p&gt;
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>使非法状态不可表示</title>
    <link href="https://swift.gg/2018/05/14/making-illegal-states-unrepresentable/"/>
    <id>https://swift.gg/2018/05/14/making-illegal-states-unrepresentable/</id>
    <published>2018-05-14T00:00:00.000Z</published>
    <updated>2018-05-18T10:47:19.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2018/03/making-illegal-states-unrepresentable/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-03-27<br>译者：<a href="http://daizi.me" target="_blank" rel="noopener">小袋子</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><blockquote><p>你知道 <code>URLSession</code> 能同时返回响应和错误吗？</p></blockquote><p><a href="https://oleb.net/blog/2015/07/swift-type-system/" target="_blank" rel="noopener">我之前介绍过</a>，Swift 强类型系统的一个主要优点是天生具备编译器强制遵循的文档规范。</p><h2 id="类型是编译器强制遵循的文档规范"><a href="#类型是编译器强制遵循的文档规范" class="headerlink" title="类型是编译器强制遵循的文档规范"></a>类型是编译器强制遵循的文档规范</h2><p>类型为函数的行为设立了一种“界限”，因此一个易用的 API 应该精心选择输入输出类型。</p><a id="more"></a><p>仔细思考以下 Swift 函数声明：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> / <span class="params">(dividend: Int, divisor: Int)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>在不阅读任何函数实现的情况下，你就可以推断出这应该是<a href="http://mathworld.wolfram.com/IntegerDivision.html" target="_blank" rel="noopener">整型除法</a>，因为返回的类型不可能是小数。相较之下，如果函数的返回类型是既可以表示整型，也可以表示浮点型数值的 <a href="https://developer.apple.com/documentation/foundation/nsnumber" target="_blank" rel="noopener"><code>NSNumber</code></a>，那你就只能祈祷开发者自觉遵循文档只返回整数。</p><p>随着类型系统的表现越来越好，这种使用类型来记录函数行为的技巧变得越来越有用。如果 <code>Swift</code> 有一个<a href="#quote1"><code>NonZeroInt</code> 类型</a>代表 “除了 <code>0</code> 之外的整型” ，那么除法函数可能就会变成下面这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> / <span class="params">(dividend: Int, divisor: NonZeroInt)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>类型检查不允许传入的除数为 <code>0</code> ，因此你不用关心函数如何处理除数为 <code>0</code> 的错误。函数会中断吗？会返回一个没有意义的值吗？如果你用的是上一种定义，就必须在文档里单独说明特殊情况的处理方式。</p><h2 id="使非法状态成为不可能"><a href="#使非法状态成为不可能" class="headerlink" title="使非法状态成为不可能"></a>使非法状态成为不可能</h2><p>我们可以把这个观点转换为一条通用规则：<strong>使用类型让你的程序无法表现非法状态</strong>。</p><p>如果你想学习更多相关知识，可以看看 Brandon Williams 和 Stephen Celis 的最新视频系列 <a href="https://www.pointfree.co/" target="_blank" rel="noopener">Point-Free</a>。他们讲了很多这方面的知识和相关话题，前八集真的特别棒，我强烈推荐大家去订阅，你会学到很多东西。</p><p>在<a href="https://www.pointfree.co/episodes/ep4-algebraic-data-types" target="_blank" rel="noopener">第四集</a>关于代数数据类型（<a href="https://en.wikipedia.org/wiki/Algebraic_data_type" target="_blank" rel="noopener">algebraic data types</a>）的视频中，Brandon 和 Stephen 讨论了如何组合 <code>enums</code> 和 <code>structs</code>（或者 <code>tuples</code>）来精确表示期望状态的类型，并且让所有非法状态无法表示。在视频的最后，他们用 Apple 的 <a href="https://developer.apple.com/documentation/foundation/urlsession" target="_blank" rel="noopener">URLSession</a> API 作为反面教材进行介绍，因为这个 API 没有使用最合适的类型，这就引出了本文的子标题——“你知道 URLSession 能同时返回响应和错误吗？”。</p><h2 id="URLSession"><a href="#URLSession" class="headerlink" title="URLSession"></a>URLSession</h2><p>Swift 的类型系统比 Objective-C 更富有表现力。然而，很多 Apple 自己的 API 也没有利用这个优势，可能是因为没空更新老旧的 API，或者是为了维持 Objective-C 的兼容性。</p><p>在 iOS 中发起一个<a href="https://developer.apple.com/documentation/foundation/urlsession/1410330-datatask" target="_blank" rel="noopener">网络请求</a>的通用方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLSession</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dataTask</span><span class="params">(with url: URL,</span></span></span><br><span class="line"><span class="function"><span class="params">        completionHandler: @escaping <span class="params">(Data?, URLResponse?, Error?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">        -&gt; <span class="type">URLSessionDataTask</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调函数的参数是三个可选值：<a href="https://developer.apple.com/documentation/foundation/data" target="_blank" rel="noopener"><code>Data?</code></a>，<a href="https://developer.apple.com/documentation/foundation/urlresponse" target="_blank" rel="noopener"><code>URLResponse?</code></a> 和 <a href="https://developer.apple.com/documentation/swift/error" target="_blank" rel="noopener"><code>Error?</code></a>。这将产生 <code>2 × 2 × 2 = 8</code> 种<a href="#quote2">可能的状态</a>，但是其中有多少种是合法的呢？</p><p>引述 <a href="https://www.pointfree.co/episodes/ep4-algebraic-data-types" target="_blank" rel="noopener">Brandon 和 Stephen</a> 的观点：“这里有很多状态毫无意义”。有些组合很明显没有意义，另外我们基本可以确定，这三个值不可能全为 <code>nil</code> 或全为非 <code>nil</code>。</p><h2 id="响应和错误能够同时非-nil"><a href="#响应和错误能够同时非-nil" class="headerlink" title="响应和错误能够同时非 nil"></a>响应和错误能够同时非 <code>nil</code></h2><p>其他状态就很棘手了，在这里 Brandon 和 Stephen 犯了一点小错误：他们认为 API 要么返回一个有效的 <code>Data</code> 和 <code>URLResponse</code>，要么返回一个 <code>Error</code>。毕竟接口不可能同时返回一个非 <code>nil</code> 的响应和错误。看起来很有道理，对不对？</p><p>但事实上这是错误的。<code>URLResponse</code> 封装了服务器的 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html" target="_blank" rel="noopener">HTTP 响应头部</a>，只要接收到一个有效的响应头部， <code>URLSession</code> API 就会一直给你提供这个值，无论后续的阶段请求是否出错（例如取消和超时)。因而 API 的完成处理中有可能包含一个有效的 <code>URLResponse</code> 和非 <code>nil</code> 的错误值（但是没有 <code>Data</code>）。</p><p>如果你对 <code>URLSession</code> 代理（delegate）API 比较熟悉的话，应该不会太惊讶，因为代理方法就是分成 <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/1410027-urlsession" target="_blank" rel="noopener"><code>didReceiveResponse</code></a> 和 <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/1411528-urlsession" target="_blank" rel="noopener"><code>didReceiveData</code></a>。实际上，<a href="https://developer.apple.com/documentation/foundation/urlsession/1410330-datatask" target="_blank" rel="noopener"><code>dataTask​(with:​completionHandler:)</code>的文档</a>也提到了这个问题：</p><blockquote><p>如果收到服务器的响应，那么<strong>无论请求成功或失败</strong>，响应参数都会有值。</p></blockquote><p>不过，我敢打赌 Cocoa 开发人员普遍对此抱有误解。仅仅在过去的四周，我就看到<a href="https://davedelong.com/blog/2018/03/02/apple-networking-feedback/" target="_blank" rel="noopener">两</a>篇<a href="https://ruiper.es/2018/03/03/ras-s2e1/" target="_blank" rel="noopener">文章</a>的作者犯了同样的错误（至少没有领悟其中的真谛）。</p><p>说真的，我很喜欢这个充满讽刺意味的事实：Brandon 和 Stephen 试图指出由于类型问题导致的 API 缺陷，但在指出错误的同时，这个类型问题又让他们犯了另一个错误。如果原始 API 使用了更好的类型，那么这两个错误就都能避免，这反而证明了他们的观点：一个有更加严格类型的 API 能够避免错误使用。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>如果你想自己体验一下 <code>URLSession</code> 的功能，你可以复制以下代码到 Swift playground：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> PlaygroundSupport</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果返回 404，把 URL 换成随便一个大文件</span></span><br><span class="line"><span class="keyword">let</span> bigFile = <span class="type">URL</span>(string: <span class="string">"https://speed.hetzner.de/1GB.bin"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: bigFile) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"data:"</span>, data <span class="keyword">as</span> <span class="type">Any</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"response:"</span>, response <span class="keyword">as</span> <span class="type">Any</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error:"</span>, error <span class="keyword">as</span> <span class="type">Any</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task.resume()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过几秒之后取消下载</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">3</span>) &#123;</span><br><span class="line">    task.cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">PlaygroundPage</span>.current.needsIndefiniteExecution = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这段代码首先下载一个大文件，然后在几秒后取消。最后，完成的处理中返回了一个非 <code>nil</code> 的响应和错误。</p><p>（这里假设指定的时间间隔内，能够获取到服务器响应的头部，但不能完成下载。如果你的网速非常慢或者非常变态，请自行调整这个时间参数）</p><h2 id="正确的类型应该是什么？"><a href="#正确的类型应该是什么？" class="headerlink" title="正确的类型应该是什么？"></a>正确的类型应该是什么？</h2><p>Brandon 和 Stephen 随后在 <a href="https://www.pointfree.co/episodes/ep9-algebraic-data-types-exponents" target="_blank" rel="noopener">Point-Free 的第九集视频</a>中发布了他们对问题的跟进。他们认为“正确”的参数类型应该是：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(<span class="type">URLResponse</span>?, <span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">Error</span>&gt;)</span><br></pre></td></tr></table></figure><p>我不同意，因为如果有数据，就一定有响应，不可能只有数据没有响应。我认为应该是这样的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Result</span>&lt;(<span class="type">Data</span>, <span class="type">URLResponse</span>), (<span class="type">Error</span>, <span class="type">URLResponse</span>?)&gt;</span><br></pre></td></tr></table></figure><p>解读：你将要么得到数据和响应（后者肯定不是 <code>nil</code>），要么得到一个错误和一个可选类型的响应。不可否认，我的建议与一般的 <code>Result</code> 类型定义相悖，因为它将失败参数约束为不能符合 <code>Error</code> 的 <a href="https://developer.apple.com/documentation/swift/error" target="_blank" rel="noopener">Error</a> 协议—<code>(Error, URLResponse?)</code>。目前 <a href="https://forums.swift.org/t/adding-result-to-the-standard-library/6932/58" target="_blank" rel="noopener">Swift 论坛正在讨论</a> <code>Error</code> 约束是否有必要。</p><h2 id="Result-类型"><a href="#Result-类型" class="headerlink" title="Result 类型"></a><code>Result</code> 类型</h2><p>由于 <code>URLResponse</code> 参数的非直观行为，<code>URLSession</code> 的API 显得特别棘手。但是 Apple 几乎所有的基于回调的异步 API 都有相同的问题，它们所提供的类型使得非法状态可以表示。</p><p>如何解决这个问题呢？</p><p>Swift 的通用方案是定义一个 <a href="https://github.com/antitypical/Result/blob/03fba33a0a8b75492480b9b2e458e88651525a2a/Result/Result.swift" target="_blank" rel="noopener">Result 类型</a>—一个可以代表通用成功值或错误的枚举。最近，又有人试图将 <a href="https://forums.swift.org/t/adding-result-to-the-standard-library/6932/20" target="_blank" rel="noopener">Result 添加到标准库</a>。</p><p>如果 Swift 5 添加了 <code>Result</code>（大胆假设），Apple 可能（更大胆的假设）会自动导入类似这样 <code>completionHandler: (A?, Error?) -&gt; Void as (Result&lt;A&gt;) -&gt; Void</code> 的 Cocoa API，将四个可表现的状态转为两个。在那之前（如果真的会发生的话），我建议你还是先自己<a href="https://oleb.net/blog/2017/01/result-init-helper/" target="_blank" rel="noopener">实现转换</a>。</p><p>长远来看，Swift 终有一天能从语言层面正确支持异步 API。社区和 Swift 团队可能会提出新的解决方案，<a href="https://gist.github.com/lattner/429b9070918248274f25b714dcfc7619#conversion-of-imported-objective-c-apis" target="_blank" rel="noopener">把现有的 Cocoa API 移植到新系统中</a>，就像把 Objective-C 的 <code>NSError **</code> 参数作为抛出（throwing）函数引入 Swift 一样。不过不要太过期待，Swift 6 之前肯定实现不了。</p><hr><p><span id="quote1"><br>1、你可以自己定义一个 <code>NonZeroInt</code> 类型，但是没有办法告诉编译器“如果有人尝试用零去初始化这个类型，就引发一个错误”。你必须依赖运行时检查。</span></p><p>不过，引入这样的类型通常是个不错的想法，因为类型的用户可以在初始化之后依赖于所声明的不变性。我还没有在其他地方看到一个 <code>NonZeroInt</code> 类型，保证类型为非空集合的自定义类型更受欢迎。<br></p><p><span id="quote2"><br>2、我只是把“<code>nil</code>”或“非<code>nil</code>”作为可能的状态。显然，非 <code>nil</code> 数据值可以具有无数种可能的状态，并且对于其他两个参数也是如此。但是这些状态对我们来说并不好玩。<br></span></p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2018/03/making-illegal-states-unrepresentable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-03-27&lt;br&gt;译者：&lt;a href=&quot;http://daizi.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小袋子&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;blockquote&gt;
&lt;p&gt;你知道 &lt;code&gt;URLSession&lt;/code&gt; 能同时返回响应和错误吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://oleb.net/blog/2015/07/swift-type-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我之前介绍过&lt;/a&gt;，Swift 强类型系统的一个主要优点是天生具备编译器强制遵循的文档规范。&lt;/p&gt;
&lt;h2 id=&quot;类型是编译器强制遵循的文档规范&quot;&gt;&lt;a href=&quot;#类型是编译器强制遵循的文档规范&quot; class=&quot;headerlink&quot; title=&quot;类型是编译器强制遵循的文档规范&quot;&gt;&lt;/a&gt;类型是编译器强制遵循的文档规范&lt;/h2&gt;&lt;p&gt;类型为函数的行为设立了一种“界限”，因此一个易用的 API 应该精心选择输入输出类型。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Elm Native UI in Production</title>
    <link href="https://swift.gg/2018/05/10/elm-native-ui-in-production/"/>
    <id>https://swift.gg/2018/05/10/elm-native-ui-in-production/</id>
    <published>2018-05-10T00:00:00.000Z</published>
    <updated>2018-05-18T10:47:19.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Josh Steiner，<a href="https://robots.thoughtbot.com/elm-native-ui-in-production" target="_blank" rel="noopener">原文链接</a>，原文日期：2016-03-01<br>译者：<a href="http://muhlenxi.com/" target="_blank" rel="noopener">muhlenXi</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="http://www.jianshu.com/users/9efd08855d3a/" target="_blank" rel="noopener">aaaron7</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>在 11 月份，thoughtbot 发布了一个叫 <a href="https://purpletrainapp.com/" target="_blank" rel="noopener">Purple Train</a> 的 APP ，该 APP 是用 <a href="https://thoughtbot.com/services/react" target="_blank" rel="noopener">React Native</a> 实现的， <code>React Native</code> 一直被用于快速构建跨平台的 APP 。由于 <code>Reactive Natice</code> 对传统移动开发的许多改进，使我们更加喜欢它，比如声明性 API、更快的开发周期、对 Web 开发和设计师来说更友好和跨平台等。但是 <code>React Native</code> 并不是对每个 APP 都非常合适，它虽然适合大多数的 APP ，但仍然有一个主要的缺陷：<code>JavaScript</code> 。</p><p><code>JavaScript</code> 作为一门语言它一直在改进，它有一个显著优点就是无所不在，然而，它也以 <a href="https://www.destroyallsoftware.com/talks/wat" target="_blank" rel="noopener">奇怪的行为</a> 和弱类型系统（读作 <code>aggressive type coercion</code> ）而闻名。</p><a id="more"></a><h3 id="Elm-Native-UI"><a href="#Elm-Native-UI" class="headerlink" title="Elm Native UI"></a>Elm Native UI</h3><p>开始说 <a href="https://github.com/ohanhi/elm-native-ui" target="_blank" rel="noopener">Elm Native UI</a> - 一个提供 <code>React Native</code> 组件编译功能的 <code>Elm</code> 库。如果你听过 <code>Elm</code> ，你可能知道 <a href="http://elm-lang.org/blog/compiler-errors-for-humans" target="_blank" rel="noopener">amazing error message</a> 和听说 <a href="https://www.pivotaltracker.com/blog/Elm-pivotal-tracker/" target="_blank" rel="noopener">zero runtime errors</a> 的主张。<code>Elm</code> 的安全性来自于它的 <code>pure function（纯函数）</code> 和强大的静态类型，这也使得 <code>Elm</code> 的代码更容易验证。</p><p>在发布 <code>Purple Train</code> 的 <code>React Native</code> 版本的时候，我们偶然发现了 <code>Elm Native UI</code> 。它在 GitHUb 的 repo 中清楚的声明了，“不要用于生产环境中”，但我想要把它加入测试，我从一些简单 feature 开始，不断拓宽边界。该 APP 很快就接近 <code>React Native APP</code> 相同的特点。在 12 月份，虽然库不成熟，但是它的开发环境是极其出色的，于是我们决定创建一个 Purple Train 的试验版本，在我们完成剩下的功能后将第一个 <code>Elm Native UI APP</code> 发布到生产环境中。</p><h3 id="React-vs-Elm"><a href="#React-vs-Elm" class="headerlink" title="React vs Elm"></a>React vs Elm</h3><p>用 <code>React</code> 和 <code>Elm</code> 开发的差异是很明显的，在 <code>React</code> 中，当开发一个功能时，你必须充分考虑每一步，如果你忘记了某一步，很少的提示会告诉你你错过什么并且 <code>React</code> 需要花一些时间来追踪和考虑如何将这些部分连接起来。</p><p>在 <code>Elm</code> 中，你可以根据编译器友好的错误提示来持续做一些简单的改变直到程序调通。你不需要担心在功能开发中途离开，因为当你回来的时候，编译器会提醒你接下来做什么。此外，你可以简单快速的在整个代码库中进行全面更改但是却没有任何程序崩溃。用 <code>Elm</code> 编程就如同和一个厉害的 robot 一起编程一样。 </p><p><code>React</code> 取决于开发者不要犯错误，尽管有像 <code>eslint</code> 这样的静态分析工具可以帮助您，但是对于像 <code>JavaScript</code> 这样的动态语言的帮助是有限的，当你犯错误时，在开发模式下，你可能会看到用 “Red Screens of Death” 显示的运行时错误。</p><p><img src="https://images.thoughtbot.com/blog-vellum-image-uploads/UMpL2QIqQFutYXmAJikX_react-native-red-screen-of-death.png" alt=""></p><p>Elm 另一方面依赖编译器来捕获 bug，我很高兴的说，在 <code>Purple Train</code> 运行期间，我没有碰到一个 Red Screen of Death<sup>[1]</sup>。</p><h3 id="Not-Ready-for-Prime-Time"><a href="#Not-Ready-for-Prime-Time" class="headerlink" title="Not Ready for Prime Time"></a>Not Ready for Prime Time</h3><p>尽管到目前为止 <code>Elm Native UI</code> 的体验非常棒，但是 <code>Elm Native UI</code> 至今还没有为大多数生产环境的 APP 做好准备。它仍然缺少关键功能，如图片绑定和简单的设定过程 - 当前过程实现这些仍然颇具挑战。目前 thoughtbot 在为 <code>Elm Native UI</code> 在一些重要方面的应用而努力。如果你还有疑问，你可以访问 <a href="http://elmlang.herokuapp.com/" target="_blank" rel="noopener">elmlang Slack</a>  的 <code>#elm-native-ui</code> 频道。</p><hr><p>1、这并不完全正确。我遇到了 Red Screens of Death ，是当我为 <code>Elm Native UI</code> 库开发新功能时，而不是为 <code>Purple Train</code> 写新功能的时候。假定 <code>Elm Native UI</code> 中的 <code>JavaScript</code> 是没有 bug ，我希望这对于其他 APP 也是这样。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Josh Steiner，&lt;a href=&quot;https://robots.thoughtbot.com/elm-native-ui-in-production&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-03-01&lt;br&gt;译者：&lt;a href=&quot;http://muhlenxi.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;muhlenXi&lt;/a&gt;；校对：&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/9efd08855d3a/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;aaaron7&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在 11 月份，thoughtbot 发布了一个叫 &lt;a href=&quot;https://purpletrainapp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Purple Train&lt;/a&gt; 的 APP ，该 APP 是用 &lt;a href=&quot;https://thoughtbot.com/services/react&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React Native&lt;/a&gt; 实现的， &lt;code&gt;React Native&lt;/code&gt; 一直被用于快速构建跨平台的 APP 。由于 &lt;code&gt;Reactive Natice&lt;/code&gt; 对传统移动开发的许多改进，使我们更加喜欢它，比如声明性 API、更快的开发周期、对 Web 开发和设计师来说更友好和跨平台等。但是 &lt;code&gt;React Native&lt;/code&gt; 并不是对每个 APP 都非常合适，它虽然适合大多数的 APP ，但仍然有一个主要的缺陷：&lt;code&gt;JavaScript&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt; 作为一门语言它一直在改进，它有一个显著优点就是无所不在，然而，它也以 &lt;a href=&quot;https://www.destroyallsoftware.com/talks/wat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;奇怪的行为&lt;/a&gt; 和弱类型系统（读作 &lt;code&gt;aggressive type coercion&lt;/code&gt; ）而闻名。&lt;/p&gt;
    
    </summary>
    
      <category term="Thoughtbot" scheme="https://swift.gg/categories/Thoughtbot/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>抛弃视图控制器，做自己的控制器</title>
    <link href="https://swift.gg/2018/05/02/just-controllers/"/>
    <id>https://swift.gg/2018/05/02/just-controllers/</id>
    <published>2018-05-02T00:00:00.000Z</published>
    <updated>2018-05-18T10:47:19.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2018/02/just-controllers/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-02-21<br>译者：<a href="https://weibo.com/u/5029986118" target="_blank" rel="noopener">东莞大唐和尚</a>；校对：<a href="https://weibo.com/u/5953150140" target="_blank" rel="noopener">Lefex</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>苹果官方文档中提到过 MVC 的软件设计模式。不过，苹果介绍的并不是本质意义上的 MVC 。<a href="http://khanlou.com/2014/03/model-view-whatever/" target="_blank" rel="noopener">关于这一点我之前也有写过一篇文章</a>，MVC 是为 Smalltalk 语言设计的一种设计模式。在 Smalltalk 语言里，MVC 的三个组件：模型（model）、视图（view）和控制器（controller）之间都可以相互通信。这就意味着要么视图知道自己持有的模型是如何实现的，要么模型知道自己是如何在视图中被应用的。</p><p>我们写 iOS 软件的时候，通常会把可以直接通信的视图和模型称之为“反模式”（PS：不推荐这么做）。我们所谓的 MVC 更准确的说其实是“模型-视图-适配器（Model - View - Adapter）”。我们说的“视图控制器”其实只是模型和视图中间沟通的一个桥梁。笼统来讲，我觉得这是对正统MVC一个不错的改良——不是把视图和模型绑在一起，而是通过一个适配器把模型和视图联系起来，这个方法不错。然而，不得不说，在我工作中涉及到的大部分系统中，模型和视图都是分开的。</p><p>以上就是为什么 iOS 开发里会有视图控制器的原因：用来连接模型和视图。但是这种模式的编码会产生一些问题：有一些代码看起来既不属于模型，也不属于视图，所以我们就把这些代码放到了视图控制器里，最后视图控制器变得超级臃肿。关于这个问题，我在博客里面讨论过<a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener">很多次</a>，但这次我想说的不是这个问题。</p><a id="more"></a><hr><p>我私下里听到过很多关于 <code>UIViewController</code> 的谈论。我认为 <code>UIViewController</code> 这个基本类写的不是很好，这一点你用 UIKit 用得越久就越能感觉到。听说 <code>UIViewController</code> 这个基本类型有 1 万到 2 万行代码（那是几年前了，现在可能已经超过两万行了）。</p><p>当我们需要把 <code>UIView</code> 和一个模型联系起来的时候，我们通常会把视图控制器分成一个个小的视图控制器组件，然后再组装到一起。</p><p>但是，这样做太小题大做了。一个小地方没处理好，就会出现很多 bug，而且这样的 bug 很难修复，也没有什么提示。然后，当你终于找到 bug 的时候，发现通常都是 <code>didMove</code> 或者 <code>willMove</code> 的调用顺序不对导致的。其实，出现 <code>didMove</code> 和 <code>willMove</code> 的时候就已经说明这些组件一些内部状态需要清理了。</p><p>这样的情况我自己就遇到过两次。第一次是我把视图控制器放在了 <code>tableView</code> 的 <code>cell</code> 里。出现的 bug 就是，table view 里面的一些内容总会莫名其妙地消失。然后过了好几个月，我才意识到我对 table view cells 的生命周期理解有误。</p><p>在我改正了一些对 <code>-addChildViewController</code> 的调用之后，程序就正常运行了。</p><p>这件事让我看到了一个很大的问题：视图控制器的视图并不是一个普普通通的视图，而是一个视图控制器的视图。它有自己一些特性。</p><p>回过头去看，一切都很明显。<code>UIViewController</code> 怎么知道什么时候该去调用 <code>viewDidLayoutSubviews</code>? 肯定是 <code>view</code> 向它发送了请求，这就意味着视图控制器对视图是有一些依赖的。</p><p>第二次是最近碰到的，这次的问题出现在我把一个视图控制器的视图作为 <code>text field</code> 的 <code>inputAccessoryView</code> 时。当时我在实现一个通信软件（类似  iMessage）里 <code>textField</code> 贴在屏幕底部的功能，整个过程十分挫败。我花了整整一天时间都没搞定，最后还是把这个视图转换成了一个普通的视图。</p><hr><p>所以，我们通常想 <code>UIViewController</code> 应该做的是哪些事情呢？</p><ul><li>承载视图</li><li>把模型和视图联系起来</li></ul><p>那 <code>UIViewController</code> 还做了哪些我们并不十分在意的事呢？</p><ul><li>为子视图控制器提供存储</li><li>把外观和过渡动画推送给子视图控制器</li><li>可以在类似 <code>UINavigationController</code> 的容器中显示</li><li>内存过低通知</li><li>处理状态栏</li><li>保存状态、恢复状态</li></ul><p>知道了这些，在一些特殊情况下，需要我们做一个替代视图控制器的东西时，我们就知道了哪些东西是我们并不需要的。我喜欢这样，因为这样可以快速地解决问题，同时也符合我“自己的事情自己做”的性格。</p><p>还有一个问题，这个东西怎么命名呢？我觉得命名成一个视图控制器不太好，很容易被误解为一个 <code>UIViewController</code>的子类。或者，我们就叫它 <code>Controller</code>？我觉得可以（<a href="http://khanlou.com/2014/11/a-controller-by-any-other-name/" target="_blank" rel="noopener">尽管我之前可能有其他观点</a>），因为它的作用就是 iOS MVC 设计框架中控制器的作用（把视图和模型联系起来），但是还有其他一些备选：<code>Binder</code>（粘合）, <code>Binding</code>（捆绑）, <code>Pair</code>（配对）, <code>Mediator</code>（中介）, <code>Concierge</code>（前台）。</p><p>这个做法还有一个好处是，<strong>特别好写</strong>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DestinationTextFieldController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> destination: <span class="type">Destination</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">DestinationTextFieldControllerDelegate</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> textField = <span class="type">UITextField</span>().configure(&#123;</span><br><span class="line">        $<span class="number">0</span>.autocorrectionType = .no</span><br><span class="line">        $<span class="number">0</span>.clearButtonMode = .always</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可能不用 <code>UIViewController</code> 的子类，然后写这样一个东西，会有人喊，“异教徒！烧死他！”。但是，当 <code>UIViewController</code> 没有把自己该做的事情做好的时候，我们就应该抛弃它。</p><p>现在大家已经知道怎么给自己的新对象加新功能了。在我的这个例子中，控制器成了 <code>textField</code> 的代理，文字变化时发出事件（以及域元数据 domain metadta），同时提供更新视图（这个例子中是<code>textField</code>）的接口。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DestinationTextFieldController</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> isActive: <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.textField.isFirstResponder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(with destination: Destination)</span></span> &#123;</span><br><span class="line"><span class="keyword">self</span>.destination = destination</span><br><span class="line">configureView()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">configureView</span><span class="params">()</span></span> &#123;</span><br><span class="line">textField.text = destination.descriptionForDisplay</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种新的控制器你还需要做其他几件事：</p><ul><li>你得新建一个实例变量来存储数据</li><li>你得负责一些触发事件——因为它不是一个视图控制器，没有 <code>-viewDidAppear</code></li><li>因为新的控制器已经不在 <code>UIKit</code> 框架里面了，所以其他一些 <code>UIKit</code> 的特性（<a href="https://developer.apple.com/documentation/uikit/uitraitcollection" target="_blank" rel="noopener">UITraitCollection</a>, <a href="https://developer.apple.com/documentation/uikit/uiview/positioning_content_relative_to_the_safe_area" target="_blank" rel="noopener">safe area insets</a>，或者<a href="https://developer.apple.com/documentation/uikit/uiresponder" target="_blank" rel="noopener">UIResponder</a>）都不能再使用了。而需要你自己实现。</li></ul><p>使用这个对象不是很难，不过你还是需要写明它的数据存储方式， 防止它的内存被回收。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span>, <span class="title">DestinationTextFieldControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> destinationViewController = <span class="type">DestinationTextFieldController</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">destinationViewController.delegate = <span class="keyword">self</span></span><br><span class="line">view.addSubview(destinationViewController.view)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//handle any delegate methods</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>话说回来，即使你使用我说的这个方法，其他大部分的视图应该还会是视图控制器和 <code>UIViewController</code> 的子类。不过，在某些特殊的情况下，整合一个视图控制器会耗费你过多的精力，这时候采用这种方法，就可以避免再次被 <code>UIKit</code> 折磨。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2018/02/just-controllers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-02-21&lt;br&gt;译者：&lt;a href=&quot;https://weibo.com/u/5029986118&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;东莞大唐和尚&lt;/a&gt;；校对：&lt;a href=&quot;https://weibo.com/u/5953150140&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lefex&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;苹果官方文档中提到过 MVC 的软件设计模式。不过，苹果介绍的并不是本质意义上的 MVC 。&lt;a href=&quot;http://khanlou.com/2014/03/model-view-whatever/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于这一点我之前也有写过一篇文章&lt;/a&gt;，MVC 是为 Smalltalk 语言设计的一种设计模式。在 Smalltalk 语言里，MVC 的三个组件：模型（model）、视图（view）和控制器（controller）之间都可以相互通信。这就意味着要么视图知道自己持有的模型是如何实现的，要么模型知道自己是如何在视图中被应用的。&lt;/p&gt;
&lt;p&gt;我们写 iOS 软件的时候，通常会把可以直接通信的视图和模型称之为“反模式”（PS：不推荐这么做）。我们所谓的 MVC 更准确的说其实是“模型-视图-适配器（Model - View - Adapter）”。我们说的“视图控制器”其实只是模型和视图中间沟通的一个桥梁。笼统来讲，我觉得这是对正统MVC一个不错的改良——不是把视图和模型绑在一起，而是通过一个适配器把模型和视图联系起来，这个方法不错。然而，不得不说，在我工作中涉及到的大部分系统中，模型和视图都是分开的。&lt;/p&gt;
&lt;p&gt;以上就是为什么 iOS 开发里会有视图控制器的原因：用来连接模型和视图。但是这种模式的编码会产生一些问题：有一些代码看起来既不属于模型，也不属于视图，所以我们就把这些代码放到了视图控制器里，最后视图控制器变得超级臃肿。关于这个问题，我在博客里面讨论过&lt;a href=&quot;http://khanlou.com/2015/10/coordinators-redux/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;很多次&lt;/a&gt;，但这次我想说的不是这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="khanlou.com" scheme="https://swift.gg/categories/khanlou-com/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程：基本概念</title>
    <link href="https://swift.gg/2018/05/02/swift-functional-programming-basic-concepts/"/>
    <id>https://swift.gg/2018/05/02/swift-functional-programming-basic-concepts/</id>
    <published>2018-05-02T00:00:00.000Z</published>
    <updated>2018-05-18T10:47:19.559Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andyy Hope，<a href="https://medium.com/swift-programming/swift-functional-programming-basic-concepts-a6b0c3937d56" target="_blank" rel="noopener">原文链接</a>，原文日期：2016-05-18<br>译者：<a href="http://muhlenxi.com/" target="_blank" rel="noopener">muhlenXi</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="https://lision.me/" target="_blank" rel="noopener">Lision</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>通常情况下，人们在学习了函数式编程（Function Programming 即 FP）之后就根本停不下来对它的修改，甚至到了一种如果 FP 不是特别酷的话就会烦躁的地步。回忆一下 1999 年经典非主流电影 Fight Club 最著名的情景，完全颠覆了人们的头脑。</p><blockquote><p><strong>函数式编程俱乐部的条例：</strong><br>1.永远不要停止函数式编程。<br>2.永远不要停止函数式编程！</p></blockquote><a id="more"></a><p>一些人对函数式编程很热心，就像对 Crossfit 一样热情，但是与 Crossfit不一样的是，函数式编程没有 73.5% 的机会去损害并且影响到你的工作，事实上它提高了你编写的代码的安全性，可读性和价值。</p><p>Swift 绝不是类似 Haskell 这种纯粹的函数式编程语言，而是一种把其他语言的部分精华紧密结合起来的多范式编程语言。</p><p>在第一部分，我们将会了解函数式编程的比较简单的概念和阐述如何用 Swift 编写函数式代码。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这是很容易理解的，不变性的意思就是一个值只要被设定，以后就不能再被改变。在 Swift 中，我们通过 <code>let</code> 关键字来创建一个不可变的值。</p><p>不变性的原因是因为它允许开发者编写线程安全的代码。在我们使用的过程中，我们可以完全确定应用中的其他线程是不能改变它的值的。</p><h3 id="值的类型"><a href="#值的类型" class="headerlink" title="值的类型"></a>值的类型</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CGRect</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>当我们用值代替引用来传递变量的值时，我们创建的代码是安全的。<code>struct</code> 类型在 Swift 标准库中使用得最多，比如：<code>Array</code>, <code>Dictionary</code>, <code>Int</code>, <code>Bool</code> 等等都是 <code>struct</code> 。</p><p>这些数据结构比引用安全的原因是因为当我们通过传递值来设置对象时，实际传递的是值的拷贝。我们可以通过下面的代码来理解这个概念：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="type">CGRect</span>.zero</span><br><span class="line"><span class="keyword">var</span> square = box.size</span><br><span class="line"></span><br><span class="line">box.size.height = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// square: width: 0,height: 0</span></span><br><span class="line"><span class="comment">// box.size: width: 0,height: 10</span></span><br></pre></td></tr></table></figure><p>如果将 <code>CGRect</code> 和 <code>CGSize</code> 的值类型改为引用类型，当我们改变 <code>box</code> 的 <code>height</code> 时候，<code>square</code> 的 <code>height</code> 也将会发生改变。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">box.size.height = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// square: width: 0,height: 10</span></span><br><span class="line"><span class="comment">// box.size: width: 0,height: 10</span></span><br></pre></td></tr></table></figure><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的返回值取仅决于输入值，没有任何可见副作用。它只做了一件事就是对输入的值进行计算并返回，没有其他的。</p><p>即使我们在 <code>sum()</code> 函数中放入一个 <code>log</code> 语句，这也会把该函数变成非纯函数，这在编写代码时非常具有传染性。</p><p>所以基本上编写纯函数的思想消除了副作用代码产生的全部机会，这些副作用代码可能会增加我们的 <code>bug</code> ，当然，也包括上文提到的 <code>log</code> 。</p><h3 id="一等函数"><a href="#一等函数" class="headerlink" title="一等函数"></a>一等函数</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hi!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeting = sayHello</span><br><span class="line"></span><br><span class="line">greeting()</span><br><span class="line"></span><br><span class="line"><span class="comment">// prints: Hi!</span></span><br></pre></td></tr></table></figure><p>在 Swift 的创作过程中，Swift 作者们决定将所有他们能想到的每件东西都视为一等公民，当函数是一等公民时，这个意思就是我们可以把一个函数赋值给一个变量，就跟我们使用 <code>Int</code> 或者 <code>String</code> 一样。</p><p>这就允许我们编写的函数可以被别的函数当做参数传递或者作为结果来返回，所以我们可以在代码中进行函数的传递。</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>因为把函数视为一等公民，那也就意味着我们能够创建高阶函数，一个函数被认定为高阶函数，它必须至少满足以下提到的两个特征的一种：</p><ul><li>使用函数作为参数</li><li>返回值是函数</li></ul><p>举个例子来说明一下，我们创建一个接受函数作为参数的高阶函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inside</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Yo!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inside's structure</span></span><br><span class="line"><span class="comment">// () -&gt; Void</span></span><br></pre></td></tr></table></figure><p>我们创建一个叫 <code>inside</code> 的无参返回值为空的函数，即返回值的类型为 <code>Void</code> ，在函数的下面，我描述了函数的结构，这对我们理解高阶函数将会很重要。当我们将一个函数作为参数来传递时，编译器将会分析和验证该函数的兼容性。现在，让我们来看一个函数接受另一个函数作为参数的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outside</span><span class="params">(inner:<span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">inner()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，<code>outside</code> 函数接受一个参数，并且这个参数是一个函数，如果你查看 <code>inner</code> 这个参数的类型，你将会发现，这和上面的 <code>inside</code> 函数的返回类型是一致的。因为这两个函数的参数类型是一样的，所以我们能够将 <code>inside</code> 赋值给 <code>inner</code> 且编译器不会发出警告或报错。</p><p>最后，我们在 <code>outside</code> 函数的内部调用参数 <code>inner</code> ，它会转而去调用 <code>inside</code> 函数内部的 <code>print()</code> 函数:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">outside(inside)</span><br><span class="line"><span class="comment">// prints: Yo!</span></span><br></pre></td></tr></table></figure><h2 id="高级概念"><a href="#高级概念" class="headerlink" title="高级概念"></a>高级概念</h2><h3 id="响应链、合成和柯里化"><a href="#响应链、合成和柯里化" class="headerlink" title="响应链、合成和柯里化"></a>响应链、合成和柯里化</h3><p>我们仅仅接触到了 Swift 函数式编程的表面，在我后续的发表文章中，将会包含许多新的内容，包括一些更高级的概念，比如上面小标题提到的第三个部分(即高级概念)，它们有些复杂，在稍后的文章中将会有详细介绍，希望现在你能对 Swift 是如何进行函数式编程的基础部分能有深入理解，然后用来使你的代码更加健壮、安全和多功能。</p><p>我想要正式的欢迎你加入函数式编程的俱乐部。在等待后续文章期间希望你能熟记练习规则 <code>1</code> 和 <code>2</code> 。</p><p>本文中的<a href="https://github.com/andyyhope/Blog_FunctionalProgramming_BasicConcepts" target="_blank" rel="noopener">示例代码</a>在 GitHub 上可以下载。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Andyy Hope，&lt;a href=&quot;https://medium.com/swift-programming/swift-functional-programming-basic-concepts-a6b0c3937d56&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-05-18&lt;br&gt;译者：&lt;a href=&quot;http://muhlenxi.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;muhlenXi&lt;/a&gt;；校对：&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;，&lt;a href=&quot;https://lision.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lision&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;通常情况下，人们在学习了函数式编程（Function Programming 即 FP）之后就根本停不下来对它的修改，甚至到了一种如果 FP 不是特别酷的话就会烦躁的地步。回忆一下 1999 年经典非主流电影 Fight Club 最著名的情景，完全颠覆了人们的头脑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;函数式编程俱乐部的条例：&lt;/strong&gt;&lt;br&gt;1.永远不要停止函数式编程。&lt;br&gt;2.永远不要停止函数式编程！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="medium.com" scheme="https://swift.gg/categories/medium-com/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>Swift 服务端开发指南</title>
    <link href="https://swift.gg/2018/04/24/server-side-commands/"/>
    <id>https://swift.gg/2018/04/24/server-side-commands/</id>
    <published>2018-04-24T00:00:00.000Z</published>
    <updated>2018-05-18T10:47:19.559Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2017/06/server-side-commands" target="_blank" rel="noopener">原文链接</a>，原文日期：2017/6/21<br>译者：<a href="http://weibo.com/277195544" target="_blank" rel="noopener">Cwift</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>在服务端使用 Swift 时，大多数路由框架都会把路由同一个指定的闭包关联起来。比如我们在编写 <a href="http://beacon.party" target="_blank" rel="noopener">Beacon</a>  时使用的 <a href="https://vapor.codes" target="_blank" rel="noopener">Vapor</a> 框架。你可以在该框架主页的测试示例中看到如下的代码：</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vapor</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> droplet = <span class="keyword">try</span> <span class="type">Droplet</span>()</span><br><span class="line"></span><br><span class="line">droplet.<span class="keyword">get</span>(<span class="string">"hello"</span>) &#123; req <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, world."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> droplet.run()</span><br></pre></td></tr></table></figure><p>当你运行这段代码时，访问 <code>localhost:8080/hello</code> 会展示文本 <code>Hello, world.</code> 。</p><p>有时候，你想要向 <code>API</code> 的调用者返回一个特殊的 <code>HTTP</code> 代码，提示执行了一个特殊的操作。示例如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">droplet.post(<span class="string">"devices"</span>, handler: &#123; request <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span> apnsToken: <span class="type">String</span> = <span class="keyword">try</span> request.niceJSON.fetch(<span class="string">"apnsToken"</span>)</span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">try</span> request.session.ensureUser()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> device = <span class="keyword">try</span> <span class="type">Device</span>(apnsToken: apnsToken, userID: user.id.unwrap())</span><br><span class="line"><span class="keyword">try</span> device.save()</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">try</span> device.makeJSON()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（我打算在之后的博客中详细介绍 <code>niceJSON</code> 的用法，不过现在请忽略它。）</p><p>这是个非常好的请求，和 <code>Beacon</code> 中的代码很像。不过有一个问题：当你返回类似字符串的对象（本文的第一个示例）或者 <code>JSON</code>（本文的第二个示例）时，Vapor 会返回 <code>200</code> 的状态码。但是这是一个 <code>POST</code> 请求并且创建了一个新的 <code>Device</code> 资源，所以应该返回 <code>201 Created</code> 的 <code>HTTP</code> 状态码。所以你需要创建一个完整的 <code>Response</code> 对象：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="type">Response</span>(status: .created)</span><br><span class="line">response.json = <span class="keyword">try</span> device.makeJSON()</span><br><span class="line"><span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>对每个创建型的请求重复执行这样的操作很烦人。</p><p>最后一点，端点（endpoints）通常会有副作用。特别是使用 Rails 编写的应用，管理和测试这些端点是非常困难的，在 Rails 社区中已经出现了许多有关的讨论了。如果注册需要发送注册邮件，那么如何布置 “桩代码” （stub）以便测试剩余的代码？这是很难做到的，如果所有逻辑都在一个复杂的函数中执行，更是难上加难。在 <code>Beacon</code> 中没有任何发送邮件的功能，但是我们的确有很多推送通知。监管这些推送的副作用是很重要的。</p><p>一般来说，在每个路由中使用一个闭包的风格，已经应用在 <code>Flask</code>、<code>Sinatra</code> 和 <code>Express</code> 之类的框架中了。它们都是非常好的示例，不过真实的项目往往具有复杂的端点，依旧是把所有逻辑放在一个复杂的方法中。</p><p>进一步说，Rails 风格的控制器模块很庞大，而与每个端点匹配的相关方法都使用控制器作为命名空间，这使得控制器彼此之间具有边界攻击性。我觉得我们可以做的比以上两种模式（使用闭包的风格和 Rails 风格）更好。（如果你想了解 Ruby 服务器架构，我已经从 <a href="https://github.com/trailblazer/trailblazer" target="_blank" rel="noopener">Trailblazer</a> 项目中总结了一些经验。）</p><p>最基本的一点是我想要一个更好的抽象来响应传入的请求。为此，我使用了一个称之为 <code>Command</code> 的对象来封装端点需要做的工作。</p><p><code>Command</code> 模式的起始部分是一个协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(request: <span class="type">Request</span>, droplet: <span class="type">Droplet</span>) <span class="keyword">throws</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> status: <span class="type">Status</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">JSON</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Command</span>: <span class="title">ResponseRepresentable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeResponse</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Response</span> &#123;</span><br><span class="line"><span class="keyword">let</span> response = <span class="type">Response</span>(status: <span class="keyword">self</span>.status)</span><br><span class="line">response.json = <span class="keyword">try</span> execute()</span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是 <code>Command</code> 协议的基础外壳，后面会向其中添加更多的代码。从协议的基础部分可以了解如何使用这种模式。下面来使用新模式重写“注册设备”这个端点。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">droplet.post(<span class="string">"devices"</span>, handler: &#123; request <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">RegisterDeviceCommand</span>(request: request, droplet: droplet)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为该命令遵守了 <code>ResponseRepresentable</code>，所以 Vapor 接受它作为路由的 <code>handler</code> 闭包的有效返回值。 它将自动调用 <code>Command</code> 的 <code>makeResponse()</code> 方法并且为 API 的调用者返回一个 <code>Response</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterDeviceCommand</span>: <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apnsToken: <span class="type">String</span></span><br><span class="line"><span class="keyword">let</span> user: <span class="type">User</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(request: <span class="type">Request</span>, droplet: <span class="type">Droplet</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line"><span class="keyword">self</span>.apnsToken = <span class="keyword">try</span> request.niceJSON.fetch(<span class="string">"apnsToken"</span>)</span><br><span class="line"><span class="keyword">self</span>.user = <span class="keyword">try</span> request.session.ensureUser()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> status = <span class="type">Status</span>.created</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">JSON</span> &#123;</span><br><span class="line"><span class="keyword">var</span> device = <span class="keyword">try</span> <span class="type">Device</span>(apnsToken: apnsToken, userID: user.id.unwrap())</span><br><span class="line"><span class="keyword">try</span> device.save()</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">try</span> device.makeJSON()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是该模式的一些优点：</p><ol><li>在服务端使用诸如 Swift 这样的新语言的主要吸引力是可以使用新的特性，比如用可选型（更针对性地说，是为了解决以前的缺陷）来保障一个请求成功完成。因为 <code>apnsToken</code> 和 <code>user</code> 的类型是非可选型的，所以如果 <code>init</code> 方法在结束时没有初始化所有的属性，则文件无法通过编译。</li><li>状态码的使用方式很友好。</li><li>初始化与执行分离。你可以编写一个测试，检查对象的初始化过程（例如，从请求中提取属性），该测试与检查实际的 <code>save()</code> 方法的测试是分离的。</li><li>至于副作用，该模式可以轻松地把不同的 <code>Command</code> 放置到自己的文件中。</li></ol><p>可以向 <code>Command</code> 中添加两个更重要的组件。首先是验证。添加 <code>func validate() throws</code> 到 <code>Command</code> 协议中，编写一个默认的空实现。他也会被添加到 <code>makeResponse()</code> 方法中，在 <code>execute()</code> 方法之前执行：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeResponse</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Response</span> &#123;</span><br><span class="line"><span class="keyword">let</span> response = <span class="type">Response</span>(status: <span class="keyword">self</span>.status)</span><br><span class="line"><span class="keyword">try</span> validate()</span><br><span class="line">response.json = <span class="keyword">try</span> execute()</span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>validate()</code> 方法的典型样式可能如下所示（来自 Beacon 的 <code>AttendEventCommand</code>）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">validate</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line"><span class="keyword">if</span> attendees.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.userID == user.id &#125;) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">ValidationError</span>(message: <span class="string">"You can't join an event you've already joined."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> attendees.<span class="built_in">count</span> &gt;= event.attendanceLimit &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">ValidationError</span>(message: <span class="string">"This event is at capacity."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> user.id == event.organizer.id &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">ValidationError</span>(message: <span class="string">"You can't join an event you're organizing."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码易于阅读，保持所有验证本地化并且非常易于测试。虽然你可以构造你自己的 <code>Request</code> 和 <code>Droplet</code> 对象，然后把它们传入 <code>Command</code> 的指定构造器，但是你完全没必要这么做。因为每个 <code>Command</code> 都是你自己的对象，所以你可以编写一个接受完备的诸如 <code>User</code> 和 <code>Event</code> 这类对象的构造器，你不需要手动构造 <code>Request</code> 对象进行测试，除非你有测试 <code>Command</code> 构造过程的特殊需求。</p><p>Command 需要的最后一个组件是执行副作用的功能。副作用很简单：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">SideEffect</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">()</span></span> <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在 <code>Command</code> 协议中增加了一个属性，该属性列出了 Command 执行之后需要执行的 <code>SideEffect</code> 对象。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sideEffects: [<span class="type">SideEffect</span>] &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>最后，副作用被添加到了 <code>makeResponse()</code> 方法中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeResponse</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Response</span> &#123;</span><br><span class="line"><span class="keyword">let</span> response = <span class="type">Response</span>(status: <span class="keyword">self</span>.status)</span><br><span class="line"><span class="keyword">try</span> validate()</span><br><span class="line">response.json = <span class="keyword">try</span> execute()</span><br><span class="line"><span class="keyword">try</span> sideEffects.forEach(&#123; <span class="keyword">try</span> $<span class="number">0</span>.perform() &#125;)</span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（在代码的未来版本中，副作用可能会以异步的方式执行，即不会阻止向用户发送响应的过程，不过目前只能同步执行。）将副作用与 <code>Command</code> 的其余部分分离的主要原因是便于测试。你可以创建 <code>Command</code> 并且执行，而不必隔离副作用，因为副作用永远不会被执行。</p><p><code>Command</code> 模式是一个简单的抽象，但它是可测试且正确的，坦白地说，它使用起来令人很愉悦。你可以在这个 <a href="https://gist.github.com/khanlou/133c3cf65d434ec2e66a28a519df3372" target="_blank" rel="noopener">gist</a> 中找到协议的完整定义。我不会因为 Vapor 没有包含这类的抽象而打击它：和其他服务端的框架一样，Vapor 设计简单，你可以根据个人喜好对它进行抽象。 </p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2017/06/server-side-commands&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017/6/21&lt;br&gt;译者：&lt;a href=&quot;http://weibo.com/277195544&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cwift&lt;/a&gt;；校对：&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在服务端使用 Swift 时，大多数路由框架都会把路由同一个指定的闭包关联起来。比如我们在编写 &lt;a href=&quot;http://beacon.party&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Beacon&lt;/a&gt;  时使用的 &lt;a href=&quot;https://vapor.codes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vapor&lt;/a&gt; 框架。你可以在该框架主页的测试示例中看到如下的代码：&lt;/p&gt;
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="Swift 跨平台" scheme="https://swift.gg/tags/Swift-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Swift 服务端错误处理</title>
    <link href="https://swift.gg/2018/04/23/errors-on-the-server/"/>
    <id>https://swift.gg/2018/04/23/errors-on-the-server/</id>
    <published>2018-04-23T00:00:00.000Z</published>
    <updated>2018-05-18T10:47:19.559Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2017/07/errors-on-the-server" target="_blank" rel="noopener">原文链接</a>，原文日期：2017/07/06<br>译者：<a href="http://weibo.com/277195544" target="_blank" rel="noopener">Cwift</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Swift 的 Promise 可以让代码变得简单、正确并具有良好的语义。Swift 的错误处理系统也不例外，正确使用它可以大大提高服务器端代码质量。我们的应用 <a href="https://beacon.party" target="_blank" rel="noopener">Beacon</a> 使用 <a href="https://vapor.codes" target="_blank" rel="noopener">Vapor</a> 构建 API。Vapor 提供了许多构建 API 的基本组件，但更重要的是，它提供了扩展功能，你可以自己添加错误处理。</p><a id="more"></a><p>错误处理的核心是给每个函数基本都标上 <code>throws</code>。你随时可以抛出错误，这个错误会一路冒泡传递上去，一路通过你的路由处理函数和所有中间件。</p><p>Vapor 通常会加载一个 HTML 错误页来显示错误。因为 Beacon 的服务端组件是 JSON API，所以我们需要用中间件将 <code>AbortError</code>（Vapor 的错误类型，包括消息内容和一个状态码）转换为可用的 JSON。这个中间件的模板非常简单，所以我没怎么写注释：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONErrorMiddleware</span>: <span class="title">Middleware</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">respond</span><span class="params">(to request: Request, chainingTo next: Responder)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Response</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">try</span> next.respond(to: request)</span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">AbortError</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> response = <span class="type">Response</span>(status: error.status)</span><br><span class="line">            response.json = <span class="keyword">try</span> <span class="type">JSON</span>(node: [</span><br><span class="line">                <span class="string">"error"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"message"</span>: error.message,</span><br><span class="line">                <span class="string">"code"</span>: error.code,</span><br><span class="line">                <span class="string">"metadata"</span>: error.metadata,</span><br><span class="line">            ])</span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Vapor 1.5 中，你可以把中间件添加到 <code>droplet</code> 中来激活它，<code>droplet</code> 对象就是你的应用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">droplet.middleware.append(<span class="type">JSONErrorMiddleware</span>())</span><br></pre></td></tr></table></figure><p>现在我们已经可以显示错误，接下来我们看看如何优化错误信息。大多数时候，当服务器发生错误时，会使用 nil 作为失败时的返回值，表示没取到想要获取的值。所以我们首先来添加一个 <code>unwrap()</code> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NilError</span>: <span class="title">Error</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">unwrap</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> result = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NilError</span>() &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个请求的返回值为 nil 但是你不想直接返回它，就可以用这个函数让请求直接失败。假设你想使用 <code>id</code> 查找某个 <code>Event</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="type">Event</span>.<span class="built_in">find</span>(id)</span><br></pre></td></tr></table></figure><p>不出所料，<code>event</code> 的类型是 <code>Optional&lt;Event&gt;</code>。因为调用 find 方法时给定的 ID 在数据库中可能不存在，所以它返回了一个可选值。有时候我们不需要空值。例如，在 Beacon 中，如果你尝试参加某个活动，该活动为空并不是正常流程。为了应对这种情况，我用 unwrap() 处理返回值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="type">Event</span>.<span class="built_in">find</span>(id).unwrap()</span><br></pre></td></tr></table></figure><p>现在 <code>event</code> 的类型是 <code>Event</code>，如果活动不存在，函数会直接结束并把错误传递到上面提到的 <code>JSONErrorMiddleware</code>，返回给用户会看到 JSON 格式的错误信息。</p><p><code>unwrap()</code> 的问题是丢失了上下文。到底什么类型获取失败了？如果是在 Ruby 或者 Java 中，我们至少有一个堆栈跟踪器，可以了解到是哪些函数调用报错。可惜在 Swift 里我们没有这种东西。我们最多只能捕获这个错误解包发生的文件和行数。我已经在 <a href="https://github.com/login/oauth/authorize?client_id=7e0a3cd836d3e544dbd9&amp;redirect_uri=https%3A%2F%2Fgist.github.com%2Fauth%2Fgithub%2Fcallback%3Freturn_to%3Dhttps%253A%252F%252Fgist.github.com%252Fkhanlou%252Fe4b5db71a6a18903d8a78edd04068780&amp;response_type=code&amp;state=7847690730bf2d71212c928a94096750c72943aa61610c1614398d52b9a1d383" target="_blank" rel="noopener">这个版本的 <code>NilError</code></a> 中实现了这个功能。</p><p>此外，由于没有上下文，Vapor 没法判断状态代码。你应该注意到了 <code>JSONErrorMiddleware</code> 仅仅遵守了 <code>AbortError</code> 协议。那么其他类型的错误呢？它们被封装在符合 <code>AbortError</code> 协议的对象中，但是状态码被预设为 <code>500</code>，这不是我们想要的。虽然 <code>unwrap()</code> 非常适合快速获取内容。但是一旦你的客户端需要返回正确的状态码以及有用的错误信息，这个方法就不再适用了。为此，我们将探讨如何为该项目构建自定义错误类型。</p><h2 id="缺少资源"><a href="#缺少资源" class="headerlink" title="缺少资源"></a>缺少资源</h2><p>先来解决对象丢失的问题。如果我们的 ID 来自一个 URL 中的参数，这个请求应该返回 <code>404</code>。在 Swift 中构建一个错误信息很简单：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ModelNotFoundError</span>: <span class="title">AbortError</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> status = <span class="type">Status</span>.notFound</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> code: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status.statusCode</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">T</span>&gt;(type: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.message = <span class="string">"<span class="subst">\(typeName)</span> could not be found."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后续的示例中，我会省略 <code>code</code> 这个计算属性，因为它的作用仅仅是转发 <code>status</code> 的 <code>statusCode</code>。</p><p>定义好 <code>ModelNotFoundError</code> 之后，我们可以加上 <code>guard</code> 和 <code>throw</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> event = <span class="type">Event</span>.<span class="built_in">find</span>(id) <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">ModelNotFoundError</span>(type: <span class="type">Event</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是每次获取对象都需要写这些的代码，真的很烦。为了解决这个问题，我在 <code>Entity</code> 的扩展中封装了这段代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">findOr404</span><span class="params">(<span class="number">_</span> id: Node)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> result = <span class="keyword">self</span>.<span class="built_in">find</span>(id) <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">ModelNotFoundError</span>(type: <span class="type">Self</span>.<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的代码好多了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="keyword">try</span> <span class="type">Event</span>.findOr404(id)</span><br></pre></td></tr></table></figure><p>在服务端使用原生的错误，可以提升正确性（基于状态码和准确的消息）以及更严密的表达性。</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>我们的 API 和其他类型的访问需要验证用户身份，以便他们可以执行某些操作。为了简洁地执行该过程，我们使用中间件从用户请求中获取认证的 token，并且把该信息保存在请求对象中。（Vapor 在每个 <code>Request</code> 中包含了一个名为 <code>storage</code> 的便捷字典，你可以把自定义的信息保存在其中。）（此外，Vapor 包含了一些身份验证和 session 处理的组件。相比弄清楚 Vapor 的源码，自己实现一个更简单。）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(user: <span class="type">User</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.user = user</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> user: <span class="type">User</span>?</span><br><span class="line">    </span><br><span class="line">@discardableResult</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">ensureUser</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line"><span class="keyword">return</span> user.unwrap()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个请求都需要提供如上所示的 <code>Session</code> 对象。如果你想确保用户已通过身份验证（并且希望与该用户通信），可以调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currentUser = <span class="keyword">try</span> request.session.ensureUser()</span><br></pre></td></tr></table></figure><p>这段代码和之前的代码有相同的问题。如果用户没有正确的授权，用户会看到 <code>500</code> 的错误和一个有关 <code>nil</code> 对象的没有任何意义的错误描述，而不是 <code>401</code> 未授权的状态码和可读的错误信息。我们需要自定义另一个错误。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AuthorizationError</span>: <span class="title">AbortError</span> </span>&#123;</span><br><span class="line"><span class="keyword">let</span> status = <span class="type">Status</span>.unauthorized</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">"Invalid credentials."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 Vapor 已经实现了对这种错误的处理：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Abort</span>.custom(status: .unauthorized, message: <span class="string">"Invalid credentials."</span>)</span><br><span class="line"> ``` </span><br><span class="line"></span><br><span class="line">我使用了自定义的错误类型，原因后面会解释。</span><br><span class="line"></span><br><span class="line">现在 `ensureUser` 函数变成了这样：</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">@discardableResult</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">ensureUser</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> user = user <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">AuthorizationError</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误的-JSON-格式"><a href="#错误的-JSON-格式" class="headerlink" title="错误的 JSON 格式"></a>错误的 JSON 格式</h2><p>Vapor 对 JSON 的处理难以令人满意。假设你想从一个 JSON 中取出 <code>title</code> 键所保存的字符串内容。看看这些问号：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title = request.json?[<span class="string">"title"</span>]?.string</span><br></pre></td></tr></table></figure><p>当然，在调用链的末尾，<code>title</code> 是一个 <code>Optional&lt;String&gt;</code>。即便在末尾添加一个 <code>unwrap()</code> 也不能解决问题：因为根据 Swift 的可选链优先级规则，它只会解包可选链的最后一个元素：<code>.string</code>。我们可以通过两种方式解决这个问题。第一种是将整个表达式包裹在括号中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title = <span class="keyword">try</span> (request.json?[<span class="string">"title"</span>]?.string).unwrap()</span><br></pre></td></tr></table></figure><p>或者在每一步解包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title = <span class="keyword">try</span> request.json.unwrap()[<span class="string">"title"</span>].unwrap().string.unwrap()</span><br></pre></td></tr></table></figure><p>不必多言，这很可怕。每个展开都代表了不同的错误：第一个解包表示 <code>Content-Type</code> 中缺失了<code>application/json</code>（或者格式不正确），第二个表示 key 不存在，第三个表示 key 对应的类型不符合期望。所有的这些信息都被 <code>unwrap()</code> 丢弃了。理想情况下，我们的 API 会为每种错误提供不同的错误信息。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">JSONError</span>: <span class="title">AbortError</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status: <span class="type">Status</span> &#123;</span><br><span class="line"><span class="keyword">return</span> .badRequest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> jsonMissing</span><br><span class="line"><span class="keyword">case</span> missingKey(keyName: <span class="type">String</span>)</span><br><span class="line"><span class="keyword">case</span> typeMismatch(keyName: <span class="type">String</span>, expectedType: <span class="type">String</span>, actualType: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些 <code>case</code> 代表了上述的三种错误。我们需要根据情况添加一个函数来生成消息，这就是我们需要的全部功能。更完善的错误信息有助于客户端调试常见的错误（比如缺少 <code>Content-Type</code> ）。</p><p>这些错误，和 <code>NiceJSON</code> 组合起来（希望把这个对象作为一个单独的文章），就是下面的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title: <span class="type">String</span> = <span class="keyword">try</span> request.niceJSON.fetch(<span class="string">"title"</span>)</span><br></pre></td></tr></table></figure><p>可读性高了许多。<code>title</code> 通常也是一个具有预设类型的实例变量（<a href="http://khanlou.com/2017/06/server-side-commands/" target="_blank" rel="noopener">这篇文章</a>中有提到），所以类型推断所需的 <code>: String</code> 也可以省略。</p><p>编写代码的“正确方式”应该同时是编写代码的“最佳实践”，你不必在有价值的错误消息或者类型安全性以及简单的易于阅读的代码之间做出痛苦的折衷。</p><h2 id="外部可见的错误"><a href="#外部可见的错误" class="headerlink" title="外部可见的错误"></a>外部可见的错误</h2><p>默认情况下，Vapor 包含一个指向 <code>AbortError</code> 的错误。然而，许多（绝大多数！）情况下用户不应该从错误中看到实现的细节。例如，PostgreSQL 适配器的错误显示你所连接的数据库以及表结构的详细信息。甚至 <code>NilError</code>包含了错误的文件和行数，它显示了服务器是基于 Swift 搭建的，因此容易受到针对 Swift 的攻击。</p><p>为了隐藏一些错误信息，我创建了一个新的协议。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ExternallyVisibleError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> status: <span class="type">Status</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> externalMessage: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>ExternallyVisibleError</code> 没有遵守 <code>AbortError</code>。一旦你让 <code>AbortError</code> 对象遵守该协议，就必须提供额外的属性：<code>externalMessage</code>，它是用户看到的内容。</p><p>我们需要对 <code>JSONErrorMiddleware</code> 进行快速地修改，以便在非 <code>ExternallyVisibleError</code> 类型的错误中隐藏错误信息：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">respond</span><span class="params">(to request: Request, chainingTo next: Responder)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Response</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> next.respond(to: request)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">ExternallyVisibleError</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> response = <span class="type">Response</span>(status: error.status)</span><br><span class="line">        response.json = <span class="keyword">try</span> <span class="type">JSON</span>(node: [</span><br><span class="line">            <span class="string">"error"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"message"</span>: error.externalMessage,</span><br><span class="line">            <span class="string">"code"</span>: error.status.statusCode,</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">AbortError</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> response = <span class="type">Response</span>(status: error.status)</span><br><span class="line">        response.json = <span class="keyword">try</span> <span class="type">JSON</span>(node: [</span><br><span class="line">            <span class="string">"error"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"There was an error processing this request."</span>,</span><br><span class="line">            <span class="string">"code"</span>: error.code,</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我还添加了一些代码，只要不是 <code>.production</code> 环境，就把 <code>AbortError</code> 传递下去。</p><p>Swift 的错误类型是一个强大的工具，可以存储附加的数据、元数据和类型。Vapor 内置类型的一些简单扩展能帮助你写出更好的代码。对于我来说，Swift 的亮点就是简洁、表现力和错误处理能力，客户端和服务端应该达成这种默契。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      如何在服务端中更 Swifty 使用错误处理
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="Swift 跨平台" scheme="https://swift.gg/tags/Swift-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Twitter iOS 教程</title>
    <link href="https://swift.gg/2018/04/15/twitter-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2018/04/15/twitter-ios-tutorial-ios10/</id>
    <published>2018-04-15T00:00:00.000Z</published>
    <updated>2018-05-18T10:47:19.559Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/twitter-ios-tutorial-ios10" target="_blank" rel="noopener">原文链接</a>，原文日期：2017/03/14<br>译者：<a href="https://imiem.github.io" target="_blank" rel="noopener">imiem</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://www.jianshu.com/u/2d46948e84e3" target="_blank" rel="noopener">mmoaay</a></p></blockquote><!--此处开始正文--><p>Social Framework 使在 App 中使用社交分享成为可能。本教程中我们将从图库中选取一张图片，然后在 Twitter 中分享一个带图片的推文。本教程使用 Xcode 8.2.1 和 iOS 10.2。</p><a id="more"></a><p>打开 Xcode，创建一个 Single View Application。<br><img src="/img/articles/twitter-ios-tutorial-ios10/single-view-xcode-templateformat=750w1523791017.6382737" alt=""></p><p>Product Name 命名为 <strong>IOS10TwitterTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier。Language 选择 Swift, 并确保 Devices 只选择了 iPhone。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=750w1523791017.6963322" alt=""></p><p>转到 Storyboard，拖拽一个 Image View 到主页面上。选中 Image View 跳转到属性选项卡。在 View 部分使用 “Aspect Fit” 模式。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.7377508" alt=""></p><p>这种模式会使图片自适应 Image View。下一步，在页面的 Image View 下方添加两个 Button 按钮。title 分别设为 “Choose Image” 和 “Tweet”。</p><p>选中 Image View，点击 Storyboard 右下角 Auto Layout 的 Pin 按钮，填写下方的值，点击 Add 4 Constraints 按钮。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.786322" alt=""></p><p>按住 Cmd 键选中 “Choose Image” 和 “Tweet” 按钮。点击 Storyboard 右下角的 Align 按钮然后选择 “Horizontally in Container”。点击 “Add 2 Constraints” 按钮添加约束。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.8271823" alt=""></p><p>选中 “Choose Image” 按钮，点击 Storyboard 右下方的 Auto Layout 的 Pin 按钮，选中左边的线，点击 Add 1 Constraint 按钮添加约束。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.870292" alt=""></p><p>选中 “Tweet” 按钮，点击 Storyboard 右下方的 Auto Layout 的 Pin 按钮，选中右边的线，点击 Add 1 Constraint 按钮添加约束。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.91299" alt=""></p><p>Storyboard 看起来应如下图：</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.956209" alt=""></p><p>点击 Assistant Editor，确保 ViewController.swift 文件内容可见。接着选中 Image View ，按住 Ctrl 键鼠标左键拖拽一条线到  ViewController 类中，创建如下 Outlet 。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.964874" alt=""></p><p>同上，选中 Choose Image 按钮，按住 Ctrl 键拖拽到 ViewController 类中，创建如下 Action。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791018.0067496" alt=""></p><p>选中 Tweet 按钮，按住 Ctrl 键拖拽到 ViewController 类中，创建如下 Action。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791018.0520294" alt=""></p><p>要想使用 Social framework，首先要将其导入到工程中。添加如下代码到 ViewController.swift 文件中。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Social</span><br></pre></td></tr></table></figure><p>ViewController 访问图库需要遵循 UINavigtionControllerDelegate 和 UiImagePickerControllerDelegate 协议。将声明 ViewController 的代码改为：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UINavigationControllerDelegate</span>, <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>在类中添加如下属性</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pickerController: <span class="type">UIImagePickerController</span> = <span class="type">UIImagePickerController</span>()</span><br></pre></td></tr></table></figure><p>下一步，实现 chooseImagePressed 方法</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">chooseImagePressed</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    pickerController.delegate = <span class="keyword">self</span></span><br><span class="line">    pickerController.sourceType = <span class="type">UIImagePickerControllerSourceType</span>.photoLibrary</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">self</span>.present(pickerController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将 View Controller 设为代理，同时设置图库的 sourceType。</li><li>呈现图片选择视图控制器。</li></ol><p>下一步，实现 tweetButtonPressed 方法来创建分享页。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">tweetButtonPressed</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">SLComposeViewController</span>.isAvailable(forServiceType: <span class="type">SLServiceTypeTwitter</span>) &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">let</span> tweetSheet = <span class="type">SLComposeViewController</span>(forServiceType: <span class="type">SLServiceTypeTwitter</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> tweetSheet = tweetSheet &#123;</span><br><span class="line">            tweetSheet.setInitialText(<span class="string">"Look at this nice picture!"</span>)</span><br><span class="line">            tweetSheet.add(imageView.image)</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">self</span>.present(tweetSheet, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下这个方法</p><ol><li>检查这个设备上是否有 twitter 账户。</li><li>创建 SLComposeViewController 对象，该对象用于显示推文界面和全部的功能。</li><li>在推文发布页面添加初始化文本和选中的图片。</li><li>显示推文发布页面。</li><li>如果没有 twitter 账户，在控制台打印一条信息。</li></ol><p>最后，实现 <code>imagePickerController:didFinishPickingMediaWithInfo</code> 方法。这里指定图库中的照片到 image view 上。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any])</span></span> &#123;</span><br><span class="line">    imageView.image = info[<span class="type">UIImagePickerControllerOriginalImage</span>] <span class="keyword">as</span>? <span class="type">UIImage</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">self</span>.dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想获得图库权限，必须要在 Info.plist 中添加一个键值（key）。打开 Info.plist 点击 + 添加如下键值。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=750w1523791018.0618207" alt=""></p><p>正常运行前，需要在 iOS 模拟器的设置中创建 Twitter 账号。</p><p>构建和运行工程。这个应用会请求访问图库的权限，点击允许。下一步，点击 “Choose Image”  按钮在图库中选择一张图片。下一步，点击 “Tweet” 按钮创建和发布推文。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=500w1523791018.070653" alt=""></p><p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="noopener">github</a> 上下载 IOS10TwitterTutorial 教程的源代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Arthur Knopper，&lt;a href=&quot;https://www.ioscreator.com/tutorials/twitter-ios-tutorial-ios10&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017/03/14&lt;br&gt;译者：&lt;a href=&quot;https://imiem.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;imiem&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;http://www.jianshu.com/u/2d46948e84e3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mmoaay&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Social Framework 使在 App 中使用社交分享成为可能。本教程中我们将从图库中选取一张图片，然后在 Twitter 中分享一个带图片的推文。本教程使用 Xcode 8.2.1 和 iOS 10.2。&lt;/p&gt;
    
    </summary>
    
      <category term="Arthur Knopper" scheme="https://swift.gg/categories/Arthur-Knopper/"/>
    
    
  </entry>
  
  <entry>
    <title>在 Xcode9 中自定义文件头部注释和其他文本宏</title>
    <link href="https://swift.gg/2017/12/10/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/"/>
    <id>https://swift.gg/2017/12/10/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/</id>
    <published>2017-12-10T00:00:00.000Z</published>
    <updated>2018-05-18T10:46:06.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2017/07/xcode-9-text-macros/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017/07/24<br>译者：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>；校对：<a href="http://www.jianshu.com/users/9c51a213b02e/latest_articles" target="_blank" rel="noopener">Joy</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>我一直<a href="https://twitter.com/olebegemann/status/845263246949011457" target="_blank" rel="noopener">不喜欢 Xcode 默认给新文件头部添加的注释</a>。在我看来，从注释里得到的绝大多数信息要么和文件本身没有关系，要么通过版本控制，你能得到更详尽的信息。此外，当文件和项目更名的时候，这些注释会立刻显得过时。</p><a id="more"></a><p><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/11.png1512891714.217959" alt=""></p><p>因此，在我个人的项目里，我创建新文件后，第一件要做的事情就是删除这些注释。</p><p>这个习惯一直持续到不久前，直到 Xcode9 允许使用一个 plist 文件来自定义文件头部注释和其他被称作文本宏的东西。这部分内容在 Xcode 的<a href="https://help.apple.com/xcode/mac/9.0/index.html" target="_blank" rel="noopener">帮助文档</a>中的<a href="https://help.apple.com/xcode/mac/9.0/index.html?localePath=en.lproj#/dev91a7a31fc" target="_blank" rel="noopener">自定义文本宏</a>这一页中有详尽的描述：</p><p><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-help-customize-text-macros.png1512892169.760428" alt=""></p><ol><li><strong>首先，创建一个叫做 <code>IDETemplateMacros.plist</code> 的 plist 文件</strong></li><li><p><strong>当你想自定义一个文本宏时，就向 plist 的字典中添加一个新的键。</strong>例如，当你想修改默认的文件头部注释时，就给 plist 文件中添加一个新条目，条目的键为 <code>FILEHEADER</code>。</p><p> <img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-plist-editor-IDETemplateMacros-plist.png1512892705.4828758" alt="在 Xcode 的 plist 编辑器中编辑`IDETemplateMacros.plist`文件"></p><blockquote><p>Xcode 的 plist 编辑器只会展示一行，不过你可以用 Option + Return 添加新行。</p></blockquote><p> 如果你想知道都有哪些文本宏可以使用，你可以查看<a href="#1">下方的文本宏参考</a>。你也可以在某个宏的值中使用其他宏，只要用下划线（译者注：三个下划线）包裹起来那个宏就可以了，比如：<code>___DATE___</code>。一些文本宏也可以用一种<code>:modifier</code>语法来进行进一步的自定义。通过查看<a href="#2">下方的文本宏格式参考</a>你可以得知更多细节。</p></li><li><p><strong>然后你可以把 plist 文件放到这么几个地方。放置的位置决定了自定义的文本宏会在什么范围内生效</strong>：</p><ul><li>使用该工程 (project) 的某个特定用户创建新文件时生效：<code>&lt;ProjectName&gt;.xcodeproj/xcuserdata/[username].xcuserdatad/IDETemplateMacros.plist</code></li><li>使用该工程的所有人创建新文件时生效：<code>&lt;ProjectName&gt;.xcodeproj/xcshareddata/IDETemplateMacros.plist</code></li><li>使用该工作空间 (workspace) 的某个特定用户创建新文件时生效：<code>&lt;WorkspaceName&gt;.xcworkspace/xcuserdata/[username].xcuserdatad/IDETemplateMacros.plist</code></li><li>使用该工作空间的所有人创建新文件时生效：<code>&lt;WorkspaceName&gt;.xcworkspace/xcshareddata/IDETemplateMacros.plist</code> </li><li>使用 Xcode 创建的所有新文件都生效：<code>~/Library/Developer/Xcode/UserData/IDETemplateMacros.plist</code></li></ul></li></ol><p>当你创建一个新文件时，新文件的头部看起来像是这样：<br>​<br><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-new-file-after-customizing-text-macros.png1512892705.61613" alt="在自定义了`FILEHEADRE`文本宏后创建爱你的新文件"><br>​    </p><blockquote><p>注意，对于<code>FILEHEADER</code>宏，目前的 Xcode(Xcode9 beta3) 只会自动给第一行添加注释标记（一个不带空格的<code>//</code>），剩下的行并不会自动添加注释标记。你需要手动在带有宏的文本中添加注释标记。我不确定对 Xcode 来说这是一个 feature 还是一个 bug（对我来说现在看起来这是一个 bug）</p><p>因此，即便你在 plist 文件中把 <code>FILEHEADER</code> 设置成空字符串，也没法让文件头部的注释完全消失，新文件的开头会是一个空的注释行。我希望这个 bug 可以在未来的版本中解决掉。我已经给苹果官方提交了这个 bug（rdar://33451838）</p></blockquote><blockquote><p>译者注：<br>rdar 指的苹果内部的 bug 追踪系统，一般开发者可以在 <a href="https://bugreport.apple.com/" target="_blank" rel="noopener">https://bugreport.apple.com/</a> 上提交 bug，当然你只能看到自己提交的 bug，高冷的苹果不会展示出来总共有多少人提交了 bug，所以有人建立了 <a href="https://openradar.appspot.com/" target="_blank" rel="noopener">https://openradar.appspot.com/</a> 这个网站呼吁大家在提交 bug 后也在这里提交一次，方便开发者们知道都有哪些问题被提交了。更多详情可以参见这个<a href="https://forums.developer.apple.com/thread/8796" target="_blank" rel="noopener">论坛帖子</a></p></blockquote><hr><h2 id="1">文本宏索引</h2><p>这里是所有可以在 Xcode9 中使用的文本宏，我把他们从 <a href="https://help.apple.com/xcode/mac/9.0/index.html?localePath=en.lproj#/dev7fe737ce0" target="_blank" rel="noopener">Xcode 的帮助页面</a>中一字不差的复制过来了。</p><p><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-help-text-macros-reference.png1512892705.665681" alt=""></p><blockquote><h5 id="DATE"><a href="#DATE" class="headerlink" title="DATE"></a>DATE</h5><p>当前的日期。</p><h5 id="DEFAULTTOOLCHAINSWIFTVERSION"><a href="#DEFAULTTOOLCHAINSWIFTVERSION" class="headerlink" title="DEFAULTTOOLCHAINSWIFTVERSION"></a>DEFAULTTOOLCHAINSWIFTVERSION</h5><p>当前工具链所使用的 Swift 的版本。</p><h5 id="FILEBASENAME"><a href="#FILEBASENAME" class="headerlink" title="FILEBASENAME"></a>FILEBASENAME</h5><p>不带扩展名的当前文件的名称。</p><h5 id="FILEBASENAMEASIDENTIFIER"><a href="#FILEBASENAMEASIDENTIFIER" class="headerlink" title="FILEBASENAMEASIDENTIFIER"></a>FILEBASENAMEASIDENTIFIER</h5><p>以 C 标识符编码的当前文件名称。（译者注：C 标识符只允许使用数字、字母和下划线，使用这个宏会把其他的字符自动替换成下划线）</p><h5 id="FILEHEADER"><a href="#FILEHEADER" class="headerlink" title="FILEHEADER"></a>FILEHEADER</h5><p>每个文本文件头部的文本。</p><h5 id="FILENAME"><a href="#FILENAME" class="headerlink" title="FILENAME"></a>FILENAME</h5><p>当前文件的完整名称。</p><h5 id="FULLUSERNAME"><a href="#FULLUSERNAME" class="headerlink" title="FULLUSERNAME"></a>FULLUSERNAME</h5><p>当前系统用户的全名。</p><h5 id="NSHUMANREADABLECOPYRIGHTPLIST"><a href="#NSHUMANREADABLECOPYRIGHTPLIST" class="headerlink" title="NSHUMANREADABLECOPYRIGHTPLIST"></a>NSHUMANREADABLECOPYRIGHTPLIST</h5><p>macOS 应用类型的 target 中，Info.plist 文件设置的版权信息条目的值（译者注：也就是这个宏最终会被替换成在 Info.plist 中 NSHumanReadableCopyright 这一项保存的字符串）。这个条目对应的一个合法的示例值为：</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &lt;key&gt;NSHumanReadableCopyright&lt;/key&gt;</span><br><span class="line">&gt; &lt;string&gt;Copyright © 2017 Apple, Inc. All rights reserved.&lt;/string&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注意值里头有一次换行<br><strong>ORGANIZATIONNAME</strong><br> Provisioning profile 文件中使用的团队所在的公司名称。<br><strong>PACKAGENAME</strong><br>当前 scheme 所设置的包名。<br><strong>PACKAGENAMEASIDENTIFIER</strong><br>当前 scheme 所设置的包名，以 C 标识符的形式编码。<br><strong>PRODUCTNAME</strong><br>当前 scheme 设置的应用名称。<br><strong>PROJECTNAME</strong><br>当前工程的名称。<br><strong>RUNNINGMACOSVERSION</strong><br>macOS 系统的版本。<br><strong>TARGETNAME</strong><br>当前 target 的名称。<br><strong>TIME</strong><br>当前的时间<br><strong>USERNAME</strong><br>当前 macOS 用户的登录名。<br><strong>UUID</strong><br>使用这个宏的时候，会返回一个唯一 ID。当这个宏第一次被使用时，Xcode 会创建一个 ID。你可以通过使用修饰符来创建多个唯一的 ID。每个修饰符都会得到一个针对这个修饰符唯一的 ID。</p><p>例如，<code>UUID:firstPurpose</code>这个宏和修饰符的组合在第一次使用的时候，它会创建并返回一个唯一的 ID。接下来其他使用 <code>UUID:firstPurpose</code>的地方都会返回这个 ID。使用 <code>UUID:secondPurpose</code> 后会产生并返回一个新的 ID，这个 ID 对于<code>UUID:secondPurpose</code>来说是唯一的，并且这个 ID 不同于前一个 ID。<br><strong>WORKSPACENAME</strong><br>当前 workspace 的名称。如果 workspace 中只有一个 project，那么这个宏的值便是当前打开的 project 的名称。<br><strong>YEAR</strong><br>四位数字格式的当前年数。</p></blockquote><hr><h2 id="2">文本宏格式索引</h2><p><em>以下内容都是从 Xcode 帮助页面中的<a href="https://help.apple.com/xcode/mac/9.0/index.html?localePath=en.lproj#/devc8a500cb9" target="_blank" rel="noopener">文本宏格式参考</a>拷贝过来的</em></p><p><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-help-text-macro-format-reference.png1512892705.816728" alt=""></p><blockquote><p>一个文本宏的值可以包含任何合法的 unicode 字符。同时一个文本宏的值也可以包含其他的文本宏。</p></blockquote><blockquote><h5 id="引入其他文本宏"><a href="#引入其他文本宏" class="headerlink" title="引入其他文本宏"></a>引入其他文本宏</h5><p>要想引入其他文本宏，在想要添加的文本宏之前和之后添加下划线(__):</p></blockquote><blockquote><p><code>___&lt;MacroName&gt;___</code></p><h5 id="编辑文本宏表达式"><a href="#编辑文本宏表达式" class="headerlink" title="编辑文本宏表达式"></a>编辑文本宏表达式</h5><p>通过添加一个或者多个修饰符，你可以修改文本宏的最终值。针对那些可以添加修饰符的文本宏，可以在宏的最后添加修饰符，宏和修饰符之间用分号(:)分隔。多个修饰符之间可以用逗号(,)分隔。</p></blockquote><blockquote><p><code>&lt;MACRO&gt;:&lt;modifier&gt;[,&lt;modifier&gt;]…</code></p><p>例如，下面的这段宏会删除掉<code>FILENAME</code>宏中的扩展名：</p></blockquote><blockquote><p><code>FILENAME:deletingPathExtension</code></p><p>为了使编辑后的宏符合 C 标识符的规范，可以在宏之后再添加一个 identifier 修饰符：</p><p><code>FILENAME:deletingPathExtension,identifier</code></p><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><h5 id="bundleIdentifier"><a href="#bundleIdentifier" class="headerlink" title="bundleIdentifier"></a>bundleIdentifier</h5><p>用一个连字符(-)替换所有不符合 bundle 标识的字符。</p><h5 id="deletingLastPathComponent"><a href="#deletingLastPathComponent" class="headerlink" title="deletingLastPathComponent"></a>deletingLastPathComponent</h5><p>从字符串中删除最后一个路径组件 (path component)。（译者注：根据<a href="https://en.wikipedia.org/wiki/Path_(computing" target="_blank" rel="noopener">维基百科</a>)的解释，一个路径是由多个路径组件组成的，路径组件之间使用斜线”/“、反斜线”\“或者句点”.“来分隔）</p><h5 id="deletingPathExtension"><a href="#deletingPathExtension" class="headerlink" title="deletingPathExtension"></a>deletingPathExtension</h5><p>从字符串中删除所有的扩展名。</p><h5 id="deletingTrailingDot"><a href="#deletingTrailingDot" class="headerlink" title="deletingTrailingDot"></a>deletingTrailingDot</h5><p>删除所有句子末尾的句点 (.)。</p><h5 id="identifier"><a href="#identifier" class="headerlink" title="identifier"></a>identifier</h5><p>用下划线(_)代替所有不符合 C 标识符编码的字符。</p><h5 id="lastPathComponent"><a href="#lastPathComponent" class="headerlink" title="lastPathComponent"></a>lastPathComponent</h5><p>仅返回字符最后一个路径组件。</p><h5 id="pathExtension"><a href="#pathExtension" class="headerlink" title="pathExtension"></a>pathExtension</h5><p>返回字符的扩展名。</p><h5 id="rfc1034Identifier"><a href="#rfc1034Identifier" class="headerlink" title="rfc1034Identifier"></a>rfc1034Identifier</h5><p>用连字符(-)替换所有不符合 rfc1034 标识符规范的字符。（译者注：rfc1034 是定义域名的规范，详情参见<a href="https://www.ietf.org/rfc/rfc1034.txt" target="_blank" rel="noopener">这里</a>）</p><h5 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h5><p>将一些特殊的 xml 字符用其转义字符替换。比如，小于号 (&lt;) 会被 &amp;lt 替换;</p></blockquote><hr><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2017/07/xcode-9-text-macros/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017/07/24&lt;br&gt;译者：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/9c51a213b02e/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Joy&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;我一直&lt;a href=&quot;https://twitter.com/olebegemann/status/845263246949011457&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不喜欢 Xcode 默认给新文件头部添加的注释&lt;/a&gt;。在我看来，从注释里得到的绝大多数信息要么和文件本身没有关系，要么通过版本控制，你能得到更详尽的信息。此外，当文件和项目更名的时候，这些注释会立刻显得过时。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Xcode" scheme="https://swift.gg/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Core NFC 指南 - iOS 设备中的 NFC</title>
    <link href="https://swift.gg/2017/09/25/core-nfc-tutorial-for-nfc-on-ios-devices/"/>
    <id>https://swift.gg/2017/09/25/core-nfc-tutorial-for-nfc-on-ios-devices/</id>
    <published>2017-09-25T00:00:00.000Z</published>
    <updated>2018-05-18T10:46:06.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jameson Quave，<a href="http://jamesonquave.com/blog/core-nfc-tutorial-for-nfc-on-ios-devices/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-06<br>译者：<a href="http://www.desgard.com/" target="_blank" rel="noopener">冬瓜</a>；校对：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>在 iOS 11 发布后，开发者们首次可以在 iPhone7 或者更高的设备上调用 NFC 读取相关的接口。这些接口可以用于传递身份信息或者是用于实现类似门禁、地铁闸机这种功能的数据交换应用。</p><p>在 iOS 11 中，这项技术被称作 Core NFC，下面我将在教程中使用 Swift 4 来讨论如何使用它。</p><p><img src="/img/articles/core-nfc-tutorial-for-nfc-on-ios-devices/nfc2.pngzoom=2&amp;w=5841512890761.307122" alt=""></p><a id="more"></a><iframe width="560" height="315" src="https://www.youtube.com/embed/SD6Rm4cGyko" frameborder="0" allowfullscreen></iframe><p>由于 Core NFC 目前权限为只读状态，非接触式支付功能是不被开放的，但是仍旧有一些能够使用 Core NFC 读取能力的<del>使用</del>场景。下面我们来讲述一下。</p><p>使用 NFC 的第一步是在 Apple Developer Center 中通过 App ID 来启用它。创建一个新的 App ID，并启用 “NFC Tag Reading” 这个功能。</p><p><img src="/img/articles/core-nfc-tutorial-for-nfc-on-ios-devices/entitlement.pngzoom=2&amp;w=5841512890761.528886" alt=""></p><p>这之后，我建议专门为这个 App ID 创建一个 development/distribution provisioning profile 文件，这样当你尝试构建 App 的时候，NFC 读取功能将会自动加入。</p><p>接下来，你需要在 Xcode 项目中的 projectName.entitlements 中为的工程添加授权。你需要右键点击该文件并选择”Open As Source Code”，显示如图所示：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.developer.nfc.readersession.formats<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>NDEF<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果没有 entitlements 文件，可以在项目中手动创建并把他加到工程的 build settings 中。在 “Build Settings” 下点击 “Coding Signing Entitlements” 选项并加入 entitlements 文件的相对路径。本例中是 “CoreNFC-Tutorial/CoreNFC-Tutorial.entitlements” ，因为我的工程文件在 “CoreNFC-Tutorial” 子目录下。</p><p>然后，需要为 Xcode 项目增加 usage string。打开 Info.plist 文件，增加 “Privacy - NFC Scan Usage Description” 这个键值。当用户使用 NFC 时，这个键值填写的内容会作为通知消息展示给用户，所以我们最好写一些有用的信息，比如可以填写 “NFC is needed to unlock doors.”。</p><p>接下来，在代码中引入 <code>CoreNFC</code> 模块。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> CoreNFC</span><br></pre></td></tr></table></figure><p>备注：Core NFC 在 iOS 的模拟器上不可用， 即便是导入模块也会编译失败。因此 Core NFC 相关代码只能真机调试。</p><p>这里我创建了一个 <code>NFCHelper.swift</code> 文件，并将所有 NFC 相关的 API 调用封装成一个 NFCHelper 类。在 <code>init</code> 方法中我创建了一个会话 ，Core NFC 需要使用 <code>NFCNDEFReaderSession</code> 这个 class 来监听 NFC 设备，从而完成通信。（注意 <code>NFCReaderSession</code> 是一个抽象类，不能直接使用）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NFCHelper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> session =</span><br><span class="line">      <span class="type">NFCNDEFReaderSession</span>(delegate: <span class="keyword">self</span>,</span><br><span class="line">                           queue: <span class="literal">nil</span>,</span><br><span class="line">                           invalidateAfterFirstRead: <span class="literal">true</span>)</span><br><span class="line">    session.begin()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中我们创建了一个会话，并且为 <code>Dispatch Queue</code> 这个参数传递了一个 nil 值。这样可以使得 <code>NFCNDEFReaderSession</code> 自动创建一个串行 Dispatch Queue。</p><p>创建会话的时候，我们也要为 <code>NFCDEFReaderSession</code> 设置代理对象。这里我使用 <code>NFCHelper</code> class 来作为代理，所以我们需要遵守 <code>NFCNDEFReaderSessionDelegate</code> 协议。这个协议是基于 <code>NSObjectProtocol</code> 协议的，所以我们需要继承 <code>NSObject</code>（译者注：NSObject 协议在 Swift 中的名称为 NSObjectProtocol）。<code>NFCNDEFReaderSessionDelegate</code> 有两个必须实现的代理方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didInvalidateWithError error: Error)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage])</span></span></span><br></pre></td></tr></table></figure><p>当 NFC 的会话获取到验证错误，或是 NFC 的感应被触发时，这两个回调方法就会被调用。我们对回调信息的处理方式取决于我们 App 的使用场景，但是所有能够获取到的信息都可以通过 <code>didDetectNDEFs</code> 回调方法中的 <code>messages</code> 变量得到。在一开始，你可以通过遍历并打印 <code>messages</code> 中的元素来了解这些信息的内容。每个元素均是 <code>NFCDEFPayload</code> 对象，并且每一个对象都会包括 <code>identifier</code>、<code>payload</code>、<code>type</code> 和 <code>typeNameFormat</code> 这些属性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage])</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Did detect NDEFs."</span>)</span><br><span class="line">  <span class="comment">// 遍历 messages 数组中所有元素</span></span><br><span class="line">  <span class="keyword">for</span> message <span class="keyword">in</span> messages &#123;</span><br><span class="line">    <span class="keyword">for</span> record <span class="keyword">in</span> message.records &#123;</span><br><span class="line">      <span class="built_in">print</span>(record.identifier)</span><br><span class="line">      <span class="built_in">print</span>(record.payload)</span><br><span class="line">      <span class="built_in">print</span>(record.type)</span><br><span class="line">      <span class="built_in">print</span>(record.typeNameFormat)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们了解了这些属性的含义之后，就可以将其集成在前端 App 中，这里我针对我的应用创建了一个专门的回调方法，你应该也会做类似的事情，这里我增加了一个回调的属性，便于我的前端页面用这个属性来做进一步的展示：</p><p>当我从 NFC 获得一个有效信号或是一个错误的时候，会调用这个回调：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NFCHelper</span>: <span class="title">NSObject</span>, <span class="title">NFCNDEFReaderSessionDelegate</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> onNFCResult: ((<span class="type">Bool</span>, <span class="type">String</span>) -&gt; ())?</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我还实现了把创建会话的方法封装到了一个新的方法中，这样我就可以通过 <code>ViewController</code> 中的一个 button 点击触发来创建一个新的会话。关于 <code>NFCHelper.swift</code> 的最终代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  NFCHelper.swift</span></span><br><span class="line"><span class="comment">//  CoreNFC-Tutorial</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Jameson Quave on 6/6/17.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 Jameson Quave. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CoreNFC</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NFCHelper</span>: <span class="title">NSObject</span>, <span class="title">NFCNDEFReaderSessionDelegate</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> onNFCResult: ((<span class="type">Bool</span>, <span class="type">String</span>) -&gt; ())?</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">restartSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> session =</span><br><span class="line">    <span class="type">NFCNDEFReaderSession</span>(delegate: <span class="keyword">self</span>,</span><br><span class="line">                       queue: <span class="literal">nil</span>,</span><br><span class="line">                       invalidateAfterFirstRead: <span class="literal">true</span>)</span><br><span class="line">    session.begin()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// MARK: NFCNDEFReaderSessionDelegate</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didInvalidateWithError error: Error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> onNFCResult = onNFCResult <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    onNFCResult(<span class="literal">false</span>, error.localizedDescription)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage])</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> onNFCResult = onNFCResult <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> message <span class="keyword">in</span> messages &#123;</span><br><span class="line">      <span class="keyword">for</span> record <span class="keyword">in</span> message.records &#123;</span><br><span class="line">        <span class="keyword">if</span>(record.payload.<span class="built_in">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">let</span> payloadString = <span class="type">String</span>.<span class="keyword">init</span>(data: record.payload, encoding: .utf8) &#123;</span><br><span class="line">              onNFCResult(<span class="literal">true</span>, payloadString)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我还搭建了一个简易的 UI 视图来展示这个类的用法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  CoreNFC-Tutorial</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Jameson Quave on 6/6/17.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 Jameson Quave. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helper: <span class="type">NFCHelper</span>?</span><br><span class="line">  <span class="keyword">var</span> payloadLabel: <span class="type">UILabel</span>!</span><br><span class="line">  <span class="keyword">var</span> payloadText = <span class="string">""</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    <span class="comment">// 增加检测按钮</span></span><br><span class="line">    <span class="keyword">let</span> button = <span class="type">UIButton</span>(type: .system)</span><br><span class="line">    button.setTitle(<span class="string">"Read NFC"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">    button.titleLabel?.font = <span class="type">UIFont</span>(name: <span class="string">"Helvetica"</span>, size: <span class="number">28.0</span>)</span><br><span class="line">    button.isEnabled = <span class="literal">true</span></span><br><span class="line">    button.addTarget(<span class="keyword">self</span>, action: #selector(didTapReadNFC), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">    button.frame = <span class="type">CGRect</span>(x: <span class="number">60</span>, y: <span class="number">200</span>, width: <span class="keyword">self</span>.view.bounds.width - <span class="number">120</span>, height: <span class="number">80</span>)</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(button)</span><br><span class="line">    <span class="comment">// 添加一个 Label 来显示状态</span></span><br><span class="line">    payloadLabel = <span class="type">UILabel</span>(frame: button.frame.offsetBy(dx: <span class="number">0</span>, dy: <span class="number">220</span>))</span><br><span class="line">    payloadLabel.text = <span class="string">"Press Read to see payload data."</span></span><br><span class="line">    payloadLabel.numberOfLines = <span class="number">100</span></span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(payloadLabel)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当 NFCHelper 已经处理过或者通信失败时调用</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">onNFCResult</span><span class="params">(success: Bool, message: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> success &#123;</span><br><span class="line">      payloadText = <span class="string">"<span class="subst">\(payloadText)</span>\n<span class="subst">\(message)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      payloadText = <span class="string">"<span class="subst">\(payloadText)</span>\n<span class="subst">\(message)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在主线程中更新 UI </span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">      <span class="keyword">self</span>.payloadLabel.text = <span class="keyword">self</span>.payloadText</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当用户点击 NFC 读取按钮时调用</span></span><br><span class="line">  <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">didTapReadNFC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> helper == <span class="literal">nil</span> &#123;</span><br><span class="line">      helper = <span class="type">NFCHelper</span>()</span><br><span class="line">      helper?.onNFCResult = <span class="keyword">self</span>.onNFCResult(success:message:)</span><br><span class="line">    &#125;</span><br><span class="line">    payloadText = <span class="string">""</span></span><br><span class="line">    helper?.restartSession()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了以上的基本框架，你就可以结合你具体的需求来为你的 APP 添砖加瓦了。无论是识别客人身份、检测 Amiibo 状态（译者注：<a href="https://zh.wikipedia.org/wiki/Amiibo" target="_blank" rel="noopener">Amiibo</a> 是任天堂推出的基于 NFC 的玩偶），甚至是完成支付，Apple 推出的 Core NFC API 终于为这些新设备提供了完成各类 NFC 功能的可能性。如果你在开发任何集成了 NFC 功能的产品，欢迎发邮件到<a href="jquave@gmail.com">jquave@gmail.com</a>和我交流。</p><p><a href="https://github.com/jquave/TagReader" target="_blank" rel="noopener">完整源码</a></p><p><a href="https://www.youtube.com/watch?v=SD6Rm4cGyko&amp;feature=youtu.be" target="_blank" rel="noopener">视频教程</a></p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Jameson Quave，&lt;a href=&quot;http://jamesonquave.com/blog/core-nfc-tutorial-for-nfc-on-ios-devices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-06-06&lt;br&gt;译者：&lt;a href=&quot;http://www.desgard.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;冬瓜&lt;/a&gt;；校对：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在 iOS 11 发布后，开发者们首次可以在 iPhone7 或者更高的设备上调用 NFC 读取相关的接口。这些接口可以用于传递身份信息或者是用于实现类似门禁、地铁闸机这种功能的数据交换应用。&lt;/p&gt;
&lt;p&gt;在 iOS 11 中，这项技术被称作 Core NFC，下面我将在教程中使用 Swift 4 来讨论如何使用它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/articles/core-nfc-tutorial-for-nfc-on-ios-devices/nfc2.pngzoom=2&amp;amp;w=5841512890761.307122&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Jameson Quave" scheme="https://swift.gg/categories/Jameson-Quave/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>升级 CMake 使 Swift 的构建过程更加愉悦</title>
    <link href="https://swift.gg/2017/09/20/swift-option-sets/"/>
    <id>https://swift.gg/2017/09/20/swift-option-sets/</id>
    <published>2017-09-20T00:00:00.000Z</published>
    <updated>2018-05-18T10:46:06.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Joe，<a href="http://dev.iachieved.it/iachievedit/upgrading-cmake-for-a-happier-swift-build/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016/06/30<br>译者：<a href="undefined">EyreFree</a>；校对：<a href="http://chengway.in/" target="_blank" rel="noopener">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p><img src="/img/articles/swift-option-sets/swift-og-1.png1512890761.873188" alt=""></p><p>开源 Swift 已经有一些更新来利用新版本的 <a href="https://cmake.org/" target="_blank" rel="noopener">CMake</a> <strong>在 Linux 上构建 Swift</strong>。需要指出的是，Ubuntu 14.04 (2.8.12.2) 自带的默认版 cmake 不再胜任这项工作。</p><p>让我们把 Ubuntu 14.04 的 CMake 升级到 3.4.3，<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160627/002299.html" target="_blank" rel="noopener">开发者表示</a>该版本可以满足需求。</p><p>当通过源代码安装软件时，通常会有一个构建区在 <code>/usr/local/src</code> 和一个存档区（所以可以跟踪我构建的版本）在 <code>/usr/local/archive</code>：</p><p>使用 root 账户或者用 sudo 方式执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd /usr/local/archive</span></span><br><span class="line"><span class="comment"># wget https://cmake.org/files/v3.4/cmake-3.4.3.tar.gz</span></span><br><span class="line"><span class="comment"># cd ../src/</span></span><br><span class="line"><span class="comment"># tar -xzvf ../archive/cmake-3.4.3.tar.gz</span></span><br></pre></td></tr></table></figure><p>接下来，进行配置并且构建：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd cmake-3.4.3</span></span><br><span class="line"><span class="comment"># ./configure --prefix=/usr/local</span></span><br><span class="line">...</span><br><span class="line">CMake has bootstrapped.  Now run make.</span><br><span class="line"><span class="comment"># make</span></span><br></pre></td></tr></table></figure><p>最后，<code>make install</code> 会将 cmake 和它的关联设置安装到 <code>/usr/local</code> 目录下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make install</span></span><br><span class="line"><span class="comment"># which cmake</span></span><br><span class="line"><span class="comment"># cmake --version</span></span><br><span class="line">cmake version 3.4.3</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br></pre></td></tr></table></figure><p>以上就是全部过程。构建愉快！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：Joe，&lt;a href=&quot;http://dev.iachieved.it/iachievedit/upgrading-cmake-for-a-happier-swift-build/&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="iAchieved.it" scheme="https://swift.gg/categories/iAchieved-it/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>从零构建 Dispatch Queue</title>
    <link href="https://swift.gg/2017/09/07/friday-qa-2015-09-04-lets-build-dispatch_queue/"/>
    <id>https://swift.gg/2017/09/07/friday-qa-2015-09-04-lets-build-dispatch_queue/</id>
    <published>2017-09-07T00:00:00.000Z</published>
    <updated>2018-05-18T10:46:06.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-09-04-lets-build-dispatch_queue.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-09-04<br>译者：<a href="http://hulizhen.me" target="_blank" rel="noopener">智多芯</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="noopener">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Grand Central Dispatch 是 Apple 公司最近几年推出的重量级 API 之一。在本次“从零构建”系列文章中，我们将探索一个由 Rob Rix 建议的主题：从零构建一个具备基本功能的 Dispatch Queue。</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>分发队列（Dispatch Queue）是一个保存了多个基于全局线程池的任务（译者注：其实就是一系列的代码块）的队列。提交到队列的任务通常会被放到一个后台线程异步执行。为了使整个系统运作得更高效，所有的线程共享一个后台线程池。</p><p>这就是下面将要实现的 API 核心功能。为了简单起见，本文会略去很多 GCD 提供的额外功能。例如，全局线程池中的线程数量会随着任务总量和系统的 CPU 使用率进行动态调整。在已有一堆耗 CPU 的任务在运行的情形下，如果此时再提交一个任务，GCD 不会再为该任务创建新的线程。因为此时 CPU 已经满负荷运行了，再创建新的线程只会导致系统更低效。下面我会直接将线程数量硬编码在代码中。同样，其他的额外功能，如目标队列和并行队列屏障，也会一并略过。</p><p>本文会把重点放在实现分发队列的核心功能上：基于一个共享的全局线程池实现串行/并行及同步/异步派发任务。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>和往常一样，本文中的代码可在 GitHub 上获取：</p><p><a href="https://github.com/mikeash/MADispatchQueue" target="_blank" rel="noopener">https://github.com/mikeash/MADispatchQueue</a></p><p>可以边读本文边敲代码，也可以自己探索。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>GCD 提供的是一系列的 C 语言 API。虽然在最近发布的 OS 上 Apple 已经将 GCD 对象转成了 Objective-C 对象，但 API 还是保持着纯 C 语言接口（还新增了对 Block 支持）。这对底层 API 来说其实是好事，提供的接口也十分简洁。但本文将采用 Objective-C 语言来实现。</p><p>本文实现的 Objective-C 类叫做 <code>MADispatchQueue</code>，它只提供了四个方法：</p><ol><li>一个获取共享的全局队列的方法。GCD 有多个不同优先级的全局队列，但为了简单起见，我们只有一个全局队列。</li><li>一个构造器，可通过它创建并行或串行队列。</li><li>一个异步派发方法。</li><li>一个同步派发方法。</li></ol><p>接口的声明如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MADispatchQueue : NSObject</span><br><span class="line"></span><br><span class="line">+ (MADispatchQueue *)globalQueue;</span><br><span class="line"></span><br><span class="line">- (id)initSerial: (BOOL)serial;</span><br><span class="line"></span><br><span class="line">- (void)dispatchAsync: (dispatch_block_t)block;</span><br><span class="line">- (void)dispatchSync: (dispatch_block_t)block;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>本文的目标就是实现这些方法的功能。</p><h3 id="线程池接口"><a href="#线程池接口" class="headerlink" title="线程池接口"></a>线程池接口</h3><p>用来支撑分发队列的线程池有着相对简洁的接口，该线程池负责执行被提交的作业。分发队列负责在合适的时机将已入队的作业提交到线程池。</p><p>线程池只有一个简单的任务：提交作业并执行。因此，它就只有一个方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MAThreadPool : NSObject</span><br><span class="line"></span><br><span class="line">- (void)addBlock: (dispatch_block_t)block;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>因为这是整个线程池的核心，所以接下来先把它实现了。</p><h3 id="线程池实现"><a href="#线程池实现" class="headerlink" title="线程池实现"></a>线程池实现</h3><p>首先看下实例变量。线程池可能会被外部或内部的多个线程同时访问，因此必须保证其线程安全。虽然 GCD 尽可能地使用了快速原子操作以保证线程安全，但本文还是采用古老的锁方案。除了保证读写操作互斥外，该锁还要支持 <code>wait</code> 和 <code>signal</code> 操作，因此使用了 <code>NSCondition</code>，而不是原生的 <code>NSLock</code>。如果你不熟悉 <code>NSCondition</code> 也没关系，实际上它只是把锁和一个条件变量封装在一起而已：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSCondition *_lock;</span><br></pre></td></tr></table></figure><p>为了确定何时启动新的线程，需要知道当前线程池中有多少线程，有多少线程正在运行，线程池最多支持多少线程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSUInteger _threadCount;</span><br><span class="line">NSUInteger _activeThreadCount;</span><br><span class="line">NSUInteger _threadCountLimit;</span><br></pre></td></tr></table></figure><p>最后是一个保存了多个代码块的数组。这里使用了 <code>NSMutableArray</code> 来实现队列，通过追加新的代码块到末尾来实现入队操作，通过删除开头的代码块来实现出队操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *_blocks;</span><br></pre></td></tr></table></figure><p>初始化方法很简单，只是初始化锁、代码块数组，最后将线程数的最大值设置成 123（随机选择的数目）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    if((self = [super init])) &#123;</span><br><span class="line">        _lock = [[NSCondition alloc] init];</span><br><span class="line">        _blocks = [[NSMutableArray alloc] init];</span><br><span class="line">        _threadCountLimit = 128;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程中主要是一个无限循环。当代码块数组为空时，线程进入休眠并等待。一旦数组不为空，该代码块立即出队并开始执行。代码块执行开始后，当前活跃线程数加一；代码块执行完成后，当前活跃线程数减一：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)workerThreadLoop: (id)ignore &#123;</span><br></pre></td></tr></table></figure><p>在进入循环之前先加锁，至于为什么这么做，请继续往下看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock lock];</span><br></pre></td></tr></table></figure><p>接着进入无限循环：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (1) &#123;</span><br></pre></td></tr></table></figure><p>如果队列为空，则等待：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while ([_blocks count] == 0) &#123;</span><br><span class="line">   [_lock wait];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的是，上面代码是在一个循环中，而不仅仅只是一个 <code>if</code> 语句。这么做是因为<a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">假性唤醒</a>。简单地说，即使没有发送<code>signal</code>信号，<code>wait</code> 也可能提前返回。为了让代码产生预期的行为，<code>wait</code> 返回时每次都要检查代码块的数量。</p><p>一旦有了可用代码块，立即出队：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_block_t block = [_blocks firstObject];</span><br><span class="line">[_blocks removeObjectAtIndex: 0];</span><br></pre></td></tr></table></figure><p>将当前活跃线程数加一，表明当前线程正忙：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_activeThreadCount++;</span><br></pre></td></tr></table></figure><p>现在是时候开始执行代码块了。但在此之前需要先解锁，否则就无法并发执行代码，并且所有试图对该锁加锁的线程都会导致死锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock unlock];</span><br></pre></td></tr></table></figure><p>安全地解锁并立即执行代码块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block();</span><br></pre></td></tr></table></figure><p>当该代码块执行完后，将当前活跃线程数减一。在这样做之前需要先加锁以避免竞争条件。到这里循环也就结束了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        [_lock lock];</span><br><span class="line">        _activeThreadCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在应该明白为什么进入上面这个循环之前先加锁了。循环中的最后一步是将当前活跃线程数减一，进入循环的第一步是检查队列中的代码块数量，而这两个操作都需要先加锁。通过在循环外加锁，后续的迭代只需要加一次锁即可。而不需要加锁、解锁，又马上加锁。</p><p>现在来看看 <code>addBlock</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addBlock: (dispatch_block_t)block &#123;</span><br></pre></td></tr></table></figure><p>这个方法中的所有操作都需要加锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock lock];</span><br></pre></td></tr></table></figure><p>第一件事就是将传入的代码块添加到队列中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_blocks addObject: block];</span><br></pre></td></tr></table></figure><p>如果目前有空闲的工作线程可以执行该代码块，那么就没什么需要做的了。如果没有空闲线程去处理这个还未被执行的代码块，并且工作线程总数还没超出限制，那就新建一个线程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSUInteger idleThreads = _threadCount - _activeThreadCount;</span><br><span class="line">   if([_blocks count] &gt; idleThreads &amp;&amp; _threadCount &lt; _threadCountLimit) &#123;</span><br><span class="line">   [NSThread detachNewThreadSelector: @selector(workerThreadLoop:)</span><br><span class="line">                                toTarget: self</span><br><span class="line">                              withObject: nil];</span><br><span class="line">       _threadCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>现在有了空闲的工作线程可以执行代码块了。但 <code>workerThreadLoop</code> 中的循环可能由于 <code>wait</code> 操作而处于休眠状态，因此执行一下 <code>signal</code> 操作唤醒它：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock signal];</span><br></pre></td></tr></table></figure><p>最后解锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面实现的线程池能够创建预定数目的工作线程以便执行新入队的代码块。接下来就利用这个线程池去实现分发队列 <code>Dispatch Queue</code>。</p><h3 id="分发队列的实现"><a href="#分发队列的实现" class="headerlink" title="分发队列的实现"></a>分发队列的实现</h3><p>和线程池相同的是，分发队列同样需要一个锁。而不同的是，它并不需要 <code>wait</code> 和 <code>signal</code>操作，只需要最基本的互斥锁 <code>NSLock</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLock *_lock;</span><br></pre></td></tr></table></figure><p>类似线程池，分发队列使用 <code>NSMutableArray</code> 维护了一个队列用于保存还未被执行的代码块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *_pendingBlocks;</span><br></pre></td></tr></table></figure><p><code>Dispatch Queue</code> 需要知道自己是串行还是并行队列。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL _serial;</span><br></pre></td></tr></table></figure><p>如果是串行队列，它还需要跟踪线程池中是否有代码块正在执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL _serialRunning;</span><br></pre></td></tr></table></figure><p>并行队列则不管是否有代码块正在运行都不影响，因此不需要跟踪该状态。</p><p>和共享的线程池一样，将全局队列保存在一个全局变量中，二者都在 <code>+initialize</code> 方法中创建：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static MADispatchQueue *gGlobalQueue;</span><br><span class="line">static MAThreadPool *gThreadPool;</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    if(self == [MADispatchQueue class]) &#123;</span><br><span class="line">        gGlobalQueue = [[MADispatchQueue alloc] initSerial: NO];</span><br><span class="line">        gThreadPool = [[MAThreadPool alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>+initialize</code> 方法已经确保了全局队列会被创建，因此 <code>+globalQueue</code> 方法可直接返回 <code>gGlobalQueue</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (MADispatchQueue *)globalQueue &#123;</span><br><span class="line">    return gGlobalQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里本来是可以直接用 <code>dispatch_once</code> 方法的，但这么做会有种使用了 GCD API 来作弊的感觉，说好的要从零构建的，虽然这并不是我们要实现的 API。</p><p>初始化方法包括分配锁、创建代码块队列（译者注：还未被执行的代码块），还要设置 <code>_serial</code> 变量：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)initSerial: (BOOL)serial &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _lock = [[NSLock alloc] init];</span><br><span class="line">        _pendingBlocks = [[NSMutableArray alloc] init];</span><br><span class="line">        _serial = serial;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在讲其余的公开 API 之前，还有一个底层方法需要实现。这个方法会在线程池中将 <code>_pendingBlocks</code> 队列中的一个代码块取出并执行，接着还很有可能（串行队列的情况下）会调用自身在线程池中执行另一个代码块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)dispatchOneBlock &#123;</span><br></pre></td></tr></table></figure><p>该方法唯一的职责就是在线程池中执行代码块，所以把自身的功能代码块添加到线程池中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[gThreadPool addBlock: ^&#123;</span><br></pre></td></tr></table></figure><p>接着从队列中取出队列头部的代码块。当然了，这个操作也需要加锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock lock];</span><br><span class="line">      dispatch_block_t block = [_pendingBlocks firstObject];</span><br><span class="line">      [_pendingBlocks removeObjectAtIndex: 0];</span><br><span class="line">      [_lock unlock];</span><br></pre></td></tr></table></figure><p>在解锁后，上面取出的代码块就可以安全地在后台线程执行（译者注：在前文线程池的实现中可以看出，每个添加到线程池中的代码块都会在独立的后台线程中执行）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block();</span><br></pre></td></tr></table></figure><p>如果队列是并行的，那么到这里就结束了。如果是串行的话，还需要下面的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(_serial) &#123;</span><br></pre></td></tr></table></figure><p>在串行队列上，新增的代码块需要等到前一个代码块执行完后才能执行。每当一个代码块执行完后，<code>dispatchOneBlock</code> 会检查当前队列是否还有代码块未执行。如果有的话，它会调用自身以便最后可以执行到该代码块。如果没有，将队列的运行状态设置回 <code>NO</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            [_lock lock];</span><br><span class="line">            if([_pendingBlocks count] &gt; 0) &#123;</span><br><span class="line">                [self dispatchOneBlock];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                _serialRunning = NO;</span><br><span class="line">            &#125;</span><br><span class="line">            [_lock unlock];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面这个方法之后，实现 <code>dispatchAsync</code> 就相对简单了。将代码块添加到队列中，然后根据情况（是否为串行队列）设置队列的运行状态并调用 <code>dispatchOneBlock</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)dispatchAsync: (dispatch_block_t)block &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    [_pendingBlocks addObject: block];</span><br></pre></td></tr></table></figure><p>如果是串行队列且当前空闲，就将队列运行状态设置为 <code>YES</code> 并调用 <code>dispatchOneBlock</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(_serial &amp;&amp; !_serialRunning) &#123;</span><br><span class="line">    _serialRunning = YES;</span><br><span class="line">    [self dispatchOneBlock];</span><br></pre></td></tr></table></figure><p>如果是并行队列，就无条件直接执行。这样保证了即使其他代码块正在执行，新增的代码块也能尽快执行，毕竟并行队列是允许多个代码块同时运行的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125; else if (!_serial) &#123;</span><br><span class="line">       [self dispatchOneBlock];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果串行队列已经在执行代码块了，就没什么需要做的了，已经在执行的 <code>dispatchOneBlock</code>最后会执行到新增的代码块的。最后解锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来轮到 <code>dispatchSync</code> 了。与 GCD 的实现不同，本文直接使用 <code>dispatchAsync</code> 派发代码块，并等到代码执行完后再返回（译者注：这就是同步的效果）。</p><p>为了实现这个目的，这里使用到了一个本地条件变量 <code>NSCondition</code>，还有一个 <code>done</code> 变量用于表示代码块是否执行完毕：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)dispatchSync: (dispatch_block_t)block &#123;</span><br><span class="line">   NSCondition *condition = [[NSCondition alloc] init];</span><br><span class="line">   __block BOOL done = NO;</span><br></pre></td></tr></table></figure><p>接着异步派发代码块。这里执行了通过函数参数传进来的代码块，然后设置 <code>done</code> 为 <code>YES</code>并唤醒 <code>condition</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self dispatchAsync: ^&#123;</span><br><span class="line">    block();</span><br><span class="line">    [condition lock];</span><br><span class="line">    done = YES;</span><br><span class="line">    [condition signal];</span><br><span class="line">    [condition unlock];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>在条件变量 <code>condition</code> 上等待 <code>done</code> 被设置成 <code>YES</code>，然后返回：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    [condition lock];</span><br><span class="line">    while (!done) &#123;</span><br><span class="line">        [condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    [condition unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就成功地运行了代码块，这也是 <code>MADispatchQueue</code> 所需要的最后一个 API 。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>可以通过一个保存代码块的队列和动态创建和销毁线程的方法来实现一个全局的线程池。通过使用一个共享的全局线程池，可以构建基本的 <code>Dispatch Queue</code> API，支持串行/并行及同步/异步派发任务。本文的实现少了许多 GCD 中很赞的功能，而且也确实比 GCD 低效得多。但即便如此，本文还是可以让你窥视到 GCD 内部的运作原理，让你明白这其实也不是什么神奇的事。（除了 <code>dispatch_once</code>，着简直就是个魔法。）</p><p>这就是今天所有的内容了，记得不要错过下一次更多有趣的内容哦。另外，周五的 Q&amp;A 是由读者驱动的，所以如果你有什么想在这里讨论的，给我<a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发个邮件</a>吧！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-09-04-lets-build-dispatch_queue.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2015-09-04&lt;br&gt;译者：&lt;a href=&quot;http://hulizhen.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;智多芯&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Grand Central Dispatch 是 Apple 公司最近几年推出的重量级 API 之一。在本次“从零构建”系列文章中，我们将探索一个由 Rob Rix 建议的主题：从零构建一个具备基本功能的 Dispatch Queue。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>如何用 UIKit Dynamics 进行碰撞检测</title>
    <link href="https://swift.gg/2017/09/06/collision-detection-uikit-dynamics-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/09/06/collision-detection-uikit-dynamics-ios-tutorial-ios10/</id>
    <published>2017-09-06T00:00:00.000Z</published>
    <updated>2018-05-18T10:46:06.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/collision-detection-uikit-dynamics-ios-tutorial-ios10" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-04-20<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="noopener">Crystal Sun</a>；校对：<a href="http://chengway.in/" target="_blank" rel="noopener">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>用 UIKit Dynamics 可以让指定对象具备碰撞行为。动态的项目能相互碰撞或者和任何指定的边界碰撞。在本节教程中，将学习创建自行一的边界，随机地让一些方块下落到边界上。本节教程使用的是 Xcode 8.3 和 iOS 10.3。</p><a id="more"></a><h3 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h3><p>打开 Xcode，创建一个 Single View Application 工程。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/single-view-xcode-templateformat=1500w1504677793.38" alt=""></p><p>Product Name 使用 <strong>IOS10CollisionDectectionTutorial</strong>（译者注：这里的 Dectection 估计是错别字，应该是 Detection），填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/line-view-uiviewformat=1500w1504677799.47" alt=""></p><p>用自定义的 UIView 画一些线，在 drawRect 方法中写点代码。选择 File -&gt; New File -&gt; iOS -&gt; Source -&gt; Cocoa Touch Class。Class 命名为 LineView，其父类为 UIView。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/line-view-uiviewformat=1500w1504677799.47" alt=""></p><p>打开 <strong>LineView.swift</strong> 文件，想要画线需要先创建一个帮手：<strong>drawLineFromPoint(fromX:toPoint:pointY:)</strong> 方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">drawLineFromPoint</span><span class="params">(fromX: CGFloat, toPoint toX: CGFloat, pointY y: CGFloat)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentContext = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> currentContext = currentContext &#123;</span><br><span class="line">        currentContext.setLineWidth(<span class="number">5.0</span>)</span><br><span class="line">        currentContext.move(to: <span class="type">CGPoint</span>(x: fromX, y: y))</span><br><span class="line">        currentContext.addLine(to: <span class="type">CGPoint</span>(x: toX, y: y))</span><br><span class="line">        currentContext.strokePath();</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>线的宽度为 5 points。接下来，改写 <strong>drawRect</strong> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    drawLineFromPoint(fromX: <span class="number">0</span>, toPoint: bounds.size.width/<span class="number">3</span>, pointY: bounds.size.height - <span class="number">100.0</span>)</span><br><span class="line">    drawLineFromPoint(fromX: bounds.size.width/<span class="number">3</span>, toPoint:bounds.size.width*<span class="number">0.67</span>, pointY:bounds.size.height - <span class="number">150.0</span>)</span><br><span class="line">    drawLineFromPoint(fromX: bounds.size.width*<span class="number">0.67</span>, toPoint:bounds.size.width, pointY:bounds.size.height - <span class="number">100.0</span>)&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/custom-class-identity-inspectorformat=500w1504677802.86" alt=""></p><p><strong>运行</strong>工程，线已经出现在屏幕上了。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/format=750w1504677808.44" alt=""></p><p>接下来，拖拽一个 Button 控件到 Storyboard 上，标题改为 “Next”。选中该 Button，点击 Auto Layout 的 Align 按钮，勾选 “Horizontally in Container”，点击 “Add 1 Constraint”。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/auto-layout-horizontally-in-containerformat=750w1504677809.87" alt=""></p><p>继续选中该 Button，点击 Auto Layout 的 Pin 按钮，选中上边距的约束线，点击 “Add 1 Constraint”。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/button-pin-to-topformat=750w1504677818.01" alt=""></p><p>主界面看起来应如下图所示：</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/collision-detection-storyboardformat=750w1504677819.34" alt=""></p><p>点击 Assistant Editor，确保 ViewController.swift 文件可见，按住 Control 键将该 Button 拖拽到 ViewController 类里，创建下列 Action 链接：</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/release%3Dsquare-actionformat=750w1504677820.03" alt=""></p><p>在 <strong>ViewController.swift</strong> 文件中，需要声明一些变量，来跟踪记录 view，如下所示：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> squareViews:[<span class="type">UIView</span>] = []</span><br><span class="line"><span class="keyword">var</span> animator:<span class="type">UIDynamicAnimator</span>!</span><br><span class="line"><span class="keyword">var</span> colors:[<span class="type">UIColor</span>] = []</span><br><span class="line"><span class="keyword">var</span> centerPoint:[<span class="type">CGPoint</span>] = []</span><br><span class="line"><span class="keyword">var</span> sizeOfSquare:<span class="type">CGSize</span>!</span><br></pre></td></tr></table></figure><p>squareViews 将包含所需的 view，view 需要颜色数组、centerPin 数组和 sizeOfSquare（方块的大小）这些属性。animator 属性要用于动画动作。接下来继续添加下列属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> leftBoundaryHeight:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> middleBoundaryHeight:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> rightBoundaryHeight:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> leftBoundaryWidth:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> middleBoundaryWidth:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> leftSquareCenterPointX:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> middleSquareCenterPointX:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> rightSquareCenterPointX:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> squareCenterPointY:<span class="type">CGFloat</span>!</span><br></pre></td></tr></table></figure><p>需要上述属性来设置自定义的边界，给所有的方块添加一个起始点。首先，创建 setBoundaryValues 方法来设置上述属性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setBoundaryValues</span><span class="params">()</span></span> &#123;</span><br><span class="line">    leftBoundaryHeight = view.bounds.size.height - <span class="number">100.0</span></span><br><span class="line">    middleBoundaryHeight = view.bounds.size.height - <span class="number">150.0</span></span><br><span class="line">    rightBoundaryHeight = view.bounds.size.height - <span class="number">100.0</span></span><br><span class="line">    leftBoundaryWidth = view.bounds.size.width/<span class="number">3</span></span><br><span class="line">    middleBoundaryWidth = view.bounds.size.width * <span class="number">0.67</span></span><br><span class="line">    leftSquareCenterPointX = view.bounds.size.width/<span class="number">6</span></span><br><span class="line">    middleSquareCenterPointX = view.bounds.size.width/<span class="number">2</span></span><br><span class="line">    rightSquareCenterPointX = view.bounds.size.width * <span class="number">0.84</span></span><br><span class="line">    squareCenterPointY = view.bounds.size.height - <span class="number">400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>viewDidLoad</strong> 里，调用上述方法。然后设置剩下的属性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">    setBoundaryValues()</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 创建颜色数组</span></span><br><span class="line">    colors = [<span class="type">UIColor</span>.red, <span class="type">UIColor</span>.blue, <span class="type">UIColor</span>.green, <span class="type">UIColor</span>.purple, <span class="type">UIColor</span>.gray]</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 创建方块的中心点（centerpoint）</span></span><br><span class="line">    <span class="keyword">let</span> leftCenterPoint = <span class="type">CGPoint</span>(x: leftSquareCenterPointX, y: squareCenterPointY)</span><br><span class="line">    <span class="keyword">let</span> middleCenterPoint = <span class="type">CGPoint</span>(x: middleSquareCenterPointX, y: squareCenterPointY)</span><br><span class="line">    <span class="keyword">let</span> rightCenterPoint = <span class="type">CGPoint</span>(x:rightSquareCenterPointX, y: squareCenterPointY)</span><br><span class="line">    centerPoint = [leftCenterPoint,middleCenterPoint,rightCenterPoint]</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 设置方块的大小</span></span><br><span class="line">    sizeOfSquare = <span class="type">CGSize</span>(width: <span class="number">50.0</span>, height: <span class="number">50.0</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在每个 view 的尺寸是 50，有 5 种不同的颜色。接下来的事情都会在 <strong>releaseNextSquare(sender:)</strong> 方法中发生。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">releaseSquare</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newView = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>, width: sizeOfSquare.width, height: sizeOfSquare.height))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> randomColorIndex = <span class="type">Int</span>(arc4random()%<span class="number">5</span>)</span><br><span class="line">    newView.backgroundColor = colors[randomColorIndex]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> randomCenterPoint = <span class="type">Int</span>(arc4random()%<span class="number">3</span>)</span><br><span class="line">    newView.center = centerPoint[randomCenterPoint]</span><br><span class="line">        </span><br><span class="line">    squareViews.append(newView)</span><br><span class="line">    view.addSubview(newView)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了 view，centerPoint 的值是随机数，也赋值了颜色，该 view 被添加到了主界面上，也被添加到了数组中。在 <strong>releaseSquare(sender:)</strong> Action 方法的最后，添加剩下的代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">animator = <span class="type">UIDynamicAnimator</span>(referenceView: view)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建重力</span></span><br><span class="line"><span class="keyword">let</span> gravity = <span class="type">UIGravityBehavior</span>(items: squareViews)</span><br><span class="line">animator.addBehavior(gravity)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建碰撞检测</span></span><br><span class="line"><span class="keyword">let</span> collision = <span class="type">UICollisionBehavior</span>(items: squareViews)</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 设置碰撞的边界</span></span><br><span class="line">collision.addBoundary(withIdentifier: <span class="string">"leftBoundary"</span> <span class="keyword">as</span> <span class="type">NSCopying</span>, from: <span class="type">CGPoint</span>(x: <span class="number">0.0</span>,y: leftBoundaryHeight), to: <span class="type">CGPoint</span>(x: leftBoundaryWidth, y: leftBoundaryHeight))</span><br><span class="line">collision.addBoundary(withIdentifier: <span class="string">"middleBoundary"</span> <span class="keyword">as</span> <span class="type">NSCopying</span>, from: <span class="type">CGPoint</span>(x: view.bounds.size.width/<span class="number">3</span>,y: middleBoundaryHeight), to: <span class="type">CGPoint</span>(x: middleBoundaryWidth, y: middleBoundaryHeight))</span><br><span class="line">collision.addBoundary(withIdentifier: <span class="string">"rightBoundary"</span> <span class="keyword">as</span> <span class="type">NSCopying</span>, from: <span class="type">CGPoint</span>(x: middleBoundaryWidth,y: rightBoundaryHeight), to: <span class="type">CGPoint</span>(x: view.bounds.size.width, y: rightBoundaryHeight))</span><br><span class="line">        </span><br><span class="line">collision.collisionMode = .everything</span><br><span class="line">animator.addBehavior(collision)</span><br></pre></td></tr></table></figure><p>首先，给方块下落的动作增加了重力，接下来，在自定义边界的基础上添加了碰撞行为。默认的碰撞模式是 UICollisionBehaviour 里的 UICollisionBehaviourMode.everything，也就是说，所有的元素都可以互相碰撞。<strong>运行</strong>工程，不停地按 Next 按钮，方块下落。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/collision-detection-simulatorformat=750w1504677820.83" alt=""></p><p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="noopener">github</a> 上下载 <strong>IOS10CollisionDectectionTutorial</strong> 教程的源代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Arthur Knopper，&lt;a href=&quot;https://www.ioscreator.com/tutorials/collision-detection-uikit-dynamics-ios-tutorial-ios10&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-04-20&lt;br&gt;译者：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Crystal Sun&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;用 UIKit Dynamics 可以让指定对象具备碰撞行为。动态的项目能相互碰撞或者和任何指定的边界碰撞。在本节教程中，将学习创建自行一的边界，随机地让一些方块下落到边界上。本节教程使用的是 Xcode 8.3 和 iOS 10.3。&lt;/p&gt;
    
    </summary>
    
      <category term="IOSCREATOR" scheme="https://swift.gg/categories/IOSCREATOR/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的并发编程(第一部分：现状）</title>
    <link href="https://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/"/>
    <id>https://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/</id>
    <published>2017-09-04T00:00:00.000Z</published>
    <updated>2018-05-18T10:46:06.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Umberto Raimondi，<a href="https://www.uraimo.com/2017/05/07/all-about-concurrency-in-swift-1-the-present/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-05-07<br>译者：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a>；校对：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>当前最新版本的 Swift 语言（译者注：当前最新稳定版本为 3.1.1）还没有包含任何原生并发特性，但是在其他现代编程语言中是带有这个特性的，比如 Go 和 Rust。<br>如果你想并发地执行任务，这时就需要处理与结果相关的竞态条件，目前唯一的选择就是使用第三方库，比如 libDispatch，或者 Foundation 和其他 OS 中提供的同步原语。<br>在这一系列文章的第一部分，看看 Swift 3 给出的处理方案，覆盖以下一些内容：Foundation 中的锁，线程和计时器提供语言层面的保证，最近不断增强的 GCD(Grand Central Dispatch) 和操作队列（Operation Queues）。</p><p>同时也会讨论到基础的并发原理和一些通用的并发模式。</p><a id="more"></a><p>原文链接：<a href="https://www.uraimo.com/2017/05/07/all-about-concurrency-in-swift-1-the-present/" target="_blank" rel="noopener">All about Concurrency in Swift - Part 1: The Present</a></p><p><img src="/img/articles/all-about-concurrency-in-swift-1-the-present/concurr.png1504576909.77" alt=""></p><p>虽然在那些可以运行 Swift 的平台上，都可以使用 pthread 库来处理并发（译者注：pthread 库是跨平台的），但是在这里，不会讨论 pthread 库相关的函数和原语，对于这些底层一些库函数来说，有更高阶的替代者。NSTimer 类也不会在这里讨论，请查阅<a href="https://www.uraimo.com/swiftbites/nstimer-in-swift-3/" target="_blank" rel="noopener">这篇文章</a>，告诉你如何在 Swift 3中使用它。</p><p>正如已经被多次提到的一样，在 Swift 4.0 发布后的某个版本（应该不需要等到 Swift 5），Swift 语言将会定义一个牛逼的内存模型，包含支持原生并发特性，用于处理并发，和并行一样，不需要引入外部库，使用 Swift 的方式来处理并发。</p><p>在下一篇系列文章中，将会讨论其他语言中使用的一些替代方式和范式实现并发，并且探讨如何在 Swift 中实现它们，然后分析一些已经存在的开源实现，<br>并且使用了当前发布版本的 Swift  编写 Actors 模式，CSP 通道（Go 语言），STM（Software Transactional Memory）等并发实现。<br>在当前的 Swift 正式版本中允许使用行动者范式，Go 语言的 CSP 频道，软件事务内存。</p><p>在第二篇文章中，将会彻底预测下，主要预测方式，是把这些涉及的对象的情况做个介绍，这样可以让你可以身临其境，明白将会在未来的 Swift 版本如何定义处理并发。</p><blockquote><p>此文章和本博客相关文章代码可以从 <a href="https://github.com/uraimo/Swift-Playgrounds" target="_blank" rel="noopener">GitHub</a>和 <a href="https://www.uraimo.com/archives/2017-05-07-ConcurrencyInSwift.playground.zip" target="_blank" rel="noopener">Zipped</a>上下载。</p></blockquote><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#multithreading_and_concurrency_primer">多线程和并发启蒙</a></li><li><a href="#language_guarantees">语言支持</a></li><li><a href="#threads">线程类</a></li><li><p><a href="#synchronization_primitives">同步原语</a></p><ul><li><a href="#nslock">NSLock</a></li><li><a href="#nsrecursivelock">NSRecursiveLock</a></li><li><a href="#nsconditionlock">NSConditionLock</a></li><li><a href="#nscondition">NSCondition</a></li><li><a href="#nsdistributedlock">NSDistributedLock</a></li><li><a href="#osatomic_where_art_thou">OSAtomic 还能用吗？</a></li><li><a href="#on_synchronized_blocks">同步代码块</a></li></ul></li><li><p><a href="#grand_central_dispatch">GCD：Grand Central Dispatch</a></p><ul><li><a href="#dispatch_queues">调度队列</a></li><li><a href="#using_quenes">使用队列</a></li><li><a href="#barriers">屏障</a></li><li><a href="#singletons_and_dispatch_once">单例和 Dispatch_once</a></li><li><a href="#dispatch_groups">调度组</a></li><li><a href="#dispatch_work_items">调度工作项</a></li><li><a href="#dispatch_semaphores">调度信号量</a></li><li><a href="#dispatch_assertions">调度断言</a></li><li><a href="#dispatch_sources">调度资源</a></li></ul></li><li><p><a href="#operations_and_operationqueues">操作和操作队列</a></p></li><li><a href="#closing_thoughts">后记</a></li></ul><p><a name="multithreading_and_concurrency_primer"></a></p><h2 id="多线程和并发启蒙"><a href="#多线程和并发启蒙" class="headerlink" title="多线程和并发启蒙"></a>多线程和并发启蒙</h2><p>现如今，无论大家编写何种类型的应用，迟早大家会发现一个事实，应用都会运行在一个多线程的执行环境下面。</p><p>使用多处理器或者拥有多个硬件执行核心处理器的计算平台已经出现了几个时代了，并且像 <em>线程</em> 和 <em>进程</em> 等概念出现的甚至更早。</p><p>操作系统通过使用各种程序来利用硬件的能力，而应用或每一个现代的框架都在实现一些大家熟知的设计模式，用到了多线程来增强自身的灵活性和性能。</p><p>在我们开始深入讨论如何使用 Swift 处理多线程之前，先来解释一些需要了解的基本概念，这样才能考虑应该使用调度队列（<code>Dispatch Queues</code>）或者操作队列（<code>Operation Queues</code>）。<br>首先，你可能会问，苹果平台和框架已经使用了线程，为啥还需要在应用中单独介绍它们呢？<br>有少量通用的场景下，让使用多线程变得容易理解：</p><p><strong>任务组隔离</strong>：线程可以从执行流程角度模块化应用，不同线程用可预测的方式执行同类的一组任务，隔离应用中其他执行流程，这样对应用当前的状态更加可控。</p><p><strong>数据独立并行计算</strong>：多个软件线程，无论是基于硬件线程还是不基于软件线程(见下一个要点)，都通过并行处理同一个任务的多个拷贝，这个任务作用于原始输入数据结构的其中某个子集。</p><p><strong>更加清晰的方式等待竞争或I/O</strong>：使用阻塞 I/O 或执行某种类型的阻塞操作时，后台线程会等待这些操作的完成。使用线程，可以增强应用的设计，并且让处理阻塞的调用更加常见。</p><p>但是在执行多线程代码时，从一个线程的角度去看代码会不再有效，需要做一些有意义的假设。</p><p>理想情况下，每一个执行线程都相互独立，没有共享数据，这样并发编程没想象中复杂，编写的代码将会在一个独立的线程中执行。但在大多数情况下，会使用多个线程操作相同的数据，需要找到一种管控访问这些数据的方式，保证每一个对数据的操作都符合预期，不被其他线程操作造成不可预期行为。</p><p>并发编程需要编程语言和操作系统额外的保证，当多线程尝试同时改变变量（更多时候被称作”资源”）的值时候，需要一个显式状态信息来提供作用。</p><p>编程语言需要定义一个<em>内存模型</em>，在多线程存在的情况下，定义显式状态一些规则，指定这些基础状态在并发线程中如何运作，定义内存如何进行共享，以及指定那种方式的内存访问是有效的。</p><p>正因为如此，开发者对于每种语言中线程行为都有一个基本认知，只需要了解每种语言的编译器是如何在这个线程内存模型下去优化性能。</p><p>定义一个内存模型也是语言演化中一个重要的步骤，一个严格的模型将会限制编译器的演化。以前在内存模型的设计有可能会让新的优化搁浅。</p><p>定义内存模型的一些考虑点：</p><ul><li><p>语言表达式是否为<em>原子性</em>，在没有其他线程可以看到的情况下，操作将被整体执行。更有意义的场景是，一个变量是否被原子化操作。</p></li><li><p>多线程如何处理共享变量，变量被缓存是否是默认的，还有就是这个缓存行为是否受到特定的语言标识符所影响。</p></li><li><p>并发操作符通常被用作标记和管控共享资源的<em>临界区</em>和区域中的代码，允许有且只有一个线程同时执行指定的代码。</p></li></ul><p>接下来言归正传讨论如何在程序中使用并发。</p><p>正确处理并发的方式是，识别程序中的<em>临界区</em>，使用并发原语或者并发相关数据结构，来管控不同线程中的共享数据。</p><p>临界区中代码和数据结果的强制访问规则会带来一系列的其它问题，这些问题来源于一个事实，每一个将要执行的线程都期望得到自己想要的结果，都有机会修改共享数据，在某些情况下，这些线程中的一些线程永远不会执行，数据的修改也可能不按预期进行。</p><p>并发编程将面临一些额外的挑战，不得不去处理一些共同的问题：</p><ul><li><p><strong>竞争条件</strong>：当多线程操作同样的数据时，读和写数据同时进行，这一系列执行操作结果在不同的线程操作顺序下，变得不可预测。</p></li><li><p><strong>资源冲突</strong>：多线程会执行多个任务，需要安全的访问相同的资源时，将会增加额外的时间，这些延迟获取资源的时间，可能会导致不可预期的行为或者使得应用程序处理这些资源的数据结构变得复杂。</p></li><li><p><strong>死锁</strong>：多线程互相等待需要资源或锁的释放，然后永远阻塞这些线程的执行。</p></li><li><p><strong>饥饿</strong>：一个线程无法获取资源或者一个特定排序的资源，需要各种条件获取资源或者尝试获取资源永远失败。</p></li><li><p><strong>优先级反转</strong>：低优先级线程可能不断持有资源，需要这个资源的高优先级线程可能被其他不需要此资源的低优先级线程反转。</p></li><li><p>不可预期和公平：不能假设在什么时候或者什么顺序下，一个线程能获取到线程资源，延迟时间<a href="https://en.wikipedia.org/wiki/Unbounded_nondeterminism" target="_blank" rel="noopener">不会被优先级所决定</a>，但是会被冲突的数量所影响。一个线程不可能独立获得资源。但是并发原语用来保证临界区是<em>公平的</em>，或者说，为了<em>公平</em>，所有线程等待访问临界区的顺序都是依据等待顺序而来。</p></li></ul><p><a name="language_guarantees"></a></p><h2 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h2><p>虽然当前 Swift 还没有提供原生的并发编程特性，但它仍然提供了属性访问的多线程保证。</p><p>举个例子，全局变量就是被原子性的初始化的，不需要担心多线程情况下对同一变量的初始化操作，也不需要担心会看到一个初始化还在进行当中的部分初始化变量。</p><p>以上行为在下面实现单例模式的时候会看到。</p><p>但是需要重点注意的是，延迟属性初始化没有保证原子性，目前 Swift 语言没有提供注释或者修饰符来修改这种行为。</p><p>访问类变量同样没有保证原子性，如果想保证原子性，那么就需要提供额外的锁或者类似的机制来保证。</p><p><a name="threads"></a></p><h2 id="线程类"><a href="#线程类" class="headerlink" title="线程类"></a>线程类</h2><p><code>Foudation</code> 库提供了一个 <code>Thread</code> 类，内部继承自 <code>pthread</code>，可以用来创建线程和执行闭包。</p><p>使用 <code>Thread</code> 类的 <code>detachNewThreadSelector:toTarget:withObject:</code> 方法创建线程，或者自定义一个线程类，重写其中的 <code>main()</code> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Thread started, sleep for 2 seconds..."</span>)</span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Done sleeping, exiting thread"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 iOS 10 和 macOS Sierra 开始，所有平台都可以使用构造器来创建一个新的线程，运行编写的闭包来指定线程执行。这篇文章所有例子仍然使用扩展基本 Thread 类，所以不需要担心是否是正确的操作系统来运行这些代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="type">Thread</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Started!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.stackSize = <span class="number">1024</span> * <span class="number">16</span></span><br><span class="line">t.start()               <span class="comment">//需要 100us 来生成一个线程</span></span><br></pre></td></tr></table></figure><p>一旦线程实例建立，需要手动的启动它。一个可选的步骤是，可以自定义新线程的栈空间大小。</p><p>可以调用<code>exit()</code>来终止线程，但这不推荐使用，因为这样不能保证当前任务能清理完成，大多数情况下，需要自己编写停止逻辑，或者使用<code>cancel()</code>方法，在主闭包中使用<code>isCancelled</code>属性来判断线程是否需要在自然结束之前终止当前任务。</p><p><a name="synchronization_primitives"></a></p><h2 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h2><p>当有不同的线程同时想修改共享数据时，有必要使用某种方式来处理线程之间的同步问题，阻止数据混乱和不可预期的行为。<br>线程间同步基础的处理手段包括锁，信号量和监视器。<br>Foundation 库提供以上几种方式。</p><p>你会马上看到，在 Swift 3 中，这些类（是的，它们都是引用类型）并没有<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0086-drop-foundation-ns.md#proposed-solution" target="_blank" rel="noopener">马上去掉 NS 前缀</a>，但是在未来的 Swift 版本中会去掉。</p><p><a name="nslock"></a></p><h3 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h3><p><code>NSLock</code> 是 <code>Foundation</code> 提供的最基本的锁类型。</p><p>当一个线程尝试对一个对象进行加锁时，可能会发生两件事情，线程会在这个锁没有被其他线程持有时，获得这个锁，或者线程将阻塞，等到锁的拥有者释放锁。从另外个角度讲，锁只能同时被一个线程所持有，这种机制非常适合作用于临界区的监控访问。</p><p><code>NSLock</code> 和其它的 <code>Foundation</code> 中锁是不公平的，意味着当一些线程想获取锁时，不会按照它们访问锁的顺序来获取锁。</p><p>不能假设一个执行顺序，在一个高度线程冲突的环境中，当有许多线程尝试获取资源是，一些线程有可能会被置为饥饿，永远不能获取它们等待的锁（或者不能及时地获取资源）。</p><p>没有竞争的情况下，获取一个锁需要的时间是 100 纳秒，但是当超过一个线程尝试获取锁资源时，耗费的时间将迅速增长。所以从性能的角度来说，锁不是解决资源分配最好的方式。</p><p>来看看两个线程的例子，记住获取锁的顺序不是注定的，甚至有可能 t1 连续获得两次锁（但是这种情况比较少见）.</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lock = <span class="type">NSLock</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(id:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.id = id</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" acquired lock."</span>)</span><br><span class="line">        lock.unlock()</span><br><span class="line">        <span class="keyword">if</span> lock.<span class="keyword">try</span>() &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" acquired lock again."</span>)</span><br><span class="line">            lock.unlock()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">// If already locked move along.</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" couldn't acquire lock."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" exiting."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = <span class="type">LThread</span>(id:<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> t2 = <span class="type">LThread</span>(id:<span class="number">2</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p>当决定使用锁机制时，需要附加一些警告。迟早会对并发程序进行调试，这种情况下，记得限制对一些需要排序数据结构去使用锁，在代码中尽量不在多个地方直接引用一个锁。</p><p>当调试一个并发问题时，检查有少量入口的同步数据结构的状态，要比随时关注锁在代码中的具体位置，并且需要记住在不同函数中锁状态来讲，要愉快的多。需要额外的工作，使得并发代码的结构更加合理。</p><p><a name="nsrecursivelock"></a></p><h3 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a><code>NSRecursiveLock</code></h3><p>递归锁可以在一个线程已经持有这个锁的情况下，在后面的代码中获取多次，在递归函数和调用多个需要顺序检查同一个锁的函数时，需要用到这种锁。递归锁和基本锁<strong>不能共用</strong>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rlock = <span class="type">NSRecursiveLock</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rlock.lock()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Thread acquired lock"</span>)</span><br><span class="line">        callMe()</span><br><span class="line">        rlock.unlock()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Exiting main"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">callMe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rlock.lock()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Thread acquired lock"</span>)</span><br><span class="line">        rlock.unlock()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Exiting callMe"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tr = <span class="type">RThread</span>()</span><br><span class="line">tr.start()</span><br></pre></td></tr></table></figure><p><a name="nsconditionlock"></a></p><h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><p>条件锁提供了附加的子锁，子锁可以独立地被加锁和被解锁，用来支持复杂的加锁步骤（比如：消费者-提供者场景）。</p><p>同时可以用一个全局锁（不管什么具体的场景都可以加锁），这种锁的行为和经典的 NSLock 一样。</p><p>下面的例子使用一个条件锁来保护共享整型，提供者每次更新整型，消费者都会在终端打印整型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">NO_DATA</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">GOT_DATA</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> clock = <span class="type">NSConditionLock</span>(condition: <span class="type">NO_DATA</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="type">SharedInt</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">            clock.lock(whenCondition: <span class="type">NO_DATA</span>) <span class="comment">//当条件为 NO_DATA 获取该锁</span></span><br><span class="line">  <span class="comment">// 如果不想等待消费者，直接调用 clock.lock() 即可</span></span><br><span class="line">            <span class="type">SharedInt</span> = i</span><br><span class="line">            clock.unlock(withCondition: <span class="type">GOT_DATA</span>) <span class="comment">//解锁并设置条件为 GOT_DATA</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">            clock.lock(whenCondition: <span class="type">GOT_DATA</span>) <span class="comment">// 当条件为 GOT_DATA 获取该锁</span></span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            clock.unlock(withCondition: <span class="type">NO_DATA</span>) <span class="comment">//解锁并设置条件为 NO_DATA</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pt = <span class="type">ProducerThread</span>()</span><br><span class="line"><span class="keyword">let</span> ct = <span class="type">ConsumerThread</span>()</span><br><span class="line">ct.start()</span><br><span class="line">pt.start()</span><br></pre></td></tr></table></figure><p>当创建一个条件锁时，需要使用一个整型指定开始条件。</p><p><code>lock(whenCondition:)</code>方法在条件成立的情况下获得一个锁，或者等待另外一个线程使用<code>unlock(withCondition:)</code>释放锁并且设置这个值。</p><p>条件锁对于基本锁的一些小的改进允许我们建模更加复杂的场景。</p><p><a name="nscondition"></a></p><h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a><code>NSCondition</code></h3><p>不要混淆了 NSCondition 和条件锁，一个条件提供了更加清晰的等待<em>条件</em>产生的方式。</p><p>当一个已经获得锁的线程需要验证额外的条件（一些需要的资源，一个处于特殊状态的对象等），满足条件才能继续运行的时候，需要一种方式挂起然后在条件成立的时候继续工作。</p><p>在没有 NSCondition 的时候，这种情况通常会被实现为连续地或者周期性地检查条件（繁忙的等待），但是这样的话，线程获取的锁将会怎样？当条件成立希望再次获取他们之前，是应该等待还是释放它们呢？</p><p>NSCondition 提供了一个此问题清晰的解决方案，拥有此锁的线程会将此条件加入了<em>等待</em>列表，当条件成立时，通过另外一个线程的信号唤醒此线程。</p><p>下面是一个例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cond = <span class="type">NSCondition</span>()</span><br><span class="line"><span class="keyword">var</span> available = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">SharedString</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriterThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">            cond.lock()</span><br><span class="line">            <span class="type">SharedString</span> = <span class="string">"😅"</span></span><br><span class="line">            available = <span class="literal">true</span></span><br><span class="line">            cond.signal() <span class="comment">// 通知并且唤醒等待的线程</span></span><br><span class="line">            cond.unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrinterThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123; <span class="comment">// 循环 5 次</span></span><br><span class="line">            cond.lock()</span><br><span class="line">            <span class="keyword">while</span>(!available)&#123;   <span class="comment">// 通过伪信号进行保护</span></span><br><span class="line">                cond.wait()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="type">SharedString</span>)</span><br><span class="line">            <span class="type">SharedString</span> = <span class="string">""</span></span><br><span class="line">            available = <span class="literal">false</span></span><br><span class="line">            cond.unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> writet = <span class="type">WriterThread</span>()</span><br><span class="line"><span class="keyword">let</span> printt = <span class="type">PrinterThread</span>()</span><br><span class="line">printt.start()</span><br><span class="line">writet.start()</span><br></pre></td></tr></table></figure><p><a name="nsdistributedlock"></a></p><h3 id="NSDistributedLock"><a href="#NSDistributedLock" class="headerlink" title="NSDistributedLock"></a><code>NSDistributedLock</code></h3><p>分布式锁和之前看到的锁机制完全不同，我不希望大家会频繁的使用它。</p><p>此锁的目标是在多个应用中共享数据，背后是是用一个文件系统的入口（比如一个简单的文件）。这意味着所有需要用到的应用都应该可以访问这个文件系统。<br>使用<code>try()</code>方法来获取锁，这是一个非阻塞的方法，立即会返回一个布尔值来表明是否获取到了锁。获取锁的尝试通常是多次，通常在尝试成功之前都会加上一个合理的延迟。<br>使用<code>unlock()</code>方法来释放一个分布式锁。<br>接下来是一个简单的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dlock = <span class="type">NSDistributedLock</span>(path: <span class="string">"/tmp/MYAPP.lock"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> dlock = dlock &#123;</span><br><span class="line">    <span class="keyword">var</span> acquired = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!acquired)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Trying to acquire the lock..."</span>)</span><br><span class="line">        usleep(<span class="number">1000</span>)</span><br><span class="line">        acquired = dlock.<span class="keyword">try</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line"></span><br><span class="line">    dlock.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="osatomic_where_art_thou"></a></p><h3 id="OSAtomic-还能用吗？"><a href="#OSAtomic-还能用吗？" class="headerlink" title="OSAtomic 还能用吗？"></a><code>OSAtomic</code> 还能用吗？</h3><p><a href="[mikeash.com: Friday Q&amp;A 2011-03-04: A Tour of OSAtomic](https://www.mikeash.com/pyblog/friday-qa-2011-03-04-a-tour-of-osatomic.html">OSAtomic</a>) 提供的原子操作，都是一些简单的操作，没有使用经典锁逻辑，允许 set，get 或者 比较后 set 变量的操作，因为 OSAtomic 考虑到了具体的 CPU 功能（一些原生原子操作），比上面的锁机制提供更好的性能。</p><p>因为它处理并发的方式比较原始，所以不能说它们在构建并发数据结构时候非常有用。</p><p>从 macOS 10.12 开始，OSAtomic 被淘汰，并且它从来不能在 Linux 下使用，但是一些开源库，比如<a href="[GitHub - glessard/swift-atomics: Atomic operations bridged from Clang to Swift](https://github.com/glessard/swift-atomics">这个库</a>)提供了有用的 Swift 扩展，还有<a href="https://github.com/bignerdranch/AtomicSwift" target="_blank" rel="noopener">这个库</a>提供类似的功能，你也可以通过最新 <a href="[GitHub - macmade/AtomicKit: Concurrency made simple in Swift.](https://github.com/macmade/AtomicKit">AtomicKit 库</a>)得到类似的功能。</p><p><a name="on_synchronized_blocks"></a></p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>在 Swift 中，不能像 Objective-C 创建一个 @synchronized 块那样去做并发操作，Swift 中没有对应可用的关键字。</p><p>在 Darwin 系统下，可以使用 <code>objc_sync_enter(OBJ)</code> 和 <code>objc_sync_exit(OBJ)</code>实现 @ synchronized 类似的功能，并且存在一个 @objc 的对象监控器。这种方式不推荐使用，还是使用更简单的锁机制来实现并发，更加有效。</p><p>正如接下来讨论 Dispatch Queues 时候会看到的那样，使用队列来实现类似的功能，在一个序列队列里面使用少量代码操作一个同步调用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serialQueue.sync &#123;</span><br><span class="line">    // 同时只有一个线程执行 </span><br><span class="line">    v += 1</span><br><span class="line">    print(&quot;Current value \(v)&quot;)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="grand_central_dispatch"></a></p><h2 id="GCD-Grand-Central-Dispatch"><a href="#GCD-Grand-Central-Dispatch" class="headerlink" title="GCD: Grand Central Dispatch"></a><code>GCD: Grand Central Dispatch</code></h2><p>对于那些还对此 API 不熟悉的人来讲，Grand Central Dispatch (GCD) 其实就是一个基于队列的 API，允许你在工作池中执行闭包。</p><p>也就是说，闭包包含需要执行的任务，然后闭包将会被添加到队列中，队列将会使用一系列串行或者并行的线程执行它们，串行或并行执行取决于队列的配置选项。但是不管是那种类型的队列，任务的执行都遵从 FIFO 原则，意味着任务的执行顺序都会按照进入的顺序进行，完工时间取决于每个任务的持续时间。</p><p>这是一个通用的处理并发的模式，在每一个现代语言的运行时中都会看到。线程池是一种简单的方式，管理，查看和控制一系列的空闲或者未连接的线程。</p><p>GCD API 在 Swift 3 有少量的修改， <a href="[swift-evolution/0088-libdispatch-for-swift3.md at master · apple/swift-evolution · GitHub](https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md">SE-0088</a>) 优化了设计，让 API 变得面向对象。</p><p><a name="dispatch_queues"></a></p><h3 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h3><p>GCD 允许创建自定义队列，同时也提供访问预先定义好的系统队列的方式。</p><p>创建一个基本的串行队列，只需要提供一个字符串标签参数来识别它，通常推荐使用一个反向排序的域名前缀，用于在栈序列中查找队列的主人。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.Serial1"</span>)  <span class="comment">//attributes: .serial</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> concurrentQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.Concurrent1"</span>, attributes: .concurrent)</span><br></pre></td></tr></table></figure><p>第二个队列是并行队列，意味着这个队列使用线程中的可用线程来执行它包含的任务。在这种情况下，执行的顺序不可预测，不要假设闭包的完成顺序和插入顺序有任何的联系。</p><p>默认的队列可以使用 <code>DispatchQueue</code> 来获取：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mainQueue = <span class="type">DispatchQueue</span>.main</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> globalDefault = <span class="type">DispatchQueue</span>.global()</span><br></pre></td></tr></table></figure><p>主队列是一个顺序执行的队列，用于处理 iOS 和 macOS 可视化应用中的主事件循环，响应事件并且更新用户界面。众所周知，每一个对于用于界面的修改都将会在此队列中执行，每一个长时间的操作都会在此线程中绘制用户界面，这样用户界面会响应不及时。</p><p>运行时也提供了不同的优先级区分访问其他全局队列的方式，通过指定 <code>Quality of Service (Qos)</code>  参数来实现。</p><p>不同级别的优先级定义在 <code>DispatchQoS</code>类（译者注：DispatchQoS 是一个结构体，内含一个枚举类型表示优先级）中，从高到低如下：</p><ul><li>.userInteractive</li><li>.userInitiated</li><li>.default</li><li>.utility</li><li>.background</li><li>.unspecified</li></ul><p>需要重点注意的是，在手机设备上，提供低电量模式，在低电量情况下，<a href="https://mjtsai.com/blog/2017/04/03/beware-default-qos/" target="_blank" rel="noopener">后台队列会被挂起</a>。</p><p>为了获取一个特定优先级的全局队列，使用 <code>global(qos:)</code>指定需要的优先级：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> backgroundQueue = <span class="type">DispatchQueue</span>.global(qos: .background)</span><br></pre></td></tr></table></figure><p>同样的优先级指定符可以用来创建自定义队列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueueHighPriority = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.SerialH"</span>, qos: .userInteractive)</span><br></pre></td></tr></table></figure><p><a name="using_queues"></a></p><h3 id="使用队列"><a href="#使用队列" class="headerlink" title="使用队列"></a>使用队列</h3><p>任务以闭包的方式存在，可以使用两种方式将任务提交到队列中：<br>使用<code>sync</code>方法进行<em>同步操作</em>，或者使用<code>async</code>方法进行<em>异步操作</em>。</p><p>当使用前者时，<code>sync</code>调用将会被阻塞，换句话说，当闭包完成时，<code>sync</code>方法才会完成（当需要等待闭包完成情况下，这种方式是有效的，但是有更好的方法），而前者会将闭包加入到队列中，安排闭包延迟执行，并且允许当前的函数继续执行。</p><p>下面是一个简单的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">globalDefault.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Async on MainQ, first?"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">globalDefault.sync &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Sync in MainQ, second?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个分发的调用可能会被嵌套，在一个设定好的队列上执行后台的，低优先级的操作，然后需要更新主队列的用户界面。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global(qos: .background).async &#123;</span><br><span class="line">    <span class="comment">// 后台运行的代码放在这里</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="comment">// 更新主界面</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"UI updated on main queue"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包可以在指定延迟时间后执行，Swift 3 提供了简便的方式来指定需要的时间间隔，使用 <code>DispatchTimeInterval</code>枚举中的 4 个时间单位来组合不同的时间间隔：<code>.seconds(Int)</code>, <code>.milliseconds(Int),</code> <code>.microseconds(Int)</code>和 <code>.nanoseconds(Int)</code>.</p><p>使用 <code>asyncAfter(deadline:execute:)</code>带有一个时间间隔参数来计划一个未来执行的闭包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">globalDefault.asyncAfter(deadline: .now() + .seconds(<span class="number">5</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"After 5 seconds"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想同时执行一个相同的闭包多次（类似于使用 <em>dispatch_apply</em>的那样），可以使用<code>concurrentPerform(iterations:execute:)</code>来实现，需要注意的是，这些闭包可能会在当前的队列中并行执行，所以请记住把这个调用的方法包含在一个支持并发队列的同步和异步调用中。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">globalDefault.sync &#123;  </span><br><span class="line">    <span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\($<span class="number">0</span>)</span> times"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>While normally a queue is ready to process its closures upon creation, it can be configured to start in an idle state and to start processing jobs only when manually enabled.<br>通常一个队列在创建后就会执行它的闭包，但是也可以手动的启动任务：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> inactiveQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.inactiveQueue"</span>, attributes: [.concurrent, .initiallyInactive])</span><br><span class="line">inactiveQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Not yet..."</span>)</span><br><span class="line">inactiveQueue.activate()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Gone!"</span>)</span><br></pre></td></tr></table></figure><p>这是第一次需要指定多个属性的情况，正如代码所示，可以使用数组来添加多个属性。</p><p>任务可以使用继承自 <code>DispatchObject</code> 的方法来挂起或者恢复任务的执行：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">inactiveQueue.suspend()</span><br><span class="line"></span><br><span class="line">inactiveQueue.resume()</span><br></pre></td></tr></table></figure><p><code>setTarget(queue:)</code> 方法可以用来配置非活跃队列的优先级（使用它来设置活跃队列将导致崩溃），调用此方法，把队列的优先级设置为作为参数传入队列的优先级。</p><p><a name="barriers"></a></p><h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>在添加一系列闭包到指定的队列中（在不同的间隔）之后，这时想在所有异步任务完成之后执行一个任务。就需要使用屏障(Barriers)来做事。</p><p>添加 20 个（译者注：代码里面是 5 个）任务（每个任务将休眠一秒钟再执行）到之前创建的并发队列中，使用屏障在所有任务完成时打印一些东西，在最后一个 async 调用时候指定一个 <code>DispatchWorkItemFlags.barrier</code> 标识：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrentQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.Concurrent"</span>, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line">concurrentQueue.async &#123; </span><br><span class="line">    <span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">5</span>) &#123; (id:<span class="type">Int</span>) <span class="keyword">in</span></span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Async on concurrentQueue, 5 times: "</span>+<span class="type">String</span>(id))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">concurrentQueue.async (flags: .barrier) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"All 5 concurrent tasks completed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>20 个任务将会并行乱序执行，可以看到打印消息会成组出现，打印数量是 Mac 系统的执行内核的个数，但是最后一个调用将会在最后执行。</p><p>屏障还被用于强制指定并发队列的执行顺序，不想让那些已经注册任务的执行按照一个重复的方式进行。</p><p>正如 Arthur Hammer 注明的那样，分发屏障不能作用与串行队列或者任何一种类型的<a href="[dispatch_barrier_async - Dispatch | Apple Developer Documentation](https://developer.apple.com/documentation/dispatch/1452797-dispatch_barrier_async?language=objc">全局并行队列</a>)，如果你想使用它，就必须自定义一个全新的并行队列。</p><p><a name="singletons_and_dispatch_once"></a></p><h3 id="单例和-Dispatch-once"><a href="#单例和-Dispatch-once" class="headerlink" title="单例和 Dispatch_once"></a>单例和 Dispatch_once</h3><p>众所周知，Swift 3 中已经没有了<code>dispatch_once</code>, 这个函数常用于构建线程安全的单例。</p><p>幸运的是，Swift 确保使用原子化的方式进行全局变量初始化，如果你确认常量不会在初始化后改变它的值，这两个特征确保全局常量是一个很好的实现单例的方式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance: <span class="type">Singleton</span> = <span class="type">Singleton</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加类的<code>final</code>修饰确保没有子类可以继承它，并且把指定构造器设置为私有，这样就没有可能通过其他方式手动创建这个类的实例了。全局静态常量将会是 Singleton 唯一访问入口，用于获取单独的，共享的实例。</p><p>类似的行为用在定义块中，以下代码将执行一次：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runMe</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> i: () = &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Once!"</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Inner</span>.i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runMe()</span><br><span class="line">runMe() <span class="comment">// 常量已经被初始化了</span></span><br><span class="line">runMe() <span class="comment">// 常量已经被初始化了</span></span><br></pre></td></tr></table></figure><p>看起来不是那么优雅，但是能够运行，这是一种可以接受的实现方式，如果只是想执行一次性代码的话。</p><p>But if we need to replicate exactly the functionality and API of dispatch_once we need to implement it from scratch, as described in the synchronized blocks section with an extension:<br>如果想重现 <code>dispatch_once</code> 所提供的功能，需要重新实现，使用一个扩展在<a href="#on_synchronized_blocks">同步模块区域</a>添加代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">DispatchQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> onceTokens = [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> internalQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"dispatchqueue.once"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">once</span>(<span class="title">token</span>: <span class="title">Int</span>, <span class="title">closure</span>: (<span class="title">Void</span>)-&gt;<span class="title">Void</span>) </span>&#123;</span><br><span class="line">        internalQueue.sync &#123;</span><br><span class="line">            <span class="keyword">if</span> onceTokens.<span class="built_in">contains</span>(token) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                onceTokens.append(token)</span><br><span class="line">            &#125;</span><br><span class="line">            closure()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = <span class="number">1</span></span><br><span class="line"><span class="type">DispatchQueue</span>.once(token: t) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"only once!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.once(token: t) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Two times!?"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.once(token: t) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Three times!!?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所愿，三个闭包中的第一个将会被真正的执行。</p><p><a name="dispatch_groups"></a></p><h3 id="调度组"><a href="#调度组" class="headerlink" title="调度组"></a>调度组</h3><p>如果你有多个任务，想添加到多个不同的队列中，并且想等待它们的完工，你可以把它们进行分组，添加到一个调度组中。</p><p>Let’s see an example, a task can be added to a specific group directly with the sync or async call:<br>下面是一个例子，直接使用 <code>sync</code> 或者 <code>async</code> 调用将一个任务添加到一个指定的组中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mygroup = <span class="type">DispatchGroup</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">    globalDefault.async(group: mygroup)&#123;</span><br><span class="line">        sleep(<span class="type">UInt32</span>(i))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Group async on globalDefault:"</span>+<span class="type">String</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任务将在 <code>globalDefault</code> 里面执行，但是可以注册一个 <code>mygroup</code> 的回调，一旦所有任务完成以后，将会在队列中执行一个闭包，<code>wait()</code>方法用于执行阻塞等待。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Waiting for completion..."</span>)</span><br><span class="line">mygroup.notify(queue: globalDefault) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Notify received, done waiting."</span>)</span><br><span class="line">&#125;</span><br><span class="line">mygroup.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Done waiting."</span>)</span><br></pre></td></tr></table></figure><p>另外一种跟踪组任务方式是，手动在运行队列代码调用中进入和离开一个组，替换指定的方式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">    mygroup.enter()</span><br><span class="line">    sleep(<span class="type">UInt32</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Group sync on MAINQ:"</span>+<span class="type">String</span>(i))</span><br><span class="line">    mygroup.leave()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dispatch_work_items"></a></p><h3 id="调度工作项"><a href="#调度工作项" class="headerlink" title="调度工作项"></a>调度工作项</h3><p>闭包不是队列中指定任务实现的唯一方式，有时可能需要一个容器类型来跟踪执行的状态，这个时候 <code>DispatchWorkItem</code> 就派上了用场，工作项的每一个方法，都包括一个闭包作为它的参数。</p><p>工作项封装了一个队列线程池执行的闭包，通过 perform()  来执行这个闭包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> workItem = <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workItem.perform()</span><br></pre></td></tr></table></figure><p><code>DispatchWorkItem</code> 同样提供其它有用的方法，比如: 和组的定义一样，<code>notify</code>方法将会在指定的队列执行完成以后执行一个闭包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">workItem.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Notify on Main Queue!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defaultQueue.async(execute: workItem)</span><br></pre></td></tr></table></figure><p>也可以等待闭包执行结束，或者在队列尝试调用<code>cancel()</code>方法（这不是取消执行中的闭包）之前标记它删除。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Waiting for work item..."</span>)</span><br><span class="line">workItem.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Done waiting."</span>)</span><br><span class="line">workItem.cancel()</span><br></pre></td></tr></table></figure><p>需要重点注意的是，<code>wait()</code>方法不仅仅是阻塞当前线程，等待完成，也会抬高所有队列中早先的工作项，试图尽快完成指定的项目。</p><p><a name="dispatch_semaphores"></a></p><h3 id="调度信号量"><a href="#调度信号量" class="headerlink" title="调度信号量"></a>调度信号量</h3><p>调度信号量是一种锁，根据当前计数的值，可以被多个线程获取。</p><p>线程会等待一个信号量，直到信号量减到 0 时，就可以获取它了。</p><p>访问信号量的槽将对等待线程释放，等待线程调用<code>signal</code>方法将会增加计数。</p><p>下面是一个简单的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sem = <span class="type">DispatchSemaphore</span>(value: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量将被两个线程池组持有</span></span><br><span class="line">globalDefault.sync &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">10</span>) &#123; (id:<span class="type">Int</span>) <span class="keyword">in</span></span><br><span class="line">        sem.wait(timeout: <span class="type">DispatchTime</span>.distantFuture)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" acquired semaphore."</span>)</span><br><span class="line">        sem.signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dispatch_assertions"></a></p><h3 id="调度断言"><a href="#调度断言" class="headerlink" title="调度断言"></a>调度断言</h3><p>Swift 3 引入了一个新的函数，用于在当前执行上下文中进行断言，用于验证一个闭包是否在预期的队列中被执行了。使用 <code>DispatchPredicate</code> 枚举的是三个值来断言执行的情况：<code>.onQueue</code>, 验证闭包是否执行在一个指定队列中，<code>.notOnQueue</code>, 验证相反的情况，<code>.onQueueAsBarrier</code>，验证当前闭包或者工作项是否作为一个队列的屏障存在。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dispatchPrecondition(condition: .notOnQueue(mainQueue))</span><br><span class="line">dispatchPrecondition(condition: .onQueue(queue))</span><br></pre></td></tr></table></figure><blockquote><p>此文章和本博客相关文章代码可以从 <a href="https://github.com/uraimo/Swift-Playgrounds" target="_blank" rel="noopener">GitHub</a>和 <a href="https://www.uraimo.com/archives/2017-05-07-ConcurrencyInSwift.playground.zip" target="_blank" rel="noopener">Zipped</a>上下载。  </p></blockquote><p><a name="dispatch_sources"></a></p><h2 id="调度资源"><a href="#调度资源" class="headerlink" title="调度资源"></a>调度资源</h2><p>调度资源是一种处理系统级异步事件的方式，包括内核信号，系统，文件或者 socket 相关使用事件处理的事件。</p><p>有以下几种类型可用的调度资源，归类如下：</p><ul><li><strong>Timer Dispatch Sources</strong> : 用作产生与时间或者周期相关的事件（DispatchSourceTimer）。<br><strong>Signal Dispatch Sources</strong> : 用于处理 UNIX 信号（DispatchSourceSignal）。<br><strong>Memory Dispatch Sources</strong>:<br>用于注册与内存使用状态相关的通知（DispatchSourceMemoryPressure）。<br><strong>Descriptor Dispatch Sources</strong>:<br>用于注册文件和socket相关的不同事件（DispatchSourceFileSystemObject, DispatchSourceRead, DispatchSourceWrite）。<br><strong>Process dispatch sources</strong>:<br>用于监控外部进程相关执行状态的时间（DispatchSourceProcess）。<br><strong>Mach related dispatch sources</strong>:<br>用于处理 Mach 内核的 <a href="http://fdiv.net/2011/01/14/machportt-inter-process-communication" target="_blank" rel="noopener">IPC 工具</a>相关的事件（<em>DispatchSourceMachReceive</em>, <em>DispatchSourceMachSend</em>）。</li></ul><p>也可以在需要的时候自定义调度资源。所有的调度资源都遵从<code>DispatchSourceProtocol</code> 协议，需要定义注册处理器的基本操作，修改调度资源的激活状态等。</p><p>举一个 <code>DispatchSourceTimer</code> 的例子来理解如何使用这些对象。</p><p>使用 <code>DispatchSource</code> 的工具函数来创建资源对象，在下面代码中使用 <code>makeTimerSource</code>， 指定需要执行处理的调度队列。</p><p>时间资源没有其它参数，只需要指定队列来创建资源，调度资源可以处理多个时间，通常需要指定处理事件的标识符。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="type">DispatchSource</span>.makeTimerSource(queue: <span class="type">DispatchQueue</span>.global())</span><br><span class="line">t.setEventHandler&#123; <span class="built_in">print</span>(<span class="string">"!"</span>) &#125;</span><br><span class="line">t.scheduleOneshot(deadline: .now() + .seconds(<span class="number">5</span>), leeway: .nanoseconds(<span class="number">0</span>))</span><br><span class="line">t.activate()</span><br></pre></td></tr></table></figure><p>资源建立以后，使用<code>setEventHandler(closure:)</code>注册一个时间处理器，如果没有其它配置了，使用<code>activate()</code>开启调度资源（前一个版本的<code>libDispatch</code> 使用的是 <code>resume()</code>方法）。</p><p>调度资源初始是不激活的，意味着不会立刻执行事件。当一切准备情绪后，资源将使用<code>activate()</code>激活分发事件，也可以使用<code>suspend()</code>挂起和使用<code>resume()</code>恢复。</p><p>时间资源需要一个额外的步骤来配置哪种类型的时间事件会被对象调度。在下面的例子中，定义一个会在 5 秒后执行的调度事件。</p><p>也可以定义一个周期事件，和在 <a href="https://www.uraimo.com/swiftbites/nstimer-in-swift-3/" target="_blank" rel="noopener">Timer</a> 对象所做的一样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">t.scheduleRepeating(deadline: .now(), interval: .seconds(<span class="number">5</span>), leeway: .seconds(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>当完成一个调度资源时，想完全阻止调度事件，可以使用<code>cancel()</code>来完成，这样可以停止资源事件，取消已经设置的处理器，并且进行一些清理操作，比如注销处理器等。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">t.cancel()</span><br></pre></td></tr></table></figure><p>其它调度资源类型的 API 是类似的，看一个 <a href="https://github.com/IBM-Swift/Kitura-net/blob/master/Sources/KituraNet/IncomingSocketHandler.swift#L96" target="_blank" rel="noopener">Kitura</a> 初始化读取资源的例子，用于处理在一个建立连接的 socket 的异步写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">readerSource = <span class="type">DispatchSource</span>.makeReadSource(fileDescriptor: socket.socketfd,</span><br><span class="line">                                             queue: socketReaderQueue(fd: socket.socketfd))</span><br><span class="line"></span><br><span class="line">readerSource.setEventHandler() &#123;</span><br><span class="line">    <span class="number">_</span> = <span class="keyword">self</span>.handleRead()</span><br><span class="line">&#125;</span><br><span class="line">readerSource.setCancelHandler(handler: <span class="keyword">self</span>.handleCancel)</span><br><span class="line">readerSource.resume()</span><br></pre></td></tr></table></figure><p>当 socket 中接收数据缓存中有新的字节可用时， <code>handleRead()</code> 将在一个专用的队列中调用。Kitura 同样使用 <code>WriteSource</code> 来操作一个缓存写，使用分发资源事件进行<a href="https://github.com/IBM-Swift/Kitura-net/blob/master/Sources/KituraNet/IncomingSocketHandler.swift#L328" target="_blank" rel="noopener">高效的写操作</a>，当 socket 管道可以发送字节时，就写入新的字节。在 *nix 平台下去进行 I/O 操作，调度资源是一个很好的高阶方案，替代那些底层的 API。</p><p>对于和文件相关的调度资源，另外一个有用的对象是 <code>DispatchSourceFileSystemObject</code>， 它允许监听指定文件的变化，从名字的变化到属性的变化都可以监听。使用调度资源，你也可以接受文件修改或者删除的通知，这是 Linux 中 inotify 内核子系统的一个子集。</p><p>剩余的资源类型操作是类似的，你可以从 <a href="https://developer.apple.com/reference/dispatch/dispatchsource" target="_blank" rel="noopener">libDispatch 文档</a>中获取更多的细节，但是请记住的是，像 <code>Mach</code> 资源和内存压力资源只能在 <code>Darwin</code> 平台中使用。</p><p><a name="operations_and_operationqueues"></a></p><h3 id="操作和操作队列"><a href="#操作和操作队列" class="headerlink" title="操作和操作队列"></a>操作和操作队列</h3><p>简单来说说操作队列，这是建立在 GCD 顶层的附加 API，把并行队列和模型任务看作为操作，易于取消，依赖其它操作完成情况来执行任务。</p><p>操作可以有优先级，定义了执行的顺序，也可以添加到 <code>OperationQueues</code> 异步执行。</p><p>看看一个基本的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> queue = <span class="type">OperationQueue</span>()</span><br><span class="line">queue.name = <span class="string">"My Custom Queue"</span></span><br><span class="line">queue.maxConcurrentOperationCount = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mainqueue = <span class="type">OperationQueue</span>.main <span class="comment">// 引用主线程中的队列</span></span><br><span class="line"></span><br><span class="line">queue.addOperation&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Op1"</span>)</span><br><span class="line">&#125;</span><br><span class="line">queue.addOperation&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Op2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以创建一个<em>阻塞操作</em>对象，在添加到队列之前进行配置，并且可以添加多个闭包到这个类型的操作中。</p><p>需要注意的是，在 Swift 中， <code>NSInvocationOperation</code>, 不再可用，这个类可以使用<br><code>target+selector</code> 来创建操作。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> op3 = <span class="type">BlockOperation</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Op3"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">op3.queuePriority = .veryHigh</span><br><span class="line">op3.completionBlock = &#123;</span><br><span class="line">    <span class="keyword">if</span> op3.isCancelled &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Someone cancelled me."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Completed Op3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> op4 = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Op4 always after Op3"</span>)</span><br><span class="line">    <span class="type">OperationQueue</span>.main.addOperation&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I'm on main queue!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作会有优先级，第二个完整的闭包将在主闭包完成后执行一次。</p><p>还可以添加 <code>op4</code> 对 <code>op3</code> 的依赖，这样 <code>op4</code> 将等待 <code>op3</code> 的完成。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">op4.addDependency(op3)</span><br><span class="line">queue.addOperation(op4)  <span class="comment">// op3 会一直在 op4 之前执行</span></span><br><span class="line">queue.addOperation(op3)</span><br></pre></td></tr></table></figure><p>也可以使用 <code>removeDependency(operation:)</code> 移除依赖，依赖是存储在一个公开访问的依赖数组中。</p><p>操作的状态可以使用指定的属性查看：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">op3.isReady       <span class="comment">// 是否准备好执行？</span></span><br><span class="line">op3.isExecuting   <span class="comment">// 是否执行中？</span></span><br><span class="line">op3.isFinished    <span class="comment">// 是否执行完成或被取消掉？</span></span><br><span class="line">op3.isCancelled    <span class="comment">// 是否被手动取消？</span></span><br></pre></td></tr></table></figure><p>调用 <code>cancelAllOperations</code> 可以取消一个现存队列中所有的操作，在队列中存在的所有操作都会被设置 <code>isCancelled</code> 标识。调用 cancel 方法可以取消单个操作：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">queue.cancelAllOperations() </span><br><span class="line">op3.cancel()</span><br></pre></td></tr></table></figure><p>推荐执行时对 <code>isCancelled</code> 属性进行检查，当计划在队列中执行这个操作时，一旦操作被取消，可以检查<code>isCancelled</code>来跳过这个执行。</p><p>最后，可以在操作队列中停止新操作的执行（当前执行中的操作不会被影响）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">queue.isSuspended = <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>此文章和本博客相关文章代码可以从 <a href="https://github.com/uraimo/Swift-Playgrounds" target="_blank" rel="noopener">GitHub</a>和 <a href="https://www.uraimo.com/archives/2017-05-07-ConcurrencyInSwift.playground.zip" target="_blank" rel="noopener">Zipped</a>上下载。  </p></blockquote><p><a name="closing_thoughts"></a></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这篇文章很好的总结了 Swift 中目前可用的外部并发框架。</p><p>即将到来的此系列第二部分将聚焦在如何在不引入外部库的情况下，使用原生语言特性来处理并发。借助现有的一些开源实现，介绍一些有趣的范式。</p><p>我希望这两篇文章是一个打开并发编程之门的很好的介绍，这将有助于理解和参与在 swift-evolution 中的讨论，至于何时会引入原生的支持，希望是 Swift 5吧。</p><p>查看更多关于 Swift 和并发有趣的故事，可以查看博客：<a href="https://www.cocoawithlove.com/tags/asynchrony.html" target="_blank" rel="noopener">Cocoa With Love</a>。</p><p>喜欢这篇文章吗？给我 <a href="https://www.twitter.com/uraimo" target="_blank" rel="noopener">twitter</a> 留言吧！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Umberto Raimondi，&lt;a href=&quot;https://www.uraimo.com/2017/05/07/all-about-concurrency-in-swift-1-the-present/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-05-07&lt;br&gt;译者：&lt;a href=&quot;http://codebuild.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shanks&lt;/a&gt;；校对：&lt;a href=&quot;http://codebuild.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shanks&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;当前最新版本的 Swift 语言（译者注：当前最新稳定版本为 3.1.1）还没有包含任何原生并发特性，但是在其他现代编程语言中是带有这个特性的，比如 Go 和 Rust。&lt;br&gt;如果你想并发地执行任务，这时就需要处理与结果相关的竞态条件，目前唯一的选择就是使用第三方库，比如 libDispatch，或者 Foundation 和其他 OS 中提供的同步原语。&lt;br&gt;在这一系列文章的第一部分，看看 Swift 3 给出的处理方案，覆盖以下一些内容：Foundation 中的锁，线程和计时器提供语言层面的保证，最近不断增强的 GCD(Grand Central Dispatch) 和操作队列（Operation Queues）。&lt;/p&gt;
&lt;p&gt;同时也会讨论到基础的并发原理和一些通用的并发模式。&lt;/p&gt;
    
    </summary>
    
      <category term="uraimo" scheme="https://swift.gg/categories/uraimo/"/>
    
    
      <category term="Swift 进阶，并发编程" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6%EF%BC%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于 Purple Train 的说明</title>
    <link href="https://swift.gg/2017/07/31/announcing-purple-train/"/>
    <id>https://swift.gg/2017/07/31/announcing-purple-train/</id>
    <published>2017-07-31T00:00:00.000Z</published>
    <updated>2018-05-18T10:46:06.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ian C. Anderson，<a href="https://robots.thoughtbot.com/announcing-purple-train" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-1-9<br>译者：<a href="undefined">Tuccuay</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><p>我一直想开发一个 iOS 应用，现在我可以很高兴的告诉大家，在许多同事的帮助下终于在今年完成了 <a href="https://purpletrainapp.com/" target="_blank" rel="noopener">Purple Train</a>。</p><p><img src="/img/articles/announcing-purple-train/TujwAPQD6B8G2RoVixXA_purple-train-iphone-app-f7b427aaec509ee65069d07f2e809152.png1501462197.36" alt=""></p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>Purple Train 为了解决一个简单的问题：我关心的下一趟 MBTA 通勤火车什么时候出发？市场上几个类似的 app 都感觉不太好用。我只想很快速的打开它并得到想要的信息，然后返回。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>如果你想从一个固定的「家」和波士顿之间通勤，这个应用能为你提供一个简单而有效的界面：选择你家附近的车站，然后就能离开看到往返于波士顿之间的列车。如果有快车不在选择的车站停车，它将会被自动过滤掉以免带来不必要的干扰。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>在开始开发 app 之前，有不少人讲过 React Native 的优点，所以我尝试了一下。我感兴趣的原因并不是因为能使用 JavaScript 开发，而是因为它能够进行 <a href="https://robots.thoughtbot.com/rapid-cross-platform-mobile-development-with-react-native" target="_blank" rel="noopener">跨平台开发</a>。我已经很熟悉使用 React 和 Redux 进行函数式响应式编程。所以想在 Purple Train 上尝试一下看看它带来多大生产力的提升。</p><p><a href="https://twitter.com/twnsndco" target="_blank" rel="noopener">Cole Townsend</a> 在完成 app 的初期设计工作的时候觉得非常舒服，他使用 React Native 的 <a href="https://facebook.github.io/react-native/docs/stylesheet.html" target="_blank" rel="noopener">StyleSheet</a> 来实现这些设计。</p><p>基本功能在 iOS 上正常运行之后，<a href="https://twitter.com/kenyonj" target="_blank" rel="noopener">Justin Kenyon</a> 和我花了半天时间把它移植到 Android。让我们感到高兴的是这个过程很简单，并且整个 app 中没有针对某个特定平台的兼容代码，在所有的工作中只用到了 React Native 和几个第三方库。</p><p>感谢 <a href="https://twitter.com/blakewilliams__" target="_blank" rel="noopener">Blake Williams</a>, <a href="https://twitter.com/kenyonj" target="_blank" rel="noopener">Justin Kenyon</a>, <a href="https://twitter.com/derekprior" target="_blank" rel="noopener">Derek Prior</a>, and <a href="https://twitter.com/mborsare" target="_blank" rel="noopener">Mike Borsare</a> 所做的前端工作！</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>这个 app 的后端是一个 Elixir Phoenix 应用，用于缓存 <a href="http://realtime.mbta.com/portal" target="_blank" rel="noopener">MBTA’s Realtime API</a> 的响应并且能够返回针对移动应用优化过的更精简的 JSON。</p><p>这个 Phoenix 使用 Elixir 提供的 <a href="http://elixir-lang.org/getting-started/mix-otp/agent.html" target="_blank" rel="noopener">Agent</a> 模块存储来自 MBTA API 的响应。这让我们有了一个非常迅速的内存缓存，使得后端能够快速响应。</p><p>后端还有一些可以过滤掉用户不关心的车次（比如已经离开用户所在车站或者不停靠用户所在站点的快车）的功能。这使得前端的工作更方便并且保持较小的 JSON 响应，这也有助于提升移动设备的性能。</p><p>感谢 <a href="https://twitter.com/derekprior" target="_blank" rel="noopener">Derek Prior</a> 和 <a href="https://twitter.com/joshuaclayton" target="_blank" rel="noopener">Josh Clayton</a> 编写并优化的后端！</p><h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><p>Web 开发工程师和设计师都可以立即开始使用 React Native。他们对 JavaScript 语言、Cmd + R 或者 Live Reloading 重新加载的工作流、函数式响应式编程和样式表都已经很熟悉了。</p><p>尽管使用 JavaScript 还可能存在很多问题，但这种熟悉的方式提供的生产力让 React Native 成为许多跨平台 app 选择。</p><h2 id="Elm-Native"><a href="#Elm-Native" class="headerlink" title="Elm Native"></a>Elm Native</h2><p>我们喜欢这个工作流，也喜欢这些概念，还熟悉这些语言。但是相比起 Swift 和 Kotlin 这些原生的编译型语言来说，则少了一些安全性和重构的便利性。</p><p>我们如何才能有一个高效的工作流，而不会遇到 JavaScript 错误，比如 undefined is not a function？如果使用 <a href="http://elm-lang.org/" target="_blank" rel="noopener">Elm</a> 语言可以让我们更自信地说代码是正确的吗？</p><p>幸运的是 Purple Train 是个很简单的 app，这让它能够很好地成为试验新技术的测试平台，请持续关注我们是如何使用 <a href="https://github.com/ohanhi/elm-native-ui" target="_blank" rel="noopener">elm-native-ui</a> 将 Purple Train 迁移到 <a href="http://elm-lang.org/" target="_blank" rel="noopener">Elm</a> 的！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://purpletrainapp.com/" target="_blank" rel="noopener">Purple Train</a> 主页</li><li>阅读 <a href="https://robots.thoughtbot.com/rapid-cross-platform-mobile-development-with-react-native" target="_blank" rel="noopener">Rapid cross-platform mobile development with React Native</a></li><li>收听 <a href="http://bikeshed.fm/86" target="_blank" rel="noopener">Bikeshed Podcast episode about Purple Train</a><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      关于 Purple Train 的说明
    
    </summary>
    
      <category term="Thoughtbot" scheme="https://swift.gg/categories/Thoughtbot/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 #76</title>
    <link href="https://swift.gg/2017/07/26/swift-weekly-issue-76/"/>
    <id>https://swift.gg/2017/07/26/swift-weekly-issue-76/</id>
    <published>2017-07-26T00:00:00.000Z</published>
    <updated>2018-05-18T10:46:06.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jesse Squires，<a href="https://swiftweekly.github.io/issue-76/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-29<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="noopener">四娘</a>；校对：<a href="http://weibo.com/277195544" target="_blank" rel="noopener">Cwift</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><p><em>本期作者：<a href="https://twitter.com/garricn" target="_blank" rel="noopener">Garric Nahapetian</a></em></p><p>Swift 的 <a href="https://github.com/apple/swift" target="_blank" rel="noopener">git 仓库</a>这周特别忙，这里有一些 GitHub 的数据：</p><blockquote><p>除了 Merge 之外，总共有 39 个作者 push 了 156 个 commit 到主分支，所有分支算起来有 284 个 commit。在主分支，401 个文件被修改，增 12589 删 9215 …</p></blockquote><p>在 WWDC 结束不久就完成了这么多的事情实属不易，在 Swift 4 立项之后核心团队和别的贡献者完成了惊人的进展。</p><a id="more"></a><p>iOS 11 beat 2，tvOS 11 beta 2 和 Swift Playgrounds 2 beta 2 都开放下载了，点击<a href="https://developer.apple.com/download/" target="_blank" rel="noopener">此处下载</a>，遇到 bug 记得要反馈哦！</p><blockquote><p><strong>赞助链接</strong></p><p><a href="http://www2.bignerdranch.com/l/299472/2017-06-21/8rxl/?utm_campaign=Swift_Weekly_Brief&amp;utm_medium=email_web&amp;utm_source=Swift_Weekly_Brief_76" target="_blank" rel="noopener">提升你的技能 — 成就你的职业生涯</a></p><p>专家带你入门到精通只需一周时间。</p><p><a href="http://www2.bignerdranch.com/l/299472/2017-06-21/8rxl/?utm_campaign=Swift_Weekly_Brief&amp;utm_medium=email_web&amp;utm_source=Swift_Weekly_Brief_76" target="_blank" rel="noopener">bignerdranch.com</a></p></blockquote><h2 id="Swift-Unwrapped"><a href="#Swift-Unwrapped" class="headerlink" title="Swift Unwrapped"></a>Swift Unwrapped</h2><p>在<a href="https://spec.fm/podcasts/swift-unwrapped/70319" target="_blank" rel="noopener">第 17 集：Swift 里的测试</a>，Jesse 和 JP 讨论了如何使用 Swift 和相应的工具进行测试，保证每一个上线版本都井然有序。</p><h2 id="资讯及社区"><a href="#资讯及社区" class="headerlink" title="资讯及社区"></a>资讯及社区</h2><p>Greg Heo <a href="https://swiftunboxed.com/stdlib/json-encoder-encodable/" target="_blank" rel="noopener">写了一篇文章</a>讲述 Swift 里 <code>Encoder</code> 和 <code>Encodable</code> 的原理，这个新功能会影响到很多开源的软件，了解它的原理更有助于你理解它们相关的 PR。</p><p>Matt Godbolt 的<em>探索编译器</em>现已<a href="https://twitter.com/Catfish_Man/status/877991651548975104" target="_blank" rel="noopener">支持 Swift</a>。（译者注：这是一个学习编译原理的网站，输入代码，就可以看到编译后在对应平台上的汇编码）</p><p>David Owens 放出了一个 <a href="https://owensd.io/2017/06/02/apous-early-preview/" target="_blank" rel="noopener">VSCode 的插件</a>，让 VSCode 也能支持 Swift。</p><p>Swift 支援团队<a href="https://twitter.com/swift_evolution/status/878322333471068160" target="_blank" rel="noopener">开源</a>了 Swift-Evolution 的 App — <a href="https://itunes.apple.com/us/app/evolution-app/id1210898168?mt=8" target="_blank" rel="noopener">Evo</a>。</p><p>Steven Hepting <a href="https://twitter.com/stevenhepting/status/878339681485635585" target="_blank" rel="noopener">讲述</a>了 Swift 的 <code>sort()</code> 方法是怎么优化的，这里可以找到相应的<a href="https://github.com/apple/swift/blob/02e2bd5380af69948d2324b936bfc61e1454d8ea/stdlib/public/core/Sort.swift.gyb#L232-L301" target="_blank" rel="noopener">源码</a>。</p><p><a href="https://www.meetup.com/Learn-Swift-Queens-Meetup/" target="_blank" rel="noopener">Learn Swift 皇后区</a> &amp; <a href="https://www.meetup.com/Learn-Swift-Portland/" target="_blank" rel="noopener">Learn Swift 波兰</a>, 都落下了帷幕。 这是11期  <a href="https://wordpress.com/post/swiftcoders.org/178" target="_blank" rel="noopener">Learn Swift {城市}</a> 系列的合集！下次会是在哪座城市呢？</p><p><a href="https://github.com/br1sk/brisk" target="_blank" rel="noopener">Brisk，一个反馈 bug 的 macOS app</a> 上线了 <a href="https://github.com/br1sk/brisk/releases/tag/1.0.0" target="_blank" rel="noopener">1.0 版本</a> ，并且快速迭代发布了 <a href="https://github.com/br1sk/brisk/releases/tag/1.0.1" target="_blank" rel="noopener">1.0.1 版本</a>，记得要帮忙反馈 bug 哦！</p><p>元组门又有了更多的<a href="https://twitter.com/s1ddok/status/879406585939984386" target="_blank" rel="noopener">进展</a>，这对我来说很有趣，因为<a href="https://github.com/garricn/GGNObservable/blob/master/GGNObservable/Classes/Observable.swift#L53" target="_blank" rel="noopener">我个人也使用过类似的方式</a>。就像 <a href="https://twitter.com/slava_pestov/status/879446070190800896" target="_blank" rel="noopener">Slava 指出</a>的那样，这件事情始终还有<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160307/012299.html" target="_blank" rel="noopener">优化的空间</a>。（译者注：元组门就是闭包里的元组不再自动展开的事情，<a href="http://swift.gg/2017/07/16/swift_weekly_issue_74/">前两周</a>的<a href="http://swift.gg/2017/07/24/swift-weekly-issue-75/">周报</a>都有提到，详情请看 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md" target="_blank" rel="noopener">SE-0029</a>，<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md" target="_blank" rel="noopener">SE-0066</a> 和 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0110-distingish-single-tuple-arg.md" target="_blank" rel="noopener">SE-0110</a>）。</p><h2 id="提交和合并的请求"><a href="#提交和合并的请求" class="headerlink" title="提交和合并的请求"></a>提交和合并的请求</h2><p>Ben Cohen 发起一个新的<a href="https://github.com/apple/swift-evolution/pull/728" target="_blank" rel="noopener">合并请求</a>，让 <code>Substring</code> 可以添加到 <code>Hashable</code> 容器里（详情请看下面的邮件列表讨论）。</p><p>Itai Ferber <a href="https://github.com/apple/swift/pull/10538" target="_blank" rel="noopener">通过了一个合并请求</a>，修复了 <a href="https://bugs.swift.org/browse/SR-5277" target="_blank" rel="noopener">SR-5277</a>，让 class 可以与父类共用一个 Encoder/Decoder。更多详情请看这里的<a href="https://twitter.com/garricn/status/878426105585127425" target="_blank" rel="noopener">讨论进程</a>。</p><p>Philippe Hausler <a href="https://github.com/apple/swift/pull/10584" target="_blank" rel="noopener">通过了一个合并请求</a>，修复了 <a href="https://bugs.swift.org/browse/SR-5292" target="_blank" rel="noopener">SR-5292</a>。修复了 Foundation 里使用 slice 嵌套 slice 时产生的 bug。</p><p>Joe Groff  <a href="https://github.com/apple/swift/pull/10556" target="_blank" rel="noopener">通过了一个合并请求</a>，让 KeyPath 支持可选链（Optional Chainning）和强制解包（Force Unwrapping）。</p><p>Doug Gregor <a href="https://github.com/apple/swift/pull/10565" target="_blank" rel="noopener">通过了一个合并请求</a> ，优化了基本类型，类型别名和递归的处理逻辑，并且修复了 <a href="https://bugs.swift.org/browse/SR-4295" target="_blank" rel="noopener">SR-4295</a>，<a href="https://bugs.swift.org/browse/SR-4757" target="_blank" rel="noopener">SR-4757</a>，<a href="https://bugs.swift.org/browse/SR-4786" target="_blank" rel="noopener">SR-4786</a>，<a href="https://bugs.swift.org/browse/SR-5014" target="_blank" rel="noopener">SR-5014</a> 和 <a href="https://bugs.swift.org/browse/SR-4737" target="_blank" rel="noopener">SR-4737</a>。</p><p>Dave Abrahams <a href="https://github.com/apple/swift/pull/9806" target="_blank" rel="noopener">发起一个合并请求</a>，实现了 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0180-string-index-overhaul.md" target="_blank" rel="noopener">SE-0180</a> 字符串索引越界（后面有详细介绍）。</p><p>在命令行里运行 <code>man swift</code> 时展示的手册<a href="https://github.com/apple/swift/pull/10241" target="_blank" rel="noopener">已获得更新</a>。</p><p>Maxim Moiseev <a href="https://github.com/apple/swift/pull/9466" target="_blank" rel="noopener">通过了一个合并请求</a>，修复了 <code>[String]</code> 使用 <code>flatMap</code> 时的向后兼容性，有兴趣了解的话可以查看这里的 <a href="https://twitter.com/codafi_/status/878330155642396673" target="_blank" rel="noopener">Swift 迷思- by Robert Widmann</a>。</p><p>David Farler <a href="https://github.com/apple/swift-clang/pull/95" target="_blank" rel="noopener">通过了一个合并请求</a>，内容主要是 Xcode 9 里编译时索引功能（index-while-building）在这段时间里的改进。</p><p>如果你想知道某个修复了 <code>rdar://</code> 的 PR 的细节，<a href="https://twitter.com/garricn/status/879551154316689408" target="_blank" rel="noopener">放心大胆地问就可以了</a>。</p><h2 id="审核中的提案"><a href="#审核中的提案" class="headerlink" title="审核中的提案"></a>审核中的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0180-string-index-overhaul.md" target="_blank" rel="noopener">SE-0180</a>: String Index Overhaul 在一些讨论之后重新退回<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170619/037653.html" target="_blank" rel="noopener">审核阶段</a>。</p><h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>Erica Sadun <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170626/037730.html" target="_blank" rel="noopener">写了一篇文章</a>关于 <code>!!</code> 这个她称为“解包或崩溃”的操作符。你可以在<a href="https://gist.github.com/erica/423e4b1c63b95c4c90338cdff4939a9b" target="_blank" rel="noopener">这个 Gist</a> 里找到相应的草稿。</p><blockquote><p>使用一个操作符，在解包失败时提供反馈信息，已经成为 Swift 开发者社区里普遍会实现的一个东西了，你对于把这个广泛使用的操作符加入到标准库有什么想法？</p><p><em>译者注：使用了 <code>!!</code> 的代码会类似于这样 <code>let _ = optionalObject !! &quot;空的对象&quot;</code>，能够在强制解包失败的时候提供 debug 信息，思路很棒，建议大家看一下。</em></p></blockquote><p>Ben Cohen <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170626/037776.html" target="_blank" rel="noopener">发了一篇文章</a>，内容主要是关于 <code>Substring</code> 性能的讨论。</p><blockquote><p>作为 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0163-string-revision-1.md" target="_blank" rel="noopener">SE-0163</a> 的要点之一，<code>Substring</code> 显式转换到 <code>String</code> 的问题都推迟到第一版实现之后讨论。直到现在，收到的反馈也都没有让我们觉得这样的显式转换很有必要 — 从 3.2 迁移到 4.0 的时候也不怎么需要用到   <code>Substring</code> 到 <code>String</code>的转换。即便不在开发目标里，只要是这方面的版本迁移问题，收到您的反馈我们都会很感谢。</p><p>[…]</p></blockquote><p>Itai Ferber <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170619/037672.html" target="_blank" rel="noopener">在 Swift-Evolution 发了一条信息</a> ，征求 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0166-swift-archival-serialization.md" target="_blank" rel="noopener">SE-0166</a> 和 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0167-swift-encoders.md" target="_blank" rel="noopener">SE-0167</a> 的反馈，希望社区了解到之前的很多建议已经被采纳并实现，继续提供建议和意见。</p><p>Robert Bennett 提了一个<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170619/037676.html" target="_blank" rel="noopener">有趣的建议</a>，希望 protocol 里可以声明 <code>let</code>。但我并不认为他提的算是一个问题。</p><blockquote><p>我在处理协议的时候遇上了一个恼人的问题。在一个 <code>class</code> 或者 <code>struct</code> 里使用 <code>let</code> 去修饰一个属性并且在 <code>init</code> 方法里初始化是很常见的情况，但却没办法在一个 protocol extension 里实现一个这样的 <code>init</code> 方法。</p><p>[…]</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>“索取”<a href="https://twitter.com/harlanhaskins/status/878499165663240192" target="_blank" rel="noopener">有时候</a>比“给予”感觉更好</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Swift 周报
    
    </summary>
    
      <category term="Swift 进阶" scheme="https://swift.gg/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Jesse Squires" scheme="https://swift.gg/tags/Jesse-Squires/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 #75</title>
    <link href="https://swift.gg/2017/07/24/swift-weekly-issue-75/"/>
    <id>https://swift.gg/2017/07/24/swift-weekly-issue-75/</id>
    <published>2017-07-24T00:00:00.000Z</published>
    <updated>2018-05-18T10:46:06.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jesse Squires，<a href="https://swiftweekly.github.io/issue-75/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-22<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="noopener">四娘</a>；校对：<a href="http://weibo.com/277195544" target="_blank" rel="noopener">Cwift</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><p><em>本期作者: <a href="https://twitter.com/gregheo" target="_blank" rel="noopener">Greg Heo</a></em></p><p>我不知道你怎么样，但我还沉浸在 WWDC 的余兴里没恢复过来。</p><p>回到实际生活中，苹果发布了 iOS 和 Xcode 的第二个 beta 版。查看<a href="https://developer.apple.com/" target="_blank" rel="noopener">开发者网站</a>，Xcode 9 Beta 2 的更新说明特别提到了 Swift 4 的更新和修复。</p><a id="more"></a><blockquote><p><strong>赞助</strong>  </p><p><a href="https://www.eventbrite.com/o/plausible-labs-12068803363/?utm_campaign=Swift_Weekly_Brief&amp;utm_medium=email_web&amp;utm_source=Swift_Weekly_Brief_75" target="_blank" rel="noopener">Advanced Swift Workshops</a>  </p><p>磨炼你的 Swift 技能，在 workshop 里学习一些更深入的主题。诸如 Mike Ash 这样世界知名的开发者，Swift 的专家齐聚一堂，他们将会带领你探索协议，泛型，反射和 C 语言的桥接。7 月 13 日华盛顿场，以及 7 月 24 日纽约场。  </p><p><a href="https://www.eventbrite.com/o/plausible-labs-12068803363/?utm_campaign=Swift_Weekly_Brief&amp;utm_medium=email_web&amp;utm_source=Swift_Weekly_Brief_75" target="_blank" rel="noopener">eventbrite.com</a>  </p></blockquote><h2 id="社区任务"><a href="#社区任务" class="headerlink" title="社区任务"></a>社区任务</h2><p>写测试是一种探索标准库和语言特性的好方式，也能避免给项目留坑。</p><ul><li><a href="https://bugs.swift.org/browse/SR-4824" target="_blank" rel="noopener">SR-4824</a>：编译期添加集合类型约束的检查</li><li><a href="https://bugs.swift.org/browse/SR-5040" target="_blank" rel="noopener">SR-5040</a>：将 “Exclude” 相关的功能性检查改为单元测试</li></ul><p>可以通过 <a href="https://github.com/SwiftWeekly/swiftweekly.github.io/compare" target="_blank" rel="noopener">pull request</a> 或者 <a href="https://twitter.com/swiftlybrief" target="_blank" rel="noopener">tweet</a> 提交任务。</p><h2 id="Swift-Unwrapped"><a href="#Swift-Unwrapped" class="headerlink" title="Swift Unwrapped"></a>Swift Unwrapped</h2><p>在 <a href="https://spec.fm/podcasts/swift-unwrapped/72297" target="_blank" rel="noopener">第 16 集：Swift 的错误处理 — 发展历史</a> 里，主持人提到了 <code>rethrows</code> 和 “类型” 很多次，缅怀 Objective-C，畅谈 Swift 错误处理机制的发展史。</p><h2 id="资讯及社区"><a href="#资讯及社区" class="headerlink" title="资讯及社区"></a>资讯及社区</h2><p>Swift 团队的巨星 <a href="https://twitter.com/jckarter/status/875401073447419904" target="_blank" rel="noopener">Joe Groff</a> 要暂时离开 Twitter，Joe 在 Twitter 上一直对社区积极响应，我们希望他早日回归。</p><p>聊到 Joe，<a href="https://www.youtube.com/watch?v=Ntj8ab-5cvE" target="_blank" rel="noopener">他的前任</a> <a href="https://twitter.com/clattner_llvm/status/877341760812232704" target="_blank" rel="noopener">Chris Lattner</a> （你们应该都认识）要重新找工作，虽然他说自己有 <a href="https://twitter.com/clattner_llvm/status/877353276676612102" target="_blank" rel="noopener">七年 Swift 开发经验</a>，但我估计大部分公司还是想找一个有十年经验的 <code>¯\_(ツ)_/¯</code></p><p>Xcode 9 和 Swift 4 现在还在测试阶段，现在是一个回顾所有提案的好机会，看一看 <a href="https://twitter.com/ecerney" target="_blank" rel="noopener">Eric Cerney</a> 总结出来的 <a href="https://www.raywenderlich.com/163857/whats-new-swift-4" target="_blank" rel="noopener">What’s New in Swift 4?</a>。</p><p><a href="https://twitter.com/aciidb0mb3r/status/877653585844031493" target="_blank" rel="noopener">Ankit Aggarwal</a> 在 Swift 的博客里写了一篇 <a href="https://swift.org/blog/swift-package-manager-manifest-api-redesign/" target="_blank" rel="noopener">重新设计 Swift Package Manager 的 API</a>，讲述新的 API 设计。Swift 的 package 描述是使用 Swift 写的，新的 API / 格式现在已经更新到了最新的语言设计规范。</p><h2 id="提交和合并的请求"><a href="#提交和合并的请求" class="headerlink" title="提交和合并的请求"></a>提交和合并的请求</h2><p>Philippe Hausler 提了一些关于 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0170-nsnumber_bridge.md" target="_blank" rel="noopener">SE-0170: NSNumber 与数字类型的桥接</a> 的<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170612/037499.html" target="_blank" rel="noopener">反馈</a>，主要是与 Float 和 Double 有关。如果你之前被浮点数的精度问题困扰过的话，可以查看<a href="https://github.com/apple/swift/commit/c358afe6555e5e32633e879f96a3664dc7a5f3dc" target="_blank" rel="noopener">“减少Double 和 Float 桥接的约束条件”的 commit</a>.</p><p>Swift 迁移工具已经 merge 到仓库里了！迁移工具的核心就是把一个文件作为输入，然后输出一份文件，包含了所有修改建议，具体细节请查看 <a href="https://github.com/apple/swift/tree/master/lib/Migrator" target="_blank" rel="noopener">Swift migrator library</a> 文件夹。</p><p>Swift 4 里大家最喜欢的 <code>Encodable</code> 协议，<a href="https://github.com/apple/swift/pull/10321" target="_blank" rel="noopener">添加了对于 non-strong（weak，unowned，unmanaged）属性的支持</a>。</p><p>Swift 问题追踪的第二个 bug 终于终于被修复了！🎉 <a href="https://bugs.swift.org/browse/SR-2" target="_blank" rel="noopener">SR-2</a> 和 <a href="https://bugs.swift.org/browse/SR-4196" target="_blank" rel="noopener">SR-4196</a> 描述了 switch 语法嵌入到 <code>#if</code> / <code>#endif</code> 里的时候不能很好地运行，<a href="https://github.com/apple/swift/pull/9457/commits/5d478bdb3b7638f5df6f0e1f4e574bececae9b80" target="_blank" rel="noopener">最近的一个 commit</a> 终于修复了这个问题.</p><p>Xcode 9 里你可以使用 <a href="https://developer.apple.com/documentation/code_diagnostics/undefined_behavior_sanitizer" target="_blank" rel="noopener">Undefined Behavior Sanitizer</a> 检测所有未定义行为，<a href="https://developer.apple.com/documentation/code_diagnostics/main_thread_checker" target="_blank" rel="noopener">Main Thread Checker</a> 利用现有的 Address Sanitizer 和 Thread Sanitizer 来检测在非主线程刷新 UI 的行为，而。这些新功能都已经 <a href="https://github.com/apple/swift-lldb/pull/211/commits" target="_blank" rel="noopener">merge 到 swift-lldb 里了</a>，如果你感兴趣的话可以去看源代码。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><p>作为<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/015920.html" target="_blank" rel="noopener">这篇去年发布的文章</a>的跟进，<a href="https://github.com/erica" target="_blank" rel="noopener">Erica Sadun</a>，<a href="https://github.com/AliSoftware" target="_blank" rel="noopener">Olivier Halligon</a>，<a href="https://github.com/calebd" target="_blank" rel="noopener">Caleb Davenport</a> 和 <a href="https://github.com/KingOfBrian" target="_blank" rel="noopener">Brian King</a> 提交了一个<a href="https://github.com/erica/swift-evolution/blob/2f2778797ceb9edc0b8acd3b68af5f81f9a95775/proposals/XXXX-role-keywords.md" target="_blank" rel="noopener">关于 protocol extention 函数的 “role keywords” 的提案草稿</a>。主要是讲了重写 protocol extension 里的函数时，需要加上一个关键字显式地声明这是一个 override 行为。</p><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0110-distingish-single-tuple-arg.md" target="_blank" rel="noopener">SE-0110</a> 想要让多个参数 <code>(String, Int)</code>  的函数和单个元组 <code>(String, Int)</code> 参数区分开来。他们看起来是不是一样？就像 Doug Gregor 在邮件列表里提到的，<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170619/037616.html" target="_blank" rel="noopener">这个修改会让编译过程变得有点复杂：</a></p><blockquote><p>Swift 4 已经实现了超出 SE-0110 的内容了，特别对于闭包来说，使用体验差了很多。  </p><p>[…]  </p><p>Swift 核心团队觉得这些使用体验的牺牲对于 Swift 4 来说是不可接受的。已经有好几个计划内的解决方案，给闭包提供一个更好的模型，解决用户体验的问题，但完整的设计和实现已经超出了 Swift 4 的开发目标了。所以，我们打算“回滚” SE-0110 在 Swift 4关于函数参数的修改。  </p></blockquote><p>没人可以预知未来，很难了解这些提案对于 Swift 的影响，但这也是为什么我们有 snapshots builds 和 beta 版本。至于说 <a href="http://ericasadun.com/2017/06/20/more-on-se-0110-important-fallout-please-read/" target="_blank" rel="noopener">SE-0110 带来的影响</a> ，我觉得我们应该全部参与进社区里，去鼓励 <a href="https://twitter.com/austinzheng/status/877054901620101120" target="_blank" rel="noopener">Austin Zheng</a>（SE-0110 的作者）继续坚持下去。</p><p>没有新的提案，但照例，更多细节请查看 <a href="https://apple.github.io/swift-evolution/" target="_blank" rel="noopener">Swift Evolution status page</a>。</p><h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>还记得 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md" target="_blank" rel="noopener">SE-0104: Protocol-oriented integers</a> 吗？<a href="https://github.com/xwu" target="_blank" rel="noopener">Xiaodi Wu</a> 最近写了一些优化实现方式的<a href="https://gist.github.com/xwu/d68baefaae9e9291d2e65bd12ad51be2" target="_blank" rel="noopener">想法和建议</a>。</p><p>Halen Wooten 开了一个新的<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170619/004829.html" target="_blank" rel="noopener">讨论</a>，讨论作为社区的成员该如何为社区贡献。我知道邮件列表的界面很粗糙，但查看<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170619/thread.html#4829" target="_blank" rel="noopener">整个讨论</a>总能有一些收获。根据<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170619/004833.html" target="_blank" rel="noopener">文档</a><a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170619/004835.html" target="_blank" rel="noopener">尽量使用增量编译节省时间</a>，我希望类似的这些技巧可以收集起来做成一份入门指南。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>学完 Swift 之后，你会希望做出什么样的语言？<a href="https://twitter.com/slava_pestov/status/875150641269571584" target="_blank" rel="noopener">例如这个</a>，<a href="https://twitter.com/slava_pestov/status/875153089174446080" target="_blank" rel="noopener">可能直接把访问权限去掉</a>? 😱</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Swift 周报
    
    </summary>
    
      <category term="Swift 进阶" scheme="https://swift.gg/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Jesse Squires" scheme="https://swift.gg/tags/Jesse-Squires/"/>
    
  </entry>
  
  <entry>
    <title>Sprite Kit 教程：二维图形动画</title>
    <link href="https://swift.gg/2017/07/20/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/07/20/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/</id>
    <published>2017-07-20T00:00:00.000Z</published>
    <updated>2018-05-18T10:46:06.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/sprite-movement-actions-sprite-kit-ios-tutorial-ios10" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-04-18<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="noopener">Crystal Sun</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><p>Sprite Kit 里，精灵（译者注：精灵的英文单词为 Sprite，计算机图形学，指包含于场景中的二维图像或动画）运动的机制是使用动作（actions）。将某种类型的动作添加到一个节点（node）上，Sprite Kit 自动更新位置直到动作完成。更棒的是，可以将多个动作（actions）组合起来。在本节教程中，我们将学习如何给精灵添加动作。本节教程使用 Xcode 8.3 和 iOS 10.3。<br><a id="more"></a></p><h3 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h3><p>打开 Xcode，使用 Game 模板创建工程。</p><p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/xcode-game-templateformat=1500w1500530564.45" alt=""></p><p>Product Name 使用 <strong>SpriteKitActionsTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p><p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/spritekit-actions-projectformat=1500w1500530565.94" alt=""></p><p>本节教程需要一个精灵，所以<a href="https://www.ioscreator.com/s/Apple.png" target="_blank" rel="noopener">下载</a>图片，将图片放到 Assets 目录中。</p><p>打开 <strong>GameViewController.swift</strong> 文件，按如下所示修改 <strong>viewDidLoad</strong> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> scene = <span class="type">GameScene</span>(size: <span class="type">CGSize</span>(width:<span class="number">750</span>, height: <span class="number">1334</span>))</span><br><span class="line">    scene.scaleMode = .aspectFill</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> skView = <span class="keyword">self</span>.view <span class="keyword">as</span>! <span class="type">SKView</span></span><br><span class="line">    skView.presentScene(scene)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gameScene 场景创建好了。打开 <strong>GameScene</strong> 文件，已经定义好了 GameScene 类，删除所有的代码，然后如下所示添加 <strong>didMove(to:)</strong> 方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didMove</span><span class="params">(to view: SKView)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> apple = <span class="type">SKSpriteNode</span>(imageNamed: <span class="string">"Apple.png"</span>)</span><br><span class="line">    apple.position = <span class="type">CGPoint</span>(x: size.width/<span class="number">2</span>, y: size.height/<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">self</span>.addChild(apple)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Apple.png 图片赋给变量 apple，将其居中添加到当前场景。<strong>运行</strong>工程，可以看到苹果已经居中出现在屏幕上了。</p><p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/center-spritekit-simulatorformat=750w1500530566.73" alt=""></p><p>为了让该精灵运动，需要创建一个运动动作（move action），让该精灵运行此运动动作。将下列代码添加到 <strong>didMove(to:)</strong> 方法的尾部：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> moveBottomLeft = <span class="type">SKAction</span>.move(to: <span class="type">CGPoint</span>(x: <span class="number">100</span>,y: <span class="number">100</span>), duration:<span class="number">2.0</span>)</span><br><span class="line">apple.run(moveBottomLeft)</span><br></pre></td></tr></table></figure><p><strong>运行</strong>工程，精灵会从中间移动到左下角，耗时 2 秒。</p><p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/bottomleft-spritekit-simulatorformat=750w1500530567.46" alt=""></p><p><strong>moveTo:duration</strong> 方法使用的是绝对位置，想让精灵移动到相对的位置，只需要使用 moveBy 变量（To move the sprite relative of the current position you can use the moveBy variant，这句翻译不确定）。只需改变一下两行代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> moveRight = <span class="type">SKAction</span>.moveBy(x: <span class="number">50</span>, y:<span class="number">0</span>, duration:<span class="number">1.0</span>)</span><br><span class="line">apple.run(moveRight)</span><br></pre></td></tr></table></figure><p>这会让精灵向右移动 50 points。使用 sequence（连贯） 可以将将动作连起来。删除 run 这行代码，添加下面的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> moveBottom = <span class="type">SKAction</span>.moveBy(x: <span class="number">0</span>, y:-<span class="number">100</span>, duration:<span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">let</span> sequence = <span class="type">SKAction</span>.sequence([moveRight, moveBottom])</span><br><span class="line">        </span><br><span class="line">apple.run(sequence)</span><br></pre></td></tr></table></figure><p><strong>运行</strong>，可以看到连贯的动作。</p><p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/sequence-spritekit-simulatorformat=750w1500530568.15" alt=""></p><p>通过调用 <strong>reversedAction</strong>，有些动作可以做反向处理，也就是说，新动作是之前旧动作的相反方向。删除 sequence 这行代码然后填写下列代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reversedMoveBottom = moveBottom.reversed()</span><br><span class="line"><span class="keyword">let</span> sequence = <span class="type">SKAction</span>.sequence([moveRight, moveBottom, reversedMoveBottom])</span><br></pre></td></tr></table></figure><p><strong>运行</strong>工程，这时可以看到 moveBottom 动作后面跟着一个相反的动作。还可以让动作重复多次或者无限循环，删除 run 这行代码添加下列代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> endlessAction = <span class="type">SKAction</span>.repeatForever(sequence)</span><br><span class="line">apple.run(endlessAction)</span><br></pre></td></tr></table></figure><p><strong>运行</strong>工程，这些动作会无限循环。</p><p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/repeat-forever-spritekit-simulatorformat=750w1500530569.94" alt=""></p><p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="noopener">github</a> 上下载 <strong>SpriteKitActionsTutorial</strong> 教程的源代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Sprite Kit 教程：二维图形动画
    
    </summary>
    
      <category term="iOS 开发" scheme="https://swift.gg/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="IOSCREATOR" scheme="https://swift.gg/tags/IOSCREATOR/"/>
    
  </entry>
  
  <entry>
    <title>TableViewController 的最佳实践</title>
    <link href="https://swift.gg/2017/07/19/the-best-table-view-controller-mar-2016-edition/"/>
    <id>https://swift.gg/2017/07/19/the-best-table-view-controller-mar-2016-edition/</id>
    <published>2017-07-19T00:00:00.000Z</published>
    <updated>2018-05-18T10:46:06.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Dominik Hauser，<a href="http://swiftandpainless.com/the-best-table-view-controller-mar-2016-edition/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016-03-28<br>译者：<a href="undefined">Doye</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><p>在阅读 <a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/" target="_blank" rel="noopener">obc.io关于轻量级的viewConroller相关讨论</a>之后，每隔几个月我都会反思怎样做才是TableviewController 的最佳实践，我曾经尝试过几种不同的方法包括把 datasource 和 delefate 放到一个独立的类中或者使用 MVVM 架构来对 Cell 进行定制。</p><p>本篇是在 2016 年我对这个问题的思索，而且我对这个方案十分满意，方案涉及到了泛型，协议，和值类型。<br><a id="more"></a></p><p>最主要的一部分是 TableviewController 的基类，它管理着模型数据存储的数组，还需要注册 Cell 类和实现 tableView 所需要的 datasoure 相关的函数。</p><p>我们的类定义如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>&lt;<span class="title">T</span>, <span class="title">Cell</span>: <span class="title">UITableViewCell</span> <span class="title">where</span> <span class="title">Cell</span>: <span class="title">Configurable</span>&gt;: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个我们设计的基类是一个 <strong>UITableViewController</strong> 的子类，形参 *Cell<strong> 是一个遵循 </strong>Configurable<strong> 协议的 </strong>UITableViewCell**，这个协议十分简单：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Configurable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">config</span><span class="params">(withItem item: Any)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Cell 将会在 <strong>TableViewController</strong> 中注册然后塞进队列，对于这个 Cell 的 identifier 我们可以有一个私有属性的对应：</p><p>然后我们需要一个数组来存储要在 table View 中要展示的数据：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="type">T</span>]() &#123;</span><br><span class="line">  <span class="keyword">didSet</span> &#123;</span><br><span class="line">    tableView.reloadData()</span><br><span class="line">    <span class="keyword">if</span> tableView.numberOfRowsInSection(<span class="number">0</span>) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      tableView.scrollToRowAtIndexPath(<span class="type">NSIndexPath</span>(forRow: <span class="number">0</span>,inSection: <span class="number">0</span>),</span><br><span class="line">                                       atScrollPosition: .<span class="type">Top</span>,</span><br><span class="line">                                       animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论数据什么时候被更新，在列表视图中的 <strong>reloadData()</strong> 方法会被调用，而且整个列表视图将上滑至顶部，下面我们定义初始化方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123; <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>) &#125;</span><br></pre></td></tr></table></figure><p>在 <strong>viewDidLoad()</strong> 之中我们对于 TableView 进行设置：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  tableView.registerClass(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: cellIdentifier)</span><br><span class="line">  tableView.rowHeight = <span class="type">UITableViewAutomaticDimension</span></span><br><span class="line">  tableView.estimatedRowHeight = <span class="number">60</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是对 <strong>UITableViewDataSource</strong> 进行补全：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(cellIdentifier,</span><br><span class="line">                                                         forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span></span><br><span class="line">  cell.config(withItem: data[indexPath.row])</span><br><span class="line">  <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一个需要注意的部分是 <strong>cell.config(withItem: data[indexPath.row])</strong> 这意味着 cell 将负责其内部各种控件展示的内容的填充。</p><p>这里是完整的基类的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>&lt;<span class="title">T</span>, <span class="title">Cell</span>: <span class="title">UITableViewCell</span> <span class="title">where</span> <span class="title">Cell</span>: <span class="title">Configurable</span>&gt;: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> cellIdentifier = <span class="type">String</span>(<span class="type">Cell</span>)</span><br><span class="line">  <span class="keyword">var</span> data = [<span class="type">T</span>]() &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">      tableView.reloadData()</span><br><span class="line">      <span class="keyword">if</span> tableView.numberOfRowsInSection(<span class="number">0</span>) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        tableView.scrollToRowAtIndexPath(<span class="type">NSIndexPath</span>(forRow: <span class="number">0</span>,inSection: <span class="number">0</span>),</span><br><span class="line">                                         atScrollPosition: .<span class="type">Top</span>,</span><br><span class="line">                                         animated: <span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>() &#123; <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>) &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    tableView.registerClass(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: cellIdentifier)</span><br><span class="line">    tableView.rowHeight = <span class="type">UITableViewAutomaticDimension</span></span><br><span class="line">    tableView.estimatedRowHeight = <span class="number">60</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// MARK: - Table view data source</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">count</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView,</span></span></span><br><span class="line"><span class="function"><span class="params">                          cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(cellIdentifier,</span><br><span class="line">                                                           forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span></span><br><span class="line">    cell.config(withItem: data[indexPath.row])</span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以利用这个基类来定义一个 TableViewController 来实现让用户输入一个字符串对于 Github 的用户来进行匹配查找：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSearchTableViewController</span>&lt;<span class="title">T</span>: <span class="title">protocol</span>&lt;<span class="title">DictCreatable</span>, <span class="title">LabelsPresentable</span>, <span class="title">UserProtocol</span>&gt;&gt;: <span class="title">TableViewController</span>&lt;<span class="title">T</span>, <span class="title">TwoLabelCell</span>&gt;, <span class="title">UISearchBarDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> searchString: <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> searchString = searchString <span class="keyword">where</span> searchString.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">      <span class="keyword">let</span> fetch = <span class="type">APIClient</span>&lt;<span class="type">T</span>&gt;().fetchUsers(forSearchString: searchString)</span><br><span class="line">      fetch &#123; (items, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> theItems = items <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.data = theItems.<span class="built_in">map</span> &#123; $<span class="number">0</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    title = <span class="string">"User"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> searchBar = <span class="type">UISearchBar</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: view.frame.size.width, height: <span class="number">40</span>))</span><br><span class="line">    searchBar.placeholder = <span class="string">"Github username"</span></span><br><span class="line">    searchBar.delegate = <span class="keyword">self</span></span><br><span class="line">    tableView.tableHeaderView = searchBar</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">searchBarSearchButtonClicked</span><span class="params">(searchBar: UISearchBar)</span></span> &#123;</span><br><span class="line">    searchBar.resignFirstResponder()</span><br><span class="line">    searchString = searchBar.text</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> next = <span class="type">RepositoriesTableViewController</span>&lt;<span class="type">Repository</span>&gt;()</span><br><span class="line">    next.username = <span class="keyword">self</span>.data[indexPath.row].name</span><br><span class="line">    navigationController?.pushViewController(next, animated: <span class="literal">true</span>)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上便是一个完整的 TableViewController，大部分的代码对于 searchBar 的展示和逻辑处理，是不是很简洁？</p><p>我们会这样来初始化 <strong>UserSearchTableViewController</strong>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> viewController = <span class="type">UserSearchTableViewController</span>&lt;<span class="type">User</span>&gt;()</span><br></pre></td></tr></table></figure><p>最后，这里是 <strong>TwoLabelCell</strong> 我自己的实现</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoLabelCell</span>: <span class="title">UITableViewCell</span>, <span class="title">Configurable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nameLabel: <span class="type">UILabel</span></span><br><span class="line">  <span class="keyword">let</span> descriptionLabel: <span class="type">UILabel</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCellStyle</span>, reuseIdentifier: <span class="type">String</span>?) &#123;</span><br><span class="line">    nameLabel = <span class="type">UILabel</span>()</span><br><span class="line">    nameLabel.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleHeadline</span>)</span><br><span class="line">    </span><br><span class="line">    descriptionLabel = <span class="type">UILabel</span>()</span><br><span class="line">    descriptionLabel.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleSubheadline</span>)</span><br><span class="line">    descriptionLabel.numberOfLines = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> stackView = <span class="type">UIStackView</span>(arrangedSubviews: [nameLabel, descriptionLabel])</span><br><span class="line">    stackView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    stackView.axis = .<span class="type">Vertical</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line">    </span><br><span class="line">    addSubview(stackView)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> views = [<span class="string">"stackView"</span>: stackView]</span><br><span class="line">    <span class="keyword">var</span> layoutConstraints = [<span class="type">NSLayoutConstraint</span>]()</span><br><span class="line">    layoutConstraints += <span class="type">NSLayoutConstraint</span>.constraintsWithVisualFormat(<span class="string">"|-[stackView]-|"</span>, options: [], metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line">    layoutConstraints += <span class="type">NSLayoutConstraint</span>.constraintsWithVisualFormat(<span class="string">"V:|-[stackView]-|"</span>, options: [], metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line">    <span class="type">NSLayoutConstraint</span>.activateConstraints(layoutConstraints)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">config</span><span class="params">(withItem item: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> item = item <span class="keyword">as</span>? <span class="type">LabelsPresentable</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> texts = item.texts</span><br><span class="line">    <span class="keyword">if</span> texts.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">      nameLabel.text = texts[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> texts.<span class="built_in">count</span> &gt; <span class="number">1</span> &amp;&amp; texts[<span class="number">1</span>].characters.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">      descriptionLabel.text = texts[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="https://github.com/dasdom/TableViewMarch2016" target="_blank" rel="noopener">Github</a>有源码还有另一个遵循类似架构的 TableViewController 实例</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      TableViewController的最佳实践
    
    </summary>
    
      <category term="iOS 开发" scheme="https://swift.gg/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Swift And Painless" scheme="https://swift.gg/tags/Swift-And-Painless/"/>
    
  </entry>
  
  <entry>
    <title>如何检测摇一摇手势</title>
    <link href="https://swift.gg/2017/07/18/detect-shake-gestures-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/07/18/detect-shake-gestures-ios-tutorial-ios10/</id>
    <published>2017-07-18T00:00:00.000Z</published>
    <updated>2018-05-18T10:46:06.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/detect-shake-gestures-ios-tutorial-ios10" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-04-18<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="noopener">Crystal Sun</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><p>iOS 设备可以检测摇一摇手势，在本节教程中，我们将学习如何检测摇一摇手势，检测到该手势后，更新 label 的文案。本节教程使用的是 Xcode 8.3 和 iOS 10.3。<br><a id="more"></a></p><h3 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h3><p>打开 Xcode，创建一个 Single View Application。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/single-view-xcode-templateformat=1500w1500341429.27" alt=""></p><p>Product Name 使用 <strong>IOS10ShakeGestureTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-gesture-projectformat=1500w1500341431.78" alt=""></p><p>打开 <strong>Storyboard</strong>，从 Object Library 中拖拽一个 Label 控件放到 View Controller 上，双击 Label 控件将文案修改为 <em>“Shake me”</em>。选中该 Label，点击 Auto Layout 的 Align 按钮。选中 “Horizontally in Container”，点击 “Add 1 Constraint”。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/auto-layout-horizontally-in-containerformat=750w1500341433.06" alt=""></p><p>选中 Label，点击 Auto Layout 的 Pin 按钮，选中上边距约束线，点击 “Add 1 Constraint”。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/auto-layout-pin-to-topformat=750w1500341433.89" alt=""></p><p>Storyboard 看起来应如下图所示。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-gesture-storyboardformat=1000w1500341434.83" alt=""></p><p>打开 Assistant Editor，确保 <strong>ViewController.swift</strong> 可见。按住 Control 键，将 Label 拖拽到 ViewController 类下，创建下图的 Outlet。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-label-outletformat=750w1500341435.62" alt=""></p><p>打开 ViewController.swift 文件，首先要让 View Controller 回应点击事件，可以通过 ViewController FirstResponder 实现，添加下列方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">becomeFirstResponder</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，要想检测摇一摇手势，添加 <strong>motionEnded(_:with:)</strong> 方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">motionEnded</span><span class="params">(<span class="number">_</span> motion: UIEventSubtype, with event: UIEvent?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> motion == .motionShake &#123;</span><br><span class="line">        shakeLabel.text = <span class="string">"Shaken, not stirred"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果确实是一个 Shake Gesture（摇一摇），那么 Label 的文案就会更新。运行工程，摇一摇测试机。可以点击 iOS 模拟器菜单栏 Hardware 选项下的 Shake Gesture 来摇一摇。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-gesture-simulatorformat=750w1500341436.36" alt=""></p><p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="noopener">github</a> 上下载 <strong>IOS10ShakeGestureTutorial</strong> 教程的源代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      如何检测摇一摇手势
    
    </summary>
    
      <category term="iOS 开发" scheme="https://swift.gg/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="IOSCREATOR" scheme="https://swift.gg/tags/IOSCREATOR/"/>
    
  </entry>
  
</feed>
