<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftGG</title>
  
  <subtitle>走心的 Swift 翻译组</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swift.gg/"/>
  <updated>2018-10-11T13:39:19.296Z</updated>
  <id>https://swift.gg/</id>
  
  <author>
    <name>SwiftGG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 类型擦除</title>
    <link href="https://swift.gg/2018/10/11/friday-qa-2017-12-08-type-erasure-in-swift/"/>
    <id>https://swift.gg/2018/10/11/friday-qa-2017-12-08-type-erasure-in-swift/</id>
    <published>2018-10-11T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：<a href="https://www.mikeash.com" target="_blank" rel="noopener">Mike Ash</a>，<a href="https://www.mikeash.com/pyblog/friday-qa-2017-12-08-type-erasure-in-swift.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-12-18<br>译者：<a href="https://github.com/rsenjoyer" target="_blank" rel="noopener">rsenjoyer</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>你也许曾听过<strong>类型擦除</strong>，甚至也使用过标准库提供的类型擦除类型如 <code>AnySequence</code>。但到底什么是类型擦除? 如何自定义类型擦除? 在这篇文章中，我将讨论如何使用类型擦除以及如何自定义。在此感谢 Lorenzo Boaro 提出这个主题。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时你想对外部调用者隐藏某个类的具体类型，或是一些实现细节。在一些情况下，这样做能防止静态类型在项目中滥用，或者保证了类型间的交互。类型擦除就是移除某个类的具体类型使其变得更通用的过程。</p><p>协议或抽象父类可作为类型擦除简单的实现方式之一。例如 <code>NSString</code> 就是一个例子，每次创建一个 <code>NSString</code> 实例时，这个对象并不是一个普通的 <code>NSString</code> 对象，它通常是某个具体的子类的实例，这个子类一般是私有的，同时这些细节通常是被隐藏起来的。你可以使用子类提供的功能而不用知道它具体的类型，你也没必要将你的代码与它们的具体类型联系起来。</p><p>在处理 Swift 泛型以及关联类型协议的时候，可能需要使用一些高级的内容。Swift 不允许把协议当做具体的类型来使用。例如， 如果你想编写一个方法，他的参数是一个包含了<code>Int</code> 的序列，那么下面这种做法是不正确的:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(seq: Sequence&lt;Int&gt;)</span></span> &#123; ...</span><br></pre></td></tr></table></figure><p>你不能这样使用协议类型，这样会在编译时报错。但你可以使用泛型来替代协议, 解决这个问题: </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>&lt;S: Sequence&gt;<span class="params">(seq: S)</span></span> <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> == <span class="type">Int</span> &#123; ...</span><br></pre></td></tr></table></figure><p>有时候这样写完全可以，但有些地方还存在一些比较麻烦的情况，通常你不可能只在一个地方添加泛型: 一个泛型函数对其他泛型要求更多… 更糟糕的是，你不能将泛型作为返回值或者属性。这就跟我们想的有点不一样了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span>&lt;S: Sequence&gt;<span class="params">()</span></span> -&gt; <span class="type">S</span> <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> == <span class="type">Int</span> &#123; ...</span><br></pre></td></tr></table></figure><p>我们希望函数 <code>g</code> 能返回任何符合的类型，但上面这个不同，它允许调用者选择他所需要的类型，然后函数 <code>g</code> 来提供一个合适的值。</p><p>Swift 标准库中提供了 <code>AnySequence</code> 来帮助我们解决这个问题。<code>AnySequence</code> 包装了一个任意类型的序列，并擦除了它的类型。使用 <code>AnySequence</code> 来访问这个序列，我们来重写一下函数 <code>f</code> 与 函数 <code>g</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(seq: AnySequence&lt;Int&gt;)</span></span> &#123; ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> -&gt; <span class="type">AnySequence</span>&lt;<span class="type">Int</span>&gt; &#123; ...</span><br></pre></td></tr></table></figure><p>泛型部分不见了，同时具体的类型也被隐藏起来了。由于使用了 <code>AnySequence</code> 包装具体的值，它带来了一定的代码复杂性以及运行时间成本。但是代码却更简洁了。</p><p>Swift 标准库中提供了很多这样的类型，如 <code>AnyCollection</code>、<code>AnyHashable</code> 及 <code>AnyIndex</code>。这些类型在你自定义泛型或协议的时候非常的管用，你也可以直接使用这些类型来简化你的代码。接下来让我们探索实现类型擦除的多种方式吧。</p><h2 id="基于类的类型擦除"><a href="#基于类的类型擦除" class="headerlink" title="基于类的类型擦除"></a>基于类的类型擦除</h2><p>有时我们需要在不暴露类型信息的情况下从多个类型中包装一些公共的功能，这听起来就像是父类-子类的关系。事实上我们的确可以使用抽象父类来实现类型擦除。父类提供 API 接口，不用去管谁来实现。而子类根据具体的类型信息实现相应的功能。</p><p>接下来我们将使用这种方式来自定义 <code>AnySequence</code>，我们将其命名为 <code>MAnySequence</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MAnySequence</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Sequence</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>这个类需要一个 <code>iterator</code> 类型作为 <code>makeIterator</code> 返回类型。我们必须要做两次类型擦除来隐藏底层的序列类型以及迭代器的类型。我们在 <code>MAnySequence</code> 内部定义了一个 <code>Iterator</code> 类，该类遵循着 <code>IteratorProtocol</code> 协议，并在  <code>next()</code> 方法中使用 <code>fatalError</code> 抛出异常。Swift 本身不支持抽象类型，但这样也够了:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Must override next()"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MAnySequence</code> 对 <code>makeIterator</code> 方法实现也差不多。直接调用将抛出异常，这用来提示子类需要重写这个方法:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Iterator</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Must override makeIterator()"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就定义了一个基于类的类型擦除的API，私有的子类将来实现这些API。公共类通过元素类型参数化，但私有实现类由它包装的序列类型进行参数化:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MAnySequenceImpl</span>&lt;<span class="title">Seq</span>: <span class="title">Sequence</span>&gt;: <span class="title">MAnySequence</span>&lt;<span class="title">Seq</span>.<span class="title">Element</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure><p><code>MAnySequenceImpl</code> 需要一个继承于 <code>Iterator</code> 的子类:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorImpl</span>: <span class="title">Iterator</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><code>IteratorImpl</code> 包装了序列的迭代器:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wrapped: <span class="type">Seq</span>.<span class="type">Iterator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(<span class="number">_</span> wrapped: <span class="type">Seq</span>.<span class="type">Iterator</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.wrapped = wrapped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>next</code> 方法中调用被包装的序列迭代器：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Seq</span>.<span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> wrapped.next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相似地，<code>MAnySequenceImpl</code> 包装一个序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> seq: <span class="type">Seq</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(<span class="number">_</span> seq: <span class="type">Seq</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.seq = seq</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从序列中获取迭代器，然后将迭代器包装成 <code>IteratorImpl</code> 对象返回，这样就实现了 <code>makeIterator</code> 的功能。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">IteratorImpl</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">IteratorImpl</span>(seq.makeIterator())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要一种方法来实际创建这些东西: 对 <code>MAnySequence</code> 添加一个静态方法，该方法创建一个 <code>MAnySequenceImpl</code> 实例，并将其作为 <code>MAnySequence</code> 类型返回给调用者。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MAnySequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">make</span>&lt;Seq: Sequence&gt;<span class="params">(<span class="number">_</span> seq: Seq)</span></span> -&gt; <span class="type">MAnySequence</span>&lt;<span class="type">Element</span>&gt; <span class="keyword">where</span> <span class="type">Seq</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MAnySequenceImpl</span>&lt;<span class="type">Seq</span>&gt;(seq)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际开发中，我们可能会做一些额外的操作来让 <code>MAnySequence</code> 提供一个初始化方法。</p><p>我们来试试 <code>MAnySequence</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInts</span><span class="params">(<span class="number">_</span> seq: MAnySequence&lt;Int&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> elt <span class="keyword">in</span> seq &#123;</span><br><span class="line">        <span class="built_in">print</span>(elt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">printInts(<span class="type">MAnySequence</span>.make(array))</span><br><span class="line">printInts(<span class="type">MAnySequence</span>.make(array[<span class="number">1</span> ..&lt; <span class="number">4</span>]))</span><br></pre></td></tr></table></figure><p>完美!</p><h2 id="基于函数的类型擦除"><a href="#基于函数的类型擦除" class="headerlink" title="基于函数的类型擦除"></a>基于函数的类型擦除</h2><p>有时我们希望对外暴露支持多种类型的方法，但又不想指定具体的类型。一个简单的办法就是，存储那些签名仅涉及到我们想公开的类型的函数，函数主体在底层已知具体实现类型的上下文中创建。</p><p>我们一起看看如何运用这种方法来设计 <code>MAnySequence</code>，与前面的实现很类似。它是一个结构体而非类，这是因为它仅仅作为容器使用，不需要有任何的继承关系。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAnySequence</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Sequence</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>跟之前一样，<code>MAnySequence</code> 也需要一个可返回的迭代器（Iterator）。迭代器同样被设计为结构体，并持有一个参数为空并返回 <code>Element?</code> 的存储型属性，实际上这个属性是一个函数，被用于 <code>IteratorProtocol</code> 协议的 <code>next</code> 方法中。接下来 <code>Iterator</code> 遵循 <code>IteratorProtocol</code> 协议，并在 <code>next</code> 方法中调用函数:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Iterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _next: () -&gt; <span class="type">Element</span>?</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> _next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MAnySequence</code> 与 <code>Iterator</code> 很相似: 持有一个参数为空返回 <code>Iterator</code> 类型的存储型属性。遵循 <code>Sequence</code> 协议并在 <code>makeIterator</code> 方法中调用这个属性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _makeIterator: () -&gt; <span class="type">Iterator</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _makeIterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MAnySequence</code> 的构造函数正是魔法起作用的地方，它接收任意序列作为参数: </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>&lt;<span class="type">Seq</span>: <span class="type">Sequence</span>&gt;(<span class="number">_</span> seq: <span class="type">Seq</span>) <span class="keyword">where</span> <span class="type">Seq</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br></pre></td></tr></table></figure><p>接下来需要在构造函数中包装此序列的功能:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">_makeIterator = &#123;</span><br></pre></td></tr></table></figure><p>如何生成迭代器？请求 <code>Seq</code> 序列生成:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iterator = seq.makeIterator()</span><br></pre></td></tr></table></figure><p>接下来我们利用自定义的迭代结构体包装序列生成的迭代器，包装后的 <code>_next</code> 属性将会在迭代器协议的 <code>next()</code> 方法中被调用:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="type">Iterator</span>(_next: &#123; iterator.next() &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来展示如何使用 <code>MAnySequence</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInts</span><span class="params">(<span class="number">_</span> seq: MAnySequence&lt;Int&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> elt <span class="keyword">in</span> seq &#123;</span><br><span class="line">        <span class="built_in">print</span>(elt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">printInts(<span class="type">MAnySequence</span>(array))</span><br><span class="line">printInts(<span class="type">MAnySequence</span>(array[<span class="number">1</span> ..&lt; <span class="number">4</span>]))</span><br></pre></td></tr></table></figure><p>正确运行，太棒了！</p><p>当需要将小部分功能包装为更大类型的一部分时，这种基于函数的类型擦除方法特别实用，这样做就不需要有单独的类来实现被擦除类型的这部分功能了。</p><p>比方说你现在想要编写一些适用于各种集合类型的代码，但它真正需要能够对这些集合执行的操作是获取计数并执行从零开始的整数下标。如访问 <code>tableView</code> 数据源。它可能看起来像这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericDataSource</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">count</span>: () -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> getElement: (<span class="type">Int</span>) -&gt; <span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">C</span>: <span class="type">Collection</span>&gt;(<span class="number">_</span> <span class="built_in">c</span>: <span class="type">C</span>) <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Element</span> == <span class="type">Element</span>，<span class="type">C</span>.<span class="type">Index</span> == <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="built_in">count</span> = &#123; <span class="built_in">c</span>.<span class="built_in">count</span> &#125;</span><br><span class="line">        getElement = &#123; <span class="built_in">c</span>[$<span class="number">0</span> - <span class="built_in">c</span>.startIndex] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GenericDataSource</code> 其他代码可通过调用 <code>count()</code> 或 <code>getElement()</code> 来操作传入的集合。且不会让集合类型破坏 <code>GenericDataSource</code> 泛型参数。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>类型擦除是一种非常有用的技术，它可用来阻止泛型对代码的侵入，也可用来保证接口简单明了。通过将底层类型包装起来，将API与具体的功能进行拆分。这可以通过使用抽象的公共超类和私有子类或将 API 包装在函数中来实现。对于只需要一些功能的简单情况，基于函数类型擦除极其有效。</p><p>Swift 标准库提供了几种可直接利用的类型擦除类型。如 <code>AnySequence</code> 包装一个 <code>Sequence</code>，正如其名，<code>AnySequence</code> 允许你对序列迭代而无需知道序列具体的类型。<code>AnyIterator</code> 也是类型擦除的类型，它提供一个类型擦除的迭代器。<code>AnyHashable</code> 也同样是类型擦除的类型，它提供了对Hashable类型访问功能。Swift 还有很多基于集合的擦除类型，你可以通过搜索 <code>Any</code> 来查阅。标准库中也为 <code>Codable</code> API 设计了类型擦除类型: <code>KeyedEncodingContainer</code> 和 <code>KeyedDecodingContainer</code>。它们都是容器协议类型包装器，可用来在不知道底层具体类型信息的情况下实现 <code>Encode</code> 和 <code>Decode</code>。</p><p>这就是今天全部的内容了，下次再见。你们的建议对 Friday Q&amp;A 是最好的鼓励，所以如果你关于这个主题有什么好的想法，请 <a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发邮件到这里</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      详细说明 Swift 类型擦除
    
    </summary>
    
      <category term="iOS" scheme="https://swift.gg/categories/iOS/"/>
    
      <category term="iOS 开发" scheme="https://swift.gg/categories/iOS/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="教程" scheme="https://swift.gg/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Tagged Pointer 字符串</title>
    <link href="https://swift.gg/2018/10/08/tagged-pointer-strings/"/>
    <id>https://swift.gg/2018/10/08/tagged-pointer-strings/</id>
    <published>2018-10-08T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-07-31-tagged-pointer-strings.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-07-31<br>译者：<a href="https://dingtz.com/" target="_blank" rel="noopener">jojotov</a>；校对：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>，<a href="http://www.desgard.com/" target="_blank" rel="noopener">冬瓜</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>Tagged pointer 是一项用于提高性能并减少内存使用的有趣技术。在 OS X 10.10 中，<code>NSString</code> 也开始使用了 tagged pointer 技术，今天我会在 Ken Ferry 的提议下，窥探其工作原理。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对象存储在内存中的时候是内存对齐的，因此他们的地址总是单个指针大小的倍数，在实际中通常是 16 的倍数。对象的指针通常是以一个完整的 64 位整型的结构进行存储，不过由于内存对齐的，指针中一些位总会为零。</p><p>Tagged pointer 技术受益于此，通过让这些位不再为 0，赋予了对象指针一些特殊意义。在苹果的 64 位 Objective-C 实现当中，对象指针的最低有效位设置为 1 的时候 (也就是说，它是一个奇数) ，此指针被认为是 tagged pointer。此时，最低有效位前面的 3 位不再被当作 isa 指针的地址，而是用于表示一个特殊的 tagged class 表的索引值。这个索引值可以用来查找 tagged pointer 所对应的类。剩余的 60 位则会被直接使用。</p><p>来看一个对上述理论的简单应用：当我们创建一个 <code>NSNumber</code> 对象时，如果它适合于 tagged pointer 技术，那么这个对象将不再是一个真正的 <code>NSNumber</code> 对象——它的指针会自动转换为 tagged pointer 指针，并且最低位会被设置为 1；接下来的 3 位会设为 <code>NSNumber</code> 所对应的 tagged class 在一个全局表中的索引；而剩余的 60 位会用作保存其数值 —— 比如一个能用 60 位表示的整型值。</p><p>对于外部而言，这样的一个指针与其他任何对象的指针看起来都是一样的。它能像其他对象一样响应消息，因为 <code>objc_msgSend</code> 知道它是一个 tagged pointer 类型的指针。假如你要向它发送 <code>integerValue</code> 的消息，OC 运行时会帮助我们从它存储数据的 60 位中拿出数据并返回。</p><p>尽管为了对外统一，运行时做了很多额外工作，但最终你节省了一次内存的初始化，一次指针的间接访问，并且也不会有任何关于引用计数的操作 —— 因为没有内存需要被释放。对于一些经常使用的类来说，这能带来显著的性能提升。</p><p><code>NSString</code> 看起来不太适用于 tagged pointer 技术，因为它的长度是可变的，而且可能会远远超出 tagged pointer 所能存储的范围。但话虽如此，一个 tagged pointer 的类是可以和普通的类共存的 —— 某些值使用 tagged pointer，另外一些值使用普通指针。例如，对于 <code>NSNumber</code> 来说，一个大于 2^60 - 1 的整型超出了 tagged pointer 所能存储的范围，那么它就需要存储为一个在内存中初始化的普通 <code>NSNumber</code> 对象。</p><p><code>NSString</code> 亦是如此。假如某些字符串可以保存为 60 位以内的二进制数据，它会创建为 tagged pointer，而其他字符串会保存为普通的对象。据此我们可以假设，如果小的字符串经常被使用且达到一定的使用量时，它会获得可观的性能。在真实的代码中会有如此效果吗？显然苹果给出了肯定的答案 —— 如果没有实际效果，他们不会尝试去实现它。</p><h2 id="可能的实现"><a href="#可能的实现" class="headerlink" title="可能的实现"></a>可能的实现</h2><p>在窥探苹果的实现之前，我们先花点时间思考一下可能的实现方案。基本准则很简单：把最低位设为 1，然后把后面的几位设为合适的 tagged class 索引，最后把剩下的位设为任意值。此时最大的问题是如何利用剩余的 60 位 —— 我们要尽可能最大化这 60 位的价值。</p><p>Cocoa 框架中的字符串在某种概念上其实是一个 Unicode 码位的序列。Unicode 包含了 1,112,064 个有效码位，所以一个码位需要用 21 位来表示。也就是说，我们可以在 60 位的长度中放入两个 Unicode 码位，这样还剩下 18 位没有使用。我们可以利用这 18 位中其中几位来表示字符串的长度。因此，这样的一个 tagged pointer  字符串可能会包含零个、一个或者两个 Unicode 码位。但问题是，最多只能包含两个码位好像并不太实用。</p><p>实际上，<code>NSString</code> API 使用了 UTF-16 实现，并非原始的 Unicode 码位。UTF-16 把 Unicode 表示为一个包含多个 16 位数值的序列。在基本多语言平面（Basic Multilingual Plane，BMP）中的字符，也就是那些最常用的字符，会使用一个 16 位的值表示。同时，那些超过 65,535 的码位会使用两个 16 位 (也就是 32 位) 的值来表示。因此，我们可以在 60 位的长度中放入三个 16 位的值，剩余的 12 位同样用于表示长度。也就是说，我们可以放入 0 至 3 个 UTF-16 编码的字符 —— 严格来说是最多三个 BMP 中的字符，或者最多一个 BMP 之上平面的字符加一个 BMP 平面之下的字符。不过最多三个字符，我们还是会很受限。</p><p>在应用中的大多数字符串都是 ASCII。即使这个应用本地化为一种非 ASCII 的语言，字符串也不只是单纯地在 UI 层用作展示 —— 字符串会用于 URL 的组成、文件扩展名、对象的键、属性列表的值等等。UTF-8 是一种兼容 ASCII 的编码，它会把每个 ASCII 字符编码为单个字节，并且对其他 Unicode 码位使用最多四个字节进行编码。这样，我们能在 60 位中放入最多 7 个字节，剩下 4 位表示长度。因此，根据不同的字符格式，我们的 tagged pointer 字符串可以包含最多 7 个 ASCII 字符，或者更少量的非 ASCII 字符。</p><p>如果我们针对 ASCII 优化一下，或许我们能完全抛弃对所有 Unicode 都支持的想法 —— 那些非 ASCII 的字符都使用真正的字符串对象来保存。ASCII 是一种 7 位的编码方式。因此，假设我们只给每个字符分配 7 位的空间呢？那么我们能在可利用的 60 位空间中保存最多 8 个 ASCII 字符，剩余 4 位表示长度。现在，我们的方案听上去开始具有一定的可行性了 —— 在应用中应该有不少字符串是纯正的 ASCII 并且仅包含 8 个或更少的字符。</p><p>让我们的思维放飞一点，完整的 ASCII 范围中包含了许多并不常用的东西。比如其中有一大堆控制字符和非常用符号。而字母和数字才是我们最常用的。我们能把它压缩成只有 6 位吗？</p><p>6 位可以表示 64 个可能的值。ASCII 字母表中有 26 个英文字母。如果把大写字母也算上的话一共有 52 个字母。再加上 0-9 的数字，一共有 62 个。现在还有两个空余的位置，我们可以把它们留给空格和句号。这样应该会有很多的字符串只包含上述的字符。如果一个字符只需要 6 位，那么我们可以在 60 位空间中保存最多 10 个字符！不过别高兴太早，我们现在没有多余的位置来表示长度了！因此，我们可以选择这 60 位保存 9 个字符和 1 个长度，或者我们去掉上面的 64 个值之一 (我投票给空格)，然后用一个 6 位的 <code>0</code> 表示少于 10 个字符的字符串的结束位。(译者注：去掉 64 个字符集合中的一个，然后加入一个结束符，当遇到结束符的时候就表示字符串结束，长度为结束符的位置，否则长度刚好为 10。)</p><p>如果只使用 5 位呢？这好像有点天方夜谭。但实际上，应该有很大一部分的字符串只包含小写字母。5 位可以表示 32 个可能的值。如果我们把整个小写字母表考虑进来，那么还剩下 6 个位置，可以分配给一些常用的大写字母、符号和数字。如果你觉得这些除小写字母外的情况更为常见，你甚至可以去掉一些不常用的小写字母，比如字母 <code>q</code>。每个字符只使用 5 位的话，那么我们可以存放 11 个字符并且还能有存放长度的空间，或者我们保存 12 个字符，并采用结束符的方案表示长度。</p><p>让我们的思维再飞远一点。每个字符只使用 5 位似乎已经是在字母表长度固定的前提下的最优解了。不过你可以使用一些变长的编码，例如 Huffman 编码。这样的话，对于一个常见的字母 <code>e</code>，可以使用比字母 <code>q</code> 更少的位表示。也就是说，假设你的字符串全都是 <code>e</code>，那字符串的每个字符最少可以只用 1 位表示。但这样的代价是你的代码会变得更加复杂，且性能或许较差。</p><p>苹果到底是采用哪种方案的呢？我们现在来一探究竟。</p><h2 id="Tagged-Pointer-字符串实践"><a href="#Tagged-Pointer-字符串实践" class="headerlink" title="Tagged Pointer 字符串实践"></a>Tagged Pointer 字符串实践</h2><p>下面的代码创建了一个 tagged pointer 字符串并打印了它的指针：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *a = <span class="string">@"a"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *b = [[a mutableCopy] <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p %p %@"</span>, a, b, object_getClass(b));</span><br></pre></td></tr></table></figure><p>这里 <code>mutableCopy</code> 和 <code>copy</code> 的操作可能会让人费解，但它却是必须的。其中有两个原因：首先，尽管一个像 <code>@&quot;a&quot;</code> 这样的字符串可以被存储为 tagged pointer 字符串，但如果是常量字符串的话，那么它永远不会存储为 tagged pointer 字符串。常量字符串必须保证能够兼容不同的操作系统版本，但 tagged pointer 字符串的内部细节却不保证能兼容。如果只是苹果的运行时代码所生成的 tagged pointer，它不会有任何问题。但如果像常量字符串一样，编译器把它们嵌入在二进制文件中时，就可能会发生崩溃的问题。因此，我们需要对常量字符串进行 <code>copy</code> 操作来拿到一个 tagged pointer。</p><p>必须进行 <code>mutableCopy</code> 操作的原因是，<code>NSString</code> 对我们来说十分的 “聪明” ，它能知道一个对不可变字符串的 <code>copy</code> 其实是一个毫无意义的操作，并返回原来的字符串作为 <code>copy</code> 操作后的值。因为常量字符串是不可变的，所以 <code>[a copy]</code> 的返回值其实与 <code>a</code> 是一样的。不过，<code>mutableCopy</code> 会强制进行真正的拷贝操作（深拷贝），然后对这样一个深拷贝后的结果再进行一次不可变拷贝操作后，足以让系统返回给我们一个 tagger pointer 字符串。</p><blockquote><p>译者注：<code>[a mutableCopy]</code> 会在运行时创建一个可变字符串（深拷贝），因此避免了上面原因一中关于常量字符串的情况。但由于 <code>mutableCopy</code> 后的对象是一个可变对象，不可能为 tagged pointer，因此需要再对此可变副本进行一次 <code>copy</code> 操作。这次 <code>copy</code> 会在运行时返回一个新的不可变副本（深拷贝），避免了上面原因二中对常量字符串拷贝返回原值的情况（浅拷贝），进而保证了最后返回的对象是经过运行时创建出来的（tagged pointer 对象只会在运行时创建）。</p></blockquote><p>注意，你一定不可以在自己的代码中依赖这些细节！<code>NSString</code> 的代码返回一个 tagged pointer 给你的情况并不是一成不变的，如果你编写的代码不知怎么地依赖于此，那它最终可能会导致崩溃。幸好，正常且合理的代码不会有任何问题 —— 让你可以幸福地忽略所有 tagged 相关的东西。</p><p>上面的代码在我的电脑上打印如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x10ba41038 0x6115 NSTaggedPointerString</span><br></pre></td></tr></table></figure><p>首先，你可以看到原始的指针 —— 一个用来表示对象指针的整数。第二个值为 <code>copy</code> 后的指针，它非常清晰地表示出 tagged pointer 的特性：首先，它是一个奇数，也就是说它不会是一个有效的对象指针（内存对齐的关系）。同时，它是一个很小的数。在 64 位 Mac 系统的地址空间中，一开始的 4GB 是没有任何映射且不能建立映射的空页。因此，这个属于空页的地址也很好地证明了它不可能是一个对象指针。</p><p>我们可以从 <code>0x6115</code> 这个值推断出什么呢？首先我们可以知道最低的 4 位是 tagged pointer 机制本身的一部分。最低的十六进制数字 <code>5</code> 在二进制中为 <code>0101</code>。最低位的 <code>1</code> 表明了它是一个 tagged pointer。剩下的 3 位表明了它的 tagged class —— 在这个例子中是 <code>010</code>，表明了 tagged pointer 字符串类的索引值为 <code>2</code>。不过这些信息并不能提供给我们什么有用的东西。</p><p>而上面例子中十六进制地址的 <code>61</code> 则很值得我们探讨一番。在十六进制中，<code>61</code> 刚好为字母 a 的 ASCII 编码。还记得这个指针所指向的值吗 —— 正好就是字母 a！看起来这里直接使用了 ASCII 编码的值，真是个方便而又合适的选择！</p><p>接下来打印出的类名明显地表明了它的类是什么，并且也提供了一个非常不错的切入点，来让我们深入其真实源码一探此特性的本质实现。我们很快会进入这一阶段，不过在此之前先做点额外的检查。</p><p>这里通过一个循环构造出 <code>abcdef...</code> 的字符串，同时把属于 tagged pointer 的字符串指针一个接一个地打印出来。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> *<span class="keyword">mutable</span> = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line"><span class="built_in">NSString</span> *immutable;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    [<span class="keyword">mutable</span> appendFormat: <span class="string">@"%c"</span>, c++];</span><br><span class="line">    immutable = [<span class="keyword">mutable</span> <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"0x%016lx %@ %@"</span>, immutable, immutable, object_getClass(immutable));</span><br><span class="line">&#125; <span class="keyword">while</span>(((uintptr_t)immutable &amp; <span class="number">1</span>) == <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>第一次迭代的打印结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000000000006115 a NSTaggedPointerString</span><br></pre></td></tr></table></figure><p>这验证了上文的所写的。需要注意的是，现在我们把包含空位 0 的指针完整地打印出来，可以让每次迭代的打印结果对比更加清晰。</p><p>现在对比一下第二次迭代的打印结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000000000626125 ab NSTaggedPointerString</span><br></pre></td></tr></table></figure><p>可以看到最低 4 位没有发生任何变化，这也在我们意料之中。这个十六进制的数字 <code>5</code> 会一直保持不变，总是表明它是一个 <code>NSTaggedPointerString</code> 类型的 tagged pointer。</p><p>而原来的 <code>61</code> 也保持原来的位置，不过现在它前面出现了 <code>62</code>。显而易见，<code>62</code> 是字母 b 的 ASCII 编码，因此我们可以知道当前的编码方式是使用 ASCII 的 8 位编码。而在最低位之前的 4 位由 <code>1</code> 变成了 <code>2</code>，由此我们可以想到它或许表示了字符串的长度。接下来的迭代确认了这个猜想：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000000063626135 abc NSTaggedPointerString</span><br><span class="line">0x0000006463626145 abcd NSTaggedPointerString</span><br><span class="line">0x0000656463626155 abcde NSTaggedPointerString</span><br><span class="line">0x0066656463626165 abcdef NSTaggedPointerString</span><br><span class="line">0x6766656463626175 abcdefg NSTaggedPointerString</span><br></pre></td></tr></table></figure><p>按理来说，由于 tagged pointer 的空位已经填满了，迭代应该也到此为止。可事实的确如此吗？并不是！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0022038a01169585 abcdefgh NSTaggedPointerString</span><br><span class="line">0x0880e28045a54195 abcdefghi NSTaggedPointerString</span><br><span class="line">0x00007fd275800030 abcdefghij __NSCFString</span><br></pre></td></tr></table></figure><p>循环中的代码继续执行下去，直到两次迭代后才终止。表示长度的区间继续保持增长，但指针剩余的部分却显得杂乱无章。到底是发生了什么呢？让我们深入其实现代码来一探究竟。</p><h2 id="刨根问底"><a href="#刨根问底" class="headerlink" title="刨根问底"></a>刨根问底</h2><p><code>NSTaggedPointer</code> 类存在于 CoreFoundation 库中。似乎把它放在 Foundation 中会更加合理一点，但实际上现在苹果许多核心的 Objective-C 类都被移到了 CoreFoundation 当中，因为苹果慢慢地放弃了把  CoreFoundation 变成一个独立实体的想法。</p><p>先来看看 <code>-[NSTaggedPointerString length]</code> 的实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push       rbp</span><br><span class="line">mov        rbp, rsp</span><br><span class="line">shr        rdi, 0x4</span><br><span class="line">and        rdi, 0xf</span><br><span class="line">mov        rax, rdi</span><br><span class="line">pop        rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>Hopper 工具为我们提供了这个简易的反编译版本：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> -[<span class="built_in">NSTaggedPointerString</span> length](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd) &#123;</span><br><span class="line">    rax = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，提取出 4 至 7 位的值并返回它们便可以得到字符串的长度。这证实了我们上文中所观察到的 —— 在最低位的十六进制 <code>5</code> 前面的 4 位表示了字符串的长度。 </p><p><code>NSString</code> 子类中另一个原始方法是 <code>characterAtIndex:</code>。由于其汇编代码太长，我会直接跳过并给出 Hopper 反编译出的可读性较高的版本：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> -[<span class="built_in">NSTaggedPointerString</span> characterAtIndex:](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> arg2) &#123;</span><br><span class="line">     rsi = _cmd;</span><br><span class="line">     rdi = <span class="keyword">self</span>;</span><br><span class="line">     r13 = arg2</span><br><span class="line">     r8 = ___stack_chk_guard;</span><br><span class="line">     var_30 = *r8;</span><br><span class="line">     r12 = rdi &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">     <span class="keyword">if</span> (r12 &gt;= <span class="number">0x8</span>) &#123;</span><br><span class="line">             rbx = rdi &gt;&gt; <span class="number">0x8</span>;</span><br><span class="line">             rcx = <span class="string">"eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX"</span>;</span><br><span class="line">             rdx = r12;</span><br><span class="line">             <span class="keyword">if</span> (r12 &lt; <span class="number">0xa</span>) &#123;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                             *(int8_t *)(rbp + rdx + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((rbx &amp; <span class="number">0x3f</span>) + rcx);</span><br><span class="line">                             rdx = rdx - <span class="number">0x1</span>;</span><br><span class="line">                             rbx = rbx &gt;&gt; <span class="number">0x6</span>;</span><br><span class="line">                     &#125; <span class="keyword">while</span> (rdx != <span class="number">0x0</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                             *(int8_t *)(rbp + rdx + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((rbx &amp; <span class="number">0x1f</span>) + rcx);</span><br><span class="line">                             rdx = rdx - <span class="number">0x1</span>;</span><br><span class="line">                             rbx = rbx &gt;&gt; <span class="number">0x5</span>;</span><br><span class="line">                     &#125; <span class="keyword">while</span> (rdx != <span class="number">0x0</span>);</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (r12 &lt;= r13) &#123;</span><br><span class="line">             rbx = r8;</span><br><span class="line">             ___CFExceptionProem(rdi, rsi);</span><br><span class="line">             [<span class="built_in">NSException</span> raise:<span class="string">@"NSRangeException"</span> format:<span class="string">@"%@: Index %lu out of bounds; string length %lu"</span>];</span><br><span class="line">             r8 = rbx;</span><br><span class="line">     &#125;</span><br><span class="line">     rax = *(int8_t *)(rbp + r13 + <span class="number">0xffffffffffffffc0</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">     <span class="keyword">if</span> (*r8 != var_30) &#123;</span><br><span class="line">             rax = __stack_chk_fail();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> rax;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们稍微整理一下：前三行中，Hopper 让我们知道了寄存器分别存放了哪些参数。我们马上着手把 <code>rsi</code> 替换成 <code>_cmd</code>，然后把 <code>rdi</code> 替换成 <code>self</code>。<code>arg2</code> 实际上是 <code>index</code> 参数，因此我们把所有 <code>r13</code> 的调用替换成 <code>index</code>。接下来，由于 <code>__stack_chk</code> 其实是一个用来加强防御性的东西，且它与函数的实际作用没有多大关联，我们可以暂时忽略掉它。现在整理过后的代码看起来大概是这个样子的：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> -[<span class="built_in">NSTaggedPointerString</span> characterAtIndex:](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> index) &#123;</span><br><span class="line">    r12 = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">if</span> (r12 &gt;= <span class="number">0x8</span>) &#123;</span><br><span class="line">            rbx = <span class="keyword">self</span> &gt;&gt; <span class="number">0x8</span>;</span><br><span class="line">            rcx = <span class="string">"eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX"</span>;</span><br><span class="line">            rdx = r12;</span><br><span class="line">            <span class="keyword">if</span> (r12 &lt; <span class="number">0xa</span>) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(rbp + rdx + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((rbx &amp; <span class="number">0x3f</span>) + rcx);</span><br><span class="line">                            rdx = rdx - <span class="number">0x1</span>;</span><br><span class="line">                            rbx = rbx &gt;&gt; <span class="number">0x6</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (rdx != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(rbp + rdx + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((rbx &amp; <span class="number">0x1f</span>) + rcx);</span><br><span class="line">                            rdx = rdx - <span class="number">0x1</span>;</span><br><span class="line">                            rbx = rbx &gt;&gt; <span class="number">0x5</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (rdx != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r12 &lt;= index) &#123;</span><br><span class="line">            rbx = r8;</span><br><span class="line">            ___CFExceptionProem(<span class="keyword">self</span>, _cmd);</span><br><span class="line">            [<span class="built_in">NSException</span> raise:<span class="string">@"NSRangeException"</span> format:<span class="string">@"%@: Index %lu out of bounds; string length %lu"</span>];</span><br><span class="line">            r8 = rbx;</span><br><span class="line">    &#125;</span><br><span class="line">    rax = *(int8_t *)(rbp + index + <span class="number">0xffffffffffffffc0</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意第一个 <code>if</code> 语句之前的这行代码：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">r12 = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span></span><br></pre></td></tr></table></figure><p>我们可以发现，这正是我们前面所看到的 <code>-length</code> 实现代码。既然如此，那我们就把 <code>r12</code> 全部替换成 <code>length</code>：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> -[<span class="built_in">NSTaggedPointerString</span> characterAtIndex:](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> index) &#123;</span><br><span class="line">    length = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= <span class="number">0x8</span>) &#123;</span><br><span class="line">            rbx = <span class="keyword">self</span> &gt;&gt; <span class="number">0x8</span>;</span><br><span class="line">            rcx = <span class="string">"eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX"</span>;</span><br><span class="line">            rdx = length;</span><br><span class="line">            <span class="keyword">if</span> (length &lt; <span class="number">0xa</span>) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(rbp + rdx + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((rbx &amp; <span class="number">0x3f</span>) + rcx);</span><br><span class="line">                            rdx = rdx - <span class="number">0x1</span>;</span><br><span class="line">                            rbx = rbx &gt;&gt; <span class="number">0x6</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (rdx != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(rbp + rdx + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((rbx &amp; <span class="number">0x1f</span>) + rcx);</span><br><span class="line">                            rdx = rdx - <span class="number">0x1</span>;</span><br><span class="line">                            rbx = rbx &gt;&gt; <span class="number">0x5</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (rdx != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= index) &#123;</span><br><span class="line">            rbx = r8;</span><br><span class="line">            ___CFExceptionProem(<span class="keyword">self</span>, _cmd);</span><br><span class="line">            [<span class="built_in">NSException</span> raise:<span class="string">@"NSRangeException"</span> format:<span class="string">@"%@: Index %lu out of bounds; string length %lu"</span>];</span><br><span class="line">            r8 = rbx;</span><br><span class="line">    &#125;</span><br><span class="line">    rax = *(int8_t *)(rbp + index + <span class="number">0xffffffffffffffc0</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看 <code>if</code> 语句内部的代码，第一行把 <code>self</code> 右移了 8 位。这 8 位是保存了 tagged pointer 的指示符以及字符串长度。而右移操作后得到的值，我们可以推测它就是其真正的数据。因此我们把 <code>rbx</code> 替换为 <code>stringData</code> 来让代码更加清晰可读一点。下一行把一个类似查找表的东西赋值给 <code>rcx</code>，因此我们也把 <code>rcx</code> 替换成 <code>table</code>。最后，<code>rdx</code> 拿到了值的长度的一份拷贝。看起来它后面会作为光标来使用，因此我们再把 <code>rdx</code> 替换为 <code>cursor</code>。现在我们的代码是这样的：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> -[<span class="built_in">NSTaggedPointerString</span> characterAtIndex:](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> index) &#123;</span><br><span class="line">    length = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= <span class="number">0x8</span>) &#123;</span><br><span class="line">            stringData = <span class="keyword">self</span> &gt;&gt; <span class="number">0x8</span>;</span><br><span class="line">            table = <span class="string">"eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX"</span>;</span><br><span class="line">            cursor = length;</span><br><span class="line">            <span class="keyword">if</span> (length &lt; <span class="number">0xa</span>) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(rbp + cursor + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((stringData &amp; <span class="number">0x3f</span>) + table);</span><br><span class="line">                            cursor = cursor - <span class="number">0x1</span>;</span><br><span class="line">                            stringData = stringData &gt;&gt; <span class="number">0x6</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (cursor != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(rbp + cursor + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((stringData &amp; <span class="number">0x1f</span>) + table);</span><br><span class="line">                            cursor = cursor - <span class="number">0x1</span>;</span><br><span class="line">                            stringData = stringData &gt;&gt; <span class="number">0x5</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (cursor != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= index) &#123;</span><br><span class="line">            rbx = r8;</span><br><span class="line">            ___CFExceptionProem(<span class="keyword">self</span>, _cmd);</span><br><span class="line">            [<span class="built_in">NSException</span> raise:<span class="string">@"NSRangeException"</span> format:<span class="string">@"%@: Index %lu out of bounds; string length %lu"</span>];</span><br><span class="line">            r8 = rbx;</span><br><span class="line">    &#125;</span><br><span class="line">    rax = *(int8_t *)(rbp + index + <span class="number">0xffffffffffffffc0</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，代码基本上已经完全符号化了，不过还有一个寄存器名称仍然存在：<code>rbp</code>。它实际上是帧指针。因此，编译器其实做了一些很 tricky 的事情 —— 直接通过帧指针进行了索引操作。二进制补码中有一条原理： “所有东西最终都是无符号整型” ，因此为了让变量减去 65，我们可以将其与 <code>0xffffffffffffffbf</code> 常量相加。接下来，它又减去了 64（倒数第二行代码）。这两个值大概都是分配在栈上的局部变量。仔细看的话，你会发现这段代码非常奇怪 —— 有一条路径是只进行了读操作而没有进行任何的写操作。这到底是怎么回事呢？</p><p>原因其实是 Hopper 忘记了对另一个 if 条件判断的 <code>else</code> 分支进行反编译。相对应的汇编代码看起来是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov        rax, rdi</span><br><span class="line">shr        rax, 0x8</span><br><span class="line">mov        qword [ss:rbp+var_40], rax</span><br></pre></td></tr></table></figure><p><code>var_40</code> 便是在 Hopper 反编译版本中的偏移量 <code>64</code>（<code>40</code> 刚好是 <code>64</code> 的十六进制表示）。我们暂且把这个位置的指针称为 <code>buffer</code>。这样一来，上面代码中遗漏分支的 C 语言代码看起来是这样的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="keyword">uint64_t</span> *)buffer = self &gt;&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><p>现在把这段代码插入原本的代码中，并替换掉其他位置的 <code>rbp</code> 为 <code>buffer</code>。最后，为了能提醒自己，我们在函数开始的位置再补上一行 <code>buffer</code> 的声明语句：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> -[<span class="built_in">NSTaggedPointerString</span> characterAtIndex:](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> index) &#123;</span><br><span class="line">    int8_t buffer[<span class="number">11</span>];</span><br><span class="line">    length = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= <span class="number">0x8</span>) &#123;</span><br><span class="line">            stringData = <span class="keyword">self</span> &gt;&gt; <span class="number">0x8</span>;</span><br><span class="line">            table = <span class="string">"eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX"</span>;</span><br><span class="line">            cursor = length;</span><br><span class="line">            <span class="keyword">if</span> (length &lt; <span class="number">0xa</span>) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(buffer + cursor - <span class="number">1</span>) = *(int8_t *)((stringData &amp; <span class="number">0x3f</span>) + table);</span><br><span class="line">                            cursor = cursor - <span class="number">0x1</span>;</span><br><span class="line">                            stringData = stringData &gt;&gt; <span class="number">0x6</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (cursor != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(buffer + cursor - <span class="number">1</span>) = *(int8_t *)((stringData &amp; <span class="number">0x1f</span>) + table);</span><br><span class="line">                            cursor = cursor - <span class="number">0x1</span>;</span><br><span class="line">                            stringData = stringData &gt;&gt; <span class="number">0x5</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (cursor != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *(uint64_t *)buffer = <span class="keyword">self</span> &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= index) &#123;</span><br><span class="line">            rbx = r8;</span><br><span class="line">            ___CFExceptionProem(<span class="keyword">self</span>, _cmd);</span><br><span class="line">            [<span class="built_in">NSException</span> raise:<span class="string">@"NSRangeException"</span> format:<span class="string">@"%@: Index %lu out of bounds; string length %lu"</span>];</span><br><span class="line">            r8 = rbx;</span><br><span class="line">    &#125;</span><br><span class="line">    rax = *(int8_t *)(buffer + index) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在代码看起来好了很多。不过那些疯狂的指针操作语句实在是太难看懂了，而它们仅仅是一些数组的索引操作。我们来简化一下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> -[<span class="built_in">NSTaggedPointerString</span> characterAtIndex:](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> index) &#123;</span><br><span class="line">     int8_t buffer[<span class="number">11</span>];</span><br><span class="line">     length = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">     <span class="keyword">if</span> (length &gt;= <span class="number">0x8</span>) &#123;</span><br><span class="line">             stringData = <span class="keyword">self</span> &gt;&gt; <span class="number">0x8</span>;</span><br><span class="line">             table = <span class="string">"eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX"</span>;</span><br><span class="line">             cursor = length;</span><br><span class="line">             <span class="keyword">if</span> (length &lt; <span class="number">0xa</span>) &#123;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                             buffer[cursor - <span class="number">1</span>] = table[stringData &amp; <span class="number">0x3f</span>];</span><br><span class="line">                             cursor = cursor - <span class="number">0x1</span>;</span><br><span class="line">                             stringData = stringData &gt;&gt; <span class="number">0x6</span>;</span><br><span class="line">                     &#125; <span class="keyword">while</span> (cursor != <span class="number">0x0</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                             buffer[cursor - <span class="number">1</span>] = table[stringData &amp; <span class="number">0x1f</span>];</span><br><span class="line">                             cursor = cursor - <span class="number">0x1</span>;</span><br><span class="line">                             stringData = stringData &gt;&gt; <span class="number">0x5</span>;</span><br><span class="line">                     &#125; <span class="keyword">while</span> (cursor != <span class="number">0x0</span>);</span><br><span class="line">             &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         *(uint64_t *)buffer = <span class="keyword">self</span> &gt;&gt; <span class="number">8</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (length &lt;= index) &#123;</span><br><span class="line">             rbx = r8;</span><br><span class="line">             ___CFExceptionProem(<span class="keyword">self</span>, _cmd);</span><br><span class="line">             [<span class="built_in">NSException</span> raise:<span class="string">@"NSRangeException"</span> format:<span class="string">@"%@: Index %lu out of bounds; string length %lu"</span>];</span><br><span class="line">             r8 = rbx;</span><br><span class="line">     &#125;</span><br><span class="line">     rax = buffer[index];</span><br><span class="line">     <span class="keyword">return</span> rax;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>现在，我们能看出些端倪了。</p><p>首先可以看到基于长度的不同，会有三种不同的情况。长度小于 8 的情况下，会执行到刚刚我们补充的遗漏分支 —— 单纯地把 <code>self</code> 的值按位移动后赋给 <code>buffer</code>。这是简单 ASCII 的情况。在此情况下，<code>index</code> 只作为 <code>self</code> 的索引值来取出给定字节，并随后返回给调用方。由于 ASCII 字符的值在指定范围内可以匹配 Unicode 码位。因此不需要额外的操作便可以返回正确结果。我们在上文曾猜测这种情况下（长度小于 8）会直接存放 ASCII 码，这也验证了我们的猜想。</p><p>那么在长度大于或等于 8 的情况下会怎么样呢？如果字符串长度等于 8 或大于 8 且小于 10，那么会执行一段循环代码：首先取出 <code>stringData</code> 的最低 6 位，然后作为 <code>table</code> 的索引并取出相应的值，再拷贝到 <code>buffer</code> 中。接下来，会把 <code>stringData</code> 右移 6 位然后重复上面的操作直到遍历完整个字符串。这段代码其实是一种 6 位编码方式 —— 通过原始 6 位数据在 <code>table</code> 中的索引进行编码。<code>buffer</code> 中会构建出一个临时的字符串，然后最后的索引操作（上面函数中倒数第二行）会取出其需要的字符。</p><p>当如果长度大于 10 呢？可以看到其代码和长度在 8 到 10 的情况下基本一致，除了现在一次只处理 5 位而不是 6 位数据。这是一种更加紧凑的编码方式，可以让 tagged pointer 字符串最多能够保存 11 个字符，不过它使用的字母表仅包含 32 个值（仅使用了 <code>table</code> 的前半部分）。</p><p>因此，我们可以得到 tagged pointer 字符串的结构大致为：</p><ol><li>长度在 0 到 7 范围内时，直接保存原始的 8 位字符。</li><li>长度为 8 或者 9时， 保存 6 位编码后的字符，编码使用的字母表为 <code>&quot;eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX&quot;</code>。 </li><li>长度大于 10 时，保存 5 位编码后的字符，编码使用的字母表为 <code>&quot;eilotrm.apdnsIc ufkMShjTRxgC4013&quot;</code>。 </li></ol><p>现在我们来对比一下前面生成的数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000000000006115 a NSTaggedPointerString</span><br><span class="line">0x0000000000626125 ab NSTaggedPointerString</span><br><span class="line">0x0000000063626135 abc NSTaggedPointerString</span><br><span class="line">0x0000006463626145 abcd NSTaggedPointerString</span><br><span class="line">0x0000656463626155 abcde NSTaggedPointerString</span><br><span class="line">0x0066656463626165 abcdef NSTaggedPointerString</span><br><span class="line">0x6766656463626175 abcdefg NSTaggedPointerString</span><br><span class="line">0x0022038a01169585 abcdefgh NSTaggedPointerString</span><br><span class="line">0x0880e28045a54195 abcdefghi NSTaggedPointerString</span><br><span class="line">0x00007fbad9512010 abcdefghij __NSCFString</span><br></pre></td></tr></table></figure><p><code>0x0022038a01169585</code> 的二进制表达式去掉了字符串后面的 8 位，并把剩余的位分成了 6 位为单位的块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">001000 100000 001110 001010 000000 010001 011010 010101</span><br></pre></td></tr></table></figure><p>以这些数值作为 <code>table</code> 的索引，我们的确可以拼出 <code>&quot;abcdefgh&quot;</code>。同样的，<code>0x0880e28045a54195</code> 的二进制表达式也有类似的规则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">001000 100000 001110 001010 000000 010001 011010 010101 000001</span><br></pre></td></tr></table></figure><p>可以看到它与上面的字符串基本一致，只是在最后多出了字符 <code>i</code>。</p><p>但是后面的字符串却不符合我们的预测。在这之后，按理来说本应会切换为 5 位编码方式进行存储，且在两个字符串之后才会终止。但事实却是，在长度等于 10 的时候 tagged pointer 字符串就已经停止了工作，并转为创建真正的字符串对象，为什么会这样？</p><p>原因是 5 位编码方式中使用的字母表过于受限，因此没有包含字母 <code>b</code>！相对于 5 位编码方式使用的字母表中 32 个 “神圣” 的字符而言，<code>b</code> 这个字母的普遍程度肯定还不够，以至于未能取得其中的一席之地。既然如此，我们换成从 <code>c</code> 开始的字符串再尝试一次，打印结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000000000006315 c NSTaggedPointerString</span><br><span class="line">0x0000000000646325 cd NSTaggedPointerString</span><br><span class="line">0x0000000065646335 cde NSTaggedPointerString</span><br><span class="line">0x0000006665646345 cdef NSTaggedPointerString</span><br><span class="line">0x0000676665646355 cdefg NSTaggedPointerString</span><br><span class="line">0x0068676665646365 cdefgh NSTaggedPointerString</span><br><span class="line">0x6968676665646375 cdefghi NSTaggedPointerString</span><br><span class="line">0x0038a01169505685 cdefghij NSTaggedPointerString</span><br><span class="line">0x0e28045a54159295 cdefghijk NSTaggedPointerString</span><br><span class="line">0x01ca047550da42a5 cdefghijkl NSTaggedPointerString</span><br><span class="line">0x39408eaa1b4846b5 cdefghijklm NSTaggedPointerString</span><br><span class="line">0x00007fbd6a511760 cdefghijklmn __NSCFString</span><br></pre></td></tr></table></figure><p>现在，我们获得了一直到长度为 11 的所有 tagged pointer 字符串。最后两个 tagged pointer 字符串的二进制表示如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01110 01010 00000 10001 11010 10101 00001 10110 10010 00010</span><br><span class="line">01110 01010 00000 10001 11010 10101 00001 10110 10010 00010 00110</span><br></pre></td></tr></table></figure><p>正是我们预期的 5 位编码。</p><h2 id="构造-Tagged-Pointer-字符串"><a href="#构造-Tagged-Pointer-字符串" class="headerlink" title="构造 Tagged Pointer 字符串"></a>构造 Tagged Pointer 字符串</h2><p>既然我们现在知道了 tagged pointer 字符串是如何编码的，那么我就不再深入地探究其构造方法的实现了。构造的代码在一个名为 <code>__CFStringCreateImmutableFunnel3</code> 的私有函数内。这个巨大的函数包含了所有可能的情况。你可以在 <a href="https://opensource.apple.com" target="_blank" rel="noopener">opensource.apple.com</a> 中提供的 CoreFoundation 开源版本中找到此函数，不过别高兴太早：开源版本并没有包含关于 tagged pointer 字符串的代码实现。</p><p>构造 tagged pointer 字符串的代码实际上是我们上面看到的代码的相反版本。如果 tagged pointer 字符串能够容下原始字符串的长度和内容，那么就会开始一点一点地构造 —— 包含 ASCII 字符、6 位或者 5 位编码的字符。其中会有一个相反的查找表。上文代码中看到的字符常量的查找表是一个名为 <code>sixBitToCharLookup</code> 的全局变量，在 <code>Funnel3</code> 函数中有一个与之相对应的 <code>sixBitToCharLookup</code> 变量。</p><h2 id="奇怪的查找表"><a href="#奇怪的查找表" class="headerlink" title="奇怪的查找表"></a>奇怪的查找表</h2><p>完整的 6 位编码查找表如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX</span><br></pre></td></tr></table></figure><p>可能大家都会很自然地问一个问题：为什么它的顺序如此奇怪？</p><p>因为这个表同时提供给 6 位编码和 5 位编码使用，这就是为什么它和普通的英语字母表有同样的顺序。那些使用频率非常高的字符位于表的前半段，而那些使用频率没那么高的字符串就会放在后半段。这在最大程度上保证了稍长的字符串能够使用 5 位编码。</p><p>虽然如此，假如我们把查找表对半分，每一半中的顺序仿佛显得无关紧要。对半分后的表按理来说可以按照英语字母表的顺序进行排序，但事实却并非如此。</p><p>查找表开头位置的几个字母似乎是按照其在英语中出现的频率排序的。英语中最常见的字母是 E，其实是 T，接下来依次为 A、O、I、N 和 S。E 确实位于表的开头，且剩下的几个字母也的确都位于靠近开头的位置。看起来这张查找表的确是按照使用频率进行排序的。至于其为什么体现出和英语的差异性，大概是因为在 Cocoa 应用中的短字符串并不是随机选自英文散文，而是一些较为特别的语言。</p><p>我猜测苹果原本打算使用一种更为巧妙的变长编码方式，或许会基于一种 <a href="https://en.wikipedia.org/wiki/Huffman_coding" target="_blank" rel="noopener">Huffman 编码</a>。但最后发现其实现难度太大，或者性价比并没有想象中高，甚至是因为时间不允许的原因。因此他们决定退而求其次，使用一种更容易实现的版本，也就是我们上文中所看到的编码方式 —— 针对不同长度的字符串使用不同的定长编码方式（每个字符 8 位、6 位或 5 位）。这个奇怪的查找表也许是基于被遗弃的变长编码方式而构建的，同时也便于日后决定再次启用变长编码方式。虽然这些纯属猜测，但至少我感觉事实便是如此。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Tagged pointer 是一种非常酷的技术。虽然应用到字符串上面并不常见，但很清楚的是，苹果肯定从中受益良多，不然也不会对它倾注如此多精力和想法。能够看到这两种技术融合在一起的效果，以及它们如何对有限的存储空间物尽其用，实在是有趣至极。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Tagged pointer 是一项用于提高性能并减少内存使用的有趣技术，本文探讨了 NSString 中应用 tagged pointer 的实现原理。
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
      <category term="Objective-C" scheme="https://swift.gg/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>拓展 Swift 应用领域</title>
    <link href="https://swift.gg/2018/10/04/expanding-swifts-reach/"/>
    <id>https://swift.gg/2018/10/04/expanding-swifts-reach/</id>
    <published>2018-10-04T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：terhechte，<a href="http://appventure.me/2018/05/03/expanding-swifts-reach/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-05-03<br>译者：<a href="https://github.com/Adolf-L" target="_blank" rel="noopener">BigLuo</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>我想大家应该都会同意 Swift 是一门优秀的语言，很好的处理了那些简单与复杂的问题。理论上讲，它将会成为重要的编程语言之一。目前，Swift 的使用仅限于苹果开发领域（外加少量服务端 Swift 以及近期宣布的 <a href="https://www.tensorflow.org/community/swift" target="_blank" rel="noopener">Swift 版本的 Tensorflow</a>）。</p><blockquote><p>“My goal for Swift has always been and still is total world domination. It’s a modest goal”</p><p>“我一直期待着 Swift 统治世界，这是一个谦虚的目标。”</p><ul><li>Chris Lattner</li></ul></blockquote><p>随着新的泛型特性在 Swift 4.1 中推出以及 <a href="https://swift.org/abi-stability/" target="_blank" rel="noopener">ABI 在 Swift 5 中逐渐稳定</a>，Swift 似乎逐渐具备了跳出苹果开发领域的条件。本文我会讨论一个我知道的问题，它阻碍着 Swift 广泛的应用，准确的讲，与其它问题一样，该问题也正在被开发社区着手解决。</p><a id="more"></a><p>我会简单介绍 Swift 在这个领域的<strong>竞争力</strong>。就像 C++ 一样，其它编程语言也渴望成为一个跨平台的通用的语言。通过比较 Swift 和其他语言处理相同问题上的方式，可以让我们该如何改进 Swift。</p><h2 id="系统包管理"><a href="#系统包管理" class="headerlink" title="系统包管理"></a>系统包管理</h2><p>Swift 拥有一个非常健康的开源社区，拥有大量杰出、精心编写且实用的开发框架。但是，这些开发框架多为 iOS（macOS 相对少很多）UI 库，这让 Swift 受限在这个开发领域。这里有很多 UI 动画库、UI 布局库、含有 UI 元素的框架、UI 协作库和 JSON 解析库。因为缺少 UIKit/AppKit，它们中的大部分无法在 Linux 上运行。当然，这里也有一些类似于 <a href="https://vapor.codes/" target="_blank" rel="noopener">Vapor</a> 或 <a href="http://kitura.io/" target="_blank" rel="noopener">Kitura</a> 的 Web 框架，致力于在 Web 开发领域推广使用 Swift 语言。</p><p>然而，与大众观点不同，在 Linux 平台上，很多公司不仅在 Web 服务端，也在 Linux 的其它方面做了大量的工作。先简单举个例子，有些编程语言可以管理系统，掌控系统权限，并且提供相应的开发工具和库。这些内容虽然和 iOS 或者 macOS 应用开发没有相关联，但是对于系统或者 Web 开发来说极其重要。比如，数据库权限、系统文件管理、进程管理、日志分析与收集、容器管理、部署工具、甚至区块链工具。</p><p>随着 Swift 4.1 的发布，在 <a href="https://news.ycombinator.com/item?id=16710895" target="_blank" rel="noopener">Hacker News 上有一个讨论这门语言的帖子</a>。我完整通读多次后，觉得回复很有趣。让我感触最深的是下面的评论：</p><blockquote><p>“相比 Go 和 Rust 在系统支持和库的量级方面，Swift 的系列库只有一小点儿……如果我们列出其它编程语言在已发布的应用、数据库后端方面库的贡献，Swift 的数量基本可以忽略不计”</p></blockquote><p>让我们来看看这些竞争对手。</p><h2 id="竞争者"><a href="#竞争者" class="headerlink" title="竞争者"></a>竞争者</h2><p>在最近几年，编程语言领域出现了几个新的有力的竞争者。当然，你也许并不同意这些语言是 Swift 的合格竞争者。这里仅根据我个人的感觉列举出几个编程语言，排名不分先后。</p><p>这些看法可能并不准确。请不要因为你是某个语言的粉丝，并认为我的说法存在错误，就把他们分享到 Twitter。我只是一个有着某些观点的普通人，而这些观点确实含有一些错误。相反，我们可以利用这些精力来追问问题原由，并改善或解决问题本身。</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Go 的发布时间比 Swift 早很多，它多用于开发系统工具，却很少在图形界面中使用。Go 不支持现代语言特性，如标签联合、泛型，或函数式编程。但它易上手，速度快，并使用了垃圾回收器，生成的二进制文件使得其内存消耗非常低。当然，垃圾回收器也使得 Go 在嵌入式开发和使用 Webassembly 变得有点棘手。</p><p>Go 良好的性能，语言的简单性和低内存占用率催生出了大量的系统工具和库。如：Grafana、Kubernetes、CoreOS-etcd、Go-Ethereum、CockroachDB、Hub、Terraform 等等。<a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">通过这个列表，我们可以看到一个问题的多种解法</a>。</p><p>简言之，如果你想做基于系统层面的开发，你能找到几乎所有你想要的依赖包。</p><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>Kotlin 像是 Android 版本下的 Swift，但其底层却完全不同。基于 JVM 的 Kotlin 使得它必须大量使用引用类型，就像 Go 的垃圾回收器使其在嵌入式系统的开发成为一个挑战。然而，<a href="https://kotlinlang.org/docs/reference/native-overview.html" target="_blank" rel="noopener">Kotlin-Native 的出现让它在未来有了更多的可能性</a>。Kotlin-Native 是基于 LLVM 构建的，支持嵌入式平台开发、Webassembly 等。Kotlin 也能被编译成 Javascript，Kotlin-Native 甚至可用于构建 iOS 应用的框架。</p><p>Kotlin 也可能会成为未来的一个主流语言，但和有着相同问题的 Swift 一样，其发展遇到了类似的阻碍。几乎所有可用的开源库集中在 Android 开发领域。而 Kotlin-Native 解决的是一个纯粹 JVM 语言所面临的问题。我不知道一个易于执行且轻量级的 Kotlin-Native 要如何实现（相比于 C++ 或 Swift，尤其是在嵌入式开发、复杂系统开发、或 Webassembly）。</p><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><p>Rust 是一个有趣的语言。事实上它是如此的有趣，我花了几个月的时间慢慢的学习它。这门语言的很多方面与 Swift 相似，但比 Swift 更难（这里我们暂不做讨论，该部分内容将以主题的形式发布在博客）。似乎这两种语言一开始就是采用完全相反的设计思路；Swift 作为一个易学的语言起初是一些容易上手的特性，慢慢的添加复杂的特性。Rust 起初作为一门复杂的语言，它正在慢慢的增添一些更简单的抽象对象或更好的错误调试信息来让初学者容易上手。两种语言语法类似，这点我并不惊讶，直到未来的突然某天，我意识到两门语言在某些简单和复杂特性上有着高度的相似性。然而，目前而言，在你经历一段复杂学习体验的后，便会发现 Rust 背后有提供了一些非常诱人的特性。</p><p>相对于 Swift，Rust 提供了更好的跨平台特性和一个虽难于处理但更高效的内存管理策略（比如在对象的生命周期和所有权方面），<a href="https://github.com/apple/swift/blob/master/docs/OwnershipManifesto.md" target="_blank" rel="noopener">幸运的是，Rust 的一部分内存管理的优点未来也会在 Swift 上出现</a>，同时它也支持 <a href="https://rust-lang-nursery.github.io/rust-wasm/" target="_blank" rel="noopener">Webassembly</a>（你可以用 Rust 写一个前端 App），也提供了很好的基础库让开发者能够快速的构建新项目，虽然它没有提供像 Go 一样数量级的高质量项目，但它也提供了一些有潜力的项目（CoreUtils，RedoxOS，TikV，Vagga，Servo，Parity）。但更重要的，现在已经有大量的 Rust 第三方库供你选择。<a href="https://github.com/rust-unofficial/awesome-rust" target="_blank" rel="noopener">你可以来看看看下这个列表。</a></p><h3 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h3><p>这里还有像 D，Nim、Chrystal、Elixir、TypeScript 等语言，当然也包括 C++ 自身。</p><h2 id="我们看到了什么"><a href="#我们看到了什么" class="headerlink" title="我们看到了什么"></a>我们看到了什么</h2><p>目前 Swift 在系统包管理领域有短板，这也是一个先有鸡还有先有蛋的问题。</p><blockquote><p>“因为没有足够多的系统包，导致那些对 Swift 感兴趣的开发者在开发简单 Demo 应用时数据库处理不方便，从而对 Swift 失去兴趣，对 Swift 失去兴趣的开发者更不愿意去改善包管理了。”</p></blockquote><p>对我而言，我们需要改进我们的系统包/库。如果我们能用 Swift 写出 Kubernets 之类的东西，那一定很棒。为了实现这个项目，我们需要一套好的基础库用于一般性的系统开发。下面我列出了基础的功能库和相关三方服务（此外，下面列出的功能，已经存在部分，不需要我们重复造轮子）。</p><ul><li>认证</li><li>缓存</li><li>并发</li><li>云服务</li><li>命令行参数解析</li><li>命令行 UI</li><li>命令行编辑器</li><li>压缩</li><li>计算（例如：BLAS）</li><li>加密</li><li>数据库</li><li>数据处理</li><li>数据结构</li><li>数据可视化</li><li>日期和时间</li><li>分布式系统</li><li>电子邮件</li><li>编码和解码</li><li>文件系统</li><li>图像处理</li><li>机器学习</li><li>解析</li><li>文本处理</li><li>虚拟化</li></ul><p>我认为，让 Swift 成为一门通用的语言，能够在非苹果操作系统上运行，Swift 需要提供一个健壮的、跨平台的包管理系统。</p><h2 id="你能做些什么？"><a href="#你能做些什么？" class="headerlink" title="你能做些什么？"></a>你能做些什么？</h2><h3 id="写库"><a href="#写库" class="headerlink" title="写库"></a>写库</h3><p>在你决定写 JSON 解析器，动画库、自定义的开关按钮，或者抽象的集合视图/表格视图的代码之前，考虑写一个跨平台的系统库。如果你不知道怎么做，你可以去看看 Go 和 Rust 提供的那些已有的库。</p><h3 id="重写现有-C-库"><a href="#重写现有-C-库" class="headerlink" title="重写现有 C 库"></a>重写现有 C 库</h3><p>对于某些场景，Swift 的确提供了库，但那些库底层仍然是 C 的实现。虽然那样也搞定了问题，但在混合的过程中引入了 C 这门不安全的语言，在那些要求绝对安全的执行案例中，我们必须要为此做特别处理。当然，如果你想不到你想要写什么，可以用纯 Swift 实现一个你使用过的东西。这也是一个好机会，学习更多的 C 的同时进而爱上 Swift。</p><h3 id="关心-Linux"><a href="#关心-Linux" class="headerlink" title="关心 Linux"></a>关心 Linux</h3><p>我最近用 Vapor 写了一个小应用，需要为它添加几个依赖库（比如：时间计数器）但大部分的现有的库只支持 iOS/macOS。 假如你有处理跨平台（由于没有 UIKit/AppKit 的依赖）的经验，可以尝试在 Linux 上测试编译 Swift。</p><p>这比听上去更简单。这里有一个可用的 <a href="https://hub.docker.com/r/ibmcom/swift-ubuntu/tags/" target="_blank" rel="noopener">Swift 4.1 版本的 docker 镜像</a>，你可以直接运行它来测试你的代码，或者选择通过 <a href="https://www.virtualbox.org/" target="_blank" rel="noopener">Virtualbox</a> 虚拟机来运行它。</p><h3 id="Swift-包管理的支持"><a href="#Swift-包管理的支持" class="headerlink" title="Swift 包管理的支持"></a>Swift 包管理的支持</h3><p>如果你已经有了一个库，除了支持 CocoaPods 和 Carthage 外，请尝试支持 Swift Package Manager。</p><h3 id="运行在-Foundation-库上"><a href="#运行在-Foundation-库上" class="headerlink" title="运行在 Foundation 库上"></a>运行在 Foundation 库上</h3><p>另一件依旧困难的事情是 Swift 在 Linux 的 <a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="noopener">Foundation 库</a> 是基于 iOS/macOS Foundation 库的二次实现，因此依旧存在些没有实现的特性和（特别棘手）bugs。这意味着也许你写在 Mac 上面的代码在 Xcode 中跑的很好，但由于 Linux Foundation 库的 bug，它运行在 Linux 上时可能会崩溃。为了拓展 Swift 的应用领域，让 Linux 上面的 Fundation 库代码变得更加健壮是一个很好的目标。</p><p>最简单的开始方式是去 <a href="https://bugs.swift.org/secure/Dashboard.jspa" target="_blank" rel="noopener">Swift Jira</a> 的首页搜索 Foundation bugs。</p><h3 id="帮助改进-Foundation-库"><a href="#帮助改进-Foundation-库" class="headerlink" title="帮助改进 Foundation 库"></a>帮助改进 Foundation 库</h3><p>如果你没有时间或者对在 Swift Foundation 上的工作内容不感兴趣。你也可以在 Linux 上使用或者测试 Foundation 库，并且提交 bug 报告。只要有越来越多的人使用它，它也将变得更加稳定。</p><h3 id="帮助改善-Linux-编辑体验"><a href="#帮助改善-Linux-编辑体验" class="headerlink" title="帮助改善 Linux 编辑体验"></a>帮助改善 Linux 编辑体验</h3><p>Linux 用户没有 Xcode，所以他们使用 Atom、Emacs、Vim 或 VSCode。这里已经有多个项目来让这些编辑器支持 Swift 语言编辑。但我们也许能够改进它们。如果你有空闲时间，用你喜欢的编辑器参与到这些项目中来，进行测试提交问题或解决这些问题。</p><h3 id="参加在-San-Jose-举办的-Try-Swift-大会"><a href="#参加在-San-Jose-举办的-Try-Swift-大会" class="headerlink" title="参加在 San Jose 举办的 Try Swift 大会"></a>参加在 San Jose 举办的 Try Swift 大会</h3><p>如果你恰好在 San Jose 参加今年的 WWDC。这是一个很好的学习机会。 你会遇见一些有趣的人，<a href="https://www.tryswift.co/events/2018/sanjose/" target="_blank" rel="noopener">尝试参加在 San Jose 举办的 Try Swift 大会</a>。 </p><blockquote><p>“你有机会为 Swift 做出贡献。加入一个 Swift 开源贡献者小组，讨论有关 Swift 开源项目的最新消息，然后在社区导师的帮助下为 Swift Evolution 做出自己贡献！”</p></blockquote><p><a href="https://www.tryswift.co/events/2018/sanjose/" target="_blank" rel="noopener">你可以查阅这个链接</a></p><h3 id="举手之劳"><a href="#举手之劳" class="headerlink" title="举手之劳"></a>举手之劳</h3><p>在过去的一年半里，我没有太多时间做任何关于开源的工作，因为我一直忙于自己的（闭源）项目，但我真想再次为 Swift 开源代码贡献。我真的很喜欢 Swift，这是一个很棒的语言，帮助它成功的那些日子，是我曾感到最美妙的时光，如果你有同样的感觉，请分享这篇文章。</p><p><a href="https://twitter.com/terhechte" target="_blank" rel="noopener">如果对文章内容有想法的话，欢迎来 Twitter 上一起讨论</a></p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：terhechte，&lt;a href=&quot;http://appventure.me/2018/05/03/expanding-swifts-reach/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-05-03&lt;br&gt;译者：&lt;a href=&quot;https://github.com/Adolf-L&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigLuo&lt;/a&gt;；校对：&lt;a href=&quot;https://github.com/Cee&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cee&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;我想大家应该都会同意 Swift 是一门优秀的语言，很好的处理了那些简单与复杂的问题。理论上讲，它将会成为重要的编程语言之一。目前，Swift 的使用仅限于苹果开发领域（外加少量服务端 Swift 以及近期宣布的 &lt;a href=&quot;https://www.tensorflow.org/community/swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift 版本的 Tensorflow&lt;/a&gt;）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“My goal for Swift has always been and still is total world domination. It’s a modest goal”&lt;/p&gt;
&lt;p&gt;“我一直期待着 Swift 统治世界，这是一个谦虚的目标。”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Chris Lattner&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着新的泛型特性在 Swift 4.1 中推出以及 &lt;a href=&quot;https://swift.org/abi-stability/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ABI 在 Swift 5 中逐渐稳定&lt;/a&gt;，Swift 似乎逐渐具备了跳出苹果开发领域的条件。本文我会讨论一个我知道的问题，它阻碍着 Swift 广泛的应用，准确的讲，与其它问题一样，该问题也正在被开发社区着手解决。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Hashable / Hasher</title>
    <link href="https://swift.gg/2018/10/01/hashable_hahser/"/>
    <id>https://swift.gg/2018/10/01/hashable_hahser/</id>
    <published>2018-10-01T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/hashable/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-08-13<br>译者：<a href="https://github.com/Damonvvong" target="_blank" rel="noopener">Damonwong</a>；校对：<a href="https://lision.me/" target="_blank" rel="noopener">Lision</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>当你在苹果商店预约天才吧服务后，相关工作人员会帮你登记并且安排特定的服务时间，在被带到座位上之后，工作人员会记录你的身份信息并添加到服务队列当中。</p><p>根据一份来自零售店某位前员工的报告表示，对于顾客的描述有着严格的指导方针。他们的外貌特征如：年龄、性别、种族、身高都没有被使用 —— 甚至连头发的颜色都没有被使用。而是通过顾客的着装来描述，例如“黑色的高领毛衣，牛仔裤和眼镜”。</p><p>这种描述顾客的方式和编程中的哈希函数有很多共同之处。同许多优秀的哈希函数一样，它是连续和易计算的，可用于快速找到你正在寻找的内容（或者人）。我想你肯定也觉得这样比队列要好用多了。</p><p>这周我们的主题是 <code>Hashable</code> 和相关的新类型 <code>Hasher</code>。它们共同组成了 Swift 最受喜爱的两个集合类 <code>Dictionary</code> 和 <code>Set</code> 的基础功能。</p><a id="more"></a><p>假设你有一个可以比较相等性的对象<strong><a href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E5%88%97_(%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5" target="_blank" rel="noopener">列表</a>)</strong>。要在这个列表中找到一个特定的对象，你需要遍历这个列表的元素，直到找到匹配项为止。随着你向列表中添加更多的元素时，需要找到其中任何一个元素所需的平均时间是线性级的(<code>O(n)</code>)。</p><p>如果将这些对象存储在一个<strong><a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">集合</a>)</strong>中，理论上可以在常量级时间(<code>O(1)</code>)内找到它们中的任何一个 - 也就是说，在一个包含 10 个元素的集合中查找或在一个包含 10000<sup>*</sup> 个元素的集合中查找所需的时间是一样的。这是怎么回事呢？因为集合不是按顺序存储对象的，而是将对象内容计算的<dfn>哈希值</dfn>作为索引存储。当在集合中查找对象时，可以使用相同的哈希函数计算新的哈希值然后查找对象存储位置。</p><p><sup>*</sup> 如果两个不同的对象具有相同的哈希值时，会产生<dfn>哈希冲突</dfn>。当发生哈希冲突时，它们将存储在该地址对应的列表中。对象之间发生冲突的概率越高，哈希集合的性能就会更加线性增长。</p><h2 id="Hashable"><a href="#Hashable" class="headerlink" title="Hashable"></a>Hashable</h2><p>在 Swift 中，<code>Array</code> 为列表提供了标准的接⼝，<code>Set</code> 为集合提供了标准的接⼝。如果要将对象存储到 <code>Set</code> 中，就要遵循 <code>Hashable</code> 协议及其扩展协议 <code>Equatable</code>。Swift 的标准映射接口 <code>Dictionary</code> 对它的关联类型 <code>Key</code> 也需要遵循 <code>Hashable</code> 协议及其扩展协议。</p><p>在 Swift 之前的版本中，为了让自定义类型能支持 <code>Set</code> 或 <code>Dictionary</code> 存储需要写⼤量的 <a href="https://nshipster.cn/swift-gyb/" target="_blank" rel="noopener">样板代码</a>。</p><p>以下面的 <code>Color</code> 类型为例，<code>Color</code> 使⽤了 8 位整型值来表示红，绿，蓝色值:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> red: <span class="type">UInt8</span></span><br><span class="line">    <span class="keyword">let</span> green: <span class="type">UInt8</span></span><br><span class="line">    <span class="keyword">let</span> blue: <span class="type">UInt8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要符合 <code>Equatable</code> 的要求，你需要提供一个 == 操作符的实现。要符合 <code>Hashable</code> 的要求，你需要提供⼀个名为 <code>hashValue</code> 的计算属性:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &lt; 4.1</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Color</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Color, rhs: Color)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.red == rhs.red &amp;&amp;</span><br><span class="line">               lhs.green == rhs.green &amp;&amp;</span><br><span class="line">               lhs.blue == rhs.blue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Color</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.red.hashValue ^</span><br><span class="line">               <span class="keyword">self</span>.green.hashValue ^</span><br><span class="line">               <span class="keyword">self</span>.blue.hashValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于大多数开发者⽽⾔，实现 <code>Hashable</code> 只是为了能尽快让要做的事情步入正轨，因此他们会对所有的存储属性使⽤<a href="https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96" target="_blank" rel="noopener">逻辑异或</a>操作，并在某一天调用它。</p><p>然⽽这种实现的一个缺陷是高哈希冲突率。由于逻辑异或满⾜<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E6%8F%9B%E5%BE%8B" target="_blank" rel="noopener">交换率</a>，像⻘色和⻩色这样不同的颜色也会发⽣哈希冲突:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &lt; 4.2</span></span><br><span class="line"><span class="keyword">let</span> cyan = <span class="type">Color</span>(red: <span class="number">0x00</span>, green: <span class="number">0xFF</span>, blue: <span class="number">0xFF</span>)</span><br><span class="line"><span class="keyword">let</span> yellow = <span class="type">Color</span>(red: <span class="number">0xFF</span>, green: <span class="number">0xFF</span>, blue: <span class="number">0x00</span>)</span><br><span class="line"></span><br><span class="line">cyan.hashValue == yellow.hashValue <span class="comment">// true, collision</span></span><br></pre></td></tr></table></figure><p>大多数时候这样做不会出问题；现代计算机已经足够强大以至于你很难意识到性能的衰减，除⾮你的实现细节存在⼤量问题。</p><p>但这并不是说这些细节⽆关紧要 —— 它们往往极其重要。稍后会详细介绍。</p><h2 id="自动合成-Hashable-实现"><a href="#自动合成-Hashable-实现" class="headerlink" title="自动合成 Hashable 实现"></a>自动合成 Hashable 实现</h2><p>从 Swift 4.1 开始，如果某个类型在声明时遵循了 <code>Equatable</code> 和 <code>Hashable</code> 协议并且它的成员变量同时也满足了这些协议，编译器会为其自动合成 <code>Equatable</code> 和 <code>Hashable</code> 的实现。</p><p>除了大大的提高了开发人员的开发效率以外，还可以大幅减少代码的数量。比如，我们之前 <code>Color</code> 的例子 —— 现在是最开始代码量的 1/3 :</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &gt;= 4.1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> red: <span class="type">UInt8</span></span><br><span class="line">    <span class="keyword">let</span> green: <span class="type">UInt8</span></span><br><span class="line">    <span class="keyword">let</span> blue: <span class="type">UInt8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管对语言进行了明显的改进，但还是有一些实现细节有着无法忽视的问题。</p><p>在 Swift Evolution 提案 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0185-synthesize-equatable-hashable.md" target="_blank" rel="noopener">SE-0185: 合成 <code>Equatable</code> 和 <code>Hashable</code> 的实现</a> 中， <a href="https://github.com/allevato" target="_blank" rel="noopener">Tony Allevato</a> 给哈希函数提供了这个注释: </p><blockquote><p>哈希函数的选择应该作为实现细节，而不是设计中的固定部分；因此，使用者不应该依赖于编译器自动生成的 Hashable 函数的具体特征。最可能的实现是在每个成员的哈希值上调用标准库中的 <code>_mixInt</code> 函数，然后将他们逻辑异或（^），如同目前 <code>Collection</code> 类型的哈希方式一样。</p></blockquote><p>幸运的是，Swift 不需要多久就能解决这个问题。我们将在下一个版本得到答案:</p><h2 id="Hasher"><a href="#Hasher" class="headerlink" title="Hasher"></a>Hasher</h2><p>Swift 4.2 通过引入 <code>Hasher</code> 类型并采用新的通用哈希函数进一步优化 <code>Hashable</code></p><p>在 Swift Evolution 提案 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0206-hashable-enhancements.md" target="_blank" rel="noopener">SE-0206: Hashable 增强</a> 中：</p><blockquote><p>使用一个好的哈希函数时，简单的查找，插入，删除操作都只需要常量级时间即可完成。然而，如果没有为当前数据选择一个合适的哈希函数，这些操作的预期时间就会和哈希表中存储的数据数量成正比。</p></blockquote><p>正如 <a href="https://github.com/lorentey" target="_blank" rel="noopener">Karoy Lorentey</a> 和 <a href="https://github.com/regexident" target="_blank" rel="noopener">Vincent Esche</a> 所指出的那样，<code>Set</code> 和 <code>Dictionary</code> 等基于哈希的集合主要特点是它们能够在常量级时间内查找值。如果哈希函数不能产生一个均匀的值分布，这些集合实际上就变成了链表。</p><p>Swift 4.2 中的哈希函数是基于伪随机函数族 <a href="https://en.wikipedia.org/wiki/SipHash" target="_blank" rel="noopener">SipHash</a> 实现的，比如 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/SipHash.swift" target="_blank" rel="noopener">SipHash-1-3 and SipHash-2-4</a>，分别在每个消息块异或哈希之后执行一次 round + 三次 final round，或两次 round + 四次 final round。(译者注：这里的 round 指的是伪随机数变化。具体实现看 <a href="https://github.com/apple/swift/blob/4967393618f89370269518cf3b5ad5247cb0a2c0/stdlib/public/core/SipHash.swift#L47" target="_blank" rel="noopener"><code>_round</code></a>)</p><p>现在，如果你要自定义类型实现 <code>Hashable</code> 的方式，可以重写 <code>hash(into:)</code> 方法而不是 <code>hashValue</code>。<code>hash(into:)</code> 通过传递了一个 <code>Hasher</code> 引用对象，然后通过这个对象调用 <code>combine(_:)</code> 来添加类型的必要状态信息。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &gt;= 4.2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> red: <span class="type">UInt8</span></span><br><span class="line">    <span class="keyword">let</span> green: <span class="type">UInt8</span></span><br><span class="line">    <span class="keyword">let</span> blue: <span class="type">UInt8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Synthesized by compiler</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">hash</span><span class="params">(into hasher: <span class="keyword">inout</span> Hasher)</span></span> &#123;</span><br><span class="line">        hasher.combine(<span class="keyword">self</span>.red)</span><br><span class="line">        hasher.combine(<span class="keyword">self</span>.green)</span><br><span class="line">        hasher.combine(<span class="keyword">self</span>.blue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default implementation from protocol extension</span></span><br><span class="line">    <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> hasher = <span class="type">Hasher</span>()</span><br><span class="line">        <span class="keyword">self</span>.hash(into: &amp;hasher)</span><br><span class="line">        <span class="keyword">return</span> hasher.finalize()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过抽象隔离底层的位操作细节，开发人员可以利用 Swift 内置的哈希函数，这样可以避免再现我们原有的基于逻辑异或实现的冲突：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &gt;= 4.2</span></span><br><span class="line"><span class="keyword">let</span> cyan = <span class="type">Color</span>(red: <span class="number">0x00</span>, green: <span class="number">0xFF</span>, blue: <span class="number">0xFF</span>)</span><br><span class="line"><span class="keyword">let</span> yellow = <span class="type">Color</span>(red: <span class="number">0xFF</span>, green: <span class="number">0xFF</span>, blue: <span class="number">0x00</span>)</span><br><span class="line"></span><br><span class="line">cyan.hashValue == yellow.hashValue <span class="comment">// false, no collision</span></span><br></pre></td></tr></table></figure><h3 id="自定义哈希函数"><a href="#自定义哈希函数" class="headerlink" title="自定义哈希函数"></a>自定义哈希函数</h3><p>默认情况下，Swift 使用通用的哈希函数将字节序列缩减为一个整数。</p><p>但是，你可以使用你项目中自定义的哈希函数来改进这个缩减的问题。比如，如果你正在编写一个程序来玩国际象棋或者棋盘游戏，你可以使用 <a href="https://en.wikipedia.org/wiki/Zobrist_hashing" target="_blank" rel="noopener">Zobrist hashing</a> 来快速的存储游戏的状态。</p><h3 id="避免哈希泛滥-Hash-Flooding"><a href="#避免哈希泛滥-Hash-Flooding" class="headerlink" title="避免哈希泛滥(Hash-Flooding)"></a>避免哈希泛滥(Hash-Flooding)</h3><p>选择像 SipHash 这样的加密算法有助于防止哈希泛滥的 DoS 攻击，这种攻击会尝试生成哈希冲突，并试图强制实施哈希数据结构最坏的情况，最终导致程序慢下来。<a href="https://arstechnica.com/information-technology/2011/12/huge-portions-of-web-vulnerable-to-hashing-denial-of-service-attack/" target="_blank" rel="noopener">这在 2010 年初引发了一系列的网络问题</a>。</p><p>为了使事情变的更加安全，<code>Hasher</code> 会在每次启动应用程序时生成一个随机种子值，使得哈希值更难以预测。</p><blockquote><p>你不应该依赖特定的哈希值，也不应该在程序执行中保存特定的哈希值。在极少数情况下，你确定要这么做的话，可以设置 SWIFT_DETERMINISTIC_HASHING 标识符来禁用随机哈希种子。</p></blockquote><p>编程类比的挑战在于它们通过边界情况规范反社会行为。</p><p>当我们能够考虑到攻击者所有可能利用来达到某种险恶目的的情况时，这时能体现出我们优秀工程师的品质 —— 比如哈希泛滥的 DoS 攻击。在现实生活中，这么做我们需要冒着失败的风险去应用这些 AFK（Away From Keyboard）知识。</p><p>也就是说…亲爱的读者，我不希望你和你的朋友下次穿一样的衣服去当地苹果商店的天才吧中制造混乱和不和谐。</p><p>请不要这么做。</p><p>相反的，希望你有下面的收获：</p><p>当你在天才吧等候的时候，和穿同样颜色衣服的人站得远一点。这会让每个人做事都变得容易得多。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了 Hashable 和相关的新类型 Hasher
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>使用 C-Reduce 进行调试</title>
    <link href="https://swift.gg/2018/09/27/debugging-with-c-reduce/"/>
    <id>https://swift.gg/2018/09/27/debugging-with-c-reduce/</id>
    <published>2018-09-27T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2018-06-29-debugging-with-c-reduce.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-06-29<br>译者：<a href="https://bignerdcoding.com/" target="_blank" rel="noopener">BigNerdCoding</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>调试复杂问题本身就并不轻松，如果还没有足够的上下文和大致方向的话那就是一件非常困难的事。所以对代码进行精简缩小调试范围也就变成了一种常见的行为。不过与繁杂的手动简化相比，执行自动化处理程序明显更容易发挥计算机自身的优势。C-Reduce 正是为此而生，它能自动对原始代码进行简化操作输出一个简化的调试友好版本。下面我们看看如何使用该自动化程序。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>C-Reduce 代码基于两个主要思想。</p><p>首先，C-Reduce 通过删除相关代码行或者将 token 重命名为更短的版本等手段，将某些原始代码转化为一个简化版本。</p><p>其次，对简化结果进行检验测试。上面的代码简化操作是盲目的，因此经常产生不含待跟踪错误甚至是根本无法编译的简化版本。所以在使用 C-Reduce 时，除原始代码外还需要一个用来测试简化操作是否符合特定“预期”的脚本程序。而“预期”的标准则由我们根据实际情况进行设定。例如，如果你想定位到某个 bug 那么“预期”就意味着简化版本包含与原始代码一致的错误。你可以利用脚本程序写出任何你想要的“预期”标准，C-Reduce 会依据该脚本程序确保简化版本符合预先定义的行为。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>C-Reduce 程序的依赖项非常多，安装也很复杂。好在有 Homebrew 的加持，我们只需输入以下命令即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install creduce</span><br></pre></td></tr></table></figure><p>如果你想手动安装的话，可以参照该安装 <a href="https://github.com/csmith-project/creduce/blob/master/INSTALL" target="_blank" rel="noopener">指南</a>。</p><h2 id="简易示例"><a href="#简易示例" class="headerlink" title="简易示例"></a>简易示例</h2><p>想出一个小的示例代码解释 C-Reduce 是很困难的，因为它的主要目的是从一个大的程序简化出一个小型示例。下面是我竭尽全力想出来的一个简单 C 程序代码，它会产生一些难以理解的编译警告。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat test.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">struct Stuff &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(int argc, char **argv) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ clang test.c</span><br><span class="line">test.c:3:1: warning: <span class="built_in">return</span> <span class="built_in">type</span> of <span class="string">'main'</span> is not <span class="string">'int'</span> [-Wmain-return-type]</span><br><span class="line">struct Stuff &#123;</span><br><span class="line">^</span><br><span class="line">test.c:3:1: note: change <span class="built_in">return</span> <span class="built_in">type</span> to <span class="string">'int'</span></span><br><span class="line">struct Stuff &#123;</span><br><span class="line">^~~~~~~~~~~~</span><br><span class="line">int</span><br><span class="line">test.c:10:1: warning: control reaches end of non-void <span class="keyword">function</span> [-Wreturn-type]</span><br><span class="line">&#125;</span><br><span class="line">^</span><br><span class="line">2 warnings generated.</span><br></pre></td></tr></table></figure><p>从警告中我们知道 <code>struct</code> 和 <code>main</code> 代码存在某种问题！至于具体问题是什么，我们可以在简化版本中仔细分析。</p><p>C-Reduce 能轻松的将程序精简到远超我们想象的程度。所以为了控制 C-Reduce 的精简行为确保简化操作符合特定预期，我们将编写一个小的 shell 脚本，编译该段代码并检查警告信息。在该脚本中我们需要匹配编译警告并拒绝任何形式编译错误，同时我们还需要确保输出文件包含 <code>struct Stuff</code>，详细脚本代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">clang test.c &amp;&gt; output.txt</span><br><span class="line">grep error output.txt &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">grep <span class="string">"warning: return type of 'main' is not 'int'"</span> output.txt &amp;&amp;</span><br><span class="line">grep <span class="string">"struct Stuff"</span> output.txt</span><br></pre></td></tr></table></figure><p>首先，我们对简化代码进行编译并将输出重定向到 <code>output.txt</code>。如果输出文件包含任何 “error” 字眼则立即退出并返回状态码 1。否则脚本将会继续检查输出文本是否包含特定警告信息和文本 <code>struct Stuff</code>。当 <code>grep</code> 同时成功匹配上述两个条件时，会返回状态码 0；否则就退出并返回状态码 1。状态码 0 表示符合预期而状态码 1 则表示简化的代码不符合预期需要重新简化。</p><p>接下来我们运行 C-Reduce 看看效果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ creduce interestingness.sh test.c </span><br><span class="line">===&lt; 4907 &gt;===</span><br><span class="line">running 3 interestingness tests <span class="keyword">in</span> parallel</span><br><span class="line">===&lt; pass_includes :: 0 &gt;===</span><br><span class="line">(14.6 %, 111 bytes)</span><br><span class="line"></span><br><span class="line">...lots of output...</span><br><span class="line"></span><br><span class="line">===&lt; pass_clex :: rename-toks &gt;===</span><br><span class="line">===&lt; pass_clex :: delete-string &gt;===</span><br><span class="line">===&lt; pass_indent :: final &gt;===</span><br><span class="line">(78.5 %, 28 bytes)</span><br><span class="line">===================== <span class="keyword">done</span> ====================</span><br><span class="line"></span><br><span class="line">pass statistics:</span><br><span class="line">  method pass_balanced :: parens-inside worked 1 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_includes :: 0 worked 1 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_blank :: 0 worked 1 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_indent :: final worked 1 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_indent :: regular worked 2 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 3 worked 3 <span class="built_in">times</span> and failed 30 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 8 worked 3 <span class="built_in">times</span> and failed 30 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 10 worked 3 <span class="built_in">times</span> and failed 30 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 6 worked 3 <span class="built_in">times</span> and failed 30 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 2 worked 3 <span class="built_in">times</span> and failed 30 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 4 worked 3 <span class="built_in">times</span> and failed 30 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 0 worked 4 <span class="built_in">times</span> and failed 20 <span class="built_in">times</span></span><br><span class="line">  method pass_balanced :: curly-inside worked 4 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 1 worked 6 <span class="built_in">times</span> and failed 33 <span class="built_in">times</span></span><br><span class="line"></span><br><span class="line"> ******** .../test.c ********</span><br><span class="line"></span><br><span class="line">struct Stuff &#123;</span><br><span class="line">&#125; <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们得到一个符合预期的简化版本，并且会覆盖原始代码文件。所以在使用 C-Reduce 时需要注意这一点！一定要在代码的副本中运行 C-Reduce 进行简化操作，否则可能对原始代码造成不可逆更改。</p><p>该简化版本使代码问题成功暴露了出来：在 <code>struct Stuff</code> 类型声明末尾忘记加分号，另外 <code>main</code> 函数没有明确返回类型。这导致编译器将 <code>struct Stuff</code> 错误的当作了返回类型。而 <code>main</code> 函数必须返回 <code>int</code> 类型，所以编译器发出了警告。</p><h2 id="Xcode-工程"><a href="#Xcode-工程" class="headerlink" title="Xcode 工程"></a>Xcode 工程</h2><p>对于单个文件的简化来说 C-Reduce 非常棒，但是更复杂场景下效果如何呢？我们大多数人都有多个 Xcode 工程，那么如何简化某个 Xcode 工程呢？</p><p>考虑到 C-Reduce 的工作方式，简化 Xcode 工程并不简单。它会将需要简化的文件拷贝到一个目录中，然后运行脚本。这样虽然能够同时运行多个简化任务，但如果需要其他依赖才能让它工作，那么就可能无法简化。好在可以在脚本中运行各种命令，所以可以将项目的其余部分复制到临时目录来解决这个问题。</p><p>我使用 Xcode 创建了一个标准的 Objective-C 语言的 Cocoa 应用，然后对 <code>AppDelegate.m</code> 进行如下修改：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> () </span>&#123;</span><br><span class="line">    <span class="built_in">NSWindow</span> *win;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">NSWindow</span> *window;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidFinishLaunching: (<span class="built_in">NSRect</span>)visibleRect &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Starting up"</span>);</span><br><span class="line">    visibleRect = <span class="built_in">NSInsetRect</span>(visibleRect, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    visibleRect.size.height *= <span class="number">2.0</span>/<span class="number">3.0</span>;</span><br><span class="line">    win = [[<span class="built_in">NSWindow</span> alloc] initWithContentRect: <span class="built_in">NSMakeRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>) styleMask:<span class="built_in">NSWindowStyleMaskTitled</span> backing:<span class="built_in">NSBackingStoreBuffered</span> defer:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line">    [win makeKeyAndOrderFront: <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Off we go"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这段代码会让应用在启动时崩溃：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = EXC_BAD_ACCESS (code=EXC_I386_GPFLT)</span><br><span class="line">  * frame #0: 0x00007fff3ab3bf2d CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 13</span><br></pre></td></tr></table></figure><p>上面的内容并不是一个非常有用的调用栈信息。虽然我们可以通过调试追溯问题，但是这里我们尝试使用 C-Reduce 来进行问题定位。</p><p>这里的 C-Reduce 预期定义将包含更多的内容。首先我们需要给应用设置运行的超时时间。我们会在运行时进行崩溃捕获操作，如果没有发生崩溃则保持应用正常运行直到触发超时处理而退出。下面是一段网上随处可见的 <code>perl</code> 脚本代码：</p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">function timeout() &#123; perl -e <span class="string">'alarm shift; exec @ARGV'</span> <span class="string">"$@"</span>; &#125;</span><br></pre></td></tr></table></figure><p>紧接着我们需要拷贝该工程文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -a ~/Development/creduce-examples/Crasher .</span><br></pre></td></tr></table></figure><p>然后将修改后的 <code>AppDelegate.m</code> 文件拷贝到合适的路径下。（注意：如果文件发现合适简化版本，C-Reduce 会将文件复制回来，所以一定要在这里使用 <code>cp</code> 而不是 <code>mv</code>。使用 <code>mv</code> 会导致一个奇怪的致命错误。）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp AppDelegate.m Crasher/Crasher</span><br></pre></td></tr></table></figure><p>接下来我们切换到 <code>Crasher</code> 目录执行编译命令，并在发生错误时退出。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Crasher</span><br><span class="line">xcodebuild || <span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p>如果编译成功，则运行应用并且设置超时时间。我的系统对编译项进行了设置，所以 <code>xcodebuild</code> 命令会将编译结果存放着本地 <code>build</code> 目录下。因为配置可能存在差异，所以你首先需要自行检查。如果你将配置设为共享构建目录的话，那么需要在命令行中增加 <code>—n 1</code> 来禁用 C-Reduce 的并发构建操作。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timeout 5 ./build/Release/Crasher.app/Contents/MacOS/Crasher</span><br></pre></td></tr></table></figure><p>如果应用发生崩溃的话，那么会返回特定状态码 139 。此时我们需要将其转化为状态码 0 ，其它情形统统返回状态码 1。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ $? -eq 139 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>紧接着，我们运行 C-Reduce：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ creduce interestingness.sh Crasher/AppDelegate.m</span><br><span class="line">...</span><br><span class="line">(78.1 %, 151 bytes)</span><br><span class="line">===================== <span class="keyword">done</span> ====================</span><br><span class="line"></span><br><span class="line">pass statistics:</span><br><span class="line">  method pass_ints :: a worked 1 <span class="built_in">times</span> and failed 2 <span class="built_in">times</span></span><br><span class="line">  method pass_balanced :: curly worked 1 <span class="built_in">times</span> and failed 3 <span class="built_in">times</span></span><br><span class="line">  method pass_clex :: rm-toks-7 worked 1 <span class="built_in">times</span> and failed 74 <span class="built_in">times</span></span><br><span class="line">  method pass_clex :: rename-toks worked 1 <span class="built_in">times</span> and failed 24 <span class="built_in">times</span></span><br><span class="line">  method pass_clex :: delete-string worked 1 <span class="built_in">times</span> and failed 3 <span class="built_in">times</span></span><br><span class="line">  method pass_blank :: 0 worked 1 <span class="built_in">times</span> and failed 1 <span class="built_in">times</span></span><br><span class="line">  method pass_comments :: 0 worked 1 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_indent :: final worked 1 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_indent :: regular worked 2 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 8 worked 3 <span class="built_in">times</span> and failed 43 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 2 worked 3 <span class="built_in">times</span> and failed 43 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 6 worked 3 <span class="built_in">times</span> and failed 43 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 10 worked 3 <span class="built_in">times</span> and failed 43 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 4 worked 3 <span class="built_in">times</span> and failed 43 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 3 worked 3 <span class="built_in">times</span> and failed 43 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 0 worked 4 <span class="built_in">times</span> and failed 23 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 1 worked 6 <span class="built_in">times</span> and failed 45 <span class="built_in">times</span></span><br><span class="line"></span><br><span class="line">******** /Users/mikeash/Development/creduce-examples/Crasher/Crasher/AppDelegate.m ********</span><br><span class="line"></span><br><span class="line"><span class="comment">#import "AppDelegate.h"</span></span><br><span class="line">@implementation AppDelegate</span><br><span class="line">- (void)applicationDidFinishLaunching:(NSRect)a &#123;</span><br><span class="line">    a = NSInsetRect(a, 0, 10);</span><br><span class="line">    NSLog(@<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>我们得到一个极其精简的代码。虽然 C-Reduce 没有移除 <code>NSLog</code> 那行代码，但是崩溃看起来并不是它引起的。所以此处导致崩溃的代码只能是 <code>a = NSInsetRect(a, 0, 10);</code> 这行代码。通过检查该行代码的功能和使用到的变量，我们能发现它使用了一个 <code>NSRect</code> 类型的变量而 <code>applicationDidFinishLaunching</code> 函数的入参实际上并不是该类型。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationDidFinishLaunching:(<span class="built_in">NSNotification</span> *)notification;</span><br></pre></td></tr></table></figure><p>因此该崩溃应该是由于类型不匹配导致的错误引起的。</p><p>因为编译工程的耗时远超过单文件而且很多测试示例都会触发超时处理，所以此例中的 C-Reduce 运行时间会比较长。C-Reduce 会在每次运行成功后将精简的文件写回原始文件，所以你可以使用文本编辑器保持文件的打开状态并查看更改结果。另外你可以在合适时时机运行 <code>^C</code> 命令结束 C-Reduce 执行，此时会得到部分精简过的文件。如果有必要你后续可以在此基础上继续进行精简工作。</p><h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><p>如果您使用 Swift 并且也有精简需求时该怎么办呢？从名字上来看，我原本以为 C-Reduce 只适用于 C（也许还包括 C++，因为很多工具都是如此）。</p><p>不过好在，这次我的直觉错了。C-Reduce 确实有一些与 C 相关的特定验证测试，但大部分还是和语言无关的。无论你使用何种语言只要你能写出相关的验证测试，C-Reduce 都能派上用场，虽然效率可能不是很理想。</p><p>下面我们就来试一试。我在 bugs.swift.org 上面找到了一个很好的测试 <a href="https://bugs.swift.org/browse/SR-7354" target="_blank" rel="noopener">用例</a>。不过该崩溃只出现在 Xcode9.3 版本上，而我正好就安装了该版本。下面是该 bug 示例的简易修改版：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crash</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> blah = <span class="type">ProblematicEnum</span>.problematicCase.problematicMethod()</span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"<span class="subst">\(blah)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ProblematicEnum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> first, second, problematicCase</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">problematicMethod</span><span class="params">()</span></span> -&gt; <span class="type">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> someVariable: <span class="type">SomeClass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .first:</span><br><span class="line">        someVariable = <span class="type">SomeClass</span>()</span><br><span class="line">    <span class="keyword">case</span> .second:</span><br><span class="line">        someVariable = <span class="type">SomeClass</span>()</span><br><span class="line">    <span class="keyword">case</span> .problematicCase:</span><br><span class="line">        someVariable = <span class="type">SomeClass</span>(someParameter: <span class="type">NSObject</span>())</span><br><span class="line">        <span class="number">_</span> = <span class="type">NSObject</span>().description</span><br><span class="line">        <span class="keyword">return</span> someVariable <span class="comment">// EXC_BAD_ACCESS (simulator: EXC_I386_GPFLT, device: code=1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="number">_</span> = [someVariable]</span><br><span class="line">    <span class="keyword">return</span> <span class="type">SomeClass</span>(someParameter: <span class="type">NSObject</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">init</span>(someParameter: <span class="type">NSObject</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">crash()</span><br></pre></td></tr></table></figure><p>当我们尝试在启用优化的情况下运行代码时，会出现如下结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swift -O test.swift </span><br><span class="line">&lt;unknown&gt;:0: error: fatal error encountered during compilation; please file a bug report with your project and the crash <span class="built_in">log</span></span><br><span class="line">&lt;unknown&gt;:0: note: Program used external <span class="keyword">function</span> <span class="string">'__T04test15ProblematicEnumON'</span> <span class="built_in">which</span> could not be resolved!</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>与之对应的验证脚本为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swift -O test.swift</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 134 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>运行 C-Reduce 程序我们可以达到如下的简化版本：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">a</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> b, <span class="built_in">c</span>, d</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">e</span><span class="params">()</span></span> -&gt; f &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .b:</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> .<span class="built_in">c</span>:</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> .d:</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">f</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>深入解析该编译错误超出了本文的范围，但如果我们需要对其进行修复时，该简化版本显然更方便。我们得到了一个相当简单的测试用例。 我们还可以推断出 Swift 语句和类的实例化之间存在一些交互，否则 C-Reduce 可能会删除其中一个。这为编译器导致该崩溃的原因提供了一些非常好的提示。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>测试示例的盲约精简并不是一种多复杂的调试技术，但是自动化让其变的更为有用高效。C-Reduce 可以作为你调试工具箱的一个很好补充。它并不适用所有场景，但是它在面对有些问题时能够带来不小的帮助。虽然在需要与多文件测试用例一起工作时可能存在一些困难，但检验脚本能够解决了该问题。另外，对于 Swift 这类其他语言来说 C-Reduce 也是开箱即用的，而不仅仅只能在 C 语言中发挥功效，所以不要因为你使用的语言不是 C 而放弃它。</p><p>今天内容到此为止。下次我还会带来与编程和代码相关的新内容。当然你也可以将你感兴趣的话题 <a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发送给我</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2018-06-29-debugging-with-c-reduce.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-06-29&lt;br&gt;译者：&lt;a href=&quot;https://bignerdcoding.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigNerdCoding&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;调试复杂问题本身就并不轻松，如果还没有足够的上下文和大致方向的话那就是一件非常困难的事。所以对代码进行精简缩小调试范围也就变成了一种常见的行为。不过与繁杂的手动简化相比，执行自动化处理程序明显更容易发挥计算机自身的优势。C-Reduce 正是为此而生，它能自动对原始代码进行简化操作输出一个简化的调试友好版本。下面我们看看如何使用该自动化程序。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="Debug" scheme="https://swift.gg/tags/Debug/"/>
    
      <category term="C-Reduce" scheme="https://swift.gg/tags/C-Reduce/"/>
    
  </entry>
  
  <entry>
    <title>iOS 12 中的 Siri Shortcuts 简介</title>
    <link href="https://swift.gg/2018/09/20/siri-shortcuts/"/>
    <id>https://swift.gg/2018/09/20/siri-shortcuts/</id>
    <published>2018-09-20T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：AppCoda，<a href="https://appcoda.com/siri-shortcuts/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-07-11<br>译者：<a href="http://wuqiuhao.github.io" target="_blank" rel="noopener">Hale</a>；校对：<a href="http://xiaolu520.com/" target="_blank" rel="noopener">liberalisman</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>在美国圣何塞举办的 2018 开发者大会上，苹果公布了 Siri Shortcuts，这是一个令人期待已久的功能，开发人员能够在自己的应用程序中扩展和增强 Siri 的功能。在这之前，SiriKit SDK 的功能非常有限。随着 Siri Shortcuts 的出现，开发人员可以扩展 Siri 的功能并通过构建自定义语音操作来唤起应用程序。</p><a id="more"></a><h2 id="Siri-Shortcuts-简史"><a href="#Siri-Shortcuts-简史" class="headerlink" title="Siri Shortcuts 简史"></a>Siri Shortcuts 简史</h2><p>Siri Shortcuts 的核心是自动化。Siri Shortcuts 是由前 WWDC 奖学金获得者开发的 iOS 自动化应用程序 Workflow 演变而来的。苹果在2017年收购了 Workflow，但出乎意料的是，即便在收购之后，该应用依然独立的在 App Store 上线。</p><p><img src="https://appcoda.com/wp-content/uploads/2018/07/workflow-app.jpg" alt=""></p><blockquote><p>Shortcuts 让你可以将应用程序的功能暴露给 Siri。</p></blockquote><p>Apple 全新的 Siri Shortcuts 大量借鉴了 Workflow。但是区分语音 Shortcuts 短句与 Shortcuts 应用本身还是很重要的。Shortcuts 应用允许用户基于语音短句创建常见的日常任务，Siri Shortcuts 使开发人员能够在自己的原生应用程序中扩展 Siri 的功能。</p><p>在撰写本文时，Shortcuts 应用程序 无法在 iOS 12 Beta 2 Build 中进行测试。那么，我们将在自己构建的自定义应用程序中探索 Siri Shortcuts 的实用功能。</p><h2 id="我们的示例工程"><a href="#我们的示例工程" class="headerlink" title="我们的示例工程"></a>我们的示例工程</h2><blockquote><p>注意：本教程假定你基本熟悉 NSUserActivity API。如果你不熟悉，请参阅我们关于此主题的 <a href="https://www.appcoda.com/core-spotlight-framework/" target="_blank" rel="noopener">优秀教程</a>。</p></blockquote><p>在本教程中，我们将探究如何在一个简单的项目中利用 Siri Shortcuts，在用户说出 “Say Hi” 之类的短语时启动我们的应用程序并展示出一个 UIAlertView。</p><p>此应用程序简单概述了如何在一个大型项目中不增加复杂代码的前提下集成 Siri Shortcuts。在本教程结束时，你应该扎实掌握 Siri Shortcuts 背后的用例和技术，并了解如何将它们与你的应用程序集成！</p><h2 id="在新项目中定义你的-Shortcuts"><a href="#在新项目中定义你的-Shortcuts" class="headerlink" title="在新项目中定义你的 Shortcuts"></a>在新项目中定义你的 Shortcuts</h2><p>当我们在创建任意新项目时，花一些时间来建立基本的项目结构是很重要的。首先我们需要有 iOS 12，macOS Mojave 和 Xcode 10 的最新开发人员预览版。如果你还没有安装这些，你可以从 <a href="https://developer.apple.com/" target="_blank" rel="noopener">开发者网站</a> 下载安装。</p><p>在 Xcode 创建一个名为 <em>SiriShortcuts</em> 的应用程序。将组织 ID 设置为 <code>com.appcoda</code>，这些后期可以按需修改。</p><p><img src="https://appcoda.com/wp-content/uploads/2018/07/2-1240x793.png" alt=""></p><p>如下所示，在项目的 <em>Project Settings</em> 中选择 <em>Capabilities</em>，启用 Siri。接下来我们就可以在应用程序中使用 Siri SDK，并将 .entitlements 文件添加到项目中。</p><p><img src="https://appcoda.com/wp-content/uploads/2018/07/4-1240x793.png" alt=""></p><p>启用 S​​iri 后，Xcode 会将 <code>.entitlements</code> 文件添加到项目里。然后将 <code>Intents.framework</code> 这个全新的框架加入到项目中。</p><p><img src="https://appcoda.com/wp-content/uploads/2018/07/7-1240x793.png" alt=""></p><p>最后，在 <code>Info.plist</code> 中添加 <code>NSUserActivityTypes</code>。该项的值应该包含你的 Bundle ID 以及唤醒 Siri 的行为 ，例如 “sayHi”。</p><p><img src="https://appcoda.com/wp-content/uploads/2018/07/8-1240x775.png" alt=""></p><h2 id="集成-Shortcut"><a href="#集成-Shortcut" class="headerlink" title="集成 Shortcut"></a>集成 Shortcut</h2><blockquote><p>要创建一个 Shortcut 应用，我们首先配置 Shortcut，然后将 Shortcut 集成到项目中</p></blockquote><p>现在我们的项目已经完成了所有 Shortcut 的配置工作，是时候将 Shortcut 集成到项目中了。</p><p>根据 Apple 开发者文档，</p><blockquote><p>每次用户在你的应用中执行操作时，你都应该进行一次 Shortcut 集成。例如，用户可以使用你的应用从餐厅订购汤，请在用户下订单后为支付操作进行 Shortcut 集成。如果用户未在你的应用中执行操作，则不需要进行集成操作。</p></blockquote><p>显然，只有在提供有意义的用例时我们才需要集成 Shortcut，从而增强应用程序的整体功能。</p><p>回到代码中，首先我们前往 <code>ViewController.swift</code> 文件。在 <code>viewDidLoad</code> 方法之后，创建一个名为 <code>setupIntents</code> 的新方法。在此方法中，实现我们的 Siri Shortcuts 代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupIntents</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> activity = <span class="type">NSUserActivity</span>(activityType: <span class="string">"com.AppCoda.SiriSortcuts.sayHi"</span>) <span class="comment">// 1</span></span><br><span class="line">        activity.title = <span class="string">"Say Hi"</span> <span class="comment">// 2</span></span><br><span class="line">        activity.userInfo = [<span class="string">"speech"</span> : <span class="string">"hi"</span>] <span class="comment">// 3</span></span><br><span class="line">        activity.isEligibleForSearch = <span class="literal">true</span> <span class="comment">// 4</span></span><br><span class="line">        activity.isEligibleForPrediction = <span class="literal">true</span> <span class="comment">// 5</span></span><br><span class="line">        activity.persistentIdentifier = <span class="type">NSUserActivityPersistentIdentifier</span>(rawValue: <span class="string">"com.AppCoda.SiriSortcuts.sayHi"</span>) <span class="comment">// 6</span></span><br><span class="line">        view.userActivity = activity <span class="comment">// 7</span></span><br><span class="line">        activity.becomeCurrent() <span class="comment">// 8</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>让我们来看看这段代码做了什么。</p><ul><li><p>第一行，我们创建了 NSUserActivity 实例并将我们在 <code>Info.plist</code> 文件中定义的标识符赋值给 activityType。</p></li><li><p>第二行，我们定义了 Activity 的标题。（会应用在设置中心和 Spotlight 的搜索中。如果你对 NSUserActivity 以及 spotlight 搜索索引的工作方式不是很熟悉，我建议你阅读我们关于这个主题的其他教程。）</p></li><li><p>第三行，我们添加了一个 <code>userInfo</code> 字典。根据 Apple 的说法， userInfo 字典包含了在另一台设备上继续活动所需的与应用程序相关的状态信息。</p></li><li><p>下一步，我们设置 <code>.isEligibleForSearch</code> 参数为 <code>true</code> 然后在下一行启用 <code>isEligibleForPrediction</code>。这两个属性允许 iOS 在设备上为我们的 NSUserActivity 提供搜索和建议。</p></li><li><p>接下来，我们将 <code>persistentIdentifier</code> 属性设置为 NSUserActivityPersistentIdentifier 的实例，此实例用与第一行相同的标识符进行构造。</p></li><li><p>最后，我们将上面创建的 activity 实例赋值给视图的 <code>userActivity</code> 属性，并调用 <code>becomeCurrent()</code> 方法来激活我们的 Activity。</p></li></ul><p>我们再创建另一个名为 <code>sayHi()</code> 的方法并粘贴以下代码。此代码创建一个 UIAlertController 以显示消息。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"Hi There!"</span>, message: <span class="string">"Hey there! Glad to see you got this working!"</span>, preferredStyle: <span class="type">UIAlertController</span>.<span class="type">Style</span>.alert)</span><br><span class="line">        alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertAction</span>.<span class="type">Style</span>.<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">        <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述方法很简单，主要用于说明 Siri Shortcuts 是如何工作的。另外需要注意这是一个 <strong>public</strong> 函数，因为我们需要在视图控制器的作用域之外使用它。</p><h2 id="公开-Activity"><a href="#公开-Activity" class="headerlink" title="公开 Activity"></a>公开 Activity</h2><p>现在，你已经在 <code>ViewController.swift</code> 设置了基本功能，切换到 <code>AppDelegate.swift</code> 文件并添加 <code>application(_:continueUserActivity:restorationHandler)</code> 方法，如下所示。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, <span class="keyword">continue</span> userActivity: NSUserActivity, restorationHandler: @escaping <span class="params">([UIUserActivityRestoring]?)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> viewController = window?.rootViewController <span class="keyword">as</span>! <span class="type">ViewController</span></span><br><span class="line">  viewController.sayHi()</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码将我们新创建的 Activity 公开在应用委托方法中并允许 Siri 对此 Activity 进行操作唤起应用。</p><p>现在让我们试试看！导航到“设置”应用并选择 Siri。你应该看到一个名为 ”Say Hi” 的新快捷方式。单击 <code>+</code> 按钮添加它，然后按照屏幕上的提示创建自定义语音短语以创建此快捷方式。</p><p>现在你可以唤起 Siri 并说出你的短语，体验 Shortcut！</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvfvhpdhd4j31kw0jr1kx.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正如你所见，在项目中使用 NSUserActivity 可以很容易地实现 Siri Shortcuts 的强大功能。在本教程中,我创建了一个基础的应用，同样的你也可以将这些技术应用到你自己的应用中。Siri Shortcuts 的使用场景还有很多，相信开发者们会以更创新和独特的方式来使用这项新技术。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了基于 iOS12 和 XCode10 创建 NSUserActivity 将示例应用支持 Siri Shortcuts，并在设置中自定义 Siri 短语以唤起应用触发事件。
    
    </summary>
    
      <category term="AppCoda" scheme="https://swift.gg/categories/AppCoda/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的属性</title>
    <link href="https://swift.gg/2018/09/18/properties-in-swift/"/>
    <id>https://swift.gg/2018/09/18/properties-in-swift/</id>
    <published>2018-09-18T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/properties-in-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-03-15<br>译者：<a href="https://www.sunnyyoung.net/" target="_blank" rel="noopener">Sunnyyoung</a>；校对：<a href="http://linusling.com" target="_blank" rel="noopener">小铁匠Linus</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>Swift 中有两种类型的属性：存储属性与计算属性。存储属性将值（常量或者变量）保存为实例或类型的一部分，而计算属性没有存储值。</p><p>提示：这篇文章已经更新至 Swift 4。</p><a id="more"></a><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p>让我们从存储属性开始看起。想象一下你有一个名为 Circle 的类：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line">circle.radius = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"radius: <span class="subst">\(circle.radius)</span>"</span>) <span class="comment">//radius: 10.0</span></span><br></pre></td></tr></table></figure><p>Circle 拥有名为 <code>radius</code> 的实例变量，默认值为 0。在 Swift 中，每个实例变量都为一个属性。因此你可以添加所谓的属性观察者。在 Swift 中有两种类型的属性观察者：一种在赋值之前调用，另一种在赋值之后调用。</p><p>在赋值后调用的属性观察者采用 <code>didSet</code> 关键字标记。在我们的示例中，你可以使用它来监测新设置的值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">                radius = oldValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line"> </span><br><span class="line">circle.radius = -<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"radius: <span class="subst">\(circle.radius)</span>"</span>) <span class="comment">//radius: 0.0</span></span><br><span class="line"> </span><br><span class="line">circle.radius = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"radius: <span class="subst">\(circle.radius)</span>"</span>) <span class="comment">//radius: 10.0</span></span><br></pre></td></tr></table></figure><p>在属性观察者中你可以通过变量 <code>oldValue</code> 来访问属性的旧值。</p><p>你还可以使用 <code>willSet</code> 属性观察者，它在赋值之前会被调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"About to assign the new value <span class="subst">\(newValue)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">                radius = oldValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line"> </span><br><span class="line">circle.radius = <span class="number">10</span> <span class="comment">//设置新值 10.0</span></span><br></pre></td></tr></table></figure><p>在 <code>willSet</code> 中，你可以通过变量 <code>newValue</code> 来访问属性的新值。</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>与存储属性不同的是，计算属性并不会存储属性的值。因此在每次调用计算属性时，都要计算该值。在 <code>Circle</code> 类中，你可以将属性 <code>area</code> 定义为计算属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">                radius = oldValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> radius * radius * <span class="type">Double</span>.pi</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line">circle.radius = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"area: <span class="subst">\(circle.area)</span>"</span>) <span class="comment">//area: 78.5398163397448</span></span><br></pre></td></tr></table></figure><p>计算属性总是需要一个 <code>getter</code>。如果缺少 <code>setter</code>，则该属性被称为只读属性。下面这个例子很好地说明了 <code>setter</code> 的作用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">                radius = oldValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> radius * radius * <span class="type">Double</span>.pi</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newArea) &#123;</span><br><span class="line">            radius = sqrt(newArea / <span class="type">Double</span>.pi)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line"></span><br><span class="line">circle.area = <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"radius: <span class="subst">\(circle.radius)</span>"</span>) <span class="comment">//radius: 2.82094791773878</span></span><br></pre></td></tr></table></figure><p>至此，每次对 area 设置了新的值之后，radius 都会被重新计算。</p><h2 id="存储属性的初始化"><a href="#存储属性的初始化" class="headerlink" title="存储属性的初始化"></a>存储属性的初始化</h2><p>每个存储属性在它的对象实例化之后都必须有值。属性初始化有两种方法：</p><ul><li>在 <code>init</code> 方法中初始化值</li><li>给属性设置默认的值</li></ul><p>下面的例子同时使用了这两种方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(radius: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.radius = radius</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> circle = <span class="type">Circle</span>(radius: <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>如果存储属性在对象实例化之后没有值，代码无法通过编译。</p><h2 id="懒加载属性"><a href="#懒加载属性" class="headerlink" title="懒加载属性"></a>懒加载属性</h2><p>如果具有默认值的存储属性使用了关键字 <code>lazy</code> 标记，则其默认值不会立即初始化，而是在第一次访问该属性时初始化。</p><p>因此，如果该属性从未被访问，它将永远不会被初始化。你可以将这种特性应用于一些特别耗费 CPU 或内存的初始化上。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> testString: <span class="type">String</span> = <span class="string">"TestString"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> testClass = <span class="type">TestClass</span>()</span><br><span class="line"><span class="built_in">print</span>(testClass.testString) <span class="comment">//TestString</span></span><br></pre></td></tr></table></figure><p>该属性在被访问之前不会进行初始化。在这个例子中并不容易看出来。但由于初始化也可以在 block 里面实现，我们可以使它更明显一些：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> testString: <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"about to initialize the property"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TestString"</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testClass = <span class="type">TestClass</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"before first call"</span>)</span><br><span class="line"><span class="built_in">print</span>(testClass.testString)</span><br><span class="line"><span class="built_in">print</span>(testClass.testString)</span><br></pre></td></tr></table></figure><p>这个例子的输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">before first call</span><br><span class="line">about to initialize the property</span><br><span class="line">TestString</span><br><span class="line">TestString</span><br></pre></td></tr></table></figure><p>这意味着该 block 仅被调用一次 - 第一次访问该属性的时候。由于存储属性是可变的，因此可以更改初始值。</p><h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><p>类型属性是类的一部分，但不是实例的一部分，类型属性也被称为静态属性。存储属性和计算属性都可以是类型属性。类型属性的关键字是 <code>static</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> testString: <span class="type">String</span> = <span class="string">"TestString"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(TestClass.testString)</span>"</span>) <span class="comment">//TestString</span></span><br></pre></td></tr></table></figure><p>如你所见，它们使用类名而不是实例对象来访问它们。此外，由于类型属性没有初始化方法，它总是需要一个默认值。</p><h2 id="拥有私有-Setter-的公共属性"><a href="#拥有私有-Setter-的公共属性" class="headerlink" title="拥有私有 Setter 的公共属性"></a>拥有私有 Setter 的公共属性</h2><p>正如我在 <a href="http://www.thomashanning.com/public-properties-with-private-setters/" target="_blank" rel="noopener">另一篇文章</a> 中介绍的那样，这是一种常见的情况，你不想提供一个公共的 setter，而是提供一个私有的 setter。这是封装的基本原则。这样只有类本身可以操作该属性，但仍可从类外部访问读取它。</p><p>来看下面的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> area: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> diameter: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> radius: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            calculateFigures()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(radius:<span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.radius = radius</span><br><span class="line">        calculateFigures()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">calculateFigures</span><span class="params">()</span></span> &#123;</span><br><span class="line">        area = <span class="type">Double</span>.pi * radius * radius</span><br><span class="line">        diameter = <span class="number">2</span> * <span class="type">Double</span>.pi * radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>(radius: <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"area: <span class="subst">\(circle.area)</span>"</span>) <span class="comment">//area: 78.5398163397448</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"diameter: <span class="subst">\(circle.diameter)</span>"</span>) <span class="comment">//diameter: 31.4159265358979</span></span><br><span class="line"></span><br><span class="line">circle.area = <span class="number">10</span> <span class="comment">//编译错误：无法对 'area' 属性进行赋值，因为 setter 方法不可访问</span></span><br></pre></td></tr></table></figure><p>这里的属性 <code>area</code> 和 <code>diameter</code> 可以从类的外部访问，但只能在类内部赋值。为此你必须使用 <code>public private(set)</code> 的组合。根据本人的经验，这个特性在 iOS 开发中很少使用，但它对写出更少 bug 的代码很有帮助。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文简单介绍了 Swift 中的属性
    
    </summary>
    
      <category term="Thomas Hanning" scheme="https://swift.gg/categories/Thomas-Hanning/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>在序列的链式操作中注入副作用</title>
    <link href="https://swift.gg/2018/09/13/chained-foreach/"/>
    <id>https://swift.gg/2018/09/13/chained-foreach/</id>
    <published>2018-09-13T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://oleb.net/blog/2017/10/chained-foreach/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017/10/30<br>译者：<a href="https://dingtz.com/" target="_blank" rel="noopener">jojotov</a>；校对：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>，<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>几周前，一位读者指出了 <a href="https://oleb.net/advanced-swift/" target="_blank" rel="noopener"><em>Advanced Swift</em></a> 中的<a href="https://twitter.com/jasonalexzurita/status/915972380685516800" target="_blank" rel="noopener">一处错误</a>。我们当时这样描述 Swift 中的 <code>forEach</code> 方法：</p><blockquote><p><code>forEach</code> 作为一系列链式调用中的一部分时确实可以大放异彩。举个例子，试想一下你在一个语句中通过链式调用的方式调用了几次 <code>map</code> 和 <code>filter</code> 方法。在调试这段代码时，你希望能够打印出某几步操作中间的值。要达成这一目的，在你期望的位置插入一个 <code>forEach</code> 或许是最快速的解决方式。</p></blockquote><p>当我写下这段描述时，众多美妙的想法涌现在我脑中，因为这听起来是个非常实用的特性<a href="#foot1" id="1"><sup>[1]</sup></a>（你并不能通过 <code>for-in</code> 循环达到这种效果）。可事实却如此的残酷 —— 你不能在一系列链式调用中间插入 <code>forEach</code>！</p><a id="more"></a><h2 id="理想中的形式"><a href="#理想中的形式" class="headerlink" title="理想中的形式"></a>理想中的形式</h2><p>为了以代码的形式更好地阐述我的想法，先让我们设想有如下一系列的链式调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = <span class="number">1</span>...<span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> sumOfSquaredEvenNumbers = numbers</span><br><span class="line">    .<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line">    .<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line"><span class="comment">// → 220</span></span><br></pre></td></tr></table></figure><p>现在假设我们希望确认一下每个链式操作是否达到了预期的效果 —— 例如 <code>filter</code> 和（或） <code>map</code> 操作后的返回值是否正确，最简洁的方式当然是在两个操作中间插入类似 <code>.forEach { print($0) }</code> 的调用。</p><p>但为什么 <code>forEach</code> 并不支持类似这样的使用方式呢？原因在于，在一系列链式调用中间的任何操作，都必须返回一个遵循 <a href="https://developer.apple.com/documentation/swift/sequence" target="_blank" rel="noopener"><code>Sequence</code></a> 协议的对象，这样下一个链式操作才能正常执行。而 <code>forEach</code> 的返回值为 <code>()</code>，因此它只能在一系列链式操作的结尾处调用。</p><h2 id="实现一个返回-Self-的-forEach"><a href="#实现一个返回-Self-的-forEach" class="headerlink" title="实现一个返回 Self 的 forEach"></a>实现一个返回 <code>Self</code> 的 <code>forEach</code></h2><p>值得庆幸的一点是，实现这个功能并不困难。我们所需要做的事情只是实现一个方法 —— 它能够遍历序列，并对每个元素执行一次传入的函数（就像 <code>forEach</code> 一样），最后返回自己（这样链式操作就能够无感知地继续进行）。换句话来说，这个方法的返回值类型应为 <code>Self</code>。为了避免在类型检查的时候这个方法与原生的 <code>forEach</code> 发生混淆，我把它命名为 <code>forEachPerform</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Perform a side effect for each element in `self`.</span></span><br><span class="line">    @discardableResult</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">forEachPerform</span><span class="params">(<span class="number">_</span> body: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; ())</span><br><span class="line">        <span class="keyword">rethrows</span> -&gt; <span class="type">Self</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> forEach(body)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>forEach</code> 不同，我们可以插入这个方法到一系列链式操作中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sumOfSquaredEvenNumbers = numbers</span><br><span class="line">    .<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">    .forEachPerform &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line">    .<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line"><span class="comment">/* Prints:</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>除此之外，我还添加了另一个非常有用的方法。这个方法只会对整个序列调用传入参数中的函数一次，而不会遍历序列并对每一个元素都调用一次。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Perform a side effect.</span></span><br><span class="line">    @discardableResult</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(<span class="number">_</span> body: <span class="params">(<span class="keyword">Self</span>)</span></span></span> <span class="keyword">throws</span> -&gt; ())</span><br><span class="line">        <span class="keyword">rethrows</span> -&gt; <span class="type">Self</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> body(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个方法可以完美地打印每一步链式操作的中间值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sumOfSquaredEvenNumbers = numbers</span><br><span class="line">    .<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">    .perform &#123; <span class="built_in">print</span>(<span class="string">"After filter: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line">    .perform &#123; <span class="built_in">print</span>(<span class="string">"After map: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</span><br><span class="line">    .<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line"><span class="comment">/* Prints:</span></span><br><span class="line"><span class="comment">After filter: [2, 4, 6, 8, 10]</span></span><br><span class="line"><span class="comment">After map: [4, 16, 36, 64, 100]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="自毁序列"><a href="#自毁序列" class="headerlink" title="自毁序列"></a>自毁序列</h2><p>我们新添加的方法返回了一个未修改过的 <code>self</code>，因此把它插入一系列链式调用中是完全没有影响的。但我们需要注意， <code>Sequence</code> 协议目前的代码实现中并没有保证多次的迭代返回完全相同的序列。</p><blockquote><p>译者注:</p><p>苹果官方 <code>Sequence</code> 的文档中有一段关与 <a href="https://developer.apple.com/documentation/swift/sequence#Repeated%20Access" target="_blank" rel="noopener">Repeated Access</a> 的描述：</p><p>The <code>Sequence</code> protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple <code>for</code>-<code>in</code> loops on a sequence will either resume iteration or restart from the beginning:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> element <span class="keyword">in</span> sequence &#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> ... some condition &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">for</span> element <span class="keyword">in</span> sequence &#123;</span><br><span class="line">&gt;     <span class="comment">// No defined behavior</span></span><br><span class="line">&gt; &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>大多数遵循 <code>Sequence</code> 的类型会确保上面的这种情况不会发生（例如 <a href="https://developer.apple.com/documentation/swift/array" target="_blank" rel="noopener"><code>Array</code></a>），但假设你有一个可以用于接收来自网络 socket 的字节流的 <code>Sequence</code> 类型——调用 <code>forEachPerform</code> 或者 <code>perform</code> 会打乱其顺序，导致随后操作中的数据不能被正确处理。</p><p>如果你的代码中存在上述问题，你可以选择让 <code>forEachPerform</code> 和 <code>perform</code> 方法返回一个 <code>Array&lt;Element&gt;</code> 类型（这样可以把可破坏的序列隐式转换为可重复的序列），或者可以把这些方法加到  <a href="https://developer.apple.com/documentation/swift/collection" target="_blank" rel="noopener"><code>Collection</code></a> 中（<code>Collection</code> 类型保证了迭代不会破坏顺序）。</p><h2 id="让它变“懒”"><a href="#让它变“懒”" class="headerlink" title="让它变“懒”"></a>让它变“懒”</h2><p><code>forEachPerform</code> 有个不太容易发现的问题：如果我们把它放在 <strong><em>惰性队列 (lazy sequences)</em></strong> 的链式调用之间，惰性队列会失去其原本的惰性。</p><p>惰性队列的设计初衷是为了把所有需要对下一个元素所做的工作都尽可能地延迟进行 —— 也就是说，当一个惰性序列的链式调用的最终返回值需要被获取时，那些被 ”延迟“ 的工作才会真正执行。由于 <code>forEachPerform</code> 的实现中遍历了序列的每个元素，我们让这个队列的任何惰性都被破坏了。</p><p>为了保证序列的惰性，我们可以定义一个自己的惰性迭代器以及序列类型，分别命名为 <code>LazyForEachIterator</code> 和 <code>LazyForEachSequence</code>。它们的工作与标准库中类似的类型相差无几：它们会把传入的函数以及序列 <em>保存</em> 起来，而不是立即执行传入的函数。<em>直到</em> 某个操作访问到下个元素时，它们才会轮流尝试获取原本序列的下一个元素，并执行相应的操作。</p><p>实现代码大概如此：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LazyForEachIterator</span>&lt;<span class="title">Base</span>: <span class="title">IteratorProtocol</span>&gt;</span></span><br><span class="line"><span class="class">    : <span class="title">IteratorProtocol</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Base</span>.<span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> nextElement = base.next() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        perform(nextElement)</span><br><span class="line">        <span class="keyword">return</span> nextElement</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> base: <span class="type">Base</span></span><br><span class="line">    <span class="keyword">let</span> perform: (<span class="type">Base</span>.<span class="type">Element</span>) -&gt; ()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LazyForEachSequence</span>&lt;<span class="title">Base</span>: <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class">    : <span class="title">LazySequenceProtocol</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span></span><br><span class="line">        -&gt; <span class="type">LazyForEachIterator</span>&lt;<span class="type">Base</span>.<span class="type">Iterator</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">LazyForEachIterator</span>(</span><br><span class="line">            base: base.makeIterator(),</span><br><span class="line">            perform: perform)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> base: <span class="type">Base</span></span><br><span class="line">    <span class="keyword">let</span> perform: (<span class="type">Base</span>.<span class="type">Element</span>) -&gt; ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这个序列遵循 <a href="https://developer.apple.com/documentation/swift/lazysequenceprotocol" target="_blank" rel="noopener"><code>LazySequenceProtocol</code></a> 协议。此协议继承于 <code>Sequence</code>。这个协议的职责是为一些即刻响应的操作（译者注：例如 <code>map</code> 和 <code>filter</code>）提供了惰性实现。</p><blockquote><p>译者注:</p><p>关于“即刻响应的操作”（原文中为 <em>normally-eager operations</em>），<code>LazySequenceProtocol</code> 的<a href="https://developer.apple.com/documentation/swift/lazysequenceprotocol" target="_blank" rel="noopener">官方文档</a>中有这样一段解释：</p><p>Sequence operations taking closure arguments, such as <code>map</code> and <code>filter</code>, are normally eager: they use the closure immediately and return a new array. </p><p>同时，文档紧跟着解释了 <code>lazy</code> 是如何让这种 <em>normally-eager operations</em> 变成惰性操作的：</p><p>Using the <code>lazy</code> property gives the standard library explicit permission to store the closure and the sequence in the result, and defer computation until it is needed.</p></blockquote><p>Swift 的类型推断机制其中一条规则是：在给定的约束的前提下，Swift 编译器会自动选择一个最明确且可工作的重载（译者注：可查看官方文档 <a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID322" target="_blank" rel="noopener">Type Safety and Type Inference</a> ）。因此，当你对一个遵循了 <code>LazySequenceProtocol</code> 协议的值调用诸如 <code>map</code> 的方法时，编译器会倾向于 <code>map</code> 方法的惰性变体而非默认版本实现。</p><p>为了在我们的方法中实现同样的效果，我们可以在 <code>LazySequenceProtocol</code> 的扩展中加入一个 <code>forEachPerform</code> 的变体，同时让它返回一个惰性序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LazySequenceProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">forEachPerform</span><span class="params">(<span class="number">_</span> body: @escaping <span class="params">(Element)</span></span></span> -&gt; ())</span><br><span class="line">        -&gt; <span class="type">LazyForEachSequence</span>&lt;<span class="type">Self</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">LazyForEachSequence</span>(base: <span class="keyword">self</span>,</span><br><span class="line">            perform: body)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在以下几个方面上与与非惰性版本略有不同：</p><ul><li>因为我们需要把传入的闭包暂存起来，所以它必须是 <code>@escaping</code>，也就是逃逸闭包。</li><li>由于其惰性性质，这个方法并不支持会抛出异常的方法。</li><li>一般来说，一个惰性操作完成后必定会有后续的操作，因此其返回值并没有标记为 <code>descardable</code>。</li></ul><p>但这个方法最重要的特性是我们上面讨论过的：除了把原本的序列和传入的函数进行存储之外，它不会执行任何操作。</p><p>当这一切准备完成后，<code>forEachPerform</code> 便可以成功维持一个序列的惰性性质（注意 <code>.lazy</code> 的调用）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> largeNumbersSquared = numbers</span><br><span class="line">    .<span class="built_in">lazy</span></span><br><span class="line">    .<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt;= <span class="number">5</span> &#125;</span><br><span class="line">    .forEachPerform &#123; <span class="built_in">print</span>(<span class="string">"After filter: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// Prints nothing</span></span><br></pre></td></tr></table></figure><p><em>注意：其实这段代码在 Swift 4.0 中会编译失败：”ambiguous use of ‘forEachPerform’”。只有当我把 Sequence.forEachPerform 的返回类型由 Self 改为 [Element] 后这段代码才能正常运行。说实话我也不太明白这是为什么。不过你也可以通过修改 LazySequenceProtocol.forEachPerform 方法的命名暂时解决这个问题。</em></p><p>这样一来，只有当我们访问到惰性序列的元素时，这些元素的副作用才会被打印出来：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Access the first two elements</span></span><br><span class="line"><span class="type">Array</span>(largeNumbersSquared.<span class="keyword">prefix</span>(<span class="number">2</span>))</span><br><span class="line"><span class="comment">/* Prints:</span></span><br><span class="line"><span class="comment">After filter: 5</span></span><br><span class="line"><span class="comment">After filter: 6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// → [25, 36]</span></span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我真的很喜欢这种往链式操作中注入副作用的功能，即便我几乎没有在调试之外的时候使用过。插句题外话，虽然基于 <code>print</code> 的调试方法一直在被争论是否已经 “过时” 了，但我还是一直在用。</p><hr><p><a id="foot1" href="#1"><sup>[1]</sup></a>RxSwift 中有一个类似的操作符 <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Debug.swift" target="_blank" rel="noopener">debug</a> </p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了如何在 Swift 的链式调用中通过使用创建的自定义函数来实现调试的目的
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的设计模式 #1 工厂方法与单例方法</title>
    <link href="https://swift.gg/2018/09/10/design-pattern-creational/"/>
    <id>https://swift.gg/2018/09/10/design-pattern-creational/</id>
    <published>2018-09-10T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://www.appcoda.com/design-pattern-creational/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-07-24<br>译者：<a href="https://github.com/Adolf-L" target="_blank" rel="noopener">BigLuo</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>“Gang of Four” (“GoF”) Erich Gamma，Richard Helm，Ralph Johonson，和 John Vlissides 在他们“<a href="https://smile.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8/" target="_blank" rel="noopener">设计模式：面向对象软件设计复用的基本原理</a>” 的重要著作里整理了大概 23 种经典的设计模式 。本文会介绍 GoF 总结的两种创建型（creational）模式：<em>工厂方法</em>和<em>单例方法</em>。</p><a id="more"></a><p>软件开发一直在努力地模拟真实世界的场景，希望通过创建工具的方式来加强人类的场景体验。财富管理工具，例如：像亚马逊或者 eBay 这样的银行 App 和购物辅助工具，相比十年前确实给消费者带来了更大的生活便利。回顾我们的发展路程。当应用变的更加强大易用时，应用的开发也已变的<a href="http://iosbrain.com/blog/2018/04/29/controlling-chaos-why-you-should-care-about-adding-error-checking-to-your-ios-apps/#chaos" target="_blank" rel="noopener"><strong>更加复杂</strong></a>。</p><p>所以开发者也开创出了一系列最佳实践。一些很流行的名字，像<a href="http://iosbrain.com/blog/2017/02/26/intro-to-object-oriented-principles-in-swift-3-via-a-message-box-class-hierarchy/" target="_blank" rel="noopener"><strong>面向对象编程</strong></a>，<a href="https://www.appcoda.com/pop-vs-oop/" target="_blank" rel="noopener"><strong>面向协议编程</strong></a>，<a href="http://iosbrain.com/blog/2018/03/28/protocol-oriented-programming-in-swift-is-it-better-than-object-oriented-programming/#value_semantics" target="_blank" rel="noopener"><strong>值语义 （value semantics）</strong></a>，<a href="http://iosbrain.com/blog/2018/03/28/protocol-oriented-programming-in-swift-is-it-better-than-object-oriented-programming/#local_reasoning" target="_blank" rel="noopener"><strong>局部推断 （local reasoning）</strong></a>将大块代码分解成具有良好接口定义的小段代码（比如使用 <a href="http://iosbrain.com/blog/2017/01/28/swift-extensions-managing-complexity-improving-readability-extensibility-protocols-delegates-uicollectionview/" target="_blank" rel="noopener"><strong>Swift 的扩展</strong></a>），以及 <a href="http://iosbrain.com/blog/2018/01/27/writing-expressive-meaningful-and-readable-code-in-swift-4/" target="_blank" rel="noopener"><strong>语法糖</strong></a>。还有我没提及，但却是最重要的、值得重视的实践之一，设计模式的使用。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是开发者管理软件复杂性的重要工具。作为常见的模板技术，它很好地对软件中类似的、复现的、容易识别的问题进行了概念化抽象。将它当作一个最佳实践应用到你日常会遇到的那些编程场景中，例如，在不了解类簇实现细节的情况下创建一个类簇相关的对象。设计模式主要是用于经常发生的那些问题场景中。它们频繁被使用是因为这些问题很普遍，让我用一个具体的例子来帮助你们理解吧。</p><p>设计模式讨论的并不是某些具体的问题，比如”如何迭代包含 11 个整数（Int）的 Swift 数组“。针对这类问题，GoF 定义了迭代器模式（Iterator Pattern），这是一个通用的模式，描述如何在不确定数据类型的情况下遍历一个数据列表。设计模式不是语言编码。它是用于解决相同软件场景问题的一套实用的指导规则。</p><p>还记得吗，之前我在 AppCoda 介绍过 <a href="https://www.appcoda.com/mvvm-vs-mvc/" target="_blank" rel="noopener">“Model-View-ViewModel” or “MVVM”</a> 与非常著名的 <a href="https://www.appcoda.com/mvvm-vs-mvc/" target="_blank" rel="noopener">“Model-View-Controller” or “MVC”</a> 设计模式，这两个模式深受 Apple 和 iOS 开发者喜爱。</p><p>这两种模式一般用在<em>整个应用</em>中。MVVM 和 MVC 是<em>架构（architectural）</em>设计模式，用于将 UI 从应用数据代码和展示逻辑中分离出来（如：MVC），以及将应用的数据从核心数据流程或者业务逻辑中分离（如：MVVM）。 而 GoF 设计模式本质上更具体，旨在解决基于程序代码中的具体问题。在一个应用里面你也许会用到 3 种、7 种或者 12 种 GoF 设计模式。除了<em>迭代器</em>例子，代理模式也是设计模式中另一个很好的例子， 尽管它在 GoF 列出的 23 种设计模式中并未被具体介绍。</p><p>当 GoF 的这本书作为大量开发者的圣经而存在时，也不乏有它的诋毁者，我们在文章的结尾处讨论这个话题。</p><h2 id="设计模式的类别"><a href="#设计模式的类别" class="headerlink" title="设计模式的类别"></a>设计模式的类别</h2><p>GoF 将 23 种设计模式整理分为 3 类，“创建型”、“结构型”和“行为型”。本教程讨论创建型模式类别中的两种（工厂模式与单例）。如同实例对象和类的实现，模式的作用是让复杂对象的创建变得简单、易于理解、易于维护，隐藏细节。</p><p><strong>隐藏复杂度（封装）</strong>是聪明的程序员最主要的目标之一。例如，面向对象（OOP）类能提供非常复杂的，强大且成熟的函数而不需要知道任何关于类内部间的工作方式。在创建型模式中，开发者甚至不需要知道类的属性和方法，但如果需要，程序员可以看到其接口 - 在 Swift 中的协议中 - 或对那些感兴趣的类进行扩展。你会在我的第一个“工厂方法”的例子中明白我的意思。</p><h2 id="工厂方法设计模式"><a href="#工厂方法设计模式" class="headerlink" title="工厂方法设计模式"></a>工厂方法设计模式</h2><p>如果你已经探索过 GoF 设计模式或在 OOP 的世界里花费了很多时间，你大概至少听说过“抽象工厂”、“工厂”，或者“工厂方法”模式。“确切”的命名可能有很多争议，不过下面我要介绍的这个例子最接近的命名是工厂模式。</p><p>在这个范例中，你通过工厂方法创建对象，而<em>不需要</em>知道类的构造器和关于类和类层次结构的任何信息。这带来了很大的方便。可以用少量的代码创建 UI 和它的相关功能。我的工厂方法项目案例，在 <a href="https://github.com/appcoda/FactoryMethodInSwift" target="_blank" rel="noopener"><strong>GitHub</strong></a> 可下载，展示了在复杂类层次结构中，如何轻松的使用对象。<br><img src="https://www.appcoda.com/wp-content/uploads/2018/07/Factory_Method.gif" alt=""></p><p>大多数成功的应用都有风格一致的主题 。为保证应用主题风格统一，假设应用中所有的 shapes 有着相同的颜色和尺寸，这样就可以和主题保持一致——也就是塑造品牌。这些图形用在自定义按钮上，或者作为登录流程的界面背景图都是不错的。</p><p>假设设计团队同意使用我的代码作为应用的主题背景图片。下面来看看我的具体代码，包括协议、类结构和（UI 开发人员不需要关心的）工厂方法。</p><p> <code>ShapeFactory.swift</code> 文件是一个用于在视图控制器内绘制形状的协议。因为可用于各种目的，所以它的访问级别是 public：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些值被图形设计团队预先选定</span></span><br><span class="line"><span class="keyword">let</span> defaultHeight = <span class="number">200</span></span><br><span class="line"><span class="keyword">let</span> defaultColor = <span class="type">UIColor</span>.blue</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HelperViewFactoryProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">configure</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">position</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> view: <span class="type">UIView</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> parentView: <span class="type">UIView</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得吗？ <code>UIView</code> 类有一个默认的矩形属性 <code>frame</code>  ，所以我可以轻松的创建出形状基类 <code>Square</code>: </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span>: <span class="title">HelperViewFactoryProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> height: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> parentView: <span class="type">UIView</span></span><br><span class="line">    <span class="keyword">var</span> view: <span class="type">UIView</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(height: <span class="type">Int</span> = defaultHeight, parentView: <span class="type">UIView</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.height = height</span><br><span class="line">        <span class="keyword">self</span>.parentView = parentView</span><br><span class="line">        view = <span class="type">UIView</span>()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">configure</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: height, height: height)</span><br><span class="line">        view.frame = frame</span><br><span class="line">        view.backgroundColor = defaultColor</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">position</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        view.center = parentView.center</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        configure()</span><br><span class="line">        position()</span><br><span class="line">        parentView.addSubview(view)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到我根据 OOP 的设计思想来构建复用代码，这样能让 shape 层级更加简化和可维护。<code>Circle</code> 和 <code>Rectangle</code> 类是 <code>Square</code> 类的特化 （另外你可以看到，从正方形出发绘制圆形是多么简单。）<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Square</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">configure</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">super</span>.configure()</span><br><span class="line">        </span><br><span class="line">        view.layer.cornerRadius = view.frame.width / <span class="number">2</span></span><br><span class="line">        view.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="title">Square</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">configure</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: height + height/<span class="number">2</span>, height: height)</span><br><span class="line">        view.frame = frame</span><br><span class="line">        view.backgroundColor = <span class="type">UIColor</span>.blue</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我使用 <code>fileprivate</code> 来强调工厂方法模式背后的一个目的：<em>封装</em>。你可以看到不用改变下面工厂方法的前提下，对 <code>shape</code> 类的层级结构进行修改和扩展是很容易的。这是工厂方法的代码，它们让对象的创建如此简单且抽象。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> square</span><br><span class="line">    <span class="keyword">case</span> circle</span><br><span class="line">    <span class="keyword">case</span> rectangle</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> parentView: <span class="type">UIView</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(parentView: <span class="type">UIView</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.parentView = parentView</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="keyword">as</span> shape: Shapes)</span></span> -&gt; <span class="type">HelperViewFactoryProtocol</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> shape &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> .square:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> square = <span class="type">Square</span>(parentView: parentView)</span><br><span class="line">            <span class="keyword">return</span> square</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> .circle:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> circle = <span class="type">Circle</span>(parentView: parentView)</span><br><span class="line">            <span class="keyword">return</span> circle</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> .rectangle:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> rectangle = <span class="type">Rectangle</span>(parentView: parentView)</span><br><span class="line">            <span class="keyword">return</span> rectangle</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共的工厂方法来展示形状</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createShape</span><span class="params">(<span class="number">_</span> shape: Shapes, on view: UIView)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> shapeFactory = <span class="type">ShapeFactory</span>(parentView: view)</span><br><span class="line">    shapeFactory.create(<span class="keyword">as</span>: shape).display()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择公共的工厂方法来展示形状</span></span><br><span class="line"><span class="comment">// 严格来说，工厂方法应该返回相关类中的一个。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getShape</span><span class="params">(<span class="number">_</span> shape: Shapes, on view: UIView)</span></span> -&gt; <span class="type">HelperViewFactoryProtocol</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> shapeFactory = <span class="type">ShapeFactory</span>(parentView: view)</span><br><span class="line">    <span class="keyword">return</span> shapeFactory.create(<span class="keyword">as</span>: shape)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意到：我已经写下一个类工厂和两个工厂方法来让你思考。严格说，一个工厂方法应该返回对应类的对象，这些类有着共同的基类或者协议。我的目的是在视图上绘制一个形状，所以我更倾心使用 <code>createShape(_:view:)</code> 这个方法。提供这种可选方式（该方法），在需要时可用于试验和探索新的可能性。</p><p>最后，我展示了两个工厂方法绘制形状的使用方式。UI 开发者不用知道形状类是如何被编码出来的。尤其是他/她不必为形状类如何被初始化而担忧。<code>ViewController.swift</code> 文件中的代码很容易阅读。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">//在加载视图后进行添加设置，一般是从nib</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// 废弃掉那些可以被重新创建的资源</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">drawCircle</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 仅仅用于绘制形状</span></span><br><span class="line">        createShape(.circle, on: view)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">drawSquare</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制图形</span></span><br><span class="line">        createShape(.square, on: view)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">drawRectangle</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从工厂获取一个对象并使用它来绘制一个形状</span></span><br><span class="line">        <span class="keyword">let</span> rectangle = getShape(.rectangle, on: view)</span><br><span class="line">        rectangle.display()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>大部分 iOS 开发者熟悉单例模式。回想一下 <code>UNUserNotificationCenter.current()</code>，<code>UIApplication.shared</code> 或 <code>FileManager.default</code> 如果你想要发送通知，或者在 Safari 里面打开一个 URL，或者操作 iOS 文件，你必须分别使用它们各自的单例。单例可以很好的用于保护共享资源，提供有且仅有一个对象实例进入一些系统，并且支持对象执行一些应用级类型的协作。正如我们将要看到的，单例也可以用来封装 iOS 内建的其它单例，添加一些值操作功能。</p><p>作为一个单例，我们需要确保这个类：</p><ul><li>声明和初始化一个 static 的类的常量属性，然后命名那个属性为 <code>shared</code> 来表明这个类的实例是一个单例（默认是共有的）；</li><li>为我们想要控制和保护的一些资源声明一个<em>私有的</em>属性。且只能通过 <code>shared</code> 共享；</li><li>声明一个私有初始化方法，只有我们的单例类能够初始化它，在 <code>init</code> 的内部，初始化我们想要用于控制的共享资源；</li></ul><p>通过定义一个 <code>shared</code> 静态常量来创建一个类的 <code>private</code> 初始化方法。我们要确保这个类只有一个实例，该类只能初始化一次，并且共享的实例在应用的任何地方都能获取。就这样我们创建了一个<em>单例</em>！</p><p>这个单例项目的代码，在 <a href="https://github.com/appcoda/SingletonInSwift" target="_blank" rel="noopener"><strong>GitHub</strong></a> 可下载，展示了一个开发者如何安全的、高效的存储用户的偏好。这是个简单的 Demo，该 Demo 能够记录用户的密码文本，偏好设置可设置为可见或隐藏。不过事后发现，这个功能并不是个好想法，我只是需要一个例子来向你展示我代码的工作机制。这段代码<em>完全是</em>出于教学的目的。我建议你<strong>永远不要</strong>让你的密码暴露。你可以看到用户可以设置他们的的密码偏好 — 且密码偏好被存储在 <code>UserDefaults</code>:</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/07/Show_Pwd.gif" alt=""></p><p>当用户关闭应用并且再次打开后，注意到他/她的密码偏好被记录了：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/07/Remember_Pwd_Setting.gif" alt=""></p><p>让我向你展示 <code>PreferencesSingleton.swift</code> 文件中的代码片段，在行内注释里，你将会看到我想准确表达的意思。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPreferences</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类的初始化方法创建一个静态的，常量实例。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">UserPreferences</span>()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这是一个私有的，收我们保护的资源共享的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> userPreferences: <span class="type">UserDefaults</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 一个私有的初始化方法只能被类本身调用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取 iOS 共享单例。我们在这里包装了它。</span></span><br><span class="line">        userPreferences = <span class="type">UserDefaults</span>.standard</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125; <span class="comment">// end class UserPreferences</span></span><br></pre></td></tr></table></figure><p>应用启动的时候需要初始化静态属性，但是全局变量默认是懒加载。你可能会担心上面这段代码在执行的时候出错，不过就我对 Swift 的了解来说，这段代码完全没问题。</p><p>你也许会问，“为什么要通过包装另一个<code>UserDefaults</code> 单例的方式来创建一个单例？” 首先，我主要目的是要向你展示在 Swift 中创建和使用单例的最佳做法。 用户偏好是一个资源类型，应该有一个单一的入口。所以在这个例子中，很明显我们应该使用 <code>UserDefaults</code>。其次，想一下你曾多少次看到在应用中 <code>UserDefaults</code> 被滥用。</p><p>在一些项目应用代码中，我看到 <code>UserDefaults</code>(或者之前的 <code>NSUserDefaults</code>)的使用缺乏条理和原由。用户偏好属性对应的每个键都是字符串引用。刚才，我在代码中发现了一个 bug。我把“switch”拼写成了“swithc”，由于我对代码进行了复制和粘贴，在发现问题前，我已经创建了不少“swithc”的实例。 如果其他开发者在这个应用开始或者继续使用“switch”作为一个键来存储对应的值呢？应用的当前状态是无法被正确保存的。 我们经常使用 <code>UserDefaults</code> 的 strings 以键值映射的方式保存应用的状态。这是一个好的写法。这可以让值的意思清晰明确、简单易懂，还便于记忆。但也不是说通过 strings 来描述是没有任何风险的。</p><p>在我讨论的“swithc”与“switch”中。大多数人可能已经明白了被称为“stringly-typed”的那些代码, 用 strings 作为唯一的标识符会产生细微的不同，最终会因为拼写错误带来灾难性的错误。Swift 编译器不能帮助我们避免“stringly-typed”这类的错误。</p><p>解决“stringly-typed”错误的方式在于把 Swift <code>enum</code> 设置成 string 类型。这么做不仅可以让我们标准化字符串的使用，而且可让我们对其进行分类管理。让我们再次回到 <code>PreferencesSingleton.swift</code>:<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPreferences</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Preferences</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">UserCredentials</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> passwordVisibile</span><br><span class="line">            <span class="keyword">case</span> password</span><br><span class="line">            <span class="keyword">case</span> username</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">AppState</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> appFirstRun</span><br><span class="line">            <span class="keyword">case</span> dateLastRun</span><br><span class="line">            <span class="keyword">case</span> currentVersion</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="comment">// end enum Preferences</span></span><br></pre></td></tr></table></figure></p><p>我们从单例模式的定义开始，向你介绍清楚在我的应用中，为什么使用一个单例来封装 <code>UserDefaults</code>。我们可以通过添加值的方式来增添新的功能，但通过简单的对 <code>UserDefaults</code> 的包装却能增强代码的健壮性。在获取和设置用户偏好时，你脑中应该要马上想到进行错误校验。在这里，我想实现一个关于用户偏好的功能，设置密码的可见性。看到下面的代码。内容都在 <code>PreferencesSingleton.swift</code> 文件：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPreferences</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Preferences</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">UserCredentials</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> passwordVisibile</span><br><span class="line">            <span class="keyword">case</span> password</span><br><span class="line">            <span class="keyword">case</span> username</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">AppState</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> appFirstRun</span><br><span class="line">            <span class="keyword">case</span> dateLastRun</span><br><span class="line">            <span class="keyword">case</span> currentVersion</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="comment">// end enum Preferences</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个静态、常量实例并初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">UserPreferences</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是一个私有的，被保护的共享资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> userPreferences: <span class="type">UserDefaults</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有类本身能调用的一个私有初始化方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 获取 iOS 共享单例。我们在这里包装它</span></span><br><span class="line">        userPreferences = <span class="type">UserDefaults</span>.standard</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setBooleanForKey</span><span class="params">(<span class="number">_</span> boolean:Bool, key:String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> key != <span class="string">""</span> &#123;</span><br><span class="line">            userPreferences.<span class="keyword">set</span>(boolean, forKey: key)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getBooleanForKey</span><span class="params">(<span class="number">_</span> key:String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> isBooleanValue = userPreferences.value(forKey: key) <span class="keyword">as</span>! <span class="type">Bool</span>? &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Key <span class="subst">\(key)</span> is <span class="subst">\(isBooleanValue)</span>"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Key <span class="subst">\(key)</span> is false"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isPasswordVisible</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> isVisible = userPreferences.bool(forKey: <span class="type">Preferences</span>.<span class="type">UserCredentials</span>.passwordVisibile.rawValue)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> isVisible &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>来到 <code>ViewController.swift</code> 文件，你将看到，访问并使用结构良好的单例是多么的容易：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> passwordTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> passwordVisibleSwitch: <span class="type">UISwitch</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"><span class="comment">// 在加载视图后（一般通过 nib 来进行）进行其它的额外设置。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="type">UserPreferences</span>.shared.isPasswordVisible() &#123;</span><br><span class="line">            passwordVisibleSwitch.isOn = <span class="literal">true</span></span><br><span class="line">            passwordTextField.isSecureTextEntry = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            passwordVisibleSwitch.isOn = <span class="literal">false</span></span><br><span class="line">            passwordTextField.isSecureTextEntry = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line"><span class="comment">// 可以销毁那些能被重新创建的资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">passwordVisibleSwitched</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> pwdSwitch:<span class="type">UISwitch</span> = sender <span class="keyword">as</span>! <span class="type">UISwitch</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> pwdSwitch.isOn &#123;</span><br><span class="line">            passwordTextField.isSecureTextEntry = <span class="literal">false</span></span><br><span class="line">            <span class="type">UserPreferences</span>.shared.setPasswordVisibity(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            passwordTextField.isSecureTextEntry = <span class="literal">true</span></span><br><span class="line">            <span class="type">UserPreferences</span>.shared.setPasswordVisibity(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>有些评论家声称设计模式在一些编程语言中的使用缺乏证明，相同的设计模式在代码中反复出现是很槽糕的一件事情。我并不同意这个说法。期望一个编程语言对<em>每件事情</em>的处理都有其对应的特性是很愚蠢的。这很可能会导致一个臃肿的语言，像 C++ 一样正在变得更大、更复杂，以致很难被学习、使用与维护。认识并解决反复出现的问题是人的一种积极性格并且这确实值得我们强化。有一些事情，人们尝试却失败了很多次，通过学习总结前人经验，对一些相同的问题进行抽象和标准化，让这些好的解决方案散播出去的方面，设计模式成为了一个成功案例。</p><p>像 Swift 这样的简单紧凑的语言和设计模式这样一系列最佳实践的组合是一个理想中的、令人开心的方法。风格统一的代码一般来说都具有较好的可读性和易维护性。不过也要记住，在数以百万的开发者不断地讨论和分享下，设计模式也在不断的发展变化，这些美好事物被万维网联系在一起，这种开发人员的讨论持续的引领着集体智慧的自我调节。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Andrew Jaffee，&lt;a href=&quot;https://www.appcoda.com/design-pattern-creational/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-07-24&lt;br&gt;译者：&lt;a href=&quot;https://github.com/Adolf-L&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigLuo&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;“Gang of Four” (“GoF”) Erich Gamma，Richard Helm，Ralph Johonson，和 John Vlissides 在他们“&lt;a href=&quot;https://smile.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式：面向对象软件设计复用的基本原理&lt;/a&gt;” 的重要著作里整理了大概 23 种经典的设计模式 。本文会介绍 GoF 总结的两种创建型（creational）模式：&lt;em&gt;工厂方法&lt;/em&gt;和&lt;em&gt;单例方法&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
    
      <category term="Design Patterns" scheme="https://swift.gg/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>Never</title>
    <link href="https://swift.gg/2018/08/30/never/"/>
    <id>https://swift.gg/2018/08/30/never/</id>
    <published>2018-08-30T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/never/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-07-30<br>译者：<a href="https://github.com/mobilefellow" target="_blank" rel="noopener">雨谨</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="undefined">wongzigii</a>，<a href="undefined">Firecrest</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p><code>Never</code> 是一个约定，表示一件事在过去或未来的任何时段都不会发生。它是时间轴上的一种逻辑上的不可能，在任何方向延展开去都没有可能。这就是为什么在代码中看到 <a href="https://github.com/search?q=%22this+will+never+happen%22&amp;type=Code" target="_blank" rel="noopener">这样的注释</a> 会特别让人不安。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个不会发生</span></span><br></pre></td></tr></table></figure><p>所有编译器的教科书都会告诉你，这样一句注释不能也不会对编译出的代码产生任何影响。<a href="https://en.wikipedia.org/wiki/Murphy%27s_law" target="_blank" rel="noopener">墨菲定理</a> 告诉你并非如此，注释以下的代码一定会被触发。</p><p>那 Swift 是如何在这种无法预测的、混乱的开发过程中保证安全呢？答案难以置信：“<strong>什么都不做</strong>”，以及“<strong>崩溃</strong>”。</p><hr><p>使用 <code>Never</code> 替换 <code>@noreturn</code> 修饰符，是由 <a href="https://github.com/jckarter" target="_blank" rel="noopener">Joe Groff</a> 在 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0102-noreturn-bottom-type.md" target="_blank" rel="noopener">SE-0102: “Remove @noreturn attribute and introduce an empty Never type”</a> 中提出的。</p><p>在 Swift 3 之前，那些要中断执行的函数，比如 <code>fatalError(_:file:line:)</code>，<code>abort()</code> 和 <code>exit(_:)</code>，需要使用 <code>@noreturn</code> 修饰符来声明，这会告诉编译器，执行完成后不用返回调用这个函数的位置。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &lt; 3.0</span></span><br><span class="line"><span class="meta">@noreturn</span> <span class="function"><span class="keyword">func</span> <span class="title">fatalError</span><span class="params">(<span class="number">_</span> message: <span class="params">()</span></span></span> -&gt; <span class="type">String</span> = <span class="type">String</span>(),</span><br><span class="line">                               file: <span class="type">StaticString</span> = #file,</span><br><span class="line">                               line: <span class="type">UInt</span> = #line)</span><br></pre></td></tr></table></figure><p>从 Swift 3 开始，<code>fatalError</code> 和它的相关函数都被声明为返回 <code>Never</code> 类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &gt;= 3.0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fatalError</span><span class="params">(<span class="number">_</span> message: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span> = <span class="type">String</span>(),</span><br><span class="line">                     file: <span class="type">StaticString</span> = #file,</span><br><span class="line">                     line: <span class="type">UInt</span> = #line) -&gt; <span class="type">Never</span></span><br></pre></td></tr></table></figure><p>作为一个注释的替代品，它肯定是很复杂的，对吗？NO！事实上，恰恰相反，<code>Never</code> 可以说是整个 Swift 标准库中最简单的一个类型：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Never</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="无实例类型（Uninhabited-Types）"><a href="#无实例类型（Uninhabited-Types）" class="headerlink" title="无实例类型（Uninhabited Types）"></a>无实例类型（<code>Uninhabited Types</code>）</h2><p><code>Never</code> 是一个<em>无实例</em>（<em>Uninhabited</em>）类型，也就是说它没有任何值。或者换句话说，无实例类型是无法被构建的。</p><p>在 Swift 中，没有定义任何 <code>case</code> 的枚举是最常见的一种无实例类型。跟结构体和类不同，枚举没有初始化方法。跟协议也不同，枚举是一个具体的类型，可以包含属性、方法、泛型约束和嵌套类型。正因如此，Swift 标准库广泛使用无实例的枚举类型来做诸如 <a href="https://github.com/apple/swift/blob/a4230ab2ad37e37edc9ed86cd1510b7c016a769d/stdlib/public/core/Unicode.swift#L918" target="_blank" rel="noopener">定义命名空间</a> 以及 <a href="https://github.com/apple/swift/blob/a6952decab6f918a9df3c6fa342153a9f9204f8e/stdlib/public/core/MemoryLayout.swift#L43" target="_blank" rel="noopener">标识类型的含义</a> 之类的事情。</p><p>但 <code>Never</code> 并不这样。它没有什么花哨的东西，它的特别之处就在于，它就是它自己（或者说，它什么都不是）。</p><p>试想一个返回值为无实例类型的函数：因为无实例类型没有任何值，所以这个函数无法正常的返回。（它要如何生成这个返回值呢？）所以，这个函数要么停止运行，要么无休止的一直运行下去。</p><h2 id="消除泛型中的不可能状态"><a href="#消除泛型中的不可能状态" class="headerlink" title="消除泛型中的不可能状态"></a>消除泛型中的不可能状态</h2><p>从理论角度上说，<code>Never</code> 确实很有意思，但它在实际应用中又能帮我们做什么呢？</p><p>做不了什么，或者说在 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0215-conform-never-to-hashable-and-equatable.md#conform-never-to-equatable-and-hashable" target="_blank" rel="noopener">SE-0215: Conform Never to Equatable and Hashable</a> 推出以前，做不了什么。</p><p><a href="https://github.com/mdiep" target="_blank" rel="noopener">Matt Diephouse</a> 在提案中解释了为什么让这个令人费解的类型去遵守 <code>Equatable</code> 和其他协议：</p><blockquote><p><code>Never</code> 在表示不可能执行的代码方面非常有用。大部分人熟悉它，是因为它是 <code>fatalError</code> 等方法的返回值，但 <code>Never</code> 在泛型方面也非常有用。比如说，一个 <code>Result</code> 类型可能使用 <code>Never</code> 作为它的 <code>Value</code>，表示某种东西一直是错误的，或者使用 <code>Never</code> 作为它的 <code>Error</code>，表示某种东西一直不是错误的。</p></blockquote><p>Swift 没有标准的 <code>Result</code> 类型，大部分情况下它们是这个样子的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">Value</span>, <span class="title">Error</span>: <span class="title">Swift</span>.<span class="title">Error</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">Value</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Result</code> 类型被用来封装异步操作生成的返回值和异常（同步操作可以使用 <code>throw</code> 来返回异常）。</p><p>比如说，一个发送异步 HTTP 请求的函数可能使用 <code>Result</code> 类型来存储响应或错误：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(<span class="number">_</span> request: Request, completion: <span class="params">(Result&lt;Response, Error&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这个方法后，你可以使用 <code>switch</code> 来分别处理它的 <code>.success</code> 和 <code>.failure</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fetch(request) &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Success: <span class="subst">\(value)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Failure: <span class="subst">\(error)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设有一个函数会在它的 <code>completion</code> 中永远返回成功结果：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alwaysSucceeds</span><span class="params">(<span class="number">_</span> completion: <span class="params">(Result&lt;String, Never&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completion(.success(<span class="string">"yes!"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>Result</code> 的 <code>Error</code> 类型指定为 <code>Never</code> 后，我们可以使用类型检测体系来表明失败是永远不可能发生的。这样做的好处在于，你不需要处理 <code>.failure</code>，Swift 可以推断出这个 <code>switch</code> 语句已经处理了所有情况。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">alwaysSucceeds &#123; (result) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> string):</span><br><span class="line">        <span class="built_in">print</span>(string)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个例子是让 <code>Never</code> 遵循 <code>Comparable</code> 协议，这段代码把 <code>Never</code> 用到了极致：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Never</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt; (lhs: Never, rhs: Never) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (lhs, rhs) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>Never</code> 是一个无实例类型，所以它没有任何可能的值。所以当我们使用 <code>switch</code> 遍历它的 <code>lhs</code> 和 <code>rhs</code> 时，Swift 可以确定所有的可能性都遍历了。既然所有的可能性 — 实际上这里不存在任何值 — 都返回了 <code>Bool</code>，那么这个方法就可以正常编译。</p><p><em>工整！</em></p><h2 id="使用-Never-作为兜底类型"><a href="#使用-Never-作为兜底类型" class="headerlink" title="使用 Never 作为兜底类型"></a>使用 <code>Never</code> 作为兜底类型</h2><p><strong>实际上，关于 <code>Never</code> 的 Swift Evolution 提案中已经暗示了这个类型在未来可能有更多用处：</strong></p><blockquote><p>一个无实例类型可以作为其他任意类型的子类型 — 如果某个表达式根本不可能产生任何结果，那么我们就不需要关心这个表达式的类型到底是什么。如果编译器支持这一特性，就可以实现很多有用的功能……</p></blockquote><h3 id="解包或者死亡"><a href="#解包或者死亡" class="headerlink" title="解包或者死亡"></a>解包或者死亡</h3><p>强制解包操作（<code>!</code>）是 Swift 中最具争议的部分之一。（在代码中使用这个操作符）往好了说，是有意为之（在异常时故意让程序崩溃）；往坏了说，可能表示使用者没有认真思考。在缺乏其他信息的情况下，很难看出这两者的区别。</p><p>比如，下面的代码假定数组一定不为空，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array: [<span class="type">Int</span>]</span><br><span class="line"><span class="keyword">let</span> firstIem = array.first!</span><br></pre></td></tr></table></figure><p>为了避免强制解包，你可以使用带条件赋值的 <code>guard</code> 语句：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array: [<span class="type">Int</span>]</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> firstItem = array.first <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"array cannot be empty"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未来，如果 <code>Never</code> 成为兜底类型，它就可以用在 <code>nil-coalescing operator</code> 表达式的右边。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未来的 Swift 写法? 🔮</span></span><br><span class="line"><span class="keyword">let</span> firstItem = array.first ?? <span class="built_in">fatalError</span>(<span class="string">"array cannot be empty"</span>)</span><br></pre></td></tr></table></figure><p>如果你想现在就使用这种模式，可以手动重载 <code>??</code> 运算符（但是……）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> ?? &lt;T&gt;<span class="params">(lhs: T?, rhs: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Never</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> lhs &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> value?:</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        rhs()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在拒绝 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0217-bangbang.md#on-forced-unwraps" target="_blank" rel="noopener">SE-0217: Introducing the !! “Unwrap or Die” operator to the Swift Standard Library</a> 的<a href="https://forums.swift.org/t/se-0217-the-unwrap-or-die-operator/14107/222" target="_blank" rel="noopener">原因说明</a>中, <a href="https://github.com/jckarter" target="_blank" rel="noopener">Joe Groff</a> 提到，“我们发现重载 [?? for Never] 会对类型检测的性能产生难以接受的影响”。所以，不建议你在自己的代码中添加上面的代码。</p></blockquote><h3 id="表达式风格的-Throw"><a href="#表达式风格的-Throw" class="headerlink" title="表达式风格的 Throw"></a>表达式风格的 Throw</h3><p>类似的，如果 <code>throw</code> 可以从语句变成一个返回 <code>Never</code>的表达式，你就可以在 <code>??</code> 右边使用 <code>throw</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未来的 Swift 写法? 🔮</span></span><br><span class="line"><span class="keyword">let</span> firstItem = array.first ?? <span class="keyword">throw</span> <span class="type">Error</span>.empty</span><br></pre></td></tr></table></figure><h3 id="带类型的-Throw"><a href="#带类型的-Throw" class="headerlink" title="带类型的 Throw"></a>带类型的 <code>Throw</code></h3><p>继续研究下去：如果函数声明的 <code>throw</code> 关键字支持类型约束，那么 <code>Never</code> 可以用来表明某个函数绝对不会抛出异常（类似于在上面的 <code>Result</code> 例子）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未来的 Swift 写法? 🔮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">neverThrows</span><span class="params">()</span></span> <span class="keyword">throws</span>&lt;<span class="type">Never</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">neverThrows() <span class="comment">// 无需使用 `try` ，因为编译器保证它一定成功（可能）</span></span><br></pre></td></tr></table></figure><hr><p>声称某个事情永远不可能发生，就像是向整个宇宙发出邀请，来证明它是错的一样。情态逻辑（modal logic）或者信念逻辑（doxastic logic）允许保面子式的妥协（“<em>它当时是对的，或者我是这么认为的！</em>”），但时态逻辑（temporal logic）似乎将这个约定提到了更高的一个标准。</p><p>幸运的是，得益于最不像类型的 <code>Never</code>，Swift 到达了这个高标准。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mattt，&lt;a href=&quot;https://nshipster.com/never/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-07-30&lt;br&gt;译者：&lt;a href=&quot;https://github.com/mobilefellow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;雨谨&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;undefined&quot;&gt;wongzigii&lt;/a&gt;，&lt;a href=&quot;undefined&quot;&gt;Firecrest&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;&lt;code&gt;Never&lt;/code&gt; 是一个约定，表示一件事在过去或未来的任何时段都不会发生。它是时间轴上的一种逻辑上的不可能，在任何方向延展开去都没有可能。这就是为什么在代码中看到 &lt;a href=&quot;https://github.com/search?q=%22this+will+never+happen%22&amp;amp;type=Code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这样的注释&lt;/a&gt; 会特别让人不安。&lt;/p&gt;
    
    </summary>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 4 泛型：如何在你的代码或App里应用泛型</title>
    <link href="https://swift.gg/2018/08/28/swift-generics/"/>
    <id>https://swift.gg/2018/08/28/swift-generics/</id>
    <published>2018-08-28T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://appcoda.com/swift-generics" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-02-14<br>译者：<a href="https://github.com/Adolf-L" target="_blank" rel="noopener">BigLuo</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://muhlenxi.com/" target="_blank" rel="noopener">muhlenXi</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>问题 1：我能否写一个 Swift 函数用于查找在<strong>任意数组</strong>中存储的<strong>任意类型</strong>的<strong>任何实例对象</strong>的位置\索引。</p><p>问题 2：我能否写一个 Swift 函数用于确定在<strong>任意数组</strong>中存储的<strong>任意类型</strong>的<strong>任何实例对象</strong>的类型。</p><p>我所说的 “任何类型”，包括自定义类型，比如我们自己定义的 Class 类型。提示：我知道我能够用 Swift <code>Array</code> 类型的内置方法，如 <code>index</code> 和 <code>contains</code>，但今天我将会用简单代码实例来说明 Swift 泛型中的一些特性。</p><a id="more"></a><p>一般来说，我将<strong>泛型编程</strong>作如下定义：</p><blockquote><p>… a style of computer programming in which algorithms are written in terms of types to-be-specified-later that are then instantiated when needed for specific types provided as parameters. This approach, pioneered by ML in 1973, permits writing common functions or types that differ only in the set of types on which they operate when used, thus reducing duplication.</p></blockquote><blockquote><p>是一种算法机制为 types to-be-specified-later (类型确定滞后)的计算机编程风格，当具体的类型作为参数传入后，该算法机制会对类型进行实例化。这个方法由 “ML” 在 1973 年开创。可以用共有的函数和类型来表示一个类型集合从而来减少函数操作的重复。</p></blockquote><p>特别的指出，来自<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/SwiftProgrammingLanguage/Generics.html" target="_blank" rel="noopener">苹果Swift文档</a> 关于”泛型”话题的说明：</p><blockquote><p>Generic code enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.</p><p>Generics are one of the most powerful features of  Swift , and much of the Swift standard library is built with generic code. … For example,  Swift ’s Array and Dictionary types are both generic collections. You can create an array that holds Int values, or an array that holds String values, or indeed an array for any other type that can be created in  Swift . Similarly, you can create a dictionary to store values of any specified type, and there are no limitations on what that type can be. …</p></blockquote><blockquote><p>泛型编码能让你写出符合需求、支持任意类型，灵活、可重用的函数。你能够编写避免重复和编程风格抽象、清晰、优雅的代码。</p><p>泛型是 Swift 中最强大的特性之一，大量的 Swift 标准库使用了泛型编码。例如， Swift 的数组和字典都是泛型集合。你可以创建一个存有整型值或者字符串值的数组，有必要的话，还可以创建一个任何 Swift 支持类型的数组。类似的，你也可以创建一个字典用于存储任意指定类型的值。</p></blockquote><p>我一直提倡构建可复用，简洁，可维护的代码，对于 Swift 中的泛型，如果运用恰当，能某种程度上帮助我实现上面提到的效果。所以对于上面两个问题，我的答案是 “YES”。</p><h2 id="生活在一个特定类型编码的世界"><a href="#生活在一个特定类型编码的世界" class="headerlink" title="生活在一个特定类型编码的世界"></a>生活在一个特定类型编码的世界</h2><p>让我们写一个 Swift 的方法来说明在一个字符串数组中是否存在特定的一个字符串：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">existsManual</span><span class="params">(item:String, inArray:[String])</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> index:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> found = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (index &lt; inArray.<span class="built_in">count</span> &amp;&amp; found == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> item == inArray[index]</span><br><span class="line">        &#123;</span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> found</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们测试这个方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strings = [<span class="string">"Ishmael"</span>, <span class="string">"Jacob"</span>, <span class="string">"Ezekiel"</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> nameExistsInArray = existsManual(item: <span class="string">"Ishmael"</span>, inArray: strings)</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> nameExistsInArray1 = existsManual(item: <span class="string">"Bubba"</span>, inArray: strings)</span><br><span class="line"><span class="comment">// returns false</span></span><br></pre></td></tr></table></figure><p>在创建了用于查找 <code>String</code> 数组的 <code>existsManual</code> 函数后。假如我决定想要一些类似的函数用于搜索 <code>Integer</code>，<code>Float</code>，和  <code>Double</code> 数组 — 甚至用于查找数组中自定义类呢？我最终花费了宝贵的时间写了很多做同样事情的函数。我需要写很多代码来实现。如果我发现了一个新的/更快的搜索算法呢？又如果在我的搜索算法有一个 bug 呢？我不得不改变我所有的查找方法的版本。我发现这简直是个复用地狱：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">existsManual</span><span class="params">(item:String, inArray:[String])</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">existsManual</span><span class="params">(item:Int, inArray:[Int])</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">existsManual</span><span class="params">(item:Float, inArray:[Float])</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">existsManual</span><span class="params">(item:Double, inArray:[Double])</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//  "Person"  is a custom class we'll create</span></span><br><span class="line"><span class="comment">//  "Person" 是我们将要创建的自定义的类</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">existsManual</span><span class="params">(item:Person, inArray:[Person])</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们已经厌烦了活在一个处理类型的世界里，不得不为每个我们想要查找的数组类型创建新的方法。终究这给我们带来了大量的技术负债。由于现代软件难以置信的复杂性，像你我这样的开发者需要使用更好地实践，更好的技术，更好的方法，用我们的神经元最大程度的控制这种混乱。据估计 Window 7 包含大约 4 千万行代码而 macOS 10.4 (Tiger) 包含大约 8.5 千万行代码，预估像这样的系统潜在行为次数都是不可能的。</p><h2 id="泛型的解决之道"><a href="#泛型的解决之道" class="headerlink" title="泛型的解决之道"></a>泛型的解决之道</h2><p>（再次紧记学习泛型的目的，我们依旧假设 Swift 的数组类型的内置的函数，<code>index</code> 和  <code>contains</code> ，不存在。）</p><p>让我们先尝试写这样一个 Swift 函数，判断 Swift 的标准类型（例如 <code>String</code>，<code>Integer</code>，<code>Float</code> 或 <code>Double</code>）的一个特定实例是否存在于这个 Swift 标准类型的数组中。怎么做呢？</p><p>让我们切换到 Swift 泛型，特别是泛型函数，类型参数，类型约束以及 <code>Equatable</code> 协议。在没有定义任何术语前，我写了一些代码，思考一下你看到的。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exists</span>&lt;T: Equatable&gt;<span class="params">(item: T, inArray: [T])</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> index:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> found = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (index &lt; inArray.<span class="built_in">count</span> &amp;&amp; found == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> item == inArray[index]</span><br><span class="line">        &#123;</span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> found</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们测试下我新写的泛型方法</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFriends:[<span class="type">String</span>] = [<span class="string">"John"</span>, <span class="string">"Dave"</span>, <span class="string">"Jim"</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isOneOfMyFriends = exists(item: <span class="string">"Dave"</span>, inArray: myFriends)</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isOneOfMyFriends1 = exists(item: <span class="string">"Laura"</span>, inArray: myFriends)</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> myNumbers:[<span class="type">Int</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isOneOfMyNumbers = exists(item: <span class="number">3</span>, inArray: myNumbers)</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isOneOfMyNumbers1 = exists(item: <span class="number">0</span>, inArray: myNumbers)</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> myNumbersFloat:[<span class="type">Float</span>] = [<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>,]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isOneOfMyFloatNumbers = exists(item: <span class="number">3.0000</span>, inArray: myNumbersFloat)</span><br><span class="line"><span class="comment">// returns true</span></span><br></pre></td></tr></table></figure><p>我新写 exists 方法是一个泛型函数，这个方法“能正常工作在任何参数类型上”，此外，让我们看看它的函数签名。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exists</span>&lt;T: Equatable &gt;<span class="params">(item: T, inArray: [T])</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>我们看到 <strong><a href="https://docs.Swift.org/Swift-book/LanguageGuide/Generics.html" target="_blank" rel="noopener">那个</a></strong> 函数使用一个占位符类型名字(名叫 <code>T</code>, 在这个案例)而不是真正的类型名（比如：<code>Int</code>，<code>Stirng</code>，或 <code>Double</code>）占位符类型名没有指定 <code>T</code> 必须是什么，但他说明了 <code>[item]</code> 和 <code>[inArray]</code> 必须是相同的类型 <code>T</code> 无论 <code>T</code> 代表什么，每当 [<code>exists(_:_:)</code>] 函数被调用时，真实的类型用于替代 <code>T</code> 被确定下来。</p><p><strong>这个 exists 函数中的占位符类型 <code>T</code> 被称为类型参数</strong>：</p><blockquote><p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/SwiftProgrammingLanguage/Generics.html" target="_blank" rel="noopener">它</a>指定和命名了占位符的类型，直接写在函数名称的后面，在一对尖括号之间(比如 <t>)。</t></p><p>一旦你指定一个类型参数你可以用它来定义函数参数的类型(比如：[<code>item</code>] and [<code>inArray</code>] [<code>exists(_:_:)</code> 函数)或者作为函数返回值的类型，在任何条件下，当函数被调用的时候类型参数会被真实类型替代。</p></blockquote><p>为了强化我们目前已经学到的，下面是一个 Swift 函数，该函数能够找到存储在数组中任何类型实例的索引。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span>&lt;T: Equatable&gt;<span class="params">(item: T, inArray: [T])</span></span> -&gt; <span class="type">Int</span>?</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> index:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> found = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (index &lt; inArray.<span class="built_in">count</span> &amp;&amp; found == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> item == inArray[index]</span><br><span class="line">        &#123;</span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> found</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们测试下它</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFriends:[<span class="type">String</span>] = [<span class="string">"John"</span>, <span class="string">"Dave"</span>, <span class="string">"Jim"</span>, <span class="string">"Arthur"</span>, <span class="string">"Lancelot"</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> findIndexOfFriend = <span class="built_in">find</span>(item: <span class="string">"John"</span>, inArray: myFriends)</span><br><span class="line"><span class="comment">// returns 0</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> findIndexOfFriend1 = <span class="built_in">find</span>(item: <span class="string">"Arthur"</span>, inArray: myFriends)</span><br><span class="line"><span class="comment">// returns 3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> findIndexOfFriend2 = <span class="built_in">find</span>(item: <span class="string">"Guinevere"</span>, inArray: myFriends)</span><br><span class="line"><span class="comment">// returns nil</span></span><br></pre></td></tr></table></figure><h2 id="关于-Equatable-协议"><a href="#关于-Equatable-协议" class="headerlink" title="关于 Equatable 协议"></a>关于 <code>Equatable</code> 协议</h2><p>exists 函数中 <code>&lt;T: Equatable &gt;</code> 标注是什么呢？它叫做类型约束，它规定了”那个类型参数必须继承自一个具体的类，或者遵守一个特定的协议或是协议组合。我指定了 exists 函数参数，<code>item: T</code> 和 <code>inArray: [T]</code>, 必须是类型 <code>T</code>, 而类型 <code>T</code> 必须遵守协议 <code>Equatable</code> 协议，为什么是这样的呢?</p><p>所有的 Swift 内置类型已经被构建支持 <code>Equatable</code> 协议。来自 <a href="https://developer.apple.com/documentation/ Swift / Equatable" target="_blank" rel="noopener">Apple docs</a>:  “遵守 <code>Equatable</code> 协议的类型进行相等比较，使用等于运算符(<code>==</code>)判断相等，或者使用不等运算符(<code>!=</code>)判断不等”。这就是为什么我的泛型函数 “exists” 能够在 Swift 的类型（如 <code>String</code>，<code>Integer</code>，<code>Float</code> 和 <code>Double</code>）上正常工作。所有这些类型都定义了 <code>==</code> 和 <code>!=</code> 运算符。 </p><h2 id="自定义类型和泛型"><a href="#自定义类型和泛型" class="headerlink" title="自定义类型和泛型"></a>自定义类型和泛型</h2><p>假如我声明了一个新的类叫做 “BasicPerson” 如下所示。我能用我的 exists” 函数来找出在数组中是否有 “BasicPerson” 类的一个实例的类型么？不行！为什么不行？看看下面这个代码，我们接下来讨论它：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPerson</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(weight: <span class="type">Int</span>, name: <span class="type">String</span>, sex: <span class="type">String</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.weight = weight</span><br><span class="line">        <span class="keyword">self</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="type">Jim</span> = <span class="type">BasicPerson</span>(weight: <span class="number">180</span>, name: <span class="string">"Jim Patterson"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Sam</span> = <span class="type">BasicPerson</span>(weight: <span class="number">120</span>, name: <span class="string">"Sam Patterson"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Sara</span> = <span class="type">BasicPerson</span>(weight: <span class="number">115</span>, name: <span class="string">"Sara Lewis"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> basicPersons = [<span class="type">Jim</span>, <span class="type">Sam</span>, <span class="type">Sara</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isSamABasicPerson = exists(item: <span class="type">Sam</span>, inArray: basicPersons)</span><br></pre></td></tr></table></figure><p>看到最后一行，因为它有一个编译错误：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">error: <span class="keyword">in</span> argument type '[<span class="type">BasicPerson</span>]', '<span class="type">BasicPerson'</span> does not conform to expected type '<span class="type">Equatable'</span></span><br><span class="line"><span class="keyword">let</span> isSamABasicPerson = exists(item: <span class="type">Sam</span>, inArray: basicPersons)</span><br></pre></td></tr></table></figure><p><img src="https://camo.githubusercontent.com/f36f760385795cb9e802f886cda24bbf8bb720ab/68747470733a2f2f617070636f64612e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f30322f73776966742d342d67656e65726963732d312e706e67" alt=""></p><p>这很糟糕了， 在 “BasicPerson” 类型的数组里面，你不能使用 Swift 数组的内建函数 <code>index</code> 和 <code>contains</code>。(你必须定义一个闭包，每当你想使用那两个方法 blah,blah,blah… 这个我就不提了。)</p><p>再次回到问题，为什么报错？</p><p>因为 “BasicPerson” 类没有遵守 <code>Equeatable</code> 协议(这是一个提示，请看下文咯)</p><h2 id="遵守-Equatable-协议"><a href="#遵守-Equatable-协议" class="headerlink" title="遵守 Equatable 协议"></a>遵守 <code>Equatable</code> 协议</h2><p>为了允许我的 “BasicPerson” 类是可以使用我的 “exists” 和 “find” 泛型方法，所有我需要做的是：</p><ul><li>让类遵守 <code>Equatable</code> 协议</li><li>重载类实例的 <code>==</code> 操作符</li></ul><p>注意<a href="https://developer.apple.com/documentation/ Swift / Equatable" target="_blank" rel="noopener">这个</a>“Swift 标准库为所有遵循 <code>Euqatable</code> 协议的类型提供了不等于(!=) 操作符的实现。通过调用自定义的 <code>==</code> 函数获取它的取反结果。</p><p>如果你对操作符重载不熟悉，我建议你阅读这些主题，链接在<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/SwiftProgrammingLanguage/AdvancedOperators.html" target="_blank" rel="noopener">这里</a>和<a href="https://www.appcoda.com/operator-overloading-Swift" target="_blank" rel="noopener">这里的</a>.相信我，你会想知道操作符重载的。</p><blockquote><p>提示：我重命名 “BasicPerson” 类为 “Person” 让他们在相同的 Swift Playground 文件能共存，接着我们来到 “Person” 类。</p></blockquote><p>我将实现 <code>==</code> 操作符，所以它能比较 “Person” 类不同实例间的 “name”, “weight”, 和 “sex” 属性。如果两个 “Person” 类的实例有相同的的三个属性。则他们是相等的。如果有一个属性不同，则他们是不相等的(!=)。这就是为什么我的 “Person” 类遵守了 <code>Equatable</code> 协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lass <span class="type">Person</span>: <span class="type">Equatable</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> weight:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> sex:<span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(weight: <span class="type">Int</span>, name: <span class="type">String</span>, sex: <span class="type">String</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.weight = weight</span><br><span class="line">        <span class="keyword">self</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Person, rhs: Person)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> lhs.weight == rhs.weight &amp;&amp;</span><br><span class="line">            lhs.name == rhs.name &amp;&amp;</span><br><span class="line">            lhs.sex == rhs.sex</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面的 <code>==</code> 重载方法，这需要让 “Person” 遵守 <code>Equatable</code> 协议。注意 <code>==</code> 重载方法中的 <code>lhs</code> 和 <code>rhs</code> 参数。这是通用的，当重载操作符时，代码中等号两边的对象应该与参数中的物理位置一致，如：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lhs == rhs</span><br><span class="line"><span class="keyword">left</span>-hand side == <span class="keyword">right</span>-hand side</span><br></pre></td></tr></table></figure><h2 id="它实用吗？"><a href="#它实用吗？" class="headerlink" title="它实用吗？"></a>它实用吗？</h2><p>如果你跟随着我的指南，你能创建像我写的 “exists” 和 “find” 泛型函数用于任何你创建的新类型，如类或者结构体。让你自定义的类和结构体集合类型遵守 <code>Equatable</code> 协议，像 Swift 里面 <code>Array</code> 中的内置函数 <code>index</code> 和 <code>contains</code>。他们确实有用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">Joe</span> = <span class="type">Person</span>(weight: <span class="number">180</span>, name: <span class="string">"Joe Patterson"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Pam</span> = <span class="type">Person</span>(weight: <span class="number">120</span>, name: <span class="string">"Pam Patterson"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Sue</span> = <span class="type">Person</span>(weight: <span class="number">115</span>, name: <span class="string">"Sue Lewis"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Jeb</span> = <span class="type">Person</span>(weight: <span class="number">180</span>, name: <span class="string">"Jeb Patterson"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Bob</span> = <span class="type">Person</span>(weight: <span class="number">200</span>, name: <span class="string">"Bob Smith"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> myPeople:<span class="type">Array</span> = [<span class="type">Joe</span>, <span class="type">Pam</span>, <span class="type">Sue</span>, <span class="type">Jeb</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> indexOfOneOfMyPeople = <span class="built_in">find</span>(item: <span class="type">Jeb</span>, inArray: myPeople)</span><br><span class="line"><span class="comment">// returns 3 from custom generic function</span></span><br><span class="line"><span class="comment">// 返回 3 源自自定义泛型函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> indexOfOneOfMyPeople1 = myPeople.index(of: <span class="type">Jeb</span>)</span><br><span class="line"><span class="comment">// returns 3 from built-in Swift member function</span></span><br><span class="line"><span class="comment">// 返回 3 源自 Swift 内建成员函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isSueOneOfMyPeople = exists(item: <span class="type">Sue</span>, inArray: myPeople)</span><br><span class="line"><span class="comment">// returns true from custom generic function</span></span><br><span class="line"><span class="comment">// 返回 true 源自自定义泛型函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isSueOneOfMyPeople1 = myPeople.<span class="built_in">contains</span>(<span class="type">Sue</span>)</span><br><span class="line"><span class="comment">// returns true from built-in Swift member function</span></span><br><span class="line"><span class="comment">// 返回 true 源自 Swift 内建成员函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> indexOfBob = <span class="built_in">find</span>(item: <span class="type">Bob</span>, inArray: myPeople)</span><br><span class="line"><span class="comment">// returns nil from custom generic function</span></span><br><span class="line"><span class="comment">// 返回 nil 源自自定义泛型函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> indexOfBob1 = myPeople.index(of: <span class="type">Bob</span>)</span><br><span class="line"><span class="comment">// returns nil from built-in Swift member function</span></span><br><span class="line"><span class="comment">// 返回 nil 源自 Swift 内建成员函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isBobOneOfMyPeople1 = exists(item: <span class="type">Bob</span>, inArray: myPeople)</span><br><span class="line"><span class="comment">// returns false from custom generic function</span></span><br><span class="line"><span class="comment">// 返回 false 源自自定义泛型函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isBobOneOfMyPeople2 = myPeople.<span class="built_in">contains</span>(<span class="type">Bob</span>)</span><br><span class="line"><span class="comment">// returns false from built-in Swift member function</span></span><br><span class="line"><span class="comment">// 返回 false 源自 Swift 内建成员函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> <span class="type">Joe</span> == <span class="type">Pam</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"they're equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"they're not equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// returns "they're not equal"</span></span><br></pre></td></tr></table></figure><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>苹果提示关于 <code>Equatable</code> 协议的更多好处：</p><blockquote><p>Adding  Equatable  conformance to your custom types means that you can use more convenient APIs when searching for particular instances in a collection.  Equatable  is also the base protocol for the Hashable and Comparable protocols, which allow more uses of your custom type, such as constructing sets or sorting the elements of a collection.</p></blockquote><blockquote><p>让你的自定义类型遵循 Equatable 协议意味着你可以使用许多系统提供的 API 来让你在一个集合里面查找特定一个实例变得更加方便。</p><p>Equatable 协议也是 Hashable 协议和 Comparable 协议的基础协议。这允许你使用更多的自定义类型，比如构建集合或者排序集合中的元素。</p></blockquote><p>比如，如果你遵守了 <code>comparable</code> 协议，你能重载和使用 <code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code> 和 <code>&gt;=</code> 操作符，这真的很 Cool。</p><h2 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h2><p>想一下我们的 “Person” 类，假如我们有一些类似下文所示的实例：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">Joe</span> = <span class="type">Person</span>(weight: <span class="number">180</span>, name: <span class="string">"Joe Patterson"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Pam</span> = <span class="type">Person</span>(weight: <span class="number">120</span>, name: <span class="string">"Pam Patterson"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Sue</span> = <span class="type">Person</span>(weight: <span class="number">115</span>, name: <span class="string">"Sue Lewis"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Jeb</span> = <span class="type">Person</span>(weight: <span class="number">180</span>, name: <span class="string">"Jeb Patterson"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Bob</span> = <span class="type">Person</span>(weight: <span class="number">200</span>, name: <span class="string">"Bob Smith"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Jan</span> = <span class="type">Person</span>(weight: <span class="number">115</span>, name: <span class="string">"Sue Lewis"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> <span class="type">Jan</span> == <span class="type">Sue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"they're equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"they're not equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// returns "they're equal" for 2 different objects</span></span><br><span class="line"><span class="comment">// 返回 "they're equal" 对于两个不同的对象</span></span><br></pre></td></tr></table></figure><p>看最后一行，因为这些 “Person” 对象中 “Jan” 和 “Sue” 对象是绝对相等的。即使他们是两个不同的实例对象。你的软件好坏仅仅取决于你的设计。在数据库的术语体系里， “Person” 类集合中，你会需要一个”主键” — 或许在类的设计中，可以添加一个索引变量。比如一个社会安全码、或者你熟知的其他的唯一值来保证 “Person” 类实例在集合 (<code>Array</code>) 中的唯一性，当然啦，你也可以使用 <code>===</code> 操作符。</p><p>享用吧！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文详细讲解了 Swift 中的泛型是什么？ 如何使用泛型？
    
    </summary>
    
      <category term="AppCoda" scheme="https://swift.gg/categories/AppCoda/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>构建第一个 Swift 区块链应用</title>
    <link href="https://swift.gg/2018/08/21/blockchain-introduction/"/>
    <id>https://swift.gg/2018/08/21/blockchain-introduction/</id>
    <published>2018-08-21T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sai Kambampati，<a href="https://appcoda.com/blockchain-introduction/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-05-31<br>译者：<a href="http://daizi.me" target="_blank" rel="noopener">小袋子</a>；校对：<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>区块链作为一项革命性的技术，开始受到越来越多追捧。为什么呢？因为区块链是许多加密数字货币的底层技术，比如：比特币（BTC），以太坊（ETH）以及莱特币（LTC）。区块链具体是如何工作的？本篇教程会涵盖所有区块链相关的知识，还会教你如何构建 Swift 区块链。下面让我们开始吧！</p><a id="more"></a><h3 id="区块链的工作原理"><a href="#区块链的工作原理" class="headerlink" title="区块链的工作原理"></a>区块链的工作原理</h3><p>顾名思义，区块链是一条由不同区块连接组成的链。每一个块包含三个信息：数据、哈希（hash）、以及前置区块的哈希。</p><p><strong>1、数据</strong> – 由于应用场景不同，存储在区块中的数据由区块链的类型决定。例如，在比特币区块链中，存储的数据是交易信息：转账金额和交易双方的信息。</p><p><strong>2、哈希</strong> – 你可以将哈希看做数字指纹，用来唯一标识一个区块及其数据。哈希的重要之处在于它是一个独特的字母数字代码，通常是 64 个字符。当一个区块被创建时，哈希也随之创建。当一个区块被修改，哈希也随之修改。因此，当你想要查看在区块上所做的任何变更时，哈希就显得非常重要。</p><p><strong>3、前置区块的哈希</strong> – 通过存储前置区块的哈希，你可以还原每个区块连接成区块链的过程！这使得区块链安全性特别高。</p><p>我们来看下这张图片：</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-explained.png" alt="区块链"></p><p>你可以看到，每一个区块包含数据（图片中没有指明）、哈希以及前置区块的哈希。例如，黄色区块包含自身的哈希：H7s6，以及红色区块的哈希：8SD9。这样它们就构成了一条相互连接的链。现在，假如有一个黑客准备恶意篡改红色的区块。请记住，每当块以任何方式被篡改时，该区块的哈希都会改变！当下一个区块检查并发现前置哈希不一致时，黑客将无法访问它，因为他与前置区块的联系被切断了（译者注：即如果黑客想要要篡改一个区块的话，就需要把这个区块后面的所有区块都要改掉，而这个工作量是很难实现的）。</p><p>这使得区块链特别安全，几乎不可能回滚或者篡改任何数据。虽然哈希为保密和隐私提供了巨大的保障，但是还有两个更加安全妥当的措施让区块链更加安全：工作量证明（Proof-of-Work）以及智能合约（Smart Contracts）。本文我不会深入讲解，你可以<a href="https://hackernoon.com/what-on-earth-is-a-smart-contract-2c82e5d89d26" target="_blank" rel="noopener">在这里</a>了解更多相关知识。</p><p>区块链最后一个保证自身安全性的方式是基于其定位。和大多数存储在服务器和数据库的数据不同，区块链使用的是点对点（P2P）网络。P2P 是一种允许任何人加入的网络，并且该网络上的数据会分发给每一个接收者。</p><p>每当有人加入这个网络，他们就会获得一份区块链的完整拷贝。每当有人新建一个区块，就会广播给全网。在将该块添加到链之前，节点会通过几个复杂的程序确定该块是否被篡改。这样，所有人、所有地方都可以使用这个信息。如果你是 <em>HBO 美剧硅谷</em> 的粉丝，对此应该不会感到陌生。在该剧中，主演（Richard）使用一种相似的技术创造了新型互联网（译者注：有趣的是剧中还发行了区块链数字货币 PiedPaperCoin，感兴趣的童鞋可以刷一下这部剧）。</p><p>因为每个人都有区块链或者节点的一份拷贝，他们可以达成一种共识并决定哪部分区块是有效的。因此，如果你想要攻击某个区块，你必须同时攻击网络上 50% 以上的区块（译者：51% 攻击），使得你的区块可以追上并替换原区块链。所以区块链或许是过去十年所创造的最安全的技术之一。</p><h3 id="关于示例程序"><a href="#关于示例程序" class="headerlink" title="关于示例程序"></a>关于示例程序</h3><p>现在你已经对区块链的原理有了初步的认识，那么我们就开始写示例程序吧！你可以在这里下载<a href="https://github.com/appcoda/BlockchainDemo/raw/master/BlockchainStarter.zip" target="_blank" rel="noopener">原始项目</a>。</p><p>如你所见，我们有两个比特币钱包。第一个账户 1065 有 500 BTC，而第二个账户 0217 没有 BTC。我们通过 send 按钮可以发送比特币到另外的账户。为了赚取 BTC，我们可以点击 Mine 按钮，可以获得 50 BTC 的奖励。我们主要工作是查看控制台输出，观察两个账户间的交易过程。</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-2.png" alt="这里写图片描述"></p><p>在左侧导航栏可以看到两个很重要的类：<code>Block</code> 和 <code>Blockchain</code>。目前这两个类都是空实现，我会带着你们在这两个类中写入相关逻辑。下面让我们开始吧！</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-3.png" alt="这里写图片描述"></p><h3 id="在-Swift-中定义区块"><a href="#在-Swift-中定义区块" class="headerlink" title="在 Swift 中定义区块"></a>在 Swift 中定义区块</h3><p>首先打开 <code>Block.swift</code> 并添加定义区块的代码。在此之前，我们需要定义区块是什么。前面我们曾定义过，区块是由三部分组成：哈希、实际记录的数据以及前置区块的哈希。当我们想要构建我们的区块链时，我们必须知道该区块是第一个还是第二个。我们可以很容易地在 Swift 的类中做如下定义：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hash: <span class="type">String</span>!</span><br><span class="line"><span class="keyword">var</span> data: <span class="type">String</span>!</span><br><span class="line"><span class="keyword">var</span> previousHash: <span class="type">String</span>!</span><br><span class="line"><span class="keyword">var</span> index: <span class="type">Int</span>!</span><br></pre></td></tr></table></figure><p>现在需要添加最重要的代码。我曾提过区块在被修改的情况下，哈希也会随之变化，这是区块链如此安全的特性之一。因此我们需要创建一个函数去生成哈希，该哈希由随机字母和数字组成。这个函数只需要几行代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateHash</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NSUUID</span>().uuidString.replacingOccurrences(of: <span class="string">"-"</span>, with: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NSUUID</code> 是一个代表通用唯一值的对象，并且可以桥接成 UUID。它可以快速地生成 32 个字符串。本函数生成一个 UUID，删除其中的连接符，然后返回一个 <code>String</code>，最后将结果作为区块的哈希。<code>Block.swift</code> 现在就像下面：</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-4.png" alt="这里写图片描述"></p><p>现在我们已经定义好了 <code>Block</code> 类，下面来定义 Blockchain 类，首先切换到 <code>Blockchain.swift</code> 。</p><h3 id="在-Swift-中定义区块链"><a href="#在-Swift-中定义区块链" class="headerlink" title="在 Swift 中定义区块链"></a>在 Swift 中定义区块链</h3><p>和之前一样，首先分析区块链的基本原理。用非常基础的术语来说，区块链只是由一连串的区块连接而成，也可以说是一个由多个条目组成的列表。这是不是听起来很熟悉呢？其实这就是数组的定义！而且这个数组是由区块组成的！接下来添加以下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> chain = [<span class="type">Block</span>]()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快速提示： 这个方法可以应用于计算机科学世界里的任何事物。如果你遇到大难题，可以尝试把它分解成若干个小问题，以此来建立起解决问题的方法，正如我们解决在 Swift 中如何添加区块和区块链的问题。</span><br></pre></td></tr></table></figure><p>你会注意到数组里面是我们前面定义的 <code>Block</code> 类，这就是区块链所需要的所有变量。为了完成功能，我们还需要在类中添加两个函数。请尝试着根据我之前教过的方法解答这个问题。</p><blockquote><p>区块链中的两个主要函数是什么？</p></blockquote><p>我希望你能认真思考并回答这个问题！实际上，区块链的两个主要功能是创建创世区块（最初的始块），以及在其结尾添加新的区块。当然现在我不打算实现分叉区块链和添加智能合约的功能，但你必须了解这两个是基本功能！将以下代码添加到 <code>Blockchain.swift</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createGenesisBlock</span><span class="params">(data:String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> genesisBlock = <span class="type">Block</span>()</span><br><span class="line">    genesisBlock.hash = genesisBlock.generateHash()</span><br><span class="line">    genesisBlock.data = data</span><br><span class="line">    genesisBlock.previousHash = <span class="string">"0000"</span></span><br><span class="line">    genesisBlock.index = <span class="number">0</span></span><br><span class="line">    chain.append(genesisBlock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createBlock</span><span class="params">(data:String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newBlock = <span class="type">Block</span>()</span><br><span class="line">    newBlock.hash = newBlock.generateHash()</span><br><span class="line">    newBlock.data = data</span><br><span class="line">    newBlock.previousHash = chain[chain.<span class="built_in">count</span>-<span class="number">1</span>].hash</span><br><span class="line">    newBlock.index = chain.<span class="built_in">count</span></span><br><span class="line">    chain.append(newBlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、我们添加的第一个函数的作用是创建创世区块。为此，我们创建了一个以区块数据为入参的函数。然后定义了一个类型为 <code>Block</code> 的变量 <code>genesisBlock</code>，它拥有此前在 <code>Block.swift</code> 中定义的所有变量和函数。我们将 <code>generateHash()</code> 赋值给哈希，将输入的 <code>data</code> 参数赋值给数据。由于这是第一个区块，我们将前置区块的哈希设为 0000，这样我们就可以知道这是起始区块。最后我们将 <code>index</code> 设为 0，并将这个区块加入到区块链中。</p><p>2、我们创建的第二个函数适用于 <code>genesisBlock</code> 之后的所有区块，并且能创建剩余的区块。你会注意到它与第一个函数非常相似。唯一的区别是，我们将 <code>previousHash</code> 的值设置为前一个区块的哈希值，并将 <code>index</code> 设置为它在区块链中的位置。就这样，区块链已经定义好了！你的代码应该看起来跟下图一样！</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-5.png" alt="这里写图片描述"></p><h3 id="钱包后端"><a href="#钱包后端" class="headerlink" title="钱包后端"></a>钱包后端</h3><p>现在切换到 <code>ViewController.swift</code>，我们会发现所有的 outlet 都已经连接好了。我们只需要处理交易，并将其输出到控制台。</p><p>然而在此之前，我们需要稍微研究一下比特币的区块链。比特币是由一个总账户产生的，我们将这个账号的编号称为 0000。当你挖到一个 BTC，意味着你解决了数学问题，因此会发行一定数量的比特币作为奖励。这提供了一个发币的高明方法，并且可以激励更多人去挖矿。在我们的应用，让我们把挖矿奖励设为 100 BTC。首先，在视图控制器中添加所需的变量：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstAccount = <span class="number">1065</span></span><br><span class="line"><span class="keyword">let</span> secondAccount = <span class="number">0217</span></span><br><span class="line"><span class="keyword">let</span> bitcoinChain = <span class="type">Blockchain</span>()</span><br><span class="line"><span class="keyword">let</span> reward = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> accounts: [<span class="type">String</span>: <span class="type">Int</span>] = [<span class="string">"0000"</span>: <span class="number">10000000</span>]</span><br><span class="line"><span class="keyword">let</span> invalidAlert = <span class="type">UIAlertController</span>(title: <span class="string">"Invalid Transaction"</span>, message: <span class="string">"Please check the details of your transaction as we were unable to process this."</span>, preferredStyle: .alert)</span><br></pre></td></tr></table></figure><p>首先定义号码为 1065 和 0217 的两个账号。然后添加一个名为 <code>bitcoinChain</code> 的变量作为我们的区块链，并将 <code>reward</code> 设为 100。我们需要一个主帐户作为所有比特币的来源：即创世帐户 0000。里面有 1000 万个比特币。你可以把这个账户想象成一个银行，所有因奖励产生的 100 个比特币都经此发放到合法账户中。我们还定义了一个提醒弹窗，每当交易无法完成时就会弹出。</p><p>现在，让我们来编写几个运行时需要的通用函数。你能猜出是什么函数吗？</p><p>1、第一个函数是用来处理交易的。我们需要确保交易双方的账户，能够接收或扣除正确的金额，并将这些信息记录到我们的区块链中。</p><p>2、下一个函数是在控制台中打印整个记录 —— 它将显示每个区块及其中的数据。</p><p>3、最后一个是用于验证区块链是否有效的函数，通过校验下一个区块的 <code>previousHash</code> 和上一个区块 <code>hash</code> 是否匹配。由于我们不会演示任何黑客方法，因此在我们的示例程序中，区块链是永远有效的。</p><h3 id="交易函数"><a href="#交易函数" class="headerlink" title="交易函数"></a>交易函数</h3><p>下面是一个通用的交易函数，请在我们定义的变量下方输入以下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transaction</span><span class="params">(from: String, to: String, amount: Int, type: String)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> accounts[from] == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.present(invalidAlert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> accounts[from]!-amount &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.present(invalidAlert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        accounts.updateValue(accounts[from]!-amount, forKey: from)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> accounts[to] == <span class="literal">nil</span> &#123;</span><br><span class="line">        accounts.updateValue(amount, forKey: to)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        accounts.updateValue(accounts[to]!+amount, forKey: to)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> type == <span class="string">"genesis"</span> &#123;</span><br><span class="line">        bitcoinChain.createGenesisBlock(data: <span class="string">"From: <span class="subst">\(from)</span>; To: <span class="subst">\(to)</span>; Amount: <span class="subst">\(amount)</span>BTC"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> type == <span class="string">"normal"</span> &#123;</span><br><span class="line">        bitcoinChain.createBlock(data: <span class="string">"From: <span class="subst">\(from)</span>; To: <span class="subst">\(to)</span>; Amount: <span class="subst">\(amount)</span>BTC"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码量看起来好像很大，但主要是定义了每个交易需要遵循的一些规则。一开始是函数的四个参数：<br><code>to</code>，<code>from</code>，<code>amount</code>，<code>type</code>。前三个参数不需要再解释了，而 <code>Type</code> 主要用于定义交易的类型。总共有两个类型：正常类型（normal） 和创世类型（genesis）。正常类型的交易会发生在账户 1065 和 2017 之间，而创世类型将会涉及到账户 0000。</p><p>1、第一个 <code>if-else</code> 条件语句处理转出账户的信息。如果账户不存在或者余额不足，将会提示交易不合法并返回。</p><p>2、第二个 <code>if-else</code> 条件语句处理转入账户的信息。如果账户不存在，则创建新账户并转入相应的比特币。反之，则向该账户转入正确数量的比特币。</p><p>3、最后一个 <code>if-else</code> 条件语句处理交易类型。如果类型是创世类型，则添加一个创世区块，否则创建一个新的区块存储数据。</p><h3 id="打印函数"><a href="#打印函数" class="headerlink" title="打印函数"></a>打印函数</h3><p>为了确保交易正确执行，在每个交易结束后，我们希望拿到所有交易的清单。以下是我们在交易函数下方的代码，用来打印相关信息：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chainState</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...bitcoinChain.chain.<span class="built_in">count</span>-<span class="number">1</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\tBlock: <span class="subst">\(bitcoinChain.chain[i].index!)</span>\n\tHash: <span class="subst">\(bitcoinChain.chain[i].hash!)</span>\n\tPreviousHash: <span class="subst">\(bitcoinChain.chain[i].previousHash!)</span>\n\tData: <span class="subst">\(bitcoinChain.chain[i].data!)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    redLabel.text = <span class="string">"Balance: <span class="subst">\(accounts[String(describing: firstAccount)</span>]!) BTC"</span></span><br><span class="line">    blueLabel.text = <span class="string">"Balance: <span class="subst">\(accounts[String(describing: secondAccount)</span>]!) BTC"</span></span><br><span class="line">    <span class="built_in">print</span>(accounts)</span><br><span class="line">    <span class="built_in">print</span>(chainValidity())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的循环语句，遍历 <code>bitcoinChain</code> 中的所有区块，并打印区块号码，哈希，前置哈希，以及存储的数据。同时我们更新了界面中的标签（label），这样就可以显示账户中正确的 BTC 数量。最后，打印所有的账户（应该是 3 个），并校验区块链的有效性。</p><p>现在你应该会在函数的最后一行发现一个错误。这是由于我们还没有实现 <code>chainValidity()</code> 函数，让我们马上开始吧。</p><h3 id="有效性函数"><a href="#有效性函数" class="headerlink" title="有效性函数"></a>有效性函数</h3><p>判断一个链是否有效的标准是：前置区块的哈希与当前区块所表示的是否匹配。我们可以再次用循环语句来遍历所有的区块：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chainValidity</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isChainValid = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...bitcoinChain.chain.<span class="built_in">count</span>-<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> bitcoinChain.chain[i].previousHash != bitcoinChain.chain[i-<span class="number">1</span>].hash &#123;</span><br><span class="line">            isChainValid = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Chain is valid: <span class="subst">\(isChainValid)</span>\n"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前一样，我们遍历了 <code>bitcoinChain</code> 中的所有区块，并检查了前置区块的 <code>hash</code> 是否与当前区块的 <code>previousHash</code> 一致。</p><p>就酱！我们已经将定义了所有需要的函数！你的 <code>ViewController.swift</code> 应该如下图一样：</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-6.png" alt="这里写图片描述"></p><p>收尾工作就是连接按钮和函数啦。让我们马上开始最后的部分吧！</p><h3 id="让一切关联起来"><a href="#让一切关联起来" class="headerlink" title="让一切关联起来"></a>让一切关联起来</h3><p>当我们的应用第一次启动时，需要创世账户 0000 发送 50 BTC 到我们的第一个账户。再从第一个账户转账 10 BTC 到第二个账户，这只需要寥寥三行代码。最后 <code>viewDidLoad</code> 中的代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    transaction(from: <span class="string">"0000"</span>, to: <span class="string">"<span class="subst">\(firstAccount)</span>"</span>, amount: <span class="number">50</span>, type: <span class="string">"genesis"</span>)</span><br><span class="line">    transaction(from: <span class="string">"<span class="subst">\(firstAccount)</span>"</span>, to: <span class="string">"<span class="subst">\(secondAccount)</span>"</span>, amount: <span class="number">10</span>, type: <span class="string">"normal"</span>)</span><br><span class="line">    chainState()</span><br><span class="line">    <span class="keyword">self</span>.invalidAlert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用已定义好的函数转账，并调用 <code>chainState()</code> 函数。最后，我们还在 <code>invalidAlert</code> 中添加了一个标题为 OK 的 <code>UIAlertAction</code>。</p><p>现在让我们来实现剩下的四个函数：<code>ReMeNe()</code>、<code>BrimeMeNe()</code>、<code>ReSdEnter()</code>和<code>BuLeScript()</code>。</p><h3 id="挖矿函数"><a href="#挖矿函数" class="headerlink" title="挖矿函数"></a>挖矿函数</h3><p>挖矿函数特别简单，只需要三行代码。添加以下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">redMine</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    transaction(from: <span class="string">"0000"</span>, to: <span class="string">"<span class="subst">\(firstAccount)</span>"</span>, amount: <span class="number">100</span>, type: <span class="string">"normal"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"New block mined by: <span class="subst">\(firstAccount)</span>"</span>)</span><br><span class="line">    chainState()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">blueMine</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    transaction(from: <span class="string">"0000"</span>, to: <span class="string">"<span class="subst">\(secondAccount)</span>"</span>, amount: <span class="number">100</span>, type: <span class="string">"normal"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"New block mined by: <span class="subst">\(secondAccount)</span>"</span>)</span><br><span class="line">    chainState()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一个挖矿函数中，我们使用交易函数从创世账户发送了 100 BTC 到第一个账户。我们打印了挖矿的区块，然后打印了区块链的状态。同样地，在 <code>blueMine</code> 函数中，我们转给了第二个账户 100 BTC。</p><h3 id="发送函数"><a href="#发送函数" class="headerlink" title="发送函数"></a>发送函数</h3><p>发送函数和挖矿函数略微相似：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">redSend</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> redAmount.text == <span class="string">""</span> &#123;</span><br><span class="line">        present(invalidAlert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transaction(from: <span class="string">"<span class="subst">\(firstAccount)</span>"</span>, to: <span class="string">"<span class="subst">\(secondAccount)</span>"</span>, amount: <span class="type">Int</span>(redAmount.text!)!, type: <span class="string">"normal"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(redAmount.text!)</span> BTC sent from <span class="subst">\(firstAccount)</span> to <span class="subst">\(secondAccount)</span>"</span>)</span><br><span class="line">        chainState()</span><br><span class="line">        redAmount.text = <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">blueSend</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> blueAmount.text == <span class="string">""</span> &#123;</span><br><span class="line">        present(invalidAlert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transaction(from: <span class="string">"<span class="subst">\(secondAccount)</span>"</span>, to: <span class="string">"<span class="subst">\(firstAccount)</span>"</span>, amount: <span class="type">Int</span>(blueAmount.text!)!, type: <span class="string">"normal"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(blueAmount.text!)</span> BTC sent from <span class="subst">\(secondAccount)</span> to <span class="subst">\(firstAccount)</span>"</span>)</span><br><span class="line">        chainState()</span><br><span class="line">        blueAmount.text = <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们检查 <code>redAmount</code> 或者 <code>blueAmount</code> 的文本值是否为空。如果为空，则弹出无效交易的提示框。如果不为空，则继续下一步。我们使用交易函数从第一个账户转账到第二个账户（或者反向转账），金额为输入的数量。我们打印转账金额，并调用 <code>chainState()</code> 方法。最后，清空文本框。</p><p>就酱，工作完成！请检查你的代码是否和图中一致：</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-7.png" alt="这里写图片描述"></p><p>现在运行应用并测试一下。从前端看，这就像一个正常的交易应用，但是运行在屏幕背后的可是区块链啊！请尝试使用应用将 BTC 从一个帐户转移到另一个帐户，随意测试，尽情把玩吧！</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在这个教程中，你已经学会了如何使用 Swift 创建区块链，并且创建了你自己的比特币交易系统。请注意，真正加密货币的后端，和我们上面的实现完全不一样，因为它需要用智能合约实现分布式，而本例仅用于学习。</p><p>在这个示例中，我们将区块链技术应用于加密货币，然而你能想到区块链的其他应用场景吗？请留言分享给大家！希望你能学到更多新东西！</p><p>为了参考，你可以从 GitHub 下载<a href="https://github.com/appcoda/BlockchainDemo" target="_blank" rel="noopener">完整的示例</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      构建第一个 Swift 区块链应用
    
    </summary>
    
      <category term="AppCoda" scheme="https://swift.gg/categories/AppCoda/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="区块链" scheme="https://swift.gg/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>在 Swift 中使用 Watch Connectivity — Application Context</title>
    <link href="https://swift.gg/2018/08/15/watch-connectivity-swift-application-context/"/>
    <id>https://swift.gg/2018/08/15/watch-connectivity-swift-application-context/</id>
    <published>2018-08-15T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：codingexplorer，<a href="http://www.codingexplorer.com/watch-connectivity-swift-application-context/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-07-18<br>译者：<a href="http://khala-wan.com" target="_blank" rel="noopener">Khala-wan</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="undefined">wongzigii</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p><img src="http://www.codingexplorer.com/wp-content/uploads/2016/02/Watch-Connectivity-Application-Context.png" alt=""></p><p>在 watchOS 1 时代，<code>WatchKit Extension</code> 位于已配对的 iOS 设备上，这使得宿主 APP 和 watch 之间的数据共享变得简单。类似偏好设置这种最简单的数据，只需要通过 App Groups 功能来存取 <code>NSUserDefaults</code>。目前在手机上留存的其他扩展程序和主 app 之间共享数据仍然应该使用这种方式，例如 <code>Today View Extension</code>，但它已不再适用于 watchOS 的 app。<br>幸运的是，苹果为我们提供了新的 API 来做这件事。相比 App Groups，Watch Connectivity 拥有更强大的功能。它不仅提供了你的 Apple Watch 和与其配对 iPhone 之间连接状态的更多信息，还允许它们之间进行交互消息和 3 种方式的后台传输，这些方式分别是：</p><ol><li>Application Context</li><li>User Info Transfer</li><li>File Transfer</li></ol><p>我们今天先讨论第一种方式：Application Context。</p><a id="more"></a><h2 id="什么是-Application-Context"><a href="#什么是-Application-Context" class="headerlink" title="什么是 Application Context"></a>什么是 Application Context</h2><p>假设你有个 watch app，它有一些可以在 iOS app 端设置的设置项，比如温度的显示单位是摄氏度还是华氏度。对于这样的设置项，除非你希望在用户在设置完成之后立即使用 watch 上的 app，否则将设置项的信息通过后台传输发送到 watch 才会是比较合理的。</p><p>因为它可能不是立即需要的，所以系统可能会在节省电量最多的情况下将其发送出去。你也不需要任何历史记录，因为用户可能并不关心一小时之前的设置是摄氏度。</p><p>这就是 Application Context 的用武之地。它仅用于发送最新的数据。如果你将温度设置项从摄氏度改为华氏度，然后在 Application Context 发送到 watch 之前再将它（或者其他设置项）设置为不同的值，那么最新的值会覆盖之前等待发送的信息。</p><p>如果你确实希望它能保存先前信息的历史记录，而且是以最省电的方式传输。那么可以使用 <code>User Info</code> 方式进行传输。它的使用方式和 Application Context 很相似，但它会将更新操作加入到一个队列中并逐一发送（而不是仅仅覆盖某些内容只发送最新的信息）。具体 <code>User Info</code> 的使用将作为以后另一篇文章的主题来讲。</p><h2 id="设置-iOS-应用程序"><a href="#设置-iOS-应用程序" class="headerlink" title="设置 iOS 应用程序"></a>设置 iOS 应用程序</h2><p>我们将从一个类似于上一篇文章 <a href="http://www.codingexplorer.com/watchos-2-hello-world-app-in-swift/" target="_blank" rel="noopener">watchOS Hello World App in Swift</a> 中的 app 说起。不过在本文中，我们将在这个 iPhone app 上加入一个 <code>UISwitch</code> 控件，并通过更新 watchOS app 上的 WKInterfaceLabel 来说明 <code>UISwitch</code> 的状态。</p><p>首先，在 iOS app 的 <code>viewController</code> 中，我们需要设置一些东西：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?)</span></span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sessionDidBecomeInactive</span><span class="params">(<span class="number">_</span> session: WCSession)</span></span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sessionDidDeactivate</span><span class="params">(<span class="number">_</span> session: WCSession)</span></span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> session: <span class="type">WCSession</span>?</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="type">WCSession</span>.isSupported() &#123;</span><br><span class="line">            session = <span class="type">WCSession</span>.<span class="keyword">default</span></span><br><span class="line">            session?.delegate = <span class="keyword">self</span></span><br><span class="line">            session?.activate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们最先需要导入 <code>WatchConnectivity</code> 框架。没有它，我们所做的都是无用功。接下来，为了响应来自 WCSession 的回调，我们需要将当前这个 <code>ViewController</code> 设置为 <code>WCSession</code> 的代理，为此我们需要让它遵守这个协议，所以在 <code>ViewController</code> 的父类声明后面添加 <code>WCSessionDelegate</code> 协议。</p><p>下一步，我们需要实现 <code>WCSessionDelegate</code> 中的一些方法。对于当前这个 app，它们不是特别必要，但是如果想要快速在 watch app 中切换，你就需要进一步实现它们。</p><p>之后，我们需要创建一个变量用于存储 <code>WCSession</code>。因为 <code>WCSession</code> 实际上是一个单例，技术上我们可以跳过这一步，但每次输入 <code>session?</code> 肯定要比 <code>WCSession.default</code> 更简短。</p><p>你应该在代码运行初期对 session 进行设置。在大多数情况下，这将在程序初始化的时候来做。但由于我们是在 <code>ViewController</code> 中执行此操作，所以最早能执行的地方大概就只有 <code>viewDidLoad</code> 方法中了。一般情况下来说，你不应该在 <code>viewController</code> 中执行这个操作，因为你的 app 希望在屏幕上未加载特定 <code>viewController</code> 时就可以更新它的数据模型。为了简单起见，我在 <code>viewController</code> 中做了这个操作，这仅仅是为了展示如何使用这些 API。如果这个 <code>ViewController</code> 是唯一关心使用 <code>WCSession</code> 的东西，那就没关系。但通常情况并非如此。</p><p>要设置 session，我们需要先根据 <code>WCSession</code> 的 <code>isSupport</code> 方法的返回值来检查是否支持。如果程序在 iPad 上运行的话，这一点尤为重要。目前，你无法将 iPad 与 Apple Watch 配对，因此它会返回 <code>false</code> 表示不支持在 iPad 上使用 <code>WCSession</code>。在 iPhone 上它会返回 <code>true</code>。</p><p>一旦我们完成检查，就可以将 WCSession 的 defaultSession 存储在那里，接着将这个 <code>ViewController</code> 设置为它的代理并激活 session。如果我们可以在初始化程序中执行 <code>isSupported</code> 来测试是否支持，就可以把 session 用作一个常量。而这里的 session 是一个可选值是因为我们不知道程序是否会运行在 <code>iPad</code> 上，所以当支持 <code>WCSession</code> 时，session 的值为 <code>WCSession.defualt</code>，反之则为 <code>nil</code>。这样，当我们在 <code>iPad</code> 上尝试访问 session 中的属性或方法时，它们甚至不会执行，因为 session 为 <code>nil</code>。</p><p>将一个 <code>UISwitch</code> 放在 Storyboard 上，并将其 <code>ValueChanged</code> 方法关联到 <code>ViewController</code> 中。<br>在方法中加入如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">switchValueChanged</span><span class="params">(<span class="number">_</span> sender: UISwitch)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> validSession = session &#123;</span><br><span class="line">        <span class="keyword">let</span> iPhoneAppContext = [<span class="string">"switchStatus"</span>: sender.isOn]</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> validSession.updateApplicationContext(iPhoneAppContext)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Something went wrong"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检查我们是否有一个有效的 session，如果是运行在 iPad 上，那么将跳过整个代码块。 <code>Application Context</code> 是一个 Swift 字典，它以 <code>String</code> 作为 <code>key</code>，<code>AnyObject</code> 作为 <code>value</code> (<code>Dictionary&lt;String, AnyObject&gt;</code>)。 value 必须遵循属性列表的规则，并且只包含某些类型。它和 <code>NSUserDefaults</code> 具有相同的限制，所以在上一篇文章 <a href="http://www.codingexplorer.com/nsuserdefaults-a-swift-introduction/" target="_blank" rel="noopener">NSUserDefaults — A Swift Introduction</a> 中已经介绍过了具体可以使用哪些类型。尽管如此，当我们发送一个 Swift <code>Bool</code> 类型时，其将会被转换为 <code>NSNumber boolean value</code>，所以没关系。</p><p>调用 <code>updateApplicationContext</code> 可能会抛出异常，所以我们需要将它包装在 <code>do-block</code> 中并通过 <code>try</code> 来调用。如果出现异常，我们只是在控制台上打印了一些信息，你还可以设置任何你需要的东西，比如你可能需要让用户知道发生了错误，那就可以显示一个 UIAlerController，同样，如果有必要可以加入异常的清理或恢复代码。这就是为了发送 <code>Application Context</code>，我们所需要的全部准备。</p><h2 id="设置-watchOS-应用程序"><a href="#设置-watchOS-应用程序" class="headerlink" title="设置 watchOS 应用程序"></a>设置 watchOS 应用程序</h2><p>因为我们使用的是之前 <a href="http://www.codingexplorer.com/watchos-2-hello-world-app-in-swift/" target="_blank" rel="noopener">watchOS Hello World App in Swift</a> 文中的 Hello World App，所以部分相同的设置已经替我们完成了。跟 iPhone 类似，我们还需要做一些设置才能使用 <code>WatchConnectivity</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceController</span>: <span class="title">WKInterfaceController</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> session = <span class="type">WCSession</span>.<span class="keyword">default</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awake</span><span class="params">(withContext context: Any?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awake(withContext: context)</span><br><span class="line">        </span><br><span class="line">        session.delegate = <span class="keyword">self</span></span><br><span class="line">        session.activate()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里省略掉了之前 App 中的一些无关代码，只展示与 <code>WatchConnectivity</code> 设置相关的部分。同样，我们需要导入 <code>WatchConnectivity</code> 框架，并让我们的 InterfaceController 遵守 WCSessionDelegate 协议，紧接着，我们将 session 常量初始化为 <code>WCSession</code> 的单例 <code>defaultSession</code>。</p><p>与 iOS 端不同的是，这里我们将 session 声明为一个非可选值的常量。很显然，运行在不低于 <code>watchOS 2</code> 系统上的 Apple Watch 是支持 <code>Watch Connectivity</code> 的，所以我们不需要在 <code>watchOS</code> 端进行相同的测试。 并且我们在声明时就初始化了它，又没有其他平台（如iPad）需要担心，所以我们不需要它是可选的。</p><p>接下来，在代码的初期，我们需要设置 session。在 InterfaceController 中 awakeWithContext 方法是个很好的地方，所以我们在这里做相关设置。和 iOS App 一样，我们设置当前类作为 session 的代理，然后激活 session。</p><p>让我们写一个辅助方法来处理 Application Context 的回调，因为我们可能会多次调用它，而不是仅仅当我们收到一个新 <code>context</code> 时（你很快会看到）。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processApplicationContext</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> iPhoneContext = session.receivedApplicationContext <span class="keyword">as</span>? [<span class="type">String</span> : <span class="type">Bool</span>] &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> iPhoneContext[<span class="string">"switchStatus"</span>] == <span class="literal">true</span> &#123;</span><br><span class="line">            displayLabel.setText(<span class="string">"Switch On"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            displayLabel.setText(<span class="string">"Switch Off"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WCSession</code> 有 2 个与 <code>Application Context</code> 相关的属性，<code>applicationContext</code> 和 <code>receivedApplicationContext</code>。它们的不同之处是：</p><ul><li>applicationContext - 此设备最近一次<strong>发送</strong>的 <code>Application Context</code>。</li><li>receivedApplicationContext - 此设备最近一次<strong>接收</strong>的 <code>Application Context</code>。</li></ul><p>现在，把它俩放到一起来看，至少接收到的看起来很明显。但在我第一次涉及这个时（不记得 WWDC 中 Watch Connectivity的介绍视频的全部内容？），我认为 applicationContext 是从最近的发送或接收来更新的，因为我认为它们是一致的 <code>context</code>。然而我大错特错，我花了一段时间才意识到它们是分开的。我当然能看出来原因，因为我们可能每次都会发送不一样的数据，就像从 Watch 的角度来看，applicationContext 就是 iPhone 端需要的 Watch 相关 <code>context</code>，而 receivedApplicationContext 则是 Watch 端需要的 iPhone 相关 <code>context</code>。无论哪种方式，请记住它们是不同的两个东西，并根据实际情况选择你所需要的那个。</p><p>所以在这个方法中，我们首先尝试将 <code>receivedApplicationContext</code> 由 <code>[String: AnyObject]</code> 类型的字典转换为我们需要的 <code>[String: Bool]</code> 类型。如果转换成功，则再根据字典中布尔值的状态将 displayLabel 的 text 值设置为 “Switch On” 或 “Switch Off”。</p><p>当我们实际接收到一个新的  Application context 时，该 InterfaceController 将会收到我们 WCSession 对象的代理回调来通知我们这个信息，我们将在那里调用这个辅助方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, didReceiveApplicationContext applicationContext: [String : Any])</span></span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async() &#123;</span><br><span class="line">        <span class="keyword">self</span>.processApplicationContext()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，你大概看到了 <code>didReceiveApplicationContext</code> 方法的入参带有它接收到的 <code>Application Context</code> 副本。它存储在上面提到的 <code>receivedApplicationContext</code> 属性中。所以我们并不需要它来调用辅助方法, 因此这个方法不需要传入任何行参。</p><blockquote><p>译者注：<br>其实对于辅助方法 <code>processApplicationContext</code> 来说，增加行参 context 反而更 <strong>函数式</strong>，也更 <strong>Swift</strong>。 通过增加一个 context 的入参，可以让方法内部实现和外部依赖解耦，更加方便我们对它进行单元测试。</p></blockquote><p>那么，调用 <code>dispatch_async</code> 是为了做什么呢？好吧，这些代理回调不在主线程上。你永远不应该在除主线程以外的任何线程更新 iOS 或 watchOS 中的 UI。而我们的辅助方法除了从 <code>receivedApplicationContext</code> 中读取信息之外，主要目的是用来更新 UI 元素。因此，我们要通过 <code>dispatch_async</code> 方法返回主线程来调用该方法。调用 <code>dispatch_async</code> 需要 2 个参数，首先是派发队列（对于主线程，我们通过 <code>dispatch_get_main_queue</code> 方法获取），其次是一个闭包来告诉它需要做什么操作，这里我们只是告诉它去调用辅助方法。</p><p>所以，为什么我们要在辅助方法里这样做，而不是直接在回调方法里面直接处理呢？好吧，当你实际接收到一个新的 <code>Application Context</code> 时，会回调 <code>didReceiveApplicationContext</code> 代理方法。当 <code>WCSession</code> 在关闭时接收到新的 <code>ApplicationContext</code> 会调用 activateSession 方法，在那不久之后也会回调到 <code>didReceiveApplicationContext</code> 方法。在这种情况下，我使用此 ApplicationContext 作为该信息的后备存储。我不确定这是不是一个好的主意，但是对于一个简单的 app 来说，这是合理的， 因为 <code>label</code> 的重点是显示 iPhone 上的 <code>UISwitch</code> 是开启还是关闭。</p><p>那么，当我们的 app 完成加载之后想使用最后一次接收到的值，但是 app 在关闭期间又没有收到新的 <code>context</code>，这种情况该怎么办？我们在视图生命周期的早期设置 label，所以现在 <code>awakeWithContext</code> 看起来应该是这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awake</span><span class="params">(withContext context: Any?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.awake(withContext: context)</span><br><span class="line"> </span><br><span class="line">    processApplicationContext()</span><br><span class="line"> </span><br><span class="line">    session.delegate = <span class="keyword">self</span></span><br><span class="line">    session.activate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 awakeWithContext 肯定在主线程上，我们不需要 <code>dispatch_async</code>。 因此这就是它仅用于在 didReceiveApplicationContext 回调中来调用辅助方法而不是在辅助方法内部使用的原因。</p><p>此时 iOS App 并没有保留该 <code>UISwitch</code> 的状态，所以在启动时保持它们的同步并不那么重要，对于一个有价值的 app 来说，我们应该将 UISwitch 的状态存储在某个地方。比如可以在 iPhone 端使用 WCSession 的 ApplicationContext 属性。（请记住，applicationContext 是从设备<strong>发送</strong>过来的最后一个 <code>context</code>），但如果是在iPad上运行呢？你可以将它存储在 <code>NSUserDefaults</code>，或者其他许多地方，但这些不在如何使用 WatchConnectivity 的讨论范畴内。具体你可以在早期的 <a href="http://www.codingexplorer.com/nsuserdefaults-a-swift-introduction/" target="_blank" rel="noopener">NSUserDefaults — A Swift Introduction</a> 文章中了解到。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是该项目的完整代码：</p><h3 id="ViewController-swift"><a href="#ViewController-swift" class="headerlink" title="ViewController.swift"></a>ViewController.swift</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?)</span></span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sessionDidBecomeInactive</span><span class="params">(<span class="number">_</span> session: WCSession)</span></span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sessionDidDeactivate</span><span class="params">(<span class="number">_</span> session: WCSession)</span></span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> theSwitch: <span class="type">UISwitch</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> session: <span class="type">WCSession</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="type">WCSession</span>.isSupported() &#123;</span><br><span class="line">            session = <span class="type">WCSession</span>.<span class="keyword">default</span></span><br><span class="line">            session?.delegate = <span class="keyword">self</span></span><br><span class="line">            session?.activate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">processApplicationContext</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> iPhoneContext = session?.applicationContext <span class="keyword">as</span>? [<span class="type">String</span> : <span class="type">Bool</span>] &#123;</span><br><span class="line">            <span class="keyword">if</span> iPhoneContext[<span class="string">"switchStatus"</span>] == <span class="literal">true</span> &#123;</span><br><span class="line">                theSwitch.isOn = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                theSwitch.isOn = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">switchValueChanged</span><span class="params">(<span class="number">_</span> sender: UISwitch)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> validSession = session &#123;</span><br><span class="line">            <span class="keyword">let</span> iPhoneAppContext = [<span class="string">"switchStatus"</span>: sender.isOn]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> validSession.updateApplicationContext(iPhoneAppContext)</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Something went wrong"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InterfaceController-swift"><a href="#InterfaceController-swift" class="headerlink" title="InterfaceController.swift"></a>InterfaceController.swift</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> WatchKit</span><br><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceController</span>: <span class="title">WKInterfaceController</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> displayLabel: <span class="type">WKInterfaceLabel</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> session = <span class="type">WCSession</span>.<span class="keyword">default</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awake</span><span class="params">(withContext context: Any?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awake(withContext: context)</span><br><span class="line">        </span><br><span class="line">        processApplicationContext()</span><br><span class="line">        </span><br><span class="line">        session.delegate = <span class="keyword">self</span></span><br><span class="line">        session.activate()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">buttonTapped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//displayLabel.setText("Hello World!")</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, didReceiveApplicationContext applicationContext: [String : Any])</span></span> &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async() &#123;</span><br><span class="line">            <span class="keyword">self</span>.processApplicationContext()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">processApplicationContext</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> iPhoneContext = session.receivedApplicationContext <span class="keyword">as</span>? [<span class="type">String</span> : <span class="type">Bool</span>] &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> iPhoneContext[<span class="string">"switchStatus"</span>] == <span class="literal">true</span> &#123;</span><br><span class="line">                displayLabel.setText(<span class="string">"Switch On"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                displayLabel.setText(<span class="string">"Switch Off"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请记住，这些代码来自 Hello World App，但是我们没有用到 watchOS App 上的 button。所以我只是注释了原始功能的代码。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>以上就是如何使用 Watch Connectivity 的 Application Context 方式进行后台传输的教程。向手机端回传数据也是完全相同的，因为它们具有同样的代理回调和属性。虽然在那种情况下，你可能还需要根据实际情况检查是否存在与该设备配对的 Apple Watch 或者 Watch 上是否安装了对应的 app。</p><p>正如我之前提到的，在 <code>ViewController / InterfaceController</code> 中执行所有代码可能不是最好的主意，但这只是为了简单地展示如何使用 API​​。我个人非常喜欢在自己的 <code>Watch Connectivity manager</code> 实例中执行这些操作。所以我强烈建议你阅读 Natasha The Robot 的文章 <a href="https://www.natashatherobot.com/watchconnectivity-say-hello-to-wcsession/" target="_blank" rel="noopener">WatchConnectivity: Say Hello to WCSession</a>，并关联他的 <a href="https://gist.github.com/NatashaTheRobot/6bcbe79afd7e9572edf6" target="_blank" rel="noopener">GitHub Gist</a>。这将对你使用 WatchConnectivity 很有帮助。</p><p>我希望本文能对你有所帮助。如果有帮到你，请不要犹豫，在 Twitter 或者你选择的社交媒体上分享这篇文章，每个分享对我都是帮助。当然，如果你有任何疑问，请随时通过<a href="http://www.codingexplorer.com/contact/" target="_blank" rel="noopener">联系页面</a>或 Twitter <a href="https://twitter.com/CodingExplorer" target="_blank" rel="noopener">@CodingExplorer</a> 与我联系，我会看看我能做些什么。谢谢！</p><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><ul><li><a href="https://itunes.apple.com/us/book/swift-programming-language/id881256329?mt=11&amp;uo=4&amp;at=10lJ3x&amp;ct=blog-SwiftOperatorOverloading" target="_blank" rel="noopener">The Swift Programming Language – Apple Inc.</a></li><li><a href="https://medium.com/swift-programming/facets-of-swift-part-5-custom-operators-1080bc78ccc" target="_blank" rel="noopener">Facets of Swift, Part 5: Custom Operators — Swift Programming — Medium</a></li><li><a href="http://www.kristinathai.com/watchos-2-tutorial-using-application-context-to-transfer-data-watch-connectivity-2/" target="_blank" rel="noopener">watchOS 2 Tutorial: Using application context to transfer data (Watch    Connectivity #2)</a> by <a href="https://twitter.com/kristinathai" target="_blank" rel="noopener">Kristina Thai</a></li><li><a href="https://www.natashatherobot.com/watchconnectivity-application-context/" target="_blank" rel="noopener">WatchConnectivity: Sharing The Latest Data via Application Context</a> by   <a href="https://twitter.com/natashatherobot" target="_blank" rel="noopener">Natasha The Robot</a></li></ul><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文详细讲解了如何通过 Watch Connectivity 的 Application Context 方式进行 watch 和 配对 iPhone 之间共享数据。
    
    </summary>
    
      <category term="codingexplorer" scheme="https://swift.gg/categories/codingexplorer/"/>
    
    
      <category term="教程" scheme="https://swift.gg/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Swift 4 中的字符串</title>
    <link href="https://swift.gg/2018/08/09/swift-4-strings/"/>
    <id>https://swift.gg/2018/08/09/swift-4-strings/</id>
    <published>2018-08-09T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2017/11/swift-4-strings" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-11-27<br>译者：<a href="https://weibo.com/u/5029986118" target="_blank" rel="noopener">东莞大唐和尚</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="undefined">Firecrest</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>这个系列中其他文章：</p><ol><li><a href="https://oleb.net/blog/2014/07/swift-strings/" target="_blank" rel="noopener">Swift 1 中的字符串</a></li><li><a href="https://oleb.net/blog/2016/08/swift-3-strings/" target="_blank" rel="noopener">Swift 3 中的字符串</a></li><li>Swift 4 中的字符串（本文）</li></ol><p>本文节选自我们的新书《高级 Swift 编程》「字符串」这一章。《高级 Swift 编程》新版本已根据 Swift 4 的新特性修订补充，新版现已上市。</p><a id="more"></a><p>所有的现代编程语言都有对 Unicode 编码字符串的支持，但这通常只意味着它们的原生字符串类型可以存储 Unicode 编码的数据——并不意味着所有像获取字符串长度这样简单的操作都会得到「合情合理」的输出结果。</p><p>实际上，大多数语言，以及用这些语言编写的大多数字符串操作代码，都表现出对Unicode固有复杂性的某种程度的否定。这可能会导致一些令人不开心的错误</p><p>Swift 为了字符串的实现支持 Unicode 做出了巨大的努力。Swift 中的 <a href="https://developer.apple.com/documentation/swift/string" target="_blank" rel="noopener"><code>String</code></a>（字符串）是一系列 <a href="https://developer.apple.com/documentation/swift/character" target="_blank" rel="noopener"><code>Character</code></a> 值（字符）的集合。这里的 <code>Character</code> 指的是人们视为单个字母的可读文本，无论这个字母是由多少个 Unicode 编码字符组成。因此，所有对于 <code>Collection</code>（集合）的操作（比如 <code>count</code> 或者 <code>prefix(5)</code>）也同样是按照用户所理解的字母来操作的。</p><p>这样的设计在正确性上无可挑剔，但这是有代价的，主要是人们对它不熟悉。如果你习惯了熟练操作其他编程语言里字符串的整数索引，Swift 的设计会让你觉得笨重不堪，让你感觉到奇怪。为什么 <code>str[999]</code> 不能获得字符串第一千个字符？为什么 <code>str[idx+1]</code> 不能获得下一个字符？为什么不能用类似 <code>&quot;a&quot;...&quot;z&quot;</code> 的方式遍历一个范围的 <code>Character</code>（字符）？</p><p>同时，这样的设计对代码性能也有一定的影响：<code>String</code> 不支持随意获取。换句话说，获得一个任意字符不是 O(1) 的操作——当字符宽度是个变量的时候，字符串只有查看过前面所有字符之后，才会知道第 n 个字符储存在哪里。</p><p>在本章中，我们一起来详细讨论一下 Swift 中字符串的设计，以及一些获得功能和性能最优的技巧。不过，首先我们要先来学习一下 Unicode 编码的专业知识。</p><h2 id="Unicode：抛弃固定宽度"><a href="#Unicode：抛弃固定宽度" class="headerlink" title="Unicode：抛弃固定宽度"></a>Unicode：抛弃固定宽度</h2><p>本来事情很简单。<a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII编码</a> 的字符串用 0 到 127 之间的一系列整数表示。如果使用 8 比特的二进制数组合表示字符，甚至还多余一个比特！由于每个字符的长度固定，所以 ASCII 编码的字符串是可以随机获取的。</p><p>但是，如果不是英语而是其他国家的语言的话，其中的一些字符 ASCII 编码是不够的（其实即使是说英语的英国也有一个”£”符号）。这些语言中的特殊字符大多数都需要超过 7 比特的编码。在 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859" target="_blank" rel="noopener">ISO 8859</a> 标准中，就用多出来的那个比特定义了 16 种超出 ASCII 编码范围的编码，比如第一部分（ISO8859-1）包括了几种西欧语言的编码，第五部分包括了对西里尔字母语言的编码。</p><p>但这样的做法其实还有局限。如果你想根据 ISO8859 标准，用土耳其语写古希腊语的话，你就不走运了，因为你要么得选择第七部分（拉丁语/希腊语）或者第九部分（土耳其语）。而且，总的来说 8 个比特的编码空间无法涵盖多种语言。例如，第六部分（拉丁语/阿拉伯语）就不包含同样使用阿拉伯字母的乌尔都语和波斯语中的很多字符。同时，越南语虽然使用的也是拉丁字母，但是有很多变音组合，这种情况只有替换掉一些原有 ASCII 编码的字母才可能存储到 8 个比特的空间里。而且，这种方法不适用其他很多东亚语言。</p><p>当固定长度编码空间不足以容纳更多字符时，你要做一个选择：要么提高存储空间，要么采用变长编码。起先，<a href="https://en.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a> 被定义为 2 字节固定宽度的格式，现在我们称之为 <a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set" target="_blank" rel="noopener">UCS-2</a>。彼时梦想尚未照进现实，后来人们发现，要实现大部分的功能，不仅 2 字节不够，甚至4个字节都远远不够。</p><p>所以到了今天，Unicode 编码的宽度是可变的，这种可变有两个不同的含义：一是说 Unicode 标量可能由若干个代码块组成；一是说字符可能由若干个标量组成。</p><p>Unicode 编码的数据可以用多种不同宽度的 <a href="https://www.unicode.org/glossary/#code_unit" target="_blank" rel="noopener">代码单元（<em>code unit</em>）</a> 来表示，最常见的是 8 比特（<a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8</a>）和 16（<a href="https://en.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16</a>）比特。UTF-8 编码的一大优势是它向后兼容 8 比特的 ACSCII 编码，这也是它取代 ASCII 成为互联网上最受欢迎的编码的一大原因。在 Swift 里面用 <code>UInt16</code> 和 <code>UInt8</code> 的数值代表UTC-16和UTF-8的代码单元（别名分别是 <a href="https://developer.apple.com/documentation/swift/unicode.utf8/codeunit" target="_blank" rel="noopener"><code>Unicode.UTF16.CodeUnit</code></a> 和 <a href="https://developer.apple.com/documentation/swift/unicode.utf16/codeunit" target="_blank" rel="noopener"><code>Unicode.UTF8.CodeUnit</code></a>）。</p><p>一个 <a href="https://www.unicode.org/glossary/#code_point" target="_blank" rel="noopener"><em>代码点（code point）</em></a> 指的是 Unicode 编码空间中一个单一的值，可能的范围是 <code>0</code> 到 <code>0x10FFFF</code> (换算成十进制就是 1114111)。现在已使用的代码点大约只有 137000 个，所以还有很多空间可以存储各种 emoji。如果你使用的是 <a href="https://en.wikipedia.org/wiki/UTF-32" target="_blank" rel="noopener">UTF-32</a> 编码，那么一个代码点就是一个代码块；如果使用的是 UTF-8 编码，一个代码点可能有 1 到 4 个代码块组成。最初的 256 个 Unicode 编码的代码点对应着 Latin-1 中的字母。</p><p><a href="https://www.unicode.org/glossary/#unicode_scalar_value" target="_blank" rel="noopener">Unicode 标量</a> 跟代码点基本一样，但是也有一点不一样。除开 <code>0xD800-0xDFFF</code> 中间的 2048 个代理代码点（<a href="https://en.wikipedia.org/wiki/UTF-16#U.2BD800_to_U.2BDFFF" target="_blank" rel="noopener"><em>surrogate code points</em></a>）之外，他们都是一样的。这 2048 个代理代码点是 UTF-16 中用作表示配对的前缀或尾缀编码。标量在 Swift 中用 <code>\u{xxxx}</code> 表示，xxxx 代表十进制的数字。所以欧元符号在Swift里可以表示为 <code>&quot;€&quot;</code> 或 <code>&quot;\u{20AC}&quot;</code>。与之对应的 Swift 类型是 <a href="https://developer.apple.com/documentation/swift/unicode.scalar" target="_blank" rel="noopener"><code>Unicode.Scalar</code></a>，一个 <a href="https://developer.apple.com/documentation/swift/uint32" target="_blank" rel="noopener"><code>UInt32</code></a> 数值的封装。</p><p>为了用一个代码单元代表一个 Unicode scalar，你需要一个 21 比特的编码机制（通常会达到 32 比特，比如 UTF-32），但是即便这样你也无法得到一个固定宽度的编码：最终表示字符的时候，Unicode 仍然是一个宽度可变的编码格式。屏幕上显示的一个字符，也就是用户通常认为的一个字符，可能需要多个 scalar 组合而成。Unicode 编码里把这种用户理解的字符称之为 <a href="https://www.unicode.org/glossary/#extended_grapheme_cluster" target="_blank" rel="noopener">（扩展）字位集</a> (extended grapheme cluster)。</p><p>标量组成字位集的规则决定了如何分词。例如，如果你按了一下键盘上的退格键，你觉得你的文本编辑器就应该删除掉一个字位集，即使那个“字符”是由多个 Unicode scalars 组成，且每个 scalar 在计算机内存上还由数量不等的代码块组成的。Swift中用 <code>Character</code> 类型代表字位集。<code>Character</code> 类型可以由任意数量的 Scalars 组成，只要它们形成一个用户看到的字符。在下一部分，我们会看到几个这样的例子。</p><h2 id="字位集和规范对等（Canonical-Equivalence）"><a href="#字位集和规范对等（Canonical-Equivalence）" class="headerlink" title="字位集和规范对等（Canonical Equivalence）"></a>字位集和规范对等（Canonical Equivalence）</h2><h3 id="组合符号"><a href="#组合符号" class="headerlink" title="组合符号"></a>组合符号</h3><p>这里有一个快速了解 <code>String</code> 类型如何处理 Unicode 编码数据的方法：写 “é” 的两种不同方法。Unicode 编码中定义为 <a href="https://codepoints.net/U+00E9" target="_blank" rel="noopener">U+00E9</a>，<em>Latin small letter e with acute</em>（拉丁字母小写 e 加重音符号），单一值。但是你也可以写一个正常的 <a href="https://codepoints.net/U+0065" target="_blank" rel="noopener">小写 e</a>，再跟上一个 <a href="https://codepoints.net/U+0301" target="_blank" rel="noopener">U+0301</a>，<em>combining acute accent</em>（重音符号）。在这两种情况中，显示的都是 é，用户当然会认为这两个 “résumé” 无论使用什么方式打出来的，肯定是相等的，长度也都是 6 个字符。这就是 Unicode 编码规范中所说的 <a href="https://www.unicode.org/glossary/#canonical_equivalent" target="_blank" rel="noopener">规范对等（Canonically Equivalent）</a>。</p><p>而且，在 Swift 语言里，代码行为和用户预期是一致的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> single = <span class="string">"Pok\u&#123;00E9&#125;mon"</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="string">"Poke\u&#123;0301&#125;mon"</span></span><br></pre></td></tr></table></figure><p>它们显示也是完全一致的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(single, double) <span class="comment">// → ("Pokémon", "Pokémon")</span></span><br></pre></td></tr></table></figure><p>它们的字符数也是一样的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">single.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br><span class="line">double.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br></pre></td></tr></table></figure><p>因此，比较起来，它们也是相等的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">single == double <span class="comment">// → true</span></span><br></pre></td></tr></table></figure><p>只有当你通过底层的显示方式查看的时候，才能看到它们的不同之处：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">single.utf16.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br><span class="line">double.utf16.<span class="built_in">count</span> <span class="comment">// → 8</span></span><br></pre></td></tr></table></figure><p>这一点和 Foundation 中的 <a href="https://developer.apple.com/documentation/foundation/nsstring" target="_blank" rel="noopener"><code>NSString</code></a> 对比一下：在 <code>NSString</code> 中，两个字符串是不相等的，它们的 <code>length</code> （很多程序员都用这个方法来确定字符串显示在屏幕上的长度）也是不同的。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nssingle = single <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">nssingle.length <span class="comment">// → 7</span></span><br><span class="line"><span class="keyword">let</span> nsdouble = double <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">nsdouble.length <span class="comment">// → 8</span></span><br><span class="line">nssingle == nsdouble <span class="comment">// → false</span></span><br></pre></td></tr></table></figure><p>这里，<code>==</code> 是定义为比较两个 <code>NSObject</code> ：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension <span class="built_in">NSObject</span>: Equatable &#123;</span><br><span class="line">    <span class="keyword">static</span> func ==(lhs: <span class="built_in">NSObject</span>, rhs: <span class="built_in">NSObject</span>) -&gt; Bool &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.isEqual(rhs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>NSString</code> 中，这个操作会比较两个 UTF-16 代码块。很多其他语言里面的字符串 API 也是这样的。如果你想做的是一个规范比较（cannonical comparison），你必须用 <code>NSString.compare(_:)</code> 。没听说过这个方法？将来遇到一些找不出来的 bug ，以及一些怒气冲冲的国外用户的时候，够你受的。</p><p>当然，只比较代码单元有一个很大的优点是：速度快！在 Swift 里，你也可以通过 <code>utf16</code> 视图来实现这一点：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">single.utf16.elementsEqual(double.utf16) <span class="comment">// → false</span></span><br></pre></td></tr></table></figure><p>为什么 Unicode 编码要支持同一字符的多种展现方式呢？因为 Latin-1 中已经有了类似 é 和 ñ 这样的字母，只有灵活的组合方式才能让长度可变的 Unicode 代码点兼容 Latin-1。</p><p>虽然使用起来会有一些麻烦，但是它使得两种编码之间的转换变得简单快速。</p><p>而且抛弃变音形式也没有什么用，因为这种组合不仅仅只是两个两个的，有时候甚至是多种变音符号组合。例如，约鲁巴语中有一个字符是 ọ́ ，可以用三种不同方式写出来：一个 ó 加一点，一个 ọ 加一个重音，或者一个 o  加一个重音和一点。而且，对最后一种方式来说，两个变音符号的顺序无关紧要！所以，下面几种形式的写法都是相等的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> chars: [<span class="type">Character</span>] = [</span><br><span class="line">    <span class="string">"\u&#123;1ECD&#125;\u&#123;300&#125;"</span>,      <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;F2&#125;\u&#123;323&#125;"</span>,        <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;6F&#125;\u&#123;323&#125;\u&#123;300&#125;"</span>, <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;6F&#125;\u&#123;300&#125;\u&#123;323&#125;"</span>  <span class="comment">// ọ́</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> allEqual = chars.<span class="built_in">dropFirst</span>()</span><br><span class="line">    .all(matching: &#123; $<span class="number">0</span> == chars.first &#125;) <span class="comment">// → true</span></span><br></pre></td></tr></table></figure><p><code>all(matching:)</code> 方法用来检测条件是否对序列中的所有元素都为真：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">all</span><span class="params">(matching predicate: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">try</span> !predicate(element) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，一些变音符号可以加无穷个。这一点，<a href="http://knowyourmeme.com/memes/zalgo" target="_blank" rel="noopener">网上流传很广</a> 的一个颜文字表现得很好：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> zalgo = <span class="string">"s̼̐͗͜o̠̦̤ͯͥ̒ͫ́ͅo̺̪͖̗̽ͩ̃͟ͅn̢͔͖͇͇͉̫̰ͪ͑"</span></span><br><span class="line"></span><br><span class="line">zalgo.<span class="built_in">count</span> <span class="comment">// → 4</span></span><br><span class="line">zalgo.utf16.<span class="built_in">count</span> <span class="comment">// → 36</span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>zalgo.count</code> 返回值是 4（正确的），而 <code>zalgo.utf16.count</code> 返回值是 36。如果你的代码连网上的颜文字都无法正确处理，那它有什么好的？</p><p>Unicode 编码的字位分割规则甚至在你处理纯 ASCII 编码的字符的时候也有影响，回车 <a href="https://codepoints.net/U+000D" target="_blank" rel="noopener">CR</a> 和 换行 <a href="https://codepoints.net/U+000A" target="_blank" rel="noopener">LF</a> 这一个字符对在 Windows 系统上通常表示新开一行，但它们其实只是一个字位：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CR+LF is a single Character</span></span><br><span class="line"><span class="keyword">let</span> crlf = <span class="string">"\r\n"</span></span><br><span class="line">crlf.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><h3 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h3><p>许多其他编程语言处理包含 emoji 的字符串的时候会让人意外。许多 emoji 的 Unicode 标量无法存储在一个 UTF-16 的代码单元里面。有些语言（例如 Java 或者 C#）把字符串当做 UTF-16 代码块的集合，这些语言定义<a href="https://emojipedia.org/face-with-tears-of-joy/" target="_blank" rel="noopener">“😂”</a>为两个 “字符” 的长度。Swift 处理上述情况更为合理：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oneEmoji = <span class="string">"😂"</span> <span class="comment">// U+1F602</span></span><br><span class="line">oneEmoji.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，重要的是字符串如何展现给程序的，<strong>不是</strong>字符串在内存中是如何存储的。对于非 ASCII 的字符串，Swift 内部用的是 UTF-16 的编码，这只是内部的实现细节。公共 API 还是基于字位集（grapheme cluster）的。</p></blockquote><p>有些 emoji 由多个标量组成。emoji 中的国旗是由两个对应 ISO 国家代码的<a href="https://en.wikipedia.org/wiki/Regional_Indicator_Symbol" target="_blank" rel="noopener">地区标识符号（reginal indicator symbols）</a>组成的。Swift 里将一个国旗视为一个 <code>Character</code> ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flags = <span class="string">"🇧🇷🇳🇿"</span></span><br><span class="line">flags.<span class="built_in">count</span> <span class="comment">// → 2</span></span><br></pre></td></tr></table></figure><p>要检查一个字符串由几个 Unicode 标量组成，需要使用 <a href="https://developer.apple.com/documentation/swift/string/1539070-unicodescalars" target="_blank" rel="noopener"><code>unicodeScalars</code></a> 视图。这里，我们将 scalar 的值格式化为十进制的数字，这是代码点的普遍格式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">flags.unicodeScalars.<span class="built_in">map</span> &#123;</span><br><span class="line">    <span class="string">"U+<span class="subst">\(String($<span class="number">0</span>.value, radix: <span class="number">16</span>, uppercase: <span class="literal">true</span>)</span>)"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// → ["U+1F1E7", "U+1F1F7", "U+1F1F3", "U+1F1FF"]</span></span><br></pre></td></tr></table></figure><p>肤色是由一个基础的角色符号（例如👧）加上一个肤色修饰符（例如🏽）组成的，Swift 里是这么处理的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> skinTone = <span class="string">"👧🏽"</span> <span class="comment">// 👧 + 🏽</span></span><br><span class="line">skinTone.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><p>这次我们用 Foundation API 里面的 <a href="https://oleb.net/blog/2016/01/icu-text-transforms/" target="_blank" rel="noopener">ICU string transform</a> 把 Unicode 标量转换成官方的 Unicode 名称：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StringTransform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> toUnicodeName = <span class="type">StringTransform</span>(rawValue: <span class="string">"Any-Name"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Unicode</span>.<span class="title">Scalar</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The scalar’s Unicode name, e.g. "LATIN CAPITAL LETTER A".</span></span><br><span class="line">    <span class="keyword">var</span> unicodeName: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// Force-unwrapping is safe because this transform always succeeds</span></span><br><span class="line">        <span class="keyword">let</span> name = <span class="type">String</span>(<span class="keyword">self</span>).applyingTransform(.toUnicodeName,</span><br><span class="line">            <span class="built_in">reverse</span>: <span class="literal">false</span>)!</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The string transform returns the name wrapped in "\\N&#123;...&#125;". Remove those.</span></span><br><span class="line">        <span class="keyword">let</span> prefixPattern = <span class="string">"\\N&#123;"</span></span><br><span class="line">        <span class="keyword">let</span> suffixPattern = <span class="string">"&#125;"</span></span><br><span class="line">        <span class="keyword">let</span> prefixLength = name.hasPrefix(prefixPattern) ? prefixPattern.<span class="built_in">count</span> : <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> suffixLength = name.hasSuffix(suffixPattern) ? suffixPattern.<span class="built_in">count</span> : <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(name.<span class="built_in">dropFirst</span>(prefixLength).<span class="built_in">dropLast</span>(suffixLength))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skinTone.unicodeScalars.<span class="built_in">map</span> &#123; $<span class="number">0</span>.unicodeName &#125;</span><br><span class="line"><span class="comment">// → ["GIRL", "EMOJI MODIFIER FITZPATRICK TYPE-4"]</span></span><br></pre></td></tr></table></figure><p>这段代码里面最重要的是对 <code>applyingTransform(.toUnicodeName,...)</code> 的调用。其他的代码只是把转换方法返回的名字清理了一下，移除了括号。这段代码很保守：先是检查了字符串是否符合期望的格式，然后计算了从头到尾的字符数。如果将来转换方法返回的名字格式发生了变化，最好输出原字符串，而不是移除多余字符后的字符串。</p><p>注意我们是如何使用标准的集合（<code>Collection</code>）方法 <code>dropFirst</code> 和 <code>droplast</code> 进行移除操作的。如果你想对字符串进行操作，但是又不想对字符串进行手动索引，这就是一个很好的例子。这个方法同样也很高效，因为 <code>dropFisrt</code> 和 <code>dropLast</code> 方法返回的是 <code>Substring</code> 值，它们只是原字符串的一部分。在我们最后一步创建一个新的 <code>String</code> 字符串，赋值为这个 substring 之前，它是不占用新的内存的。关于这一点，我们在这一章的后面还有很多东西会涉及到。</p><p>Emoji 里面对家庭和夫妻的表示（例如 <a href="https://emojipedia.org/family-man-woman-girl-boy/" target="_blank" rel="noopener">👨‍👩‍👧‍👦</a> 和 <a href="https://emojipedia.org/couple-with-heart-woman-woman/" target="_blank" rel="noopener">👩‍❤️‍👩</a>）是 Unicode 编码标准面临的又一个挑战。由于性别以及人数的可能组合太多，为每种可能的组合都做一个代码点肯定会有问题。再加上每个人物角色的肤色的问题，这样做几乎不可行。Unicode 编码是这样解决这个问题的，它将这种 emoji 定义为一系列由零宽度连接符（<a href="https://codepoints.net/U+200D" target="_blank" rel="noopener"><em>zero-width joiner</em></a>）联系起来的 emoji 。这样下来，这个家庭 👨‍👩‍👧‍👦 emoji 其实就是 <a href="https://emojipedia.org/man/" target="_blank" rel="noopener"><em>man</em> 👨</a> + ZWJ + <a href="https://emojipedia.org/woman/" target="_blank" rel="noopener"><em>woman</em> 👩</a> + ZWJ + <a href="https://emojipedia.org/girl/" target="_blank" rel="noopener"><em>girl</em> 👧</a> + ZWJ + <a href="https://emojipedia.org/boy/" target="_blank" rel="noopener"><em>boy</em> 👦</a>。而零宽度连接符的作用就是让操作系统知道这个 emoji 应该只是一个字素。</p><p>我们可以验证一下到底是不是这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> family1 = <span class="string">"👨‍👩‍👧‍👦"</span></span><br><span class="line"><span class="keyword">let</span> family2 = <span class="string">"👨\u&#123;200D&#125;👩\u&#123;200D&#125;👧\u&#123;200D&#125;👦"</span></span><br><span class="line">family1 == family2 <span class="comment">// → true</span></span><br></pre></td></tr></table></figure><p>在 Swift 里，这样一个 emoji 也同样被认为是一个字符 <code>Character</code> ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">family1.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">family2.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><p>2016年新引入的职业类型 emoji 也是这种情况。例如女性消防队员 <a href="https://emojipedia.org/female-firefighter/" target="_blank" rel="noopener">👩‍🚒</a> 就是 <a href="https://emojipedia.org/woman/" target="_blank" rel="noopener"><em>woman</em> 👩</a> + ZWJ + <a href="https://emojipedia.org/fire-engine/" target="_blank" rel="noopener"><em>fire engine</em> 🚒</a>。男性医生就是 <a href="https://emojipedia.org/man/" target="_blank" rel="noopener"><em>man</em> 👨</a> + ZWJ + <a href="https://emojipedia.org/staff-of-aesculapius/" target="_blank" rel="noopener"><em>staff of aesculapius</em> ⚕</a>（译者注：阿斯克勒庇厄斯，是古希腊神话中的医神，一条蛇绕着一个柱子指医疗相关职业）。</p><p>将这些一系列零宽度连接符连接起来的 emoji 渲染为一个字素是操作系统的工作。2017年，Apple 的操作系统表示支持 Unicode 编码标准下的 RGI 系列（“<a href="https://unicode.org/emoji/charts/emoji-zwj-sequences.html" target="_blank" rel="noopener">recommended for general interchange</a>”）。如果没有字位可以正确表示这个序列，那文本渲染系统会回退，显示为每个单个的字素。</p><p>注意这里又可能会导致一个理解偏差，即用户所认为的字符和 Swift 所认为的字位集之间的偏差。我们上面所有的例子都是担心编程语言会把字符<strong>数多了</strong>，但这里正好相反。举例来说，上面那个家庭的 emoji 里面涉及到的肤色 emoji 还未被收录到 RGI 集合里面。但尽管大多数操作系统都把这系列 emoji 渲染成多个字素，但 Swift 仍旧只把它们看做一个字符，因为 Unicode 编码的分词规则和渲染无关：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Family with skin tones is rendered as multiple glyphs</span></span><br><span class="line"><span class="comment">// on most platforms in 2017</span></span><br><span class="line"><span class="keyword">let</span> family3 = <span class="string">"👱🏾\u&#123;200D&#125;👩🏽\u&#123;200D&#125;👧🏿\u&#123;200D&#125;👦🏻"</span> <span class="comment">// → "👱🏾‍👩🏽‍👧🏿‍👦🏻"</span></span><br><span class="line"><span class="comment">// But Swift still counts it as a single Character</span></span><br><span class="line">family3.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.emojipedia.org/diverse-emoji-families-come-to-windows/" target="_blank" rel="noopener">Windows 系统已经可以</a>把这些 emoji 渲染为一个字素了，其他操作系统厂家肯定也会尽快支持。但是，有一点是不变的：无论一个字符串的 API 如何精心设计，都无法完美支持每一个细小的案例，因为文本太复杂了。</p><blockquote><p>过去 Swift 很难跟得上 Unicode 编码标准改变的步伐。Swift 3 渲染肤色和零宽度连接符系列 emoji 是错误的，因为当时的分词算法是根据上一个版本的 Unicode 编码标准。自 Swift 4 起，Swift 开始启用操作系统的 <a href="http://site.icu-project.org" target="_blank" rel="noopener">ICU</a> 库。因此，只要用户更新他们的操作系统，你的程序就会采用最新的 Unicode 编码标准。硬币的另一面是，你开发中看到的和用户看到的东西可能是不一样的。</p></blockquote><p>编程语言如果全面考虑 Unicode 编码复杂性的话，在处理文本的时候会引发很多问题。上面这么多例子我们只是谈及其中的一个问题：字符串的长度。如果一个编程语言不是按字素集处理字符串，而这个字符串又包含很多字符序列的话，这时候一个简简单单的反序输出字符串的操作会变得多么复杂。</p><p>这不是个新问题，但是 emoji 的流行使得糟糕的文本处理方法造成的问题更容易浮出表面，即使你的用户群大部分是说英语的。而且，错误的级别也大大提升：十年前，弄错一个变音符号的字母可能只会造成 1 个字符数的误差，现在如果弄错了 emoji 的话很可能就是 10 个字符数的误差。例如，一个四人家庭的 emoji 在 UTF-16 编码下是 11 个字符，在 UTF-8 编码下就是 25 个字符了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">family1.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">family1.utf16.<span class="built_in">count</span> <span class="comment">// → 11</span></span><br><span class="line">family1.utf8.<span class="built_in">count</span> <span class="comment">// → 25</span></span><br></pre></td></tr></table></figure><p>也不是说其他编程语言就完全没有符合 Unicode 编码标准的 API，大部分还是有的。例如，<code>NSString</code> 就有一个 <a href="https://developer.apple.com/documentation/foundation/nsstring/1416774-enumeratesubstrings" target="_blank" rel="noopener"><code>enumerateSubstrings</code></a> 的方法可以按照字位集遍历一个字符串。但是缺省设置很重要，而 Swift 的原则就是缺省情况下，就按正确的方式来做。而且如果你需要低一个抽象级别去看，<code>String</code> 也提供不同的视图，然你可以直接从 Unicode 标量或者代码块的级别操作。下面的内容里我们还会涉及到这一点。</p><h2 id="字符串和集合"><a href="#字符串和集合" class="headerlink" title="字符串和集合"></a>字符串和集合</h2><p>我们已经看到，<code>String</code> 是一个 <code>Character</code> 值的集合。在 Swift 语言发展的前三年里，<code>String</code> 这个类在遵守还是不遵守 <code>Collection</code> 集合协议这个问题上左右摇摆了几次。坚持不要遵守集合协议的人认为，如果遵守的话，程序员会认为所有通用的集合处理算法用在字符串上是绝对安全的，也绝对符合 Unicode 编码标准的，但是显然有一些特例存在。</p><p>举一个简单的例子，两个集合相加，得到的新的集合的长度肯定是两个子集合长度的和。但是在字符串中，如果第一个字符串的后缀和第二个字符串的前缀形成了一个字位集，长度就会有变化了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flagLetterJ = <span class="string">"🇯"</span></span><br><span class="line"><span class="keyword">let</span> flagLetterP = <span class="string">"🇵"</span></span><br><span class="line"><span class="keyword">let</span> flag = flagLetterJ + flagLetterP <span class="comment">// → "🇯🇵"</span></span><br><span class="line">flag.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">flag.<span class="built_in">count</span> == flagLetterJ.<span class="built_in">count</span> + flagLetterP.<span class="built_in">count</span> <span class="comment">// → false</span></span><br></pre></td></tr></table></figure><p>出于这种考虑，在 Swift 2 和 Swift 3 中，<code>String</code> 并没有被算作一个集合。这个特性是作为 <code>String</code> 的一个 <a href="https://developer.apple.com/documentation/swift/string/1540072-characters" target="_blank" rel="noopener"><code>characters</code></a> 视图存在的，和其他几个集合视图一样：<a href="https://developer.apple.com/documentation/swift/string/1539070-unicodescalars" target="_blank" rel="noopener"><code>unicodeScalars</code></a>，<a href="https://developer.apple.com/documentation/swift/string/1539703-utf8" target="_blank" rel="noopener"><code>utf8</code></a> 和 <a href="https://developer.apple.com/documentation/swift/string/1541301-utf16" target="_blank" rel="noopener"><code>utf16</code></a>。选择一个特定的视图，就相当于让程序员转换到另一种“处理集合”的模式，相应的，程序员就必须考虑到这种模式下可能产生的问题。</p><p>但是，在实际应用中，这个改变提升了学习成本，降低了可用性；单单为了保证在那些极端个例中的正确性（其实在真实应用中很少遇到，除非你写的是个文本编辑器的应用）做出这样的改变太不值得了。因此，在 Swift 4 中，<code>String</code> 再次成了一个集合。<code>characters</code> 视图还在，但是只是为了向后兼容 Swift 3。</p><h3 id="双向获取，而非任意获取"><a href="#双向获取，而非任意获取" class="headerlink" title="双向获取，而非任意获取"></a>双向获取，而非任意获取</h3><p>然而，<code>String</code> 并<strong>不是</strong>一个可以任意获取的集合，原因的话，上一部分的几个例子已经展现的很清楚。一个字符到底是第几个字符取决于它前面有多少个 Unicode scalar，这样的情况下，根本不可能实现任意获取。由于这个原因，Swift 里面的字符串遵守双向获取（<a href="https://developer.apple.com/documentation/swift/bidirectionalcollection" target="_blank" rel="noopener"><code>BidirectionalCollection</code></a>）规则。可以从字符串的两头数，代码会根据相邻字符的组成，跳过正确数量的字节。但是，每次访问只能上移或者下移一个字符。</p><p>在写处理字符串的代码的时候，要考虑到这种方式的操作对代码性能的影响。那些依靠任意获取来保证代码性能的算法对 Unicode 编码的字符串并不合适。我们看一个例子，我们要获取一个字符串所有 prefix 的列表。我们只需要得到一个从零到字符串长度的一系列整数，然后根据每个长度的整数在字符串中找到对应长度的 prefix：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allPrefixes1: [<span class="type">Substring</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>...<span class="keyword">self</span>.<span class="built_in">count</span>).<span class="built_in">map</span>(<span class="keyword">self</span>.<span class="keyword">prefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="string">"Hello"</span></span><br><span class="line">hello.allPrefixes1 <span class="comment">// → ["", "H", "He", "Hel", "Hell", "Hello"]</span></span><br></pre></td></tr></table></figure><p>尽管这段代码看起来很简单，但是运行性能很低。它先是遍历了字符串一次，计算出字符串的长度，这还 OK。但是每次对 <a href="https://developer.apple.com/documentation/swift/substring/2893985-prefix" target="_blank" rel="noopener"><code>prefix</code></a> 进行 n+1 的调用都是一次 <em>O(n)</em> 操作，因为 <code>prefix</code> 方法需要从字符串的开头往后找出所需数量的字符。而在一个线性运算里进行另一个线性运算就意味着算法已经成了 <em>O(n2)</em> ——随着字符串长度的增加，算法所需的时间是呈指数级增长的。</p><p>如果可能的话，一个高性能的算法应该是遍历字符串一次，然后通过对字符串索引的操作得到想要的子字符串。下面是相同算法的另一个版本：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allPrefixes2: [<span class="type">Substring</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">""</span>] + <span class="keyword">self</span>.<span class="built_in">indices</span>.<span class="built_in">map</span> &#123; index <span class="keyword">in</span> <span class="keyword">self</span>[...index] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello.allPrefixes2 <span class="comment">// → ["", "H", "He", "Hel", "Hell", "Hello"]</span></span><br></pre></td></tr></table></figure><p>这段代码只需要遍历字符串一次，得到字符串的索引（<a href="https://developer.apple.com/documentation/swift/bidirectionalcollection/1785188-indices" target="_blank" rel="noopener"><code>indices</code></a>）集合。一旦完成之后，之后再 <code>map</code> 内的操作就只是 <em>O(1)</em>。整个算法也只是 <em>O(n)</em>。</p><h3 id="范围可替换，不可变"><a href="#范围可替换，不可变" class="headerlink" title="范围可替换，不可变"></a>范围可替换，不可变</h3><p><code>String</code> 还遵从于 <a href="https://developer.apple.com/documentation/swift/rangereplaceablecollection" target="_blank" rel="noopener"><code>RangeReplaceableCollection</code></a> （范围可替换）的集合操作。也就是说，你可以先按字符串索引的形式定义出一个范围，然后通过调用 <a href="https://developer.apple.com/documentation/swift/string/1641462-replacesubrange" target="_blank" rel="noopener"><code>replaceSubrange</code></a> （替换子范围）方法，替换掉字符串中的一些字符。这里有一个例子。替换的字符串可以有不同的长度，甚至还可以是空的（这时候就相当于调用 <a href="https://developer.apple.com/documentation/swift/string/2893740-removesubrange" target="_blank" rel="noopener"><code>removeSubrange</code></a> 方法了）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello, world!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> comma = greeting.index(of: <span class="string">","</span>) &#123;</span><br><span class="line">    greeting[..&lt;comma] <span class="comment">// → "Hello"</span></span><br><span class="line">    greeting.replaceSubrange(comma..., with: <span class="string">" again."</span>)</span><br><span class="line">&#125;</span><br><span class="line">greeting <span class="comment">// → "Hello again."</span></span><br></pre></td></tr></table></figure><p>同样，这里也要注意一个问题，如果替换的字符串和原字符串中相邻的字符形成了新的字位集，那结果可能就会有点出人意料了。</p><p>字符串无法提供的一个类集合特性是：<a href="https://developer.apple.com/documentation/swift/mutablecollection" target="_blank" rel="noopener"><code>MutableCollection</code></a>。该协议给集合除 <code>get</code> 之外，添加了一个通过下标进行单一元素 <code>set</code> 的特性。这并不是说字符串是不可变的——我们上面已经看到了，有好几种变化的方法。你无法完成的是使用下标操作符替换其中的一个字符。许多人直觉认为用下标操作符替换一个字符是即时发生的，就像数组 <a href="https://developer.apple.com/documentation/swift/array" target="_blank" rel="noopener"><code>Array</code></a> 里面的替换一样。但是，因为字符串里的字符长度是不定的，所以替换一个字符的时间和字符串的长度呈线性关系：替换一个元素的宽度会把其他所有元素在内存中的位置重新洗牌。而且，替换元素索引后面的元素索引在洗牌之后都变了，这也是跟人们的直觉相违背的。出于这些原因，你必须使用 <code>replaceSubrange</code> 进行替换，即使你变化只是一个元素。</p><h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h2><p>大多数编程语言都是用整数作为字符串的下标，例如 <code>str[5]</code> 就会返回 <code>str</code> 的第六个“字符”（无论这个语言定义的“字符”是什么）。Swift 却不允许这样。为什么呢？原因可能你已经听了很多遍了：下标应该是使用固定时间的(无论是直觉上，还是根据集合协议)，但是查询第 n 个“字符”的操作必须查询它前面所有的字节。</p><p><a href="https://developer.apple.com/documentation/swift/string.index" target="_blank" rel="noopener">字符串索引（<code>String.Index</code>）</a> 是字符串及其视图使用的索引类型。它是个不透明值（opaque value，内部使用的值，开发者一般不直接使用），本质上存储的是从字符串开头算起的字节偏移量。如果你想计算第 n 个字符的索引，它还是一个 <em>O(n)</em> 的操作，而且你还是必须从字符串的开头开始算起，但是一旦你有了一个正确的索引之后，对这个字符串进行下标操作就只需要 <em>O(1)</em> 次了。关键是，找到现有索引后面的元素的索引的操作也会变得很快，因为你只需要从已有索引字节后面开始算起了——没有必要从字符串开头开始了。这也是为什么有序（向前或是向后）访问字符串里的字符效率很高的原因。</p><p>字符串索引操作的依据跟你在其他集合里使用的所有 API 一样。因为我们最常用的集合：数组，使用的是整数索引，我们通常使用简单的算术来操作，所以有一点很容易忘记： <a href="https://developer.apple.com/documentation/swift/string/1782583-index" target="_blank" rel="noopener"><code>index(after:)</code></a> 方法返回的是下一个字符的索引：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"abcdef"</span></span><br><span class="line"><span class="keyword">let</span> second = s.index(after: s.startIndex)</span><br><span class="line">s[second] <span class="comment">// → "b"</span></span><br></pre></td></tr></table></figure><p>使用 <a href="https://developer.apple.com/documentation/swift/string/1786175-index" target="_blank" rel="noopener"><code>index(_:offsetBy:)</code></a>方法，你可以通过一次操作，自动地访问多个字符，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Advance 4 more characters</span></span><br><span class="line"><span class="keyword">let</span> sixth = s.index(second, offsetBy: <span class="number">4</span>)</span><br><span class="line">s[sixth] <span class="comment">// → "f"</span></span><br></pre></td></tr></table></figure><p>如果可能超出字符串末尾，你可以加一个 <a href="https://developer.apple.com/documentation/swift/anybidirectionalcollection/1781464-index" target="_blank" rel="noopener"><code>limitedBy:</code></a> 参数。如果在访问到目标索引之前到达了字符串的末尾，这个方法会返回一个 <code>nil</code> 值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> safeIdx = s.index(s.startIndex, offsetBy: <span class="number">400</span>, limitedBy: s.endIndex)</span><br><span class="line">safeIdx <span class="comment">// → nil</span></span><br></pre></td></tr></table></figure><p>比起简单的整数索引，这无疑使用了更多的代码。<strong>这是 Swift 故意的。</strong>如果 Swift 允许对字符串进行整数索引，那不小心写出性能烂到爆的代码（比如在一个循环中使用整数的下标操作）的诱惑太大了。</p><p>然而，对一个习惯于处理固定宽度字符的人来说，刚开始使用 Swift 处理字符串会有些挑战——没有了整数索引怎么搞？而且确实，一些看起来简单的任务处理起来还得大动干戈，比如提取字符串的前四个字符：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">s[..&lt;s.index(s.startIndex, offsetBy: <span class="number">4</span>)] <span class="comment">// → "abcd"</span></span><br></pre></td></tr></table></figure><p>不过谢天谢地，你可以使用集合的接口来获取字符串，这意味着许多适用于数组的方法同样也适用于字符串。比如上面那个例子，如果使用 <code>prefix</code> 方法就简单得多了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">s.<span class="keyword">prefix</span>(<span class="number">4</span>) <span class="comment">// → "abcd"</span></span><br></pre></td></tr></table></figure><p>（注意，上面的几个方法返回的都是子字符串 <a href="https://developer.apple.com/documentation/swift/substring" target="_blank" rel="noopener"><code>Substring</code></a>，你可以使用一个 <code>String.init</code> 把它转换为字符串。关于这一部分，我们下一部分会讲更多。）</p><p>没有整数索引，循环访问字符串里的字符也很简单，用 <code>for</code> 循环。如果你想按顺序排列，使用 <a href="https://developer.apple.com/documentation/swift/sequence/1641222-enumerated" target="_blank" rel="noopener"><code>enumerated()</code></a>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i, <span class="built_in">c</span>) <span class="keyword">in</span> s.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(i)</span>: <span class="subst">\(<span class="built_in">c</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者如果你想找到一个特定的字符，你可以使用 <a href="https://developer.apple.com/documentation/swift/string/2893264-index" target="_blank" rel="noopener"><code>index(of:)</code></a>:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">"Hello!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> idx = hello.index(of: <span class="string">"!"</span>) &#123;</span><br><span class="line">    hello.insert(contentsOf: <span class="string">", world"</span>, at: idx)</span><br><span class="line">&#125;</span><br><span class="line">hello <span class="comment">// → "Hello, world!"</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swift/string/2893571-insert" target="_blank" rel="noopener"><code>insert(contentsOf:at:)</code></a> 方法可以在指定索引前插入相同类型的另一个集合（比如说字符串里的字符）。并不一定是另一个字符串，你可以很容易地把一个字符的数组插入到一个字符串里。</p><h2 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h2><p>和其他的集合一样，字符串有一个特定的切片类型或者说子序列类型（<a href="https://developer.apple.com/documentation/swift/collection/1641276-subsequence" target="_blank" rel="noopener"><code>SubSequence</code></a>）：子字符串（<a href="https://developer.apple.com/documentation/swift/substring" target="_blank" rel="noopener"><code>Substring</code></a>）。子字符串就像是一个数组切片（<a href="https://developer.apple.com/documentation/swift/arrayslice" target="_blank" rel="noopener"><code>ArraySlice</code></a>）：它是原字符串的一个视图，起始索引和结束索引不同。子字符串共享原字符串的文本存储空间。这是一个很大的优势，对一个字符串进行切片操作不占用内存空间。在下面的例子中，创建<code>firstWord</code>变量不占用内存：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence = <span class="string">"The quick brown fox jumped over the lazy dog."</span></span><br><span class="line"><span class="keyword">let</span> firstSpace = sentence.index(of: <span class="string">" "</span>) ?? sentence.endIndex</span><br><span class="line"><span class="keyword">let</span> firstWord = sentence[..&lt;firstSpace] <span class="comment">// → "The"</span></span><br><span class="line">type(of: firstWord) <span class="comment">// → Substring.Type</span></span><br></pre></td></tr></table></figure><p>切片操作不占用内存意义重大，特别是在一个循环中，比如你要通过循环访问整个字符串（可能会很长）来提取其中的字符。比如在文本中找到一个单词使用的次数，比如解析一个 CSV 文件。这里有一个非常有用的字符串处理操作：split。<code>split</code> 是 <code>Collection</code> 集合中定义的一个方法，它会返回一个子序列的数组（即 <code>[Substring]</code> ）。它最常见的变种就像是这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(separator: Element, maxSplits: Int = Int.<span class="built_in">max</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        omittingEmptySubsequences: Bool = <span class="literal">true</span>)</span></span> -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以这样使用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> poem = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    Over the wintry</span></span><br><span class="line"><span class="string">    forest, winds howl in rage</span></span><br><span class="line"><span class="string">    with no leaves to blow.</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line"><span class="keyword">let</span> lines = poem.<span class="built_in">split</span>(separator: <span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">// → ["Over the wintry", "forest, winds howl in rage", "with no leaves to blow."]</span></span><br><span class="line">type(of: lines) <span class="comment">// → Array&lt;Substring&gt;.Type</span></span><br></pre></td></tr></table></figure><p>这个跟 <code>String</code> 继承自 <code>NSString</code> 的 <a href="https://developer.apple.com/documentation/swift/stringprotocol/2923413-components" target="_blank" rel="noopener"><code>components(separatedBy:)</code></a> 方法的功能类似，你还可以用一些额外设置比如是否抛弃空的组件。而且在这个操作中，所有输入字符串都没有创建新的复制。因为还有其他<code>split</code>方法的变种可以完成操作，除了比较字符以外，<code>split</code> 还可以完成更多的事情。下面这个例子是文本换行算法的一个原始的实现，最后的代码计算了行的长度：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">wrapped</span><span class="params">(after: Int = <span class="number">70</span>)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> lines = <span class="keyword">self</span>.<span class="built_in">split</span>(omittingEmptySubsequences: <span class="literal">false</span>) &#123;</span><br><span class="line">            character <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> character &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"\n"</span>, <span class="string">" "</span> <span class="keyword">where</span> i &gt;= after:</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lines.joined(separator: <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sentence.wrapped(after: <span class="number">15</span>)</span><br><span class="line"><span class="comment">// → "The quick brown\nfox jumped over\nthe lazy dog."</span></span><br></pre></td></tr></table></figure><p>或者，考虑写另外一个版本，可以拿到一个包含多个分隔符的序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">split</span>&lt;S: Sequence&gt;<span class="params">(separators: S)</span></span> -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">        <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">S</span>.<span class="type">Element</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">split</span> &#123; separators.<span class="built_in">contains</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，你还可以这么写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="string">"Hello, world!"</span>.<span class="built_in">split</span>(separators: <span class="string">",! "</span>) <span class="comment">// → ["Hello", "world"]</span></span><br></pre></td></tr></table></figure><h3 id="字符串协议-StringProtocol"><a href="#字符串协议-StringProtocol" class="headerlink" title="字符串协议 StringProtocol"></a>字符串协议 <code>StringProtocol</code></h3><p><code>Substring</code> 和 <code>String</code> 几乎有着相同的接口，因为两种类型都遵守一个共同的字符串协议（<a href="https://developer.apple.com/documentation/swift/stringprotocol" target="_blank" rel="noopener"><code>StringProtocol</code></a>）。因为几乎所有的字符串API 都是在 <a href="https://developer.apple.com/documentation/swift/stringprotocol" target="_blank" rel="noopener"><code>StringProtocol</code></a> 中定义的，所以操作 <code>Substring</code> 跟操作 <code>String</code> 没有什么大的区别。但是，在有些情况下，你还必须把子字符串转换为字符串的类型；就像所有的切片（slice）一样，子字符串只是为了短时间内的存储，为了防止一次操作定义太多个复制。如果操作结束之后，你还想保留结果，将数据传到另一个子系统里，你应该创建一个新的字符串。你可以用一个 <code>Substring</code> 的值初始化一个 <code>String</code>，就像我们在这个例子中做的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastWord</span><span class="params">(<span class="keyword">in</span> input: String)</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="comment">// Process the input, working on substrings</span></span><br><span class="line">    <span class="keyword">let</span> words = input.<span class="built_in">split</span>(separators: [<span class="string">","</span>, <span class="string">" "</span>])</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> lastWord = words.last <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="comment">// Convert to String for return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(lastWord)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lastWord(<span class="keyword">in</span>: <span class="string">"one, two, three, four, five"</span>) <span class="comment">// → "five"</span></span><br></pre></td></tr></table></figure><p>不建议子字符串长期存储背后的原因是子字符串一直关联着原字符串。即使一个超长字符串的子字符串只有一个字符，只要子字符串还在使用，那原先的字符串就还会在内存里，即使原字符串的生命周期已经结束。因此，长期存储子字符串可能导致内存泄漏，因为有时候原字符串已经无法访问了，但是还在占用内存。</p><p>操作过程中使用子字符串，操作结束的时候才创建新的字符串，通过这种方式，我们把占用内存的动作推迟到了最后一刻，而且保证了我们只会创建必要的字符串。在上面的例子当中，我们把整个字符串（可能会很长）分成了一个个的子字符串，但是在最后只是创建了一个很短的字符串。（例子中的算法可能效率不是那么高，暂时忽略一下；从后先前找到第一个分隔符可能是个更好的方法。）</p><p>遇到只接受 <code>Substring</code> 类型的方法，但是你想传递一个 <code>String</code> 的类型，这种情况很少见（大部分的方法都接受 <code>String</code> 类型或者接受所有符合字符串协议的类型），但是如果你确实需要传递一个 <code>String</code> 的类型，最便捷的方法是使用范围操作符：<code>...</code>（range operator），不限定范围：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子字符串和原字符串的起始和结束的索引完全一致 </span></span><br><span class="line"><span class="keyword">let</span> substring = sentence[...]</span><br></pre></td></tr></table></figure><hr><p><code>Substring</code> 类型是 Swift 4 中的新特性。在 Swift 3 中，<code>String.CharacterView</code> 是自己独有的切片类型（slice type）。这么做的优势是用户只需要了解一种类型，但这也意味这如果存储一个子字符串，整个原字符串也会占据内存，即使它正常情况下应该已经被释放了。Swift 4 损失了一点便捷，换来的是的方便的切片操作和可预测的内存使用。</p><p>要求 <code>Substring</code> 到 <code>String</code> 的转换必须明确写出，Swift 团队认为这没那么烦人。如果实际应用中大家都觉得问题很大，他们也会考虑直接在编译器中写一个 <code>Substring</code> 和 <code>String</code> 之间的<a href="https://github.com/apple/swift/blob/master/docs/StringManifesto.md#substrings" target="_blank" rel="noopener">模糊子类型关系（implicit subtype relationship）</a>，就像 <code>Int</code> 是 <code>Optional&lt;Int&gt;</code> 的子类型一样。这样你就可以随意传递 <code>Substring</code> 类型，编译器会帮你完成类型转换。</p><hr><p>你可能会倾向于充分利用字符串协议，把你所有的 API 写成接受所有遵守字符串协议的实例，而不是仅仅接受 <code>String</code> 字符串。但 Swift 团队的建议是，<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170626/037828.html" target="_blank" rel="noopener">别这样</a>：</p><blockquote><p>总的来说，我们建议继续使用字符串变量。 使用字符串变量，大多数的 API 都会比把它们写成通用类型（这个操作本身就有一些代价）更加简洁清晰，用户在必要的时候进行一些转换并不需要花费很大的精力。</p></blockquote><p>一些 API 极有可能和子字符串一起使用，同时无法泛化到适用于整个序列 <code>Sequence</code> 或集合 <code>Collection</code> 的级别，这些 API 可以不受这条规则的限制。一个例子就是标准库中的 <a href="https://developer.apple.com/documentation/swift/sequence/1641243-joined" target="_blank" rel="noopener"><code>joined</code></a> 方法。Swift 4 中，针对遵守字符串协议的元素组成的序列（<code>Sequence</code>）添加了一个重载（<code>overload</code>）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">StringProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 两个元素中间加上一个特定分隔符后</span></span><br><span class="line">    <span class="comment">/// 合并序列中所有元素，返回一个新的字符串</span></span><br><span class="line">    <span class="comment">/// Returns a new string by concatenating the elements of the sequence,</span></span><br><span class="line">    <span class="comment">/// adding the given separator between each element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">joined</span><span class="params">(separator: String = <span class="string">""</span>)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，你就可以直接对一个子字符串的数组调用 <code>joined</code> 方法了，没必要遍历一次数组并且把每个子字符串转换为新的字符串。这样，一切都很方便快速。</p><p>数值类型初始器（number type initializer）可以将字符串转换为一个数字。在 Swift 4 中，它也接受遵守字符串协议的值。如果你要处理一个子字符串的数组的话，这个方法很顺手：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> commaSeparatedNumbers = <span class="string">"1,2,3,4,5"</span></span><br><span class="line"><span class="keyword">let</span> numbers = commaSeparatedNumbers</span><br><span class="line">    .<span class="built_in">split</span>(separator: <span class="string">","</span>).flatMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125;</span><br><span class="line"><span class="comment">// → [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>由于子字符串的生命周期很短，所以不建议方法的返回值是子字符串，除非是序列 <code>Sequence</code> 或集合 <code>Collection</code> 的一些返回切片的 API。如果你写了一个类似的方法，只对字符串有意义，那让它的返回值是子字符串，好让读者明白这个方法并不会产生复制，不会占用内存。创建新字符串的方法需要占用内存，比如 <a href="https://developer.apple.com/documentation/swift/stringprotocol/2908613-uppercased" target="_blank" rel="noopener"><code>uppercased()</code></a>，这类的方法应该返回 <code>String</code> 字符串类型的值。</p><p>如果你想为字符串类型扩展新的功能， 好的办法是将扩展放在字符串协议 <code>StringProtocol</code> 上，保证 API 在字符串和子字符串层面的一致性。字符权协议的设计初衷就是替换原先在字符串基础上做的扩展功能。如果你想把现有的扩展从字符串转移到字符串协议上，你要做的唯一改变就是，把传递 <code>Self</code> 给只接受具体 <code>String</code> 值的 API替换为 <code>String(Self)</code>。</p><p>需要记住的一点是，从 Swift 4 开始，如果你有一些自定义的字符串类型，不建议遵守字符串协议<code>StringProtocol</code>。官方文档明确警告：</p><blockquote><p>不要做任何新的遵守字符串协议 <code>StringProtocol</code> 的声明。只有标准库里的 <code>String</code> 和 <code>Substring</code> 是有效的遵守类型。</p></blockquote><p>允许开发者写自己的字符串类型（比如有特殊的存储优化或性能优化）是终极目标，但是现阶段协议的设计还没有最终确定，所以现在就启用它可能会导致你的代码在 Swift 5里无法正常运行。</p><p><code>… &lt;SNIP&gt;  &lt;内容有删减&gt;…</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Swift 语言里的字符串跟其他所有的主流编程语言里的字符串差异很大。当你习惯于把字符串当做代码块的数组后，你得花点时间转化思维，习惯 Swift 的处理方法：它把遵守 Unicode 编码标准放在<strong>简洁</strong>前面。</p><p>总的来讲，我们认为 Swift 的选择是正确的。Unicode 编码文本比其他编程语言所认为的要复杂得多。长远来看，处理你可能写出来的 bug 的时间肯定比学习新的索引方式（忘记整数索引）所需的时间多。</p><p>我们已经习惯于任意获取“字符”，以至于我们都忘了其实这个特性在真正的字符串处理的代码里很少用到。我们希望通过这一章里的例子可以说服大家，对于大多数常规的操作，简单的按序遍历也完全 OK。强迫你清楚地写出你想在哪个层面（字位集，Unicode scalar，UTF-16 代码块，UTF-8 代码块）处理字符串是另一项安全措施；读你代码的人会对你心存感激的。</p><p>2016年7月，Chris Lattner 谈到了 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html" target="_blank" rel="noopener">Swift 语言字符串处理的目标</a>，他最后是这么说的：</p><blockquote><p>我们的目标是在字符串处理上超越 Perl。</p></blockquote><p>当然 Swift 4 还没有实现这个目标——很多想要的特性还没实现，包括把 Foundation 库中的诸多字符串 API 转移到标准库，正则表达式的自然语言支持，字符串格式化和解析 API，更强大的字符串插入功能。好消息是 Swift 团队已经表示 <a href="https://github.com/apple/swift/blob/master/docs/StringManifesto.md" target="_blank" rel="noopener">会在将来解决所有这些问题</a>。</p><hr><p>如果喜欢本文的话，请考虑<a href="https://gumroad.com/a/507458675" target="_blank" rel="noopener">购买全书</a>。谢谢！</p><p>全书中第一张是本文的两本。讨论了其他的一些问题，包括如何使用以及什么时候使用字符串的代码块视图，如何和 Foundation里的处理字符串的 API（例如 <a href="https://developer.apple.com/documentation/foundation/nsregularexpression" target="_blank" rel="noopener"><code>NSRegularExpression</code></a> 或者 <a href="https://developer.apple.com/documentation/foundation/nsattributedstring" target="_blank" rel="noopener"><code>NSAttributedString</code></a>） 配合处理。贴别是后面这个问题很难，而且很容易犯错。除此之外还讨论了其他标准库里面机遇字符串的 API，例如文本输出流（<a href="https://developer.apple.com/documentation/swift/textoutputstream" target="_blank" rel="noopener"><code>TextOutputStream</code></a>）或自定义字符串转换（<a href="https://developer.apple.com/documentation/swift/customstringconvertible" target="_blank" rel="noopener"><code>CustomStringConvertible</code></a>）。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2017/11/swift-4-strings&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-11-27&lt;br&gt;译者：&lt;a href=&quot;https://weibo.com/u/5029986118&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;东莞大唐和尚&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;，&lt;a href=&quot;undefined&quot;&gt;Firecrest&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;这个系列中其他文章：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://oleb.net/blog/2014/07/swift-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift 1 中的字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://oleb.net/blog/2016/08/swift-3-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift 3 中的字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Swift 4 中的字符串（本文）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文节选自我们的新书《高级 Swift 编程》「字符串」这一章。《高级 Swift 编程》新版本已根据 Swift 4 的新特性修订补充，新版现已上市。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemannh" scheme="https://swift.gg/categories/Ole-Begemannh/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>剖析 ARM 64 架构中的 objc_msgSend</title>
    <link href="https://swift.gg/2018/08/06/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64/"/>
    <id>https://swift.gg/2018/08/06/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64/</id>
    <published>2018-08-06T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-30<br>译者：<a href="https://bignerdcoding.com/" target="_blank" rel="noopener">BigNerdCoding</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>很高兴，我又回来了。在刚刚过去的 WWDC 期间，我在 CocoaConf Next Door 做个一个关于剖析 ARM64 上 <code>objc_msgSend</code> 运行流程的发言。现在我将整理后的内容重新发布到 Friday Q&amp;A 上。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>每个 Objective-C 对象都会指向一个类，而每个类又包含一个方法列表。每个方法则由选择器（<code>selector</code>）、函数指针和一些元数据（<code>metadata</code>）构成。<code>objc_msgSend</code> 职责就是接收对象（<code>object</code>）和选择器（<code>selector</code>），根据选择器名称找到对应方法的函数指针并跳转执行该函数。</p><p>查找过程相对来说还是比较复杂的。若某个方法在当前类中未找到，就需要沿着继承链继续在父类中查找。如果在父类中也未查询到的话，则会触发 runtime 机制中的消息转发机制。任何对象在接收到第一条消息后都会触发类方法 <code>+initialize</code> 。</p><p>因为每次方法调用都会触发上述流程，所以在常见场景下的查找速度必须非常快。显然这与复杂的操作过程之间存在一定冲突。</p><p>为了解决这对矛盾提高查询速度，Objective-C 采用了方法缓存策略。每个类都会使用哈希表将其方法按照 Selector - IMPs（函数指针） 键值对关系缓存起来。这样在查询方法时，runtime 首先会直接去哈希表中查询。如果哈希表中不存在的话则转而执行原有复杂、缓慢的处理流程，并将最终结果缓存起来已备下次使用。</p><p><code>objc_msgSend</code> 用汇编语言进行实现，具体理由有两个：首先纯 C 语言无法实现这么一个函数：接收不定个数且未知类型的参数作为入参跳转至任意函数指针（即调用实现）；其次，执行速度对 <code>objc_msgSend</code> 来说非常重要，汇编语言能最大化提升该项指标。</p><p>当然，使用汇编语言实现整个复杂的消息处理过程是不现实的，而且也没这种必要。因为有些流程一旦触发程序都会变慢，无论采用何种语言层面的实现。整个消息处理流程代码可以分为两个部分：通过汇编代码实现的快速路径部分（fast path） ，C 语言实现的慢路径流程（slow path）。其中汇编代码对应缓存表中查询方法部分并且未命中时跳转 C 代码来进行下一步处理。</p><p>因此，<code>objc_msgSend</code> 代码处理流程大致如下：</p><ol><li>获取消息对象所对应的类信息</li><li>获取类所对应的方法缓存</li><li>在方法缓存中查询 <em>selector</em> 对象的函数实现</li><li>如果查询失败则调用 C 代码进行下一步处理</li><li>跳转到 IMP 所指的函数实现</li></ol><p>下面开始分析其具体实现。</p><h2 id="执行过程的指令"><a href="#执行过程的指令" class="headerlink" title="执行过程的指令"></a>执行过程的指令</h2><p><em>objc_msgSend</em> 在不同情形下执行路径不尽相同。对于向 <code>nil</code> 发送消息，标记指针（tagged pointers），哈希表冲突会相应特殊代码中进行处理。下面我将通过最常见也是最简单的情形来解释 <code>objc_msgSend</code>  的执行，即处理 non-nil、non-tagged 消息并且哈希表也能命中该方法。我会在该过程中标记出那些需要注意的处理路径<em>岔路口</em>，然后回过头来进行详细讲解。</p><p>我将列出单条或一组指令，然后在下面紧接相关解释内容。</p><p>每条指令前面都会有一个地址偏移量，可以将其看作一个指示跳转位置的标记量。</p><p>ARM64 架构中包含 31 个 64 位整型寄存器，对应符号表示为 x0 - x30 。每个寄存器的低 32 位也可以通过 w0 到 w30 进行访问，就像它也是一个单独的寄存器。其中 x0 到 x7 被用来保存函数调用时的前 8 个参数。这意味着 <code>objc_msgSend</code> 函数中的 <code>self</code> 参数保存在 x0 而 <code>_cmd</code> 保存在 x1 。</p><p>起始指令如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000 cmp     x0, #0x0</span><br><span class="line">0x0004 b.le    0x6c</span><br></pre></td></tr></table></figure><p>该段指令是将 <code>self</code> 与 0 进行有符号比较，如果 <code>self</code> 不大于 0 的话则会进行跳转处理。等于 0 其实就相当于 <code>nil</code> 对象，也就是说此时会调用向 <em>nil</em> 发送消息情形下对应的特定代码。另外，该指令也被用于标记指针（<code>tagged pointers</code>）的处理。ARM64 通过设置最高位为 1 来标记 Tagged Pointers（x86-64 则是最低位），此时对应有符号数比为负。对于普通指针来说，上述处理分支都会不被触发。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0008 ldr    x13, [x0]</span><br></pre></td></tr></table></figure><p>该指令将 x0 中所表示的 <em>self</em> 的 isa 地址加载到 x13 寄存器中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x000c and    x16, x13, #0xffffffff8</span><br></pre></td></tr></table></figure><p>因为 ARM64 架构下能够使用 <a href="(http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html)[http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html]"><code>non-pointer isas</code></a> 技术，所以与之前相比 isa 字段不仅可以包含指向 Class 的信息，它还能利用多余比特位存储其它有效信息（例如，引用计数）。这里通过 AND 逻辑运算去除低位的冗余信息得到最终的 Class 的地址并将其存入 x13 寄存器中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0010 ldp    x10, x11, [x16, #0x10]</span><br></pre></td></tr></table></figure><p>这是整个 <code>objc_msgSend</code> 处理流程中我最喜欢的指令。该指令会将 Class 中的方法缓存哈希表加载到 x10 和 x11 两个寄存器中。<code>ldp</code> 指令会将有效的内存信息加载到该指令的前两个寄存器中，而第三个参数则对应该信息的内存地址。在该例中缓存哈希表地址为 x16 寄存器中地址偏移 16 后所处位置。缓存对象数据结构类似于：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述 <code>ldp</code> 指令中，x10 中保存了 <code>_buckets</code> 值，而 x11 寄存器的高 32 位保存的是 <code>_occupied</code> 低 32 位则保存了 <code>_mask</code> 。</p><p><code>_occupied</code> 表示哈希表中的元素的数量，在 <code>objc_msgSend</code> 处理过程中没有太大的作用。而 <code>_mask</code> 则相对重要：它将哈希表大小描述为了一个便于进行与操作的掩码。<code>_mask</code> 值为 2^n - 1 ，换句话说它的二进制表示将以一组 1 作为结尾，形如 000000001111111 。该值为查询 selector 的哈希表索引以及标记表尾的必要条件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0014 and    w12, w1, w11</span><br></pre></td></tr></table></figure><p>该指令用于计算 <code>_cmd</code> 所传递过来的 <code>selector</code> 在哈希表中的起始位置。因为 <code>_cmd</code> 保存在 x1 寄存器中，所以 w1 寄存器则包含了 <code>_cmd</code> 的低 32 位信息。而 w11 寄存器保存了上面提到的 <code>_mask</code> 信息。通过 AND 指令我们将这两个寄存器中数值<em>与操作</em>结果保存到 w12 寄存器中。计算结果相当于 <code>_cmd % table_size</code>  ，但是它却避免了模操作的昂贵开销。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0018 add    x12, x10, x12, lsl #4</span><br></pre></td></tr></table></figure><p>仅仅得到索引是不够，为了从表中加载数据，我们需要得到最终的实际地址。而这正是该指令的目的。因为哈希表的 bucket 都是 16 个比特位，所以这里先对 x12 寄存器中的索引值左移 4 位也就是乘以 16 ，然后再将其与表首地址相加后的确切 bucket 地址信息保存到 x12 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x001c ldp    x9, x17, [x12]</span><br></pre></td></tr></table></figure><p>再一次通过 <code>ldp</code> 指令，将上一步保存在 x12 寄存器中 bucket 对应的信息加载到 x9 和 x17 寄存器中。因为 bucket 由 selector 和 IMP 两部分构成，所以 x9 对应保存了 selector 信息而 x17 则保存了 IMP 信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0020 cmp    x9, x1</span><br><span class="line">0x0024 b.ne   0x2c</span><br></pre></td></tr></table></figure><p>该段指令会将 x9 寄存器中的内容和 x1 中的 <code>_cmd</code> 进行对比，如果它们不等则意味着 bucket 中不包含我们所操作的 selector ，并且在此时跳转到 0x2c 处执行对应的未匹配处理。如果相同的话则表示命中，继续执行下一条指令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0028 br    x17</span><br></pre></td></tr></table></figure><p>该指令为无条件跳转到 x17 寄存器所指位置，也就是跳转到 IMP 所指处执行具体实现代码。此时 <code>objc_msgSend</code> 处理流程中最快的路径已经结束。其余参数所做寄存器都没有被干扰，目标方法会接受传入的全部参数，一切行如直接调用目标函数。</p><p>在最理想的情形下，<code>objc_msgSend</code> 处理流程最快可以在 3 纳秒内执行完毕。</p><p>在介绍完理想的最快情形后，接下来我们需要关注其余几种情形。首先，我们来看下当方法未缓存时的处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x002c cbz    x9, __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><p>前面提到 x9 寄存器包含了加载后的 selector 信息。将寄存器中的信息与零进行比较，如果等于 0 的话就跳转到 <code>__objc_msgSend_uncached</code> 代码处。因为等于 0 就意味着 bucket 为空也就是说方法查询失败，selector 对应的方法没有被缓存到哈希表中。此时我们需要调用 C 语言代码进行更为复杂的处理，也就是 <code>__objc_msgSend_uncached</code> 。如果仅仅只是方法不匹配且 bucket 不为空的话，则需要继续进行方法查找。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0030 cmp    x12, x10</span><br><span class="line">0x0034 b.eq   0x40</span><br></pre></td></tr></table></figure><p>该指令将 x12 寄存器中的当前 bucket 地址与 x10 寄存器中的哈希表首地址进行比较。如果两者内容匹配上了，则我们从哈希表的末尾进行反向查询。虽然我还没弄明白此时为什么没有采用常见的正向遍历查询，但是有理由认为可能这样速度更快。</p><p>0x40 表示匹配后跳转目的地址。如果两者不匹配则继续执行下面的指令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0038 ldp    x9, x17, [x12, #-0x10]!</span><br></pre></td></tr></table></figure><p>再一次代码通过 ldp 指令加载缓存信息，只不过地址为距当前 bucket  偏移 -0x10 所指位置。该指令中的 ！符号表示寄存器回写操作，也就是说会使用计算后的结果更新 x12 寄存器。将其用数学方式表示就是：x12 -= 16，将 x12 中表示的地址前移 16 个单位。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x003c b      0x20</span><br></pre></td></tr></table></figure><p>加载新的 bucket 信息后，代码重新跳转到 0x20 处循环查询过程，直到出现下列情形：找到匹配项，bucket 为空，再次回到了哈希表的起始处。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0040 add    x12, x12, w11, uxtw #4</span><br></pre></td></tr></table></figure><p>当查询到匹配想后会触发该指令。此时 x12 寄存器为最新的 bucket 地址，而 w11 保存了包含哈希表大小的掩码值。该指令将 w11 左移 4 位后将两个值进行叠加得到哈希表尾地址，并将结果保存到 x12 寄存器中，然后接着恢复查询操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0044 ldp    x9, x17, [x12]</span><br></pre></td></tr></table></figure><p>该指令为加载新 bucket 信息到 x9，x17 寄存器中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0048 cmp    x9, x1</span><br><span class="line">0x004c b.ne   0x54</span><br><span class="line">0x0050 br     x17</span><br></pre></td></tr></table></figure><p>该段指令与前面的 0x0020 处的功能一致，只要寄存器内容匹配上了就跳转到对应 IMP 位置执行代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0054 cbz    x9, __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><p>同样的，若不匹配则执行与前面 0x002c 一样的处理流程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0058 cmp    x12, x10</span><br><span class="line">0x005c b.eq   0x68</span><br></pre></td></tr></table></figure><p>该指令与 0x0030 处一致，只不过如果此时 x12 寄存器内容依旧是哈希表首地址的话程序会跳转到 0x68 处进行处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0068 b      __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><p>这种情况一般不太容易发生，因为它会导致哈希表持续膨胀。此时哈希表的查询效率会下降而去潜在哈希碰撞的可能性会变高。</p><p>至于原因，源码中的注释是这些写的：</p><blockquote><p>Clone scanning loop to miss instead of hang when cache is corrupt. The slow path may detect any corruption and halt later.<br>当缓存损坏时，需要跳出上面的循环查询流程而不是进入挂起状态。 转而执行慢速路径流程去检测任何可能的损坏并终止代码执行。</p></blockquote><p>我怀疑这种情况很常见，但很显然苹果公司的员工已经看到内存损坏会让哈希表充满无效内容所以在此处跳转到 C 代码中进行错误诊断。</p><p>此项检查的存在应该将对未损坏的缓存的影响降低到最小。去除该检查，原来的循环处理流程可以被重用，这会节省一点指令缓存空间。 无论如何，该处理程序器并不是常见的情况。 只会在哈希表的开始位置查询到所需的选择子或者发生了哈希碰撞时才会被调用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0060 ldp    x9, x17, [x12, #-0x10]!</span><br><span class="line">0x0064 b      0x48</span><br></pre></td></tr></table></figure><p>该段指令与之前功能一致，加载新 bucket 信息到 x9，x17 寄存器中。更新 x12 中的地址，并跳转到 0x48 处重复查找流程。</p><p>objc_msgSend 的主要处理流程到此告一段落，剩下 Tagged Pointer 和 <code>nil</code> 两个特殊情形的处理。</p><h2 id="标记指针的处理"><a href="#标记指针的处理" class="headerlink" title="标记指针的处理"></a>标记指针的处理</h2><p>我们回到第一组汇编指令的跳转处来讲解标记指针（<code>Tagged Pointer</code>）的处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x006c b.eq    0xa4</span><br></pre></td></tr></table></figure><p>当参数 <em>self</em> 不大于 0 时，该指令就会被触发。其中小于 0 对应标记指针，而等于零则对应 <code>nil</code> 。这两种情形有各自的处理流程，所以第一步就是要区分出到底是哪种情形。若为 <em>nil</em> 情形则跳转到 0xa4 处进行处理，否则继续执行。</p><p>在继续讲解之前，先简单讨论下标记指针工作原理。 标记指针支持多个类。其中高 4 位（在 ARM64 上）指明了“对象”的类信息，本质上就是 Tagged Pointer 的 isa 。当然 4 个比特位不足以容纳一个类指针，实际上这些信息都被存在了一张特殊表中。我们可以以高 4 位的值为索引去表中查询真正的类信息。</p><p>这还不是全部，标记指针（至少在 ARM64 上）支持拓展类。当高 4 位全为 1 时，紧接着的 8 个比特位将被用作拓展类表中的索引值。 这样在运行时支持更多的标记指针类，不过代价就是能存储的有效信息会变少。</p><p>下面继续指令的执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0070 mov    x10, #-0x1000000000000000</span><br></pre></td></tr></table></figure><p>该指令将一个整形值（高 4 位为 1 ，其余全为 0）写入 x10 寄存器中。这将用作下一步提取 <code>self</code> 标记位的掩码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0074 cmp    x0, x10</span><br><span class="line">0x0078 b.hs   0x90</span><br></pre></td></tr></table></figure><p>这一步时检查拓展标记指针内容。如果 <code>self</code> 大于或者等于 x10 中的值，则意味这 <code>self</code> 的高 4 位也全部为 1 。此时代码会跳转到 0x90 处理拓展类部分的内容，否则就继续执行下面的指令去主标记指针表中的查询类信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x007c adrp   x10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class="line">0x0080 add    x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br></pre></td></tr></table></figure><p>该段指令主要就是加载 <code>_objc_debug_taggedpointer_classes@PAGE</code>  所指的主标记指针表地址。因为 ARM64 上的指针是 64 位宽，而指令只有 32 位宽，所以需要采用类 RISC 标准技术通过两个指令来加载符号地址。</p><p>x86 架构则不存在该问题，因为它采用可变长度指令集。它可以通过一个 10 字节长的指令处理上面的问题：2 个字节用来区分具体指令和寄存器，剩下 8 个字节用来保存指针地址。</p><p>而在定长指令集机器上，我们只能通过一组命令加以应对。例如，上例就是通过两条指令实现 64 位指针地址的加载操作。adrp 指令加载高 32 位信息然后再通过 add 指令将其与低 32 位进行求和。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0084 lsr    x11, x0, #60</span><br></pre></td></tr></table></figure><p>因为索引值保存在 x0 的高 4 位中，所以该指令将 x0 进行右移 60 位取出对应的索引值（取值范围为 0-15）并保存到 x11 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0088 ldr    x16, [x10, x11, lsl #3]</span><br></pre></td></tr></table></figure><p>根据索引值获取标记指针的类信息并保存到 x16 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x008c b      0x10</span><br></pre></td></tr></table></figure><p>获得类信息后程序会无条件跳回 0x10 处，并复用主分支中的代码进行方法查询处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0090 adrp   x10, _objc_debug_taggedpointer_ext_classes@PAGE</span><br><span class="line">0x0094 add    x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</span><br></pre></td></tr></table></figure><p>该段指令与前面加载主标记指针表功能一样，只不过此时它用于处理前面提到的拓展表分支。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0098 ubfx   x11, x0, #52, #8</span><br></pre></td></tr></table></figure><p>该指令只要是取出 <em>self</em> 中从第 52 位开始的 8 位信息作为拓展表的索引值，并将其保存到 x11 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x009c ldr    x16, [x10, x11, lsl #3]</span><br></pre></td></tr></table></figure><p>再一次，我们将获得的类信息加载到 x16 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00a0 b      0x10</span><br></pre></td></tr></table></figure><p>最后，我们同样跳回到 0x10 处。</p><p>接下来，我们来看 <code>nil</code> 情形的处理过程。</p><h2 id="nil-的处理"><a href="#nil-的处理" class="headerlink" title="nil 的处理"></a><code>nil</code> 的处理</h2><p>作为最后一个特殊情况，下面就是 <code>nil</code> 情形下被执行的所有指令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00a4 mov    x1, #0x0</span><br><span class="line">0x00a8 movi   d0, #0000000000000000</span><br><span class="line">0x00ac movi   d1, #0000000000000000</span><br><span class="line">0x00b0 movi   d2, #0000000000000000</span><br><span class="line">0x00b4 movi   d3, #0000000000000000</span><br><span class="line">0x00b8 ret</span><br></pre></td></tr></table></figure><p><code>nil</code> 情形的处理与其他情形完全不同，它不会进行类查询和方法派发，而仅仅返回 0 给调用者。</p><p>该段指令最麻烦的事情是 <code>objc_msgSend</code> 不知道具体的返回值类型。是整型值、浮点值、亦或者是什么都不返回。</p><p>幸运的是，所有用于设置返回值的寄存器都能被安全覆写，即使此次调用过程不会使用到。整型返回值被保存在 x0 和 x1 中，而浮点值则保存在向量寄存器 v0 - v3 中。同时使用多个寄存器可以返回一个小型结构体类型返回值。</p><p>在处理 <code>nil</code> 情形时，上诉指令会将 x1 以及 v0 - v3 中的值全部清空并设置为 0。其中 d0 - d3 分别对应向量寄存器 v0 - v3 的后半部分，通过将其设置为 0 清除了后半部分然后在通过 movi 清除所有的寄存器内容。清空返回值寄存器后，控制权将重新回到调用方。</p><p>如果返回值为比较大的结构体，那么寄存器可能就变的不够用了。此时就需要调用者做出一些配合。调用者会在一开始为该结构体分配一块内存，然后将其地址提前写入到 x8 寄存器中。在设置返回值的时候，直接往该地址中写数据即可。<br>因为该内存大小对 <code>objc_msgSend</code> 是透明的，因此不能对其进行清空操作。取而代之的操作就是在调用 <code>objc_msgSend</code>  之前编译器会将其设置为 0 。</p><p>以上就是 <code>nil</code> 情形的处理，<code>objc_msgSend</code> 流程到此也宣告结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>深入框架底层还是很有趣的，而 <code>objc_msgSend</code>  就像一件艺术品，值得细细玩味。</p><p>今天的内容到此结束，下次再会为大家带来一些更好的内容。Friday Q&amp;A 很多内容都是由读者驱动而来，所以欢迎大家在下面积极发言。</p><h3 id="汇编指令校对者注"><a href="#汇编指令校对者注" class="headerlink" title="汇编指令校对者注"></a>汇编指令校对者注</h3><ol><li><code>#0x0</code>：“#”修饰的数字表示立即数，可简单理解为数值，而非地址：</li><li><code>b</code> ：跳转指令，b.le 指比较结果小于等于的时候跳转至某内存地址；</li><li><code>ldr</code> ：从内存中读取数据到寄存器；</li><li><code>and</code>：arm 的 <code>and</code> 指令，需要3个操作数，例如 <code>AND R0，R0，#3</code> 是将 R0 寄存器的值与数字3（0x0000003）逻辑与，将结果存储为 R0 寄存器</li><li><code>add</code>：<code>ADD[con][S] Rd,Rn,operand</code>，将 operand 数据与 Rn 的值相加，结果保存到 Rd 寄存器；</li><li><code>lsl</code>： 逻辑左移指令，可以结合 <code>add</code> 指令一起使用，如<code>ADDS R0,R1,R2,LSL#2</code>，将 R2 寄存器左移 2 位，接着 R1 和 R2 值相加，将结果存储到 R0 中；</li><li><code>cbz</code>：c对应compare，b就是上面的跳转，z对应0 zero，因此这条命令当比较结果为零（Zero）就跳转至之后的指令；</li><li><code>UXTW</code>： 32 位的逻辑左移指令，更多请见<a href="http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20140407/212142.html" target="_blank" rel="noopener">[llvm] r205861</a>;</li><li><code>LSR</code>： 逻辑右移；</li><li><code>UBFX</code>：<code>UBFX{cond} Rd, Rn, #lsb, #width</code> 从一个寄存器中提取位域，cond —可选，条件码 ；Rd — 目标寄存器 ；Rn — 源寄存器 ；lsb —位域的最低有效位的位置，范围是 0 - 31； width — 位域的宽度，范围是1到 32-lsb</li></ol><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-06-30&lt;br&gt;译者：&lt;a href=&quot;https://bignerdcoding.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigNerdCoding&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;，&lt;a href=&quot;http://codebuild.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shanks&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;很高兴，我又回来了。在刚刚过去的 WWDC 期间，我在 CocoaConf Next Door 做个一个关于剖析 ARM64 上 &lt;code&gt;objc_msgSend&lt;/code&gt; 运行流程的发言。现在我将整理后的内容重新发布到 Friday Q&amp;amp;A 上。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 4 弱引用实现</title>
    <link href="https://swift.gg/2018/08/02/swift-4-weak-references/"/>
    <id>https://swift.gg/2018/08/02/swift-4-weak-references/</id>
    <published>2018-08-02T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2017-09-22-swift-4-weak-references.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-09-22<br>译者：<a href="https://bignerdcoding.com/" target="_blank" rel="noopener">BigNerdCoding</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Swift 开源不久我就写了篇关于弱引用实现的<a href="https://mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html" target="_blank" rel="noopener">文章</a>。时移势易，Swift 4 中的弱引用实现已经与旧文不一致了。应 Guillaume Lessard 建议，今天我将会介绍新版实现，并比较其与老版的区别。</p><a id="more"></a><h2 id="旧实现"><a href="#旧实现" class="headerlink" title="旧实现"></a>旧实现</h2><p>考虑到有些人可能已经忘记了旧实现并且不愿重看前面的文章，下面我们就一起简要的回顾下之前的实现方式。</p><p>在旧实现中，Swift 对象有两个引用计数：强引用计数和弱引用计数。当强引用计数为 0 而弱引用计数不为 0 时，对象会被销毁，但是内存并不会被立即释放。内存中会保留弱引用指向的僵尸对象。</p><p>在加载弱引用时，运行时会对引用对象进行检查。如果是僵尸对象，则会对弱引用计数进行递减操作。一旦弱引用计数为 0，对象内存将会被释放。换句话说，僵尸对象的所有弱引用被加载访问后僵尸对象才会真正被清空。</p><p>虽然我喜欢该实现的简单性，但它有一些缺陷。其中一个就是，僵尸对象可能会长时间停留在内存中。对于那些拥有很多实例的类（因为它们包含许多属性，或使用类似 ManagedBuffer 分配了内联的额外内存），这会造成严重的内存浪费。</p><p>另外，在写完旧文后我还发现：对于并发读取，该实现是非线程安全的。虽然已经有补丁修复了这个问题，但从相关讨论可以看出，开发者希望找到一个更好的实现方式，避免出现类似问题。</p><h2 id="对象数据"><a href="#对象数据" class="headerlink" title="对象数据"></a>对象数据</h2><p>Swift 中的 “对象” 其实是由一组数据构成。</p><p>首先，最容易想到的就是源码中声明的那些可直接访问的存储属性。</p><p>其次就是对象的类信息。该信息主要被用于动态派发和 <strong>type(of: )</strong> 内置函数。虽然动态派发和 <strong>type(of: )</strong> 内置函数从侧面暗示了它的存在，但是实际上该信息大多是被隐藏的。</p><p>第三种就是各种引用计数信息。除非你进行一些非常规操作，例如，读取对象的原始内存或说服编译器让你调用 CFGetRetainCount，否则这些信息对你来说是完全透明不可见的。</p><p>第四种就是 Objective-C 运行时存储的辅助信息，例如 Objective-C 弱引用列表（Objective-C 的弱引用实现是通过单独追踪每个弱引用）和关联对象。</p><p>那么这些信息最终都存储在哪里呢？</p><p>在 Objective-C 中，类信息和存储属性（例如，实例变量）内联在对象内存中。其中类信息位于指针所在第一块内存，其后才是实例变量。辅助类信息则保存在外部表中。当你需要操作关联对象时，运行时机制会使用内存地址去一个大的哈希表中查找它。为了实现多线程安全，该表在操作时会加锁，所以存在一定程度访问速度问题。引用计数的保存位置，则取决于具体操作系统版本和 CPU 架构，它有时位于对象内存中，而有时又存储在外部表中。</p><p>在 Swift 旧有实现中，类信息，引用计数和存储属性全部内联在对象内存中。而辅助信息则依旧存储在单独的外部表中。</p><p>下面我们不妨将具体实现代码先放一边，仔细思考下：理论上应该如何存储这些信息呢？</p><p>每种存储方案都有利弊。将数据存储在对象内存中虽然能提高访问速度，但是会让内存空间变得吃紧。与之相对，外部存储方案则是通过牺牲速度来换空间。</p><p>Objective-C 传统存储方案不将对象引用计数保存在内存中，部分原因正是基于此。因为在 Objective-C 引入引用计数概念时，设备的性能远不如现在，而且内存容量也极为有限。Objective-C 程序中大多数对象只有一个所有者，即引用计数为 1 。此时在对象内存中腾出 4 个字节空间存储该引用计数 1 是很浪费的。而外部表方案中，数值 1 可以通过缺省默认值方式表示从而减少内存消耗。</p><p>每次进行动态方法派发时都需要对象的类信息，所有作为最常用信息，类信息应该直接保存在内存中，存在外部表中是不合适的。</p><p>而实例变量这类存储属性在编译期就确定了，而且有现实的访问速度需求，所以存在对象内存中也是最合理的设计。另外，当对象没有存储属性时，系统不会为其分配内存空间也就不存在浪费问题。</p><p>每个对象都需要保留引用计数。虽然不是每个对象的引用计数都为 1，但它依旧是一个相对常见的情形，加上现在内存足够，它可以直接保存在内存中。</p><p>大多数对象都不会有弱引用或关联对象数据，所有它们应该保存在外部以期节约内存空间。</p><p>对于那些有弱引用或关联对象数据的对象来说，访问速度确实不够快但这是合理的权衡结果。那么问题来了，该旧实现有没有改进空间和可行方法呢？</p><h2 id="Side-Tables"><a href="#Side-Tables" class="headerlink" title="Side Tables"></a>Side Tables</h2><p>在 Swift 弱引用的新版实现代码中，引入了 <em>side tables</em> 概念来改进上诉缺陷。</p><p>Side table 本质就是用于保存额外信息的单独内存块，并且它还是可选的。也就是说，对于那些无需保存额外信息的对象来说并没有多余开销。</p><p>每个对象都有一个指向其对应 side table 的指针，而 side table 也有一个指针指向该对象。另外，side table 可以存储关联的对象数据等其他信息。</p><p>为了避免 side table 带来的 8 字节空间开销，Swift 做了一个漂亮的优化。通常内存中的第一个字（Word）是类信息，第二个字则是引用计数。当对象存在 side table 需求时，第二个字将保存指向 side table 的指针。因为引用计数是必要信息，所以此时会将引用计数保存到 side table 中。至于程序运行时到底是哪种情形，则由该块内存中的一个标志位进行区分。</p><p>通过将弱引用从指向对象本身改为指向 side table ，Swift 得以在保留原有引用计数设计的同时修复了旧设计中的缺陷。</p><p>因为 side table 比较小并且弱引用不再指向对象本身，这样之前大型僵尸对象的内存空间将能立即释放从而降低了内存浪费。同时该实现也让线程安全问题变得更易解决：不再需要提前将弱引用置空。因为 side table 比较小，指向它的弱引用可以持续保留，直到这些引用自身被覆写或销毁。</p><p>这里需要提醒一下，当前 side table 实现中只保存引用计数和指向原始对象的指针。类似保存关联对象等用途只是一个猜想和假设。因为 Swift 还没有内建关联对象功能，而 Objective-C API 仍在使用全局表。</p><p>该技术还有不少潜力可挖，也许在不久的将来能看到其应用在关联对象等内容上。我希望它能为类拓展中的存储属性和其他有趣的功能打开一扇新窗。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>因为 Swift 已经开源，所有相关代码都能直接访问。</p><p>关于 side table 的大部分代码都在 <a href="https://github.com/apple/swift/blob/c262440e70896299118a0a050c8a834e1270b606/stdlib/public/SwiftShims/RefCount.h" target="_blank" rel="noopener">stdlib/public/SwiftShims/RefCount.h</a> 。</p><p>高层级的弱引用 API 以及相关注释都在 <a href="https://github.com/apple/swift/blob/c262440e70896299118a0a050c8a834e1270b606/stdlib/public/runtime/WeakReference.h" target="_blank" rel="noopener">swift/stdlib/public/runtime/WeakReference.h</a>。</p><p>更多关于堆对象的实现和注释在 <a href="https://github.com/apple/swift/blob/c262440e70896299118a0a050c8a834e1270b606/stdlib/public/runtime/HeapObject.cpp" target="_blank" rel="noopener">stdlib/public/runtime/HeapObject.cpp</a>。</p><p>上述链接其实带着版本信息，以便后面的读者也能找到本文内容当时的上下文。如果你想看最新的实现代码，你在点击链接后切换到 master 分支即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>弱引用是一个重要的语言特性。Swift 最初的实现方式非常聪明，也有一些不错的特性，但是同时也存在一些问题。通过引入 side table，Swift 开发工程师在保留原有特点的同时还解决了这些缺陷。Side table 的实现也为将来更多新特性创造了更多可能性。</p><p>今天内容到此为止。下次我还会带来与编程和代码相关的新内容。当然你也可以将你感兴趣的话题<a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发送给我</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2017-09-22-swift-4-weak-references.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-09-22&lt;br&gt;译者：&lt;a href=&quot;https://bignerdcoding.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigNerdCoding&lt;/a&gt;；校对：&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/Cee&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cee&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 开源不久我就写了篇关于弱引用实现的&lt;a href=&quot;https://mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;。时移势易，Swift 4 中的弱引用实现已经与旧文不一致了。应 Guillaume Lessard 建议，今天我将会介绍新版实现，并比较其与老版的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="Swift 入门" scheme="https://swift.gg/tags/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>构建一个 @synchronized</title>
    <link href="https://swift.gg/2018/07/30/friday-qa-2015-02-20-lets-build-synchronized/"/>
    <id>https://swift.gg/2018/07/30/friday-qa-2015-02-20-lets-build-synchronized/</id>
    <published>2018-07-30T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-02-20-lets-build-synchronized.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-02-20<br>译者：<a href="https://www.sunnyyoung.net/" target="_blank" rel="noopener">Sunnyyoung</a>；校对：<a href="http://hulizhen.me" target="_blank" rel="noopener">智多芯</a>；定稿：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>上一篇文章讲了线程安全，今天这篇最新一期的 Let’s Build 我会探讨一下如何实现 Objective-C 中的 <code>@synchronized</code>。本文基于 Swift 实现，Objective-C 版本大体上也差不多。</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p><code>@synchronized</code> 在 Objective-C 中是一种控制结构。它接受一个对象指针作为参数，后面跟着一段代码块。对象指针充当锁，在任何时候 <code>@synchronized</code> 代码块中只允许有一个线程使用该对象指针。</p><p>这是一种使用锁进行多线程编程的简单方法。举个例子，你可以使用 <code>NSLock</code> 来保护对 NSMutableArray 的操作：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array;</span><br><span class="line"><span class="built_in">NSLock</span> *arrayLock;</span><br><span class="line"></span><br><span class="line">[arrayLock lock];</span><br><span class="line">[array addObject: obj];</span><br><span class="line">[arrayLock unlock];</span><br></pre></td></tr></table></figure><p>也可以使用 <code>@synchronized</code> 来将数组本身加锁：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(array) &#123;</span><br><span class="line">    [array addObject: obj];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我个人更喜欢显式的锁，这样做既可以使事情更清楚，<code>@synchronized</code> 的性能没那么好，原因如下图所示。但它（<code>@synchronized</code>）使用很方便，不管怎样，实现起来都很有意思。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Swift 版本的 <code>@synchronized</code> 是一个函数。它接受一个对象和一个闭包，并使用持有的锁调用闭包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">synchronized</span><span class="params">(obj: AnyObject, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是，如何将任意对象变成锁？</p><p>在一个理想的世界里（从实现这个函数的角度来看），每个对象都会为锁留出一些额外空间。在这个额外的小空间里 <code>synchronized</code> 可以使用适当的 <code>lock</code> 和 <code>unlock</code> 方法。然而实际上并没有这种额外空间。这可能是件好事，因为这会增大对象占用的内存空间，但是大多数对象永远都不会用到这个特性。</p><p>另一种方法是用一张表来记录对象到锁的映射。<code>synchronized</code> 可以查找表中的锁，然后执行 <code>lock</code> 和 <code>unlock</code> 操作。这种方法的问题是表本身需要保证线程安全，它要么需要自己的锁，要么需要某种特殊的无锁数据结构。为表单独设置一个锁要容易得多。</p><p>为了防止锁不断累积常驻，表需要跟踪锁的使用情况，并在不再需要锁的时候销毁或者复用。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>要实现将对象映射到锁的表，<code>NSMapTable</code> 非常合适。它可以把原始对象的地址设置成键（key），并且可以保存对键（key）和值（value）的弱引用，从而允许系统自动回收未被使用的锁。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> locksTable = <span class="type">NSMapTable</span>.weakToWeakObjectsMapTable()</span><br></pre></td></tr></table></figure><p>表中存储的对象是 <code>NSRecursiveLock</code> 实例。因为它是一个类，所以可以直接用在 <code>NSMapTable</code> 中，这点 <code>pthread_mutex_t</code> 就做不到。<code>@synchronized</code> 支持递归语义，我们的实现一样支持。</p><p>表本身也需要一个锁。自旋锁（spinlock）在这种情况下很适合使用，因为对表的访问是短暂的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> locksTableLock = <span class="type">OS_SPINLOCK_INIT</span></span><br></pre></td></tr></table></figure><p>有了这个表，我们就可以实现以下方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">synchronized</span><span class="params">(obj: AnyObject, f: Void -&gt; Void)</span></span> &#123;</span><br></pre></td></tr></table></figure><p>它所做的第一件事就是在 <code>locksTable</code> 中找出与 <code>obj</code> 对应的锁，执行操作之前必须持有 <code>locksTableLock</code> 锁：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">OSSpinLockLock</span>(&amp;locksTableLock)</span><br><span class="line"><span class="keyword">var</span> lock = locksTable.objectForKey(obj) <span class="keyword">as</span>! <span class="type">NSRecursiveLock</span>?</span><br></pre></td></tr></table></figure><p>如果表中没有找到对应锁，则创建一个新锁并保存到表中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> lock == <span class="literal">nil</span> &#123;</span><br><span class="line">    lock = <span class="type">NSRecursiveLock</span>()</span><br><span class="line">    locksTable.setObject(lock!, forKey: obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了锁之后主表锁就可以释放了。为了避免死锁这必须要在调用 <code>f</code> 之前完成：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">OSSpinLockUnlock</span>(&amp;locksTableLock)</span><br></pre></td></tr></table></figure><p>现在我们可以调用 <code>f</code> 了，在调用前后分别进行加锁和解锁操作：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    lock!.lock()</span><br><span class="line">    f()</span><br><span class="line">    lock!.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对比苹果的方案"><a href="#对比苹果的方案" class="headerlink" title="对比苹果的方案"></a>对比苹果的方案</h2><p>苹果实现 <code>@synchronized</code> 的方案可以在 Objective-C runtime 源码中找到:</p><p><a href="http://www.opensource.apple.com/source/objc4/objc4-646/runtime/objc-sync.mm" target="_blank" rel="noopener">http://www.opensource.apple.com/source/objc4/objc4-646/runtime/objc-sync.mm</a></p><p>它的主要目标是性能，因此不像上面那个玩具般的例子那么简单。对比它们之间有什么异同是一件非常有趣的事。</p><p>基本概念是相同的。存在一个全局表，它将对象指针映射到锁，然后该锁在 <code>@synchronized</code> 代码块前后进行加锁解锁操作。</p><p>对于底层的锁对象，Apple 使用配置为递归锁的 <code>pthread_mutex_t</code>。<code>NSRecursiveLock</code> 内部很可能也使用了 <code>pthread_mutex_t</code>，直接使用就省去了中间环节，并避免了运行时对 Foundation 的依赖。</p><p>表本身的实现是一个链表而不是一个哈希表。常见的情况是在任何给定的时间里只存在少数几个锁，所以链表的性能表现很不错，可能比哈希表性能更好。每个线程缓存了最近在当前线程查找的锁，从而进一步提高性能。</p><p>苹果的实现并不是只有一个全局表，而是在一个数组里保存了 16 个表。对象根据地址映射到不同的表，这减少了不同对象 <code>@synchronized</code> 操作导致的不必要的资源竞争，因为它们很可能使用的是两个不同的全局表。</p><p>苹果的实现没有使用弱指针引用（这会大量增加额外开销），而是为每个锁保留一个内部的引用计数。当引用计数达到零时，该锁可以给新对象重新使用。未使用的锁不会被销毁，但复用意味着在任何时间锁的总数都不能超过激活锁的数量，也就是说锁的数量不随着新对象的创建无限制增长。</p><p>苹果的实现方案非常巧妙，性能也不错。但与使用单独的显式锁相比，它仍然会带来一些不可避免的额外开销。尤其是：</p><ol><li>如果不相关的对象刚好被分配到同一个全局表中，那么它们仍然可能存在资源竞争。</li><li>通常情况下在线程缓存中查找一个不存在的锁时，必须获取并释放一个自旋锁。</li><li>必须做更多的工作来查找全局表中对象的锁。</li><li>即使不需要，每个加锁/解锁周期都会产生递归语义方面的开销。</li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>@synchronized</code> 是一个有趣的语言结构，实现起来并不简单。它的作用是实现线程安全，但它的实现本身也需要同步操作来保证线程安全。我们使用全局锁来保护对锁表的访问，苹果的实现中则使用不同的技巧来提高性能。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-02-20-lets-build-synchronized.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2015-02-20&lt;br&gt;译者：&lt;a href=&quot;https://www.sunnyyoung.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sunnyyoung&lt;/a&gt;；校对：&lt;a href=&quot;http://hulizhen.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;智多芯&lt;/a&gt;；定稿：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;上一篇文章讲了线程安全，今天这篇最新一期的 Let’s Build 我会探讨一下如何实现 Objective-C 中的 &lt;code&gt;@synchronized&lt;/code&gt;。本文基于 Swift 实现，Objective-C 版本大体上也差不多。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Block 形式的通知中心观察者是否需要手动注销</title>
    <link href="https://swift.gg/2018/07/26/notificationcenter-removeobserver/"/>
    <id>https://swift.gg/2018/07/26/notificationcenter-removeobserver/</id>
    <published>2018-07-26T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2018/01/notificationcenter-removeobserver/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-01-05<br>译者：<a href="https://bignerdcoding.com/" target="_blank" rel="noopener">BigNerdCoding</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>简单回答：需要 （在 iOS 11.2 上验证过）</p><p>几周之前，我在 twitter 上提出了一个<a href="https://twitter.com/olebegemann/status/938085544780877824" target="_blank" rel="noopener">问题</a>：</p><blockquote><p>在 iOS 11 中是否还需要手动移除基于 block 形式的通知观察者？苹果开发文档中比较模糊。<a href="https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver" target="_blank" rel="noopener"><code>addObserver(forName:object:queue:using:)</code></a> 中说需要，而 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver" target="_blank" rel="noopener"><code>removeObserver(_:)</code></a> 中又表明 iOS 9 之后都不在需要。</p></blockquote><p>虽然我没有统计准确的数字，但是大致看来持不同意见的人差不多五五开。</p><p>所以下面我们就来具体测试验证一下。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>首先，我所说的基于 block 的接口声明是 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver" target="_blank" rel="noopener"><code>NotificationCenter.addObserver(forName: object: queue: using:)</code></a> 。使用该 API 我们在通知中心注册了一个函数用于处理对应的通知，并且得到一个表示观察者的返回值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> observation: <span class="type">Any</span>? = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        observation = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(</span><br><span class="line">            forName: myNotification, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123; notification <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Received <span class="subst">\(notification.name.rawValue)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是：当代码中的返回值 <em>observation</em> 销毁时（例如，MyObserver 实例对象析构了），通知中心会不会自动忽略并停止调用处理函数呢？毕竟基于 <a href="https://developer.apple.com/documentation/swift/key_path_expressions" target="_blank" rel="noopener">KeyPath</a> 的 <a href="http://skyefreeman.io/programming/2017/06/28/kvo-in-ios11.html" target="_blank" rel="noopener">KVO 新接口</a>当观察者销毁后，响应处理不再被调用，所以通知可能也被理解成是这样进行的。</p><p>或者，我们依旧需要手动调用 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver" target="_blank" rel="noopener"><code>NotificationCenter.removeObserver(_:)</code></a>（例如，在 MyObserver 的析构函数 <strong>deinit</strong> 手动注销）？</p><h2 id="文档中的说明"><a href="#文档中的说明" class="headerlink" title="文档中的说明"></a>文档中的说明</h2><p>基于 selector 形式的观察接口 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1415360-addobserver" target="_blank" rel="noopener"><code>addObserver(_:selector:name:object:)</code></a> 的手动注销操作在 iOS 9 和 OSX 10.11 之后已经变成可选了。然而在 <a href="https://developer.apple.com/library/archive/releasenotes/Foundation/RN-FoundationOlderNotes/index.html#10_11NotificationCenter" target="_blank" rel="noopener">Foundation 发布注意事项</a>中明确表明 Block 形式的接口依然需要进行手动注销操作。</p><blockquote><p>通过 <code>-[NSNotificationCenter addObserverForName:object:queue:usingBlock:_]</code> 形式添加的block类型观察者在无用时依然需要进行注销操作，因为系统会保留对该观察者的强引用。</p></blockquote><p>该文档发布之后是否存在新变化呢？</p><p>在 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver" target="_blank" rel="noopener"><code>addObserver(forName:object:queue:using:)</code></a> 文档说明部分也明确指出了注销操作是必要的：</p><blockquote><p>所有通过 <code>addObserver(forName:object:queue:using:)</code> 创建的观察者在析构之前都需要调用 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver" target="_blank" rel="noopener"><code>removeObserver(_:)</code></a> 或者 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1407263-removeobserver" target="_blank" rel="noopener"><code>removeObserver(_:name:object:)</code></a> 进行注销操作。</p></blockquote><p>然而 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver" target="_blank" rel="noopener"><code>removeObserver(_:)</code></a> 文档说明处似乎与之相反：</p><blockquote><p>如果你的 APP 运行在 iOS 9 或者 macOS 10.11 及最新的版本上的话则不需要注销这个观察者在它的析构方法。</p></blockquote><p>该文档中并没有对 selector 或者 block 进行区分说明，也就是说该操作同时适用于两者。</p><h2 id="进行测试验证"><a href="#进行测试验证" class="headerlink" title="进行测试验证"></a>进行测试验证</h2><p>通过我写的<a href="https://github.com/ole/NotificationUnregistering" target="_blank" rel="noopener">测试应用</a>，你可以得到验证上诉问题（通过 Xcode 的终端输出）。</p><p>下面是我发现的：</p><ul><li>基于block 形式的观察者依然需要进行手动注销操作（即使在 iOS 11.2 上），所以 <code>removeObserver (_:)</code> 文档存在明显的误导。</li><li>如果没有进行注销操作的话，那么 block 就会被一直持有而且依然能够被相关通知触发执行。此时该行为对 APP 的潜在威胁取决于 block 内部持有的对象。</li><li>即使你在 <em>deinit</em> 中调用了注销操作，你依旧需要注意 block 中不能捕获 self 引用，否则会造成循环引用此时 <em>deinit</em> 也永远不会得到执行。</li></ul><h2 id="自动注销"><a href="#自动注销" class="headerlink" title="自动注销"></a>自动注销</h2><p>处理这个问题最好的方式是什么呢？我的建议是：对观察对象进行一次封装。该封装类型的指责就是保持观察者对象并且在析构函数中自动将其注销。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Wraps the observer token received from </span></span><br><span class="line"><span class="comment">/// NotificationCenter.addObserver(forName:object:queue:using:)</span></span><br><span class="line"><span class="comment">/// and unregisters it in deinit.</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationToken</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> notificationCenter: <span class="type">NotificationCenter</span></span><br><span class="line">    <span class="keyword">let</span> token: <span class="type">Any</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(notificationCenter: <span class="type">NotificationCenter</span> = .<span class="keyword">default</span>, token: <span class="type">Any</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.notificationCenter = notificationCenter</span><br><span class="line">        <span class="keyword">self</span>.token = token</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        notificationCenter.removeObserver(token)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过封装处理，我们将观察者的生命周期和该类型实例进行了绑定。接下来我们只需要将该封装类型实例通过私有属性进行保存，那么其持有者就会 <em>deinit</em> 触发时销毁该封装实例紧接着销毁观察者实例对象。这样就不需要在代码中对其进行手动注销操作了。另外我们还可以将该实例声明为 <code>Optional &lt;Notification​Token&gt;</code> ，这样通过将其设置为 nil 也能进行手动注销操作。该模式被称为<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" target="_blank" rel="noopener"> <strong>资源获取即初始化</strong> （RAII）</a>。</p><p>接下来让我们为 <code>NotificationCenter</code> 编写一个便利点的方法，它为我们承担了包装观察接口的任务。 </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NotificationCenter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Convenience wrapper for addObserver(forName:object:queue:using:)</span></span><br><span class="line">    <span class="comment">/// that returns our custom NotificationToken.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">observe</span><span class="params">(name: NSNotification.Name?, object obj: Any?, </span></span></span><br><span class="line"><span class="function"><span class="params">    queue: OperationQueue?, using block: @escaping <span class="params">(Notification)</span></span></span> -&gt; ())</span><br><span class="line">    -&gt; <span class="type">NotificationToken</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> token = addObserver(forName: name, object: obj, queue: queue, using: block)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NotificationToken</span>(notificationCenter: <span class="keyword">self</span>, token: token)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此时将原有的 <code>addObserver(forName:​object:​queue:​using:)</code> 替换为新 API ，并将得到 <em>NotificationToken</em> 实例通过属性保存的话，你将不再需要手动注销操作了。</p><p>Chris 和 Florian 也在 <a href="https://talk.objc.io/episodes/S01E27-typed-notifications-part-1" target="_blank" rel="noopener"><strong>Swift Talk episode 27: Typed Notifications</strong></a> 中提到过该技术，我向你强烈的推荐它。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2018/01/notificationcenter-removeobserver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-01-05&lt;br&gt;译者：&lt;a href=&quot;https://bignerdcoding.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigNerdCoding&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;简单回答：需要 （在 iOS 11.2 上验证过）&lt;/p&gt;
&lt;p&gt;几周之前，我在 twitter 上提出了一个&lt;a href=&quot;https://twitter.com/olebegemann/status/938085544780877824&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;问题&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 iOS 11 中是否还需要手动移除基于 block 形式的通知观察者？苹果开发文档中比较模糊。&lt;a href=&quot;https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;addObserver(forName:object:queue:using:)&lt;/code&gt;&lt;/a&gt; 中说需要，而 &lt;a href=&quot;https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;removeObserver(_:)&lt;/code&gt;&lt;/a&gt; 中又表明 iOS 9 之后都不在需要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然我没有统计准确的数字，但是大致看来持不同意见的人差不多五五开。&lt;/p&gt;
&lt;p&gt;所以下面我们就来具体测试验证一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>在 Swift 中使用马尔可夫链生成文本</title>
    <link href="https://swift.gg/2018/07/23/friday-qa-2018-04-27-generating-text-with-markov-chains-in-swift/"/>
    <id>https://swift.gg/2018/07/23/friday-qa-2018-04-27-generating-text-with-markov-chains-in-swift/</id>
    <published>2018-07-23T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2018-04-27-generating-text-with-markov-chains-in-swift.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-28<br>译者：<a href="http://wuqiuhao.github.io" target="_blank" rel="noopener">Hale</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/u/2d46948e84e3" target="_blank" rel="noopener">mmoaay</a>，<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>马尔可夫链可用于快速生成真实但无意义的文本。今天，我将使用这种技术来创建一个基于这篇博客内容的文本生成器。这个灵感来源于读者 Jordan Pittman。</p><a id="more"></a><h2 id="马尔可夫链"><a href="#马尔可夫链" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h2><p>理论上讲，马尔可夫链是一种状态机，每一个状态转换都有一个与之相关的概率。你可以选择一个起始状态，然后随机地转换成其他状态，通过转移概率来加权，直到到达一个终止状态。</p><p>马尔可夫链有着<a href="https://en.wikipedia.org/wiki/Markov_chain#Steady-state_analysis_and_limiting_distributions" target="_blank" rel="noopener">广泛的应用</a>，但最有趣的是用于文本生成。在本文生成领域，每个状态是文本的一部分，通常是一个单词。状态和转换是由一些语料库生成的，然后遍历整个链并为每个状态输出单词来生成文本。这样生成的文本通常没有实际意义，因为该链不包含足够的信息来保留语料库的任何潜在含义及语法结构，但是缺乏意义本身却给文本带来了意料之外的乐趣。</p><h2 id="构建算法"><a href="#构建算法" class="headerlink" title="构建算法"></a>构建算法</h2><p>链中的节点由 <code>Word</code> 类的实例表示，此类将会为它所表示的单词保存一个字符串，同时持有一组指向其他单词的链接。</p><p>我们如何表示这一组链接呢？最直接的方法是采用某种计数的集合，它将存储其他 <code>Word</code> 实例以及在输入语料库中转换次数的计数。不过，从这样一个集合中随机选择一个链接可能会非常棘手。一个简单的方法是生成一个范围从 0 到集合元素总计数之间的随机数，然后遍历该集合直到取到很多的链接，然后选中你想要的链接。虽然这个方式简单，但可能比较耗时。另一种方法是预先生成一个数组，用于存储数组中每个链接的累积总数，然后对 0 和总数之间的随机数进行二分搜索。这相对来说更繁琐一些，但执行效率更高。如果你追求更好的方案，你其实可以做更多的预处理，并最终得到一个可以在<a href="http://www.keithschwarz.com/darts-dice-coins/" target="_blank" rel="noopener">常量时间内完成查询的紧凑结构</a>。</p><p>最终，我决定偷懒使用一种在空间上极其浪费，但在时间上效率很高且易于实现的结构。该结构每个 <code>Word</code> 包含一个后续 <code>Words</code> 的数组。如果一个链接被指向多次，那么将会保存重复的 <code>Words</code> 数组。在数组中选择一个随机索引，根据索引返回具有适当权重的随机元素。</p><p><code>Word</code> 类结构如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span> </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> str: <span class="type">String</span>?</span><br><span class="line">   <span class="keyword">var</span> links: [<span class="type">Word</span>] = []</span><br><span class="line"></span><br><span class="line">   <span class="keyword">init</span>(str: <span class="type">String</span>?) &#123;</span><br><span class="line">       <span class="keyword">self</span>.str = str</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">randomNext</span><span class="params">()</span></span> -&gt; <span class="type">Word</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> index = arc4random_uniform(<span class="type">UInt32</span>(links.<span class="built_in">count</span>))</span><br><span class="line">       <span class="keyword">return</span> links[<span class="type">Int</span>(index)]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>links</code> 数组可能会导致大量循环引用。为了避免内存泄漏，我们需要手动清理那些内存。</p><p>我们引入 <code>Chain</code> 类，它将管理链中所有的 <code>Words</code> 。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> words: [<span class="type">String</span>?: <span class="type">Word</span>] = [:]</span><br></pre></td></tr></table></figure><p>在 <code>deinit</code> 方法中，清除所有的 <code>links</code> 数组，以消除所有的循环引用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words.values &#123;</span><br><span class="line">        word.links = []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有这一步，许多单词实例的内存都会泄漏。</p><p>现在让我们看看如何将单词添加到链中。<code>add</code> 方法需要一个字符串数组，该数组中每一个元素都保存着一个单词（或调用者希望使用的其他任何字符串）:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> words: [String])</span></span> &#123;</span><br></pre></td></tr></table></figure><p>如果链中没有单词，那么提前返回。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> words.isEmpty &#123; <span class="keyword">return</span> &#125;</span><br></pre></td></tr></table></figure><p>我们想要遍历那些成对的单词，遍历规则是第二个元素的第一个单词紧随第一个元素后面的单词。例如，在句子 “Help, I’m being oppressed,” 中，我们要迭代 <code>(&quot;Help&quot;, &quot;I&#39;m&quot;)</code> ， <code>(&quot;I&#39;m&quot;, &quot;being&quot;)</code> ， <code>(&quot;being&quot;, &quot;oppressed&quot;)</code> 。</p><p>实际上，还需要多做一点事情，因为我们需要编码句子的开头和结尾。我们将句子的开头和结尾用 <code>nil</code> 表示，所以我们要迭代的实际序列是 <code>(nil, &quot;Help&quot;)</code> ， <code>(&quot;Help&quot;, &quot;I&#39;m&quot;)</code> ， <code>(&quot;I&#39;m&quot;, &quot;being&quot;)</code> ， <code>(&quot;being&quot;, &quot;oppressed&quot;)</code> ， <code>(&quot;oppressed&quot;, nil)</code> 。</p><p>为了允许值为 <code>nil</code> ， 我们的数组声明为 <code>String?</code> 类型，而不是 <code>String</code>  类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> words = words <span class="keyword">as</span> [<span class="type">String</span>?]</span><br></pre></td></tr></table></figure><p>接下来构造两个数组，一个头部添加 <code>nil</code>，另一个尾部添加 <code>nil</code>。把它们通过 <code>zip</code> 合并在一起生成我们想要的序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wordPairs = <span class="built_in">zip</span>([<span class="literal">nil</span>] + words, words + [<span class="literal">nil</span>])</span><br><span class="line"><span class="keyword">for</span> (first, second) <span class="keyword">in</span> wordPairs &#123;</span><br></pre></td></tr></table></figure><p>对于这一对中的每个单词，我们使用一个辅助方法来获取相应的 <code>Word</code> 对象：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstWord = word(first)</span><br><span class="line"><span class="keyword">let</span> secondWord = word(second)</span><br></pre></td></tr></table></figure><p>然后把第二个单词添加到第一个单词的链接中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">        firstWord.links.append(secondWord)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Word</code> 辅助方法从 <code>words</code> 字典中提取实例，如果实例不存在就创建一个新实例并将其放入字典中。这样就不用担心字符串匹配不到单词：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">word</span><span class="params">(<span class="number">_</span> str: String?)</span></span> -&gt; <span class="type">Word</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> word = words[str] &#123;</span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> word = <span class="type">Word</span>(str: str)</span><br><span class="line">        words[str] = word</span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后生成我们要的单词序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br></pre></td></tr></table></figure><p>我们将逐个生成单词，并将他们存储在下面的数组中:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result: [<span class="type">String</span>] = []</span><br></pre></td></tr></table></figure><p>这是一个无限循环。因为退出条件没有清晰的映射到循环条件，代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br></pre></td></tr></table></figure><p>在 <code>result</code> 中获取最后一个字符串构成 <code>Word</code> 实例。这很好地处理了当 <code>result</code> 为空时的初始情况，因为一旦 <code>last</code> 取值为 <code>nil</code> 就表示第一个单词：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currentWord = word(result.last)</span><br></pre></td></tr></table></figure><p>随机获取链接的词：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nextWord = currentWord.randomNext()</span><br></pre></td></tr></table></figure><p>如果链接的单词不是结尾，将其追加到 <code>result</code> 中。如果是结束，则终止循环：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> str = nextWord.str &#123;</span><br><span class="line">        result.append(str)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回包含所有单词的 <code>result</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一件事：我们正在使用 <code>String?</code> 作为 <code>words</code> 的键类型，但 <code>Optional</code> 不符合 <code>Hashable</code> 协议。下面是一个扩展，当它的封装类型遵循 <code>Hashable</code> 时添加 <code>Optional</code> 对 <code>Hashable</code> 的实现：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span>: <span class="title">Hashable</span> <span class="title">where</span> <span class="title">Wrapped</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> wrapped?: <span class="keyword">return</span> wrapped.hashValue</span><br><span class="line">        <span class="keyword">case</span> .<span class="keyword">none</span>: <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>备注：Swift 4.2 中 <code>Optional</code> 类型已默认实现 <code>Hashable</code> 协议</p></blockquote><h2 id="生成输入数据"><a href="#生成输入数据" class="headerlink" title="生成输入数据"></a>生成输入数据</h2><p>以上就是马尔可夫链的结构，下面我们输入一些真实文本试试看。</p><p>我决定从 <code>RSS</code> 提要中提取文本。还有什么比用我自己博客全文作为输入更好的选择呢？</p><p><code>let feedURL = URL(string: &quot;https://www.mikeash.com/pyblog/rss.py?mode=fulltext&quot;)!</code></p><p><code>RSS</code> 是一种 <code>XML</code> 格式，所以我们使用 <code>XMLDocument</code> 来解析它：</p><p><code>let xmlDocument = try! XMLDocument(contentsOf: feedURL, options: [])</code></p><p>文章主体被嵌套在 <code>item</code> 节点下的 <code>description</code> 节点。通过 <code>XPath</code> 查询检索：</p><p><code>let descriptionNodes = try! xmlDocument.nodes(forXPath: &quot;//item/description&quot;)</code></p><p>我们需要 <code>XML</code> 节点中的字符串，所以我们从中提取并过滤掉为 <code>nil</code> 的内容。</p><p><code>let descriptionHTMLs = descriptionNodes.compactMap({ $0.stringValue })</code></p><p>我们根本不用关心标签。<code>NSAttributedString</code> 可以解析 <code>HTML</code> 并生成一个 <code>AttributedString</code>，然后我们可以过滤它：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> descriptionStrings = descriptionHTMLs.<span class="built_in">map</span>(&#123;</span><br><span class="line">   <span class="type">NSAttributedString</span>(html: $<span class="number">0</span>.data(using: .utf8)!, options: [:], documentAttributes: <span class="literal">nil</span>)!.string</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们需要一个将字符串分解成若干部分的函数。我们的目的是生成 String 数组，每个数组对应文本里的一句话。一段文本可能会有很多句话，所以 <code>wordSequences</code> 函数会返回一个 String 的二维数组：</p><p><code>func wordSequences(in str: String) -&gt; [[String]] {</code></p><p>然后我们将处理结果存储在一个局部变量中：</p><p><code>var result: [[String]] = []</code></p><p>将字符串分解成句子并不简单。你可以直接搜索标点符号，但需要考虑到像 <code>“Mr. Jock, TV quiz Ph.D., bags few lynx.”</code> 这样的句子，按照标点符号会被分割成四段，但这是一个完整的句子。</p><p><code>NSString</code> 提供了一些智能检查字符串部分的方法，前提是你需要 <code>import Foundation</code> 。我们会枚举 <code>str</code> 包含的句子，并让 <code>Foundation</code> 进行处理：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">str.enumerateSubstrings(<span class="keyword">in</span>: str.startIndex..., options: .bySentences, &#123; substring, substringRange, enclosingRange, stop <span class="keyword">in</span></span><br></pre></td></tr></table></figure><p>在将句子拆分成单词的时候会遇到相似的问题。<code>NSString</code> 也提供了一种用于枚举词的方法，但是存在一些问题，例如丢失标点符号。我最终决定用一种愚蠢的方式来进行单词分割，只按空格进行分割。这意味着你最终将包含标点符号的单词作为字符串的一部分。与标点符号被删除相比，这更多地限制了马尔可夫链，但另一方面，输出会包含合理的标点符号。我觉得这个折中方案还不错。</p><p>一些换行符会进入数据集，我们首先将这些换行符移除：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> words = substring!.<span class="built_in">split</span>(separator: <span class="string">" "</span>).<span class="built_in">map</span>(&#123;</span><br><span class="line">    $<span class="number">0</span>.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.newlines)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>分割的句子最终被添加到 <code>result</code> 中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    result.append(words)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>枚举完成后，根据输入的句子计算出 <code>result</code> ，然后将其返回给调用者：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到主代码。现在已经有办法将字符串转换为句子列表，我们就可以继续构建自己的马尔可夫链。首先我们创建一个空的 <code>Chain</code> 对象：</p><p><code>let chain = Chain()</code></p><p>然后我们遍历所有的字符串，提取句子，并将它们添加到链中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> str <span class="keyword">in</span> descriptionStrings &#123;</span><br><span class="line">   <span class="keyword">for</span> sentence <span class="keyword">in</span> wordSequences(<span class="keyword">in</span>: str) &#123;</span><br><span class="line">       chain.add(sentence)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步当然是生成一些新句子！我们调用 <code>generate()</code>，然后用空格连接结果。输出结果可能命中也可能不命中（考虑到该技术的随机性，这并不奇怪），所以我们会多生成一些：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span> ..&lt; <span class="number">200</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"\""</span> + chain.generate().joined(separator: <span class="string">" "</span>) + <span class="string">"\""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h2><p>为了演示，下面是这个程序的一些示例输出：</p><ul><li>“We’re ready to be small, weak references in New York City.”</li><li>“It thus makes no values?”</li><li>“Simple JSON tasks, it’s wasteful if you can be.”</li><li>“Another problem, but it would make things more programming-related mystery goo.”</li><li>“The escalating delays after excessive focus on Friday, September 29th.”</li><li>“You may not set.”</li><li>“Declare conformance to use = Self.init() to detect the requested values.”</li><li>“The tagged pointer is inlined at this nature; even hundreds of software and writing out at 64 bits wide.”</li><li>“We’re ready to express that it works by reader ideas, so the decoding methods for great while, it’s inaccessible to 0xa4, which takes care of increasing addresses as the timing.”</li><li>“APIs which is mostly a one-sided use it yourself?”</li><li>“There’s no surprise.”</li><li>“I wasn’t sure why I’ve been called ‘zero-cost’ in control both take serious effort to miss instead of ARC and games.”</li><li>“For now, we can look at the filesystem.”</li><li>“The intent is intended as reader-writer locks.”</li><li>“For example, we can use of the code?”</li><li>“Swift’s generics can all fields of Swift programming, with them is no parameters are static subscript, these instantiate self = cluster.reduce(0, +) / Double(cluster.count)”</li><li>“However, the common case, you to the left-hand side tables.”</li></ul><p>上面有很多无意义的句子，所以你必须深入挖掘才能找到有意义的句子，但不可否认马尔可夫链可以产生一些非常有趣的输出。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>马尔可夫链有许多实际用途，在用于生成文本时它可能显得比较有趣但不是很实用。除了展示了其娱乐性之外，该代码还说明了在没有明确引用关系的情况下如何处理循环引用，如何灵活地使用 <code>NSString</code> 提供的枚举方法从文本中提取特征，以及简要说明了条件一致性（<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0143-conditional-conformances.md" target="_blank" rel="noopener">conditional conformances</a>）的优点。</p><p>今天就讲这些。期待下次一起分享更多的乐趣，在娱乐中进行学习。<code>Friday Q&amp;A</code> 是由读者的想法驱动的，所以如果你有一些想在这里看到的话题，请给我<a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发送邮件</a>！</p><blockquote><p>你喜欢这篇文章吗？我正在卖收录了这些文章的一本书！第二卷和第三卷现在也出来了！包括 ePub，PDF，实体版以及 iBook 和 Kindle。<a href="https://www.mikeash.com/book.html" target="_blank" rel="noopener">点击这里查看更多信息</a>。</p></blockquote><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了使用 Swift 来构造马尔可夫链结构，并使用该结构指定输入数据源随机生成文本。
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift Package Manager 重写 macOS 部署目标</title>
    <link href="https://swift.gg/2018/07/19/swift-3-1-package-manager-deployment-target/"/>
    <id>https://swift.gg/2018/07/19/swift-3-1-package-manager-deployment-target/</id>
    <published>2018-07-19T00:00:00.000Z</published>
    <updated>2018-10-11T13:39:19.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2017/04/swift-3-1-package-manager-deployment-target/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-04-07<br>译者：<a href="undefined">EyreFree</a>；校对：<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>，<a href="undefined">Firecrest</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Swift 3.1 修复了 <a href="https://swift.org/package-manager/" target="_blank" rel="noopener">Swift Package Manager</a> 无法重写 MacOS 部署目标的 Bug。</p><p>当你在 macOS 上执行 <code>swift build</code> 命令时，包管理器目前（Swift 3.0 和 3.1）会将部署目标硬编码为 macOS 10.10 ¹  现已证明是命令参数的一个 <a href="https://bugs.swift.org/browse/SR-2535" target="_blank" rel="noopener">Bug</a> 引起的 Swift 3.0 中无法重写部署目标这个问题。</p><a id="more"></a><p>因此，你不能轻松编译用到了最新 API 的代码 ²  举个栗子，假设有一个非常简单的包，只包含几行代码在一个源文件中。这个程序用到了 macOS 10.12 引入的新的 <a href="https://oleb.net/blog/2016/07/measurements-and-units/" target="_blank" rel="noopener">单位和测量类型</a> 来将一个值从以 km/h 转换为 m/s ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.swift</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> kph = <span class="type">Measurement</span>(value: <span class="number">100</span>,</span><br><span class="line">    unit: <span class="type">UnitSpeed</span>.kilometersPerHour)</span><br><span class="line"><span class="keyword">let</span> mps = kph.converted(to: .metersPerSecond)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(kph)</span> is <span class="subst">\(mps)</span>"</span>)</span><br></pre></td></tr></table></figure><p>在 macOS（Swift 3.0 或 3.1）上用 <code>swift build</code> 命令编译上面这段代码会报错，因为这段代码用到的 API 在 macOS 10.10 上不可用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swift build</span><br><span class="line">Compile Swift Module <span class="string">'Units'</span> (1 sources)</span><br><span class="line">main.swift:3:11: error: <span class="string">'Measurement'</span> is only available on OS X 10.12 or newer</span><br><span class="line"><span class="built_in">let</span> kph = Measurement(value: 100,</span><br><span class="line">          ^</span><br><span class="line">main.swift:3:11: note: add <span class="string">'if #available'</span> version check</span><br><span class="line"><span class="built_in">let</span> kph = Measurement(value: 100,</span><br><span class="line">          ^</span><br><span class="line">...</span><br><span class="line">&lt;unknown&gt;:0: error: build had 1 <span class="built_in">command</span> failures</span><br><span class="line">error: <span class="built_in">exit</span>(1): /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift-build-tool -f .build/debug.yaml</span><br></pre></td></tr></table></figure><p>在 Swift 3.1 中，你可以在命令行中修改部署目标，如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swift build -Xswiftc <span class="string">"-target"</span> \</span><br><span class="line">    -Xswiftc <span class="string">"x86_64-apple-macosx10.12"</span></span><br><span class="line">Compile Swift Module <span class="string">'Units'</span> (1 sources)</span><br><span class="line">Linking ./.build/debug/Units</span><br></pre></td></tr></table></figure><p>现在，你可以正常执行之前的这段代码了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ .build/debug/Units</span><br><span class="line">100.0 km/h is 27.7778 m/s</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>除了部署目标，另一个常见的自定义编译设置例子是传递一个 <code>DEBUG</code> 标志给编译器，所以可以在你的代码中使用 <code>#if DEBUG/#endif</code> 代码段作为标志传递给编译器，从而来判断是否处于 Debug 模式 - 当前包管理器并没有在 Debug 构建模式下自动完成这些工作。你可以通过 <code>swift build -Xswiftc &quot;-D&quot; -Xswiftc &quot;DEBUG&quot;</code> 命令实现这一目的。</p><p>这仍然不够理想 - 你在每次执行 <code>swift build</code> 或 <code>swift test</code> 命令时都需要手动输入命令行参数 - 但至少这是可行的。</p><p>对于包管理器来说能够在包配置清单中指定自定义编译设置是 <a href="https://lists.swift.org/pipermail/swift-evolution-announce/2017-January/000307.html" target="_blank" rel="noopener">Swift 4 路线图</a>的一部分。我猜我们很快就会看到一个和这一特性有关的 <a href="https://apple.github.io/swift-evolution/" target="_blank" rel="noopener">Swift 发展提案</a>。</p><hr><ol><li>你可以通过添加如下代码段到你的 <code>main.swift</code> 文件然后编译并执行对应包的方式来验证这一点：</li></ol><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> os(macOS)</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"macOS deployment target:"</span>, __MAC_OS_X_VERSION_MIN_REQUIRED)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>如果在 macOS 执行，将会打印：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">macOS deployment target: 101000</span><br></pre></td></tr></table></figure><ol start="2"><li>你必须把所有依赖新 API 的代码用 <code>if #available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *) { ... }</code> 或类似的 block 进行包裹。</li></ol><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2017/04/swift-3-1-package-manager-deployment-target/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-04-07&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;EyreFree&lt;/a&gt;；校对：&lt;a href=&quot;https://weibo.com/1743643682/profile?topnav=1&amp;amp;wvr=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;liberalism&lt;/a&gt;，&lt;a href=&quot;undefined&quot;&gt;Firecrest&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 3.1 修复了 &lt;a href=&quot;https://swift.org/package-manager/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift Package Manager&lt;/a&gt; 无法重写 MacOS 部署目标的 Bug。&lt;/p&gt;
&lt;p&gt;当你在 macOS 上执行 &lt;code&gt;swift build&lt;/code&gt; 命令时，包管理器目前（Swift 3.0 和 3.1）会将部署目标硬编码为 macOS 10.10 ¹  现已证明是命令参数的一个 &lt;a href=&quot;https://bugs.swift.org/browse/SR-2535&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bug&lt;/a&gt; 引起的 Swift 3.0 中无法重写部署目标这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
