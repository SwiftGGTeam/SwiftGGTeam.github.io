<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftGG</title>
  
  <subtitle>走心的 Swift 翻译组</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swift.gg/"/>
  <updated>2018-09-18T06:56:59.958Z</updated>
  <id>https://swift.gg/</id>
  
  <author>
    <name>SwiftGG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 中的属性</title>
    <link href="https://swift.gg/2018/09/18/properties-in-swift/"/>
    <id>https://swift.gg/2018/09/18/properties-in-swift/</id>
    <published>2018-09-18T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/properties-in-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-03-15<br>译者：<a href="undefined">Sunnyyoung</a>；校对：<a href="http://linusling.com" target="_blank" rel="noopener">小铁匠Linus</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>Swift 中有两种类型的属性：存储属性与计算属性。存储属性将值（常量或者变量）保存为实例或类型的一部分，而计算属性没有存储值。</p><p>提示：这篇文章已经更新至 Swift 4。</p><a id="more"></a><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p>让我们从存储属性开始看起。想象一下你有一个名为 Circle 的类：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line">circle.radius = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"radius: <span class="subst">\(circle.radius)</span>"</span>) <span class="comment">//radius: 10.0</span></span><br></pre></td></tr></table></figure><p>Circle 拥有名为 <code>radius</code> 的实例变量，默认值为 0。在 Swift 中，每个实例变量都为一个属性。因此你可以添加所谓的属性观察者。在 Swift 中有两种类型的属性观察者：一种在赋值之前调用，另一种在赋值之后调用。</p><p>在赋值后调用的属性观察者采用 <code>didSet</code> 关键字标记。在我们的示例中，你可以使用它来监测新设置的值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">                radius = oldValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line"> </span><br><span class="line">circle.radius = -<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"radius: <span class="subst">\(circle.radius)</span>"</span>) <span class="comment">//radius: 0.0</span></span><br><span class="line"> </span><br><span class="line">circle.radius = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"radius: <span class="subst">\(circle.radius)</span>"</span>) <span class="comment">//radius: 10.0</span></span><br></pre></td></tr></table></figure><p>在属性观察者中你可以通过变量 <code>oldValue</code> 来访问属性的旧值。</p><p>你还可以使用 <code>willSet</code> 属性观察者，它在赋值之前会被调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"About to assign the new value <span class="subst">\(newValue)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">                radius = oldValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line"> </span><br><span class="line">circle.radius = <span class="number">10</span> <span class="comment">//设置新值 10.0</span></span><br></pre></td></tr></table></figure><p>在 <code>willSet</code> 中，你可以通过变量 <code>newValue</code> 来访问属性的新值。</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>与存储属性不同的是，计算属性并不会存储属性的值。因此在每次调用计算属性时，都要计算该值。在 <code>Circle</code> 类中，你可以将属性 <code>area</code> 定义为计算属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">                radius = oldValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> radius * radius * <span class="type">Double</span>.pi</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line">circle.radius = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"area: <span class="subst">\(circle.area)</span>"</span>) <span class="comment">//area: 78.5398163397448</span></span><br></pre></td></tr></table></figure><p>计算属性总是需要一个 <code>getter</code>。如果缺少 <code>setter</code>，则该属性被称为只读属性。下面这个例子很好地说明了 <code>setter</code> 的作用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">                radius = oldValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> radius * radius * <span class="type">Double</span>.pi</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newArea) &#123;</span><br><span class="line">            radius = sqrt(newArea / <span class="type">Double</span>.pi)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line"></span><br><span class="line">circle.area = <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"radius: <span class="subst">\(circle.radius)</span>"</span>) <span class="comment">//radius: 2.82094791773878</span></span><br></pre></td></tr></table></figure><p>至此，每次对 area 设置了新的值之后，radius 都会被重新计算。</p><h2 id="存储属性的初始化"><a href="#存储属性的初始化" class="headerlink" title="存储属性的初始化"></a>存储属性的初始化</h2><p>每个存储属性在它的对象实例化之后都必须有值。属性初始化有两种方法：</p><ul><li>在 <code>init</code> 方法中初始化值</li><li>给属性设置默认的值</li></ul><p>下面的例子同时使用了这两种方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(radius: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.radius = radius</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> circle = <span class="type">Circle</span>(radius: <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>如果存储属性在对象实例化之后没有值，代码无法通过编译。</p><h2 id="懒加载属性"><a href="#懒加载属性" class="headerlink" title="懒加载属性"></a>懒加载属性</h2><p>如果具有默认值的存储属性使用了关键字 <code>lazy</code> 标记，则其默认值不会立即初始化，而是在第一次访问该属性时初始化。</p><p>因此，如果该属性从未被访问，它将永远不会被初始化。你可以将这种特性应用于一些特别耗费 CPU 或内存的初始化上。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> testString: <span class="type">String</span> = <span class="string">"TestString"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> testClass = <span class="type">TestClass</span>()</span><br><span class="line"><span class="built_in">print</span>(testClass.testString) <span class="comment">//TestString</span></span><br></pre></td></tr></table></figure><p>该属性在被访问之前不会进行初始化。在这个例子中并不容易看出来。但由于初始化也可以在 block 里面实现，我们可以使它更明显一些：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> testString: <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"about to initialize the property"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TestString"</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testClass = <span class="type">TestClass</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"before first call"</span>)</span><br><span class="line"><span class="built_in">print</span>(testClass.testString)</span><br><span class="line"><span class="built_in">print</span>(testClass.testString)</span><br></pre></td></tr></table></figure><p>这个例子的输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">before first call</span><br><span class="line">about to initialize the property</span><br><span class="line">TestString</span><br><span class="line">TestString</span><br></pre></td></tr></table></figure><p>这意味着该 block 仅被调用一次 - 第一次访问该属性的时候。由于存储属性是可变的，因此可以更改初始值。</p><h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><p>类型属性是类的一部分，但不是实例的一部分，类型属性也被称为静态属性。存储属性和计算属性都可以是类型属性。类型属性的关键字是 <code>static</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> testString: <span class="type">String</span> = <span class="string">"TestString"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(TestClass.testString)</span>"</span>) <span class="comment">//TestString</span></span><br></pre></td></tr></table></figure><p>如你所见，它们使用类名而不是实例对象来访问它们。此外，由于类型属性没有初始化方法，它总是需要一个默认值。</p><h2 id="拥有私有-Setter-的公共属性"><a href="#拥有私有-Setter-的公共属性" class="headerlink" title="拥有私有 Setter 的公共属性"></a>拥有私有 Setter 的公共属性</h2><p>正如我在 <a href="http://www.thomashanning.com/public-properties-with-private-setters/" target="_blank" rel="noopener">另一篇文章</a> 中介绍的那样，这是一种常见的情况，你不想提供一个公共的 setter，而是提供一个私有的 setter。这是封装的基本原则。这样只有类本身可以操作该属性，但仍可从类外部访问读取它。</p><p>来看下面的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> area: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> diameter: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> radius: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            calculateFigures()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(radius:<span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.radius = radius</span><br><span class="line">        calculateFigures()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">calculateFigures</span><span class="params">()</span></span> &#123;</span><br><span class="line">        area = <span class="type">Double</span>.pi * radius * radius</span><br><span class="line">        diameter = <span class="number">2</span> * <span class="type">Double</span>.pi * radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>(radius: <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"area: <span class="subst">\(circle.area)</span>"</span>) <span class="comment">//area: 78.5398163397448</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"diameter: <span class="subst">\(circle.diameter)</span>"</span>) <span class="comment">//diameter: 31.4159265358979</span></span><br><span class="line"></span><br><span class="line">circle.area = <span class="number">10</span> <span class="comment">//编译错误：无法对 'area' 属性进行赋值，因为 setter 方法不可访问</span></span><br></pre></td></tr></table></figure><p>这里的属性 <code>area</code> 和 <code>diameter</code> 可以从类的外部访问，但只能在类内部赋值。为此你必须使用 <code>public private(set)</code> 的组合。根据本人的经验，这个特性在 iOS 开发中很少使用，但它对写出更少 bug 的代码很有帮助。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文简单介绍了 Swift 中的属性
    
    </summary>
    
      <category term="Thomas Hanning" scheme="https://swift.gg/categories/Thomas-Hanning/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>在序列的链式操作中注入副作用</title>
    <link href="https://swift.gg/2018/09/13/chained-foreach/"/>
    <id>https://swift.gg/2018/09/13/chained-foreach/</id>
    <published>2018-09-13T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://oleb.net/blog/2017/10/chained-foreach/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017/10/30<br>译者：<a href="https://dingtz.com/" target="_blank" rel="noopener">jojotov</a>；校对：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>，<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>几周前，一位读者指出了 <a href="https://oleb.net/advanced-swift/" target="_blank" rel="noopener"><em>Advanced Swift</em></a> 中的<a href="https://twitter.com/jasonalexzurita/status/915972380685516800" target="_blank" rel="noopener">一处错误</a>。我们当时这样描述 Swift 中的 <code>forEach</code> 方法：</p><blockquote><p><code>forEach</code> 作为一系列链式调用中的一部分时确实可以大放异彩。举个例子，试想一下你在一个语句中通过链式调用的方式调用了几次 <code>map</code> 和 <code>filter</code> 方法。在调试这段代码时，你希望能够打印出某几步操作中间的值。要达成这一目的，在你期望的位置插入一个 <code>forEach</code> 或许是最快速的解决方式。</p></blockquote><p>当我写下这段描述时，众多美妙的想法涌现在我脑中，因为这听起来是个非常实用的特性<a href="#foot1" id="1"><sup>[1]</sup></a>（你并不能通过 <code>for-in</code> 循环达到这种效果）。可事实却如此的残酷 —— 你不能在一系列链式调用中间插入 <code>forEach</code>！</p><a id="more"></a><h2 id="理想中的形式"><a href="#理想中的形式" class="headerlink" title="理想中的形式"></a>理想中的形式</h2><p>为了以代码的形式更好地阐述我的想法，先让我们设想有如下一系列的链式调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = <span class="number">1</span>...<span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> sumOfSquaredEvenNumbers = numbers</span><br><span class="line">    .<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line">    .<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line"><span class="comment">// → 220</span></span><br></pre></td></tr></table></figure><p>现在假设我们希望确认一下每个链式操作是否达到了预期的效果 —— 例如 <code>filter</code> 和（或） <code>map</code> 操作后的返回值是否正确，最简洁的方式当然是在两个操作中间插入类似 <code>.forEach { print($0) }</code> 的调用。</p><p>但为什么 <code>forEach</code> 并不支持类似这样的使用方式呢？原因在于，在一系列链式调用中间的任何操作，都必须返回一个遵循 <a href="https://developer.apple.com/documentation/swift/sequence" target="_blank" rel="noopener"><code>Sequence</code></a> 协议的对象，这样下一个链式操作才能正常执行。而 <code>forEach</code> 的返回值为 <code>()</code>，因此它只能在一系列链式操作的结尾处调用。</p><h2 id="实现一个返回-Self-的-forEach"><a href="#实现一个返回-Self-的-forEach" class="headerlink" title="实现一个返回 Self 的 forEach"></a>实现一个返回 <code>Self</code> 的 <code>forEach</code></h2><p>值得庆幸的一点是，实现这个功能并不困难。我们所需要做的事情只是实现一个方法 —— 它能够遍历序列，并对每个元素执行一次传入的函数（就像 <code>forEach</code> 一样），最后返回自己（这样链式操作就能够无感知地继续进行）。换句话来说，这个方法的返回值类型应为 <code>Self</code>。为了避免在类型检查的时候这个方法与原生的 <code>forEach</code> 发生混淆，我把它命名为 <code>forEachPerform</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Perform a side effect for each element in `self`.</span></span><br><span class="line">    @discardableResult</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">forEachPerform</span><span class="params">(<span class="number">_</span> body: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; ())</span><br><span class="line">        <span class="keyword">rethrows</span> -&gt; <span class="type">Self</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> forEach(body)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>forEach</code> 不同，我们可以插入这个方法到一系列链式操作中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sumOfSquaredEvenNumbers = numbers</span><br><span class="line">    .<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">    .forEachPerform &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line">    .<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line"><span class="comment">/* Prints:</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>除此之外，我还添加了另一个非常有用的方法。这个方法只会对整个序列调用传入参数中的函数一次，而不会遍历序列并对每一个元素都调用一次。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Perform a side effect.</span></span><br><span class="line">    @discardableResult</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(<span class="number">_</span> body: <span class="params">(<span class="keyword">Self</span>)</span></span></span> <span class="keyword">throws</span> -&gt; ())</span><br><span class="line">        <span class="keyword">rethrows</span> -&gt; <span class="type">Self</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> body(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个方法可以完美地打印每一步链式操作的中间值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sumOfSquaredEvenNumbers = numbers</span><br><span class="line">    .<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">    .perform &#123; <span class="built_in">print</span>(<span class="string">"After filter: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line">    .perform &#123; <span class="built_in">print</span>(<span class="string">"After map: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</span><br><span class="line">    .<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line"><span class="comment">/* Prints:</span></span><br><span class="line"><span class="comment">After filter: [2, 4, 6, 8, 10]</span></span><br><span class="line"><span class="comment">After map: [4, 16, 36, 64, 100]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="自毁序列"><a href="#自毁序列" class="headerlink" title="自毁序列"></a>自毁序列</h2><p>我们新添加的方法返回了一个未修改过的 <code>self</code>，因此把它插入一系列链式调用中是完全没有影响的。但我们需要注意， <code>Sequence</code> 协议目前的代码实现中并没有保证多次的迭代返回完全相同的序列。</p><blockquote><p>译者注:</p><p>苹果官方 <code>Sequence</code> 的文档中有一段关与 <a href="https://developer.apple.com/documentation/swift/sequence#Repeated%20Access" target="_blank" rel="noopener">Repeated Access</a> 的描述：</p><p>The <code>Sequence</code> protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple <code>for</code>-<code>in</code> loops on a sequence will either resume iteration or restart from the beginning:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> element <span class="keyword">in</span> sequence &#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> ... some condition &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">for</span> element <span class="keyword">in</span> sequence &#123;</span><br><span class="line">&gt;     <span class="comment">// No defined behavior</span></span><br><span class="line">&gt; &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>大多数遵循 <code>Sequence</code> 的类型会确保上面的这种情况不会发生（例如 <a href="https://developer.apple.com/documentation/swift/array" target="_blank" rel="noopener"><code>Array</code></a>），但假设你有一个可以用于接收来自网络 socket 的字节流的 <code>Sequence</code> 类型——调用 <code>forEachPerform</code> 或者 <code>perform</code> 会打乱其顺序，导致随后操作中的数据不能被正确处理。</p><p>如果你的代码中存在上述问题，你可以选择让 <code>forEachPerform</code> 和 <code>perform</code> 方法返回一个 <code>Array&lt;Element&gt;</code> 类型（这样可以把可破坏的序列隐式转换为可重复的序列），或者可以把这些方法加到  <a href="https://developer.apple.com/documentation/swift/collection" target="_blank" rel="noopener"><code>Collection</code></a> 中（<code>Collection</code> 类型保证了迭代不会破坏顺序）。</p><h2 id="让它变“懒”"><a href="#让它变“懒”" class="headerlink" title="让它变“懒”"></a>让它变“懒”</h2><p><code>forEachPerform</code> 有个不太容易发现的问题：如果我们把它放在 <strong><em>惰性队列 (lazy sequences)</em></strong> 的链式调用之间，惰性队列会失去其原本的惰性。</p><p>惰性队列的设计初衷是为了把所有需要对下一个元素所做的工作都尽可能地延迟进行 —— 也就是说，当一个惰性序列的链式调用的最终返回值需要被获取时，那些被 ”延迟“ 的工作才会真正执行。由于 <code>forEachPerform</code> 的实现中遍历了序列的每个元素，我们让这个队列的任何惰性都被破坏了。</p><p>为了保证序列的惰性，我们可以定义一个自己的惰性迭代器以及序列类型，分别命名为 <code>LazyForEachIterator</code> 和 <code>LazyForEachSequence</code>。它们的工作与标准库中类似的类型相差无几：它们会把传入的函数以及序列 <em>保存</em> 起来，而不是立即执行传入的函数。<em>直到</em> 某个操作访问到下个元素时，它们才会轮流尝试获取原本序列的下一个元素，并执行相应的操作。</p><p>实现代码大概如此：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LazyForEachIterator</span>&lt;<span class="title">Base</span>: <span class="title">IteratorProtocol</span>&gt;</span></span><br><span class="line"><span class="class">    : <span class="title">IteratorProtocol</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Base</span>.<span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> nextElement = base.next() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        perform(nextElement)</span><br><span class="line">        <span class="keyword">return</span> nextElement</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> base: <span class="type">Base</span></span><br><span class="line">    <span class="keyword">let</span> perform: (<span class="type">Base</span>.<span class="type">Element</span>) -&gt; ()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LazyForEachSequence</span>&lt;<span class="title">Base</span>: <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class">    : <span class="title">LazySequenceProtocol</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span></span><br><span class="line">        -&gt; <span class="type">LazyForEachIterator</span>&lt;<span class="type">Base</span>.<span class="type">Iterator</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">LazyForEachIterator</span>(</span><br><span class="line">            base: base.makeIterator(),</span><br><span class="line">            perform: perform)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> base: <span class="type">Base</span></span><br><span class="line">    <span class="keyword">let</span> perform: (<span class="type">Base</span>.<span class="type">Element</span>) -&gt; ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这个序列遵循 <a href="https://developer.apple.com/documentation/swift/lazysequenceprotocol" target="_blank" rel="noopener"><code>LazySequenceProtocol</code></a> 协议。此协议继承于 <code>Sequence</code>。这个协议的职责是为一些即刻响应的操作（译者注：例如 <code>map</code> 和 <code>filter</code>）提供了惰性实现。</p><blockquote><p>译者注:</p><p>关于“即刻响应的操作”（原文中为 <em>normally-eager operations</em>），<code>LazySequenceProtocol</code> 的<a href="https://developer.apple.com/documentation/swift/lazysequenceprotocol" target="_blank" rel="noopener">官方文档</a>中有这样一段解释：</p><p>Sequence operations taking closure arguments, such as <code>map</code> and <code>filter</code>, are normally eager: they use the closure immediately and return a new array. </p><p>同时，文档紧跟着解释了 <code>lazy</code> 是如何让这种 <em>normally-eager operations</em> 变成惰性操作的：</p><p>Using the <code>lazy</code> property gives the standard library explicit permission to store the closure and the sequence in the result, and defer computation until it is needed.</p></blockquote><p>Swift 的类型推断机制其中一条规则是：在给定的约束的前提下，Swift 编译器会自动选择一个最明确且可工作的重载（译者注：可查看官方文档 <a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID322" target="_blank" rel="noopener">Type Safety and Type Inference</a> ）。因此，当你对一个遵循了 <code>LazySequenceProtocol</code> 协议的值调用诸如 <code>map</code> 的方法时，编译器会倾向于 <code>map</code> 方法的惰性变体而非默认版本实现。</p><p>为了在我们的方法中实现同样的效果，我们可以在 <code>LazySequenceProtocol</code> 的扩展中加入一个 <code>forEachPerform</code> 的变体，同时让它返回一个惰性序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LazySequenceProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">forEachPerform</span><span class="params">(<span class="number">_</span> body: @escaping <span class="params">(Element)</span></span></span> -&gt; ())</span><br><span class="line">        -&gt; <span class="type">LazyForEachSequence</span>&lt;<span class="type">Self</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">LazyForEachSequence</span>(base: <span class="keyword">self</span>,</span><br><span class="line">            perform: body)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在以下几个方面上与与非惰性版本略有不同：</p><ul><li>因为我们需要把传入的闭包暂存起来，所以它必须是 <code>@escaping</code>，也就是逃逸闭包。</li><li>由于其惰性性质，这个方法并不支持会抛出异常的方法。</li><li>一般来说，一个惰性操作完成后必定会有后续的操作，因此其返回值并没有标记为 <code>descardable</code>。</li></ul><p>但这个方法最重要的特性是我们上面讨论过的：除了把原本的序列和传入的函数进行存储之外，它不会执行任何操作。</p><p>当这一切准备完成后，<code>forEachPerform</code> 便可以成功维持一个序列的惰性性质（注意 <code>.lazy</code> 的调用）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> largeNumbersSquared = numbers</span><br><span class="line">    .<span class="built_in">lazy</span></span><br><span class="line">    .<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt;= <span class="number">5</span> &#125;</span><br><span class="line">    .forEachPerform &#123; <span class="built_in">print</span>(<span class="string">"After filter: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// Prints nothing</span></span><br></pre></td></tr></table></figure><p><em>注意：其实这段代码在 Swift 4.0 中会编译失败：”ambiguous use of ‘forEachPerform’”。只有当我把 Sequence.forEachPerform 的返回类型由 Self 改为 [Element] 后这段代码才能正常运行。说实话我也不太明白这是为什么。不过你也可以通过修改 LazySequenceProtocol.forEachPerform 方法的命名暂时解决这个问题。</em></p><p>这样一来，只有当我们访问到惰性序列的元素时，这些元素的副作用才会被打印出来：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Access the first two elements</span></span><br><span class="line"><span class="type">Array</span>(largeNumbersSquared.<span class="keyword">prefix</span>(<span class="number">2</span>))</span><br><span class="line"><span class="comment">/* Prints:</span></span><br><span class="line"><span class="comment">After filter: 5</span></span><br><span class="line"><span class="comment">After filter: 6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// → [25, 36]</span></span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我真的很喜欢这种往链式操作中注入副作用的功能，即便我几乎没有在调试之外的时候使用过。插句题外话，虽然基于 <code>print</code> 的调试方法一直在被争论是否已经 “过时” 了，但我还是一直在用。</p><hr><p><a id="foot1" href="#1"><sup>[1]</sup></a>RxSwift 中有一个类似的操作符 <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Debug.swift" target="_blank" rel="noopener">debug</a> </p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了如何在 Swift 的链式调用中通过使用创建的自定义函数来实现调试的目的
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的设计模式 #1 工厂方法与单例方法</title>
    <link href="https://swift.gg/2018/09/10/design-pattern-creational/"/>
    <id>https://swift.gg/2018/09/10/design-pattern-creational/</id>
    <published>2018-09-10T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://www.appcoda.com/design-pattern-creational/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-07-24<br>译者：<a href="https://github.com/Adolf-L" target="_blank" rel="noopener">BigLuo</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>“Gang of Four” (“GoF”) Erich Gamma，Richard Helm，Ralph Johonson，和 John Vlissides 在他们“<a href="https://smile.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8/" target="_blank" rel="noopener">设计模式：面向对象软件设计复用的基本原理</a>” 的重要著作里整理了大概 23 种经典的设计模式 。本文会介绍 GoF 总结的两种创建型（creational）模式：<em>工厂方法</em>和<em>单例方法</em>。</p><a id="more"></a><p>软件开发一直在努力地模拟真实世界的场景，希望通过创建工具的方式来加强人类的场景体验。财富管理工具，例如：像亚马逊或者 eBay 这样的银行 App 和购物辅助工具，相比十年前确实给消费者带来了更大的生活便利。回顾我们的发展路程。当应用变的更加强大易用时，应用的开发也已变的<a href="http://iosbrain.com/blog/2018/04/29/controlling-chaos-why-you-should-care-about-adding-error-checking-to-your-ios-apps/#chaos" target="_blank" rel="noopener"><strong>更加复杂</strong></a>。</p><p>所以开发者也开创出了一系列最佳实践。一些很流行的名字，像<a href="http://iosbrain.com/blog/2017/02/26/intro-to-object-oriented-principles-in-swift-3-via-a-message-box-class-hierarchy/" target="_blank" rel="noopener"><strong>面向对象编程</strong></a>，<a href="https://www.appcoda.com/pop-vs-oop/" target="_blank" rel="noopener"><strong>面向协议编程</strong></a>，<a href="http://iosbrain.com/blog/2018/03/28/protocol-oriented-programming-in-swift-is-it-better-than-object-oriented-programming/#value_semantics" target="_blank" rel="noopener"><strong>值语义 （value semantics）</strong></a>，<a href="http://iosbrain.com/blog/2018/03/28/protocol-oriented-programming-in-swift-is-it-better-than-object-oriented-programming/#local_reasoning" target="_blank" rel="noopener"><strong>局部推断 （local reasoning）</strong></a>将大块代码分解成具有良好接口定义的小段代码（比如使用 <a href="http://iosbrain.com/blog/2017/01/28/swift-extensions-managing-complexity-improving-readability-extensibility-protocols-delegates-uicollectionview/" target="_blank" rel="noopener"><strong>Swift 的扩展</strong></a>），以及 <a href="http://iosbrain.com/blog/2018/01/27/writing-expressive-meaningful-and-readable-code-in-swift-4/" target="_blank" rel="noopener"><strong>语法糖</strong></a>。还有我没提及，但却是最重要的、值得重视的实践之一，设计模式的使用。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是开发者管理软件复杂性的重要工具。作为常见的模板技术，它很好地对软件中类似的、复现的、容易识别的问题进行了概念化抽象。将它当作一个最佳实践应用到你日常会遇到的那些编程场景中，例如，在不了解类簇实现细节的情况下创建一个类簇相关的对象。设计模式主要是用于经常发生的那些问题场景中。它们频繁被使用是因为这些问题很普遍，让我用一个具体的例子来帮助你们理解吧。</p><p>设计模式讨论的并不是某些具体的问题，比如”如何迭代包含 11 个整数（Int）的 Swift 数组“。针对这类问题，GoF 定义了迭代器模式（Iterator Pattern），这是一个通用的模式，描述如何在不确定数据类型的情况下遍历一个数据列表。设计模式不是语言编码。它是用于解决相同软件场景问题的一套实用的指导规则。</p><p>还记得吗，之前我在 AppCoda 介绍过 <a href="https://www.appcoda.com/mvvm-vs-mvc/" target="_blank" rel="noopener">“Model-View-ViewModel” or “MVVM”</a> 与非常著名的 <a href="https://www.appcoda.com/mvvm-vs-mvc/" target="_blank" rel="noopener">“Model-View-Controller” or “MVC”</a> 设计模式，这两个模式深受 Apple 和 iOS 开发者喜爱。</p><p>这两种模式一般用在<em>整个应用</em>中。MVVM 和 MVC 是<em>架构（architectural）</em>设计模式，用于将 UI 从应用数据代码和展示逻辑中分离出来（如：MVC），以及将应用的数据从核心数据流程或者业务逻辑中分离（如：MVVM）。 而 GoF 设计模式本质上更具体，旨在解决基于程序代码中的具体问题。在一个应用里面你也许会用到 3 种、7 种或者 12 种 GoF 设计模式。除了<em>迭代器</em>例子，代理模式也是设计模式中另一个很好的例子， 尽管它在 GoF 列出的 23 种设计模式中并未被具体介绍。</p><p>当 GoF 的这本书作为大量开发者的圣经而存在时，也不乏有它的诋毁者，我们在文章的结尾处讨论这个话题。</p><h2 id="设计模式的类别"><a href="#设计模式的类别" class="headerlink" title="设计模式的类别"></a>设计模式的类别</h2><p>GoF 将 23 种设计模式整理分为 3 类，“创建型”、“结构型”和“行为型”。本教程讨论创建型模式类别中的两种（工厂模式与单例）。如同实例对象和类的实现，模式的作用是让复杂对象的创建变得简单、易于理解、易于维护，隐藏细节。</p><p><strong>隐藏复杂度（封装）</strong>是聪明的程序员最主要的目标之一。例如，面向对象（OOP）类能提供非常复杂的，强大且成熟的函数而不需要知道任何关于类内部间的工作方式。在创建型模式中，开发者甚至不需要知道类的属性和方法，但如果需要，程序员可以看到其接口 - 在 Swift 中的协议中 - 或对那些感兴趣的类进行扩展。你会在我的第一个“工厂方法”的例子中明白我的意思。</p><h2 id="工厂方法设计模式"><a href="#工厂方法设计模式" class="headerlink" title="工厂方法设计模式"></a>工厂方法设计模式</h2><p>如果你已经探索过 GoF 设计模式或在 OOP 的世界里花费了很多时间，你大概至少听说过“抽象工厂”、“工厂”，或者“工厂方法”模式。“确切”的命名可能有很多争议，不过下面我要介绍的这个例子最接近的命名是工厂模式。</p><p>在这个范例中，你通过工厂方法创建对象，而<em>不需要</em>知道类的构造器和关于类和类层次结构的任何信息。这带来了很大的方便。可以用少量的代码创建 UI 和它的相关功能。我的工厂方法项目案例，在 <a href="https://github.com/appcoda/FactoryMethodInSwift" target="_blank" rel="noopener"><strong>GitHub</strong></a> 可下载，展示了在复杂类层次结构中，如何轻松的使用对象。<br><img src="https://www.appcoda.com/wp-content/uploads/2018/07/Factory_Method.gif" alt=""></p><p>大多数成功的应用都有风格一致的主题 。为保证应用主题风格统一，假设应用中所有的 shapes 有着相同的颜色和尺寸，这样就可以和主题保持一致——也就是塑造品牌。这些图形用在自定义按钮上，或者作为登录流程的界面背景图都是不错的。</p><p>假设设计团队同意使用我的代码作为应用的主题背景图片。下面来看看我的具体代码，包括协议、类结构和（UI 开发人员不需要关心的）工厂方法。</p><p> <code>ShapeFactory.swift</code> 文件是一个用于在视图控制器内绘制形状的协议。因为可用于各种目的，所以它的访问级别是 public：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些值被图形设计团队预先选定</span></span><br><span class="line"><span class="keyword">let</span> defaultHeight = <span class="number">200</span></span><br><span class="line"><span class="keyword">let</span> defaultColor = <span class="type">UIColor</span>.blue</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HelperViewFactoryProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">configure</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">position</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> view: <span class="type">UIView</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> parentView: <span class="type">UIView</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得吗？ <code>UIView</code> 类有一个默认的矩形属性 <code>frame</code>  ，所以我可以轻松的创建出形状基类 <code>Square</code>: </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span>: <span class="title">HelperViewFactoryProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> height: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> parentView: <span class="type">UIView</span></span><br><span class="line">    <span class="keyword">var</span> view: <span class="type">UIView</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(height: <span class="type">Int</span> = defaultHeight, parentView: <span class="type">UIView</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.height = height</span><br><span class="line">        <span class="keyword">self</span>.parentView = parentView</span><br><span class="line">        view = <span class="type">UIView</span>()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">configure</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: height, height: height)</span><br><span class="line">        view.frame = frame</span><br><span class="line">        view.backgroundColor = defaultColor</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">position</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        view.center = parentView.center</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        configure()</span><br><span class="line">        position()</span><br><span class="line">        parentView.addSubview(view)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到我根据 OOP 的设计思想来构建复用代码，这样能让 shape 层级更加简化和可维护。<code>Circle</code> 和 <code>Rectangle</code> 类是 <code>Square</code> 类的特化 （另外你可以看到，从正方形出发绘制圆形是多么简单。）<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Square</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">configure</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">super</span>.configure()</span><br><span class="line">        </span><br><span class="line">        view.layer.cornerRadius = view.frame.width / <span class="number">2</span></span><br><span class="line">        view.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="title">Square</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">configure</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: height + height/<span class="number">2</span>, height: height)</span><br><span class="line">        view.frame = frame</span><br><span class="line">        view.backgroundColor = <span class="type">UIColor</span>.blue</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我使用 <code>fileprivate</code> 来强调工厂方法模式背后的一个目的：<em>封装</em>。你可以看到不用改变下面工厂方法的前提下，对 <code>shape</code> 类的层级结构进行修改和扩展是很容易的。这是工厂方法的代码，它们让对象的创建如此简单且抽象。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> square</span><br><span class="line">    <span class="keyword">case</span> circle</span><br><span class="line">    <span class="keyword">case</span> rectangle</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> parentView: <span class="type">UIView</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(parentView: <span class="type">UIView</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.parentView = parentView</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="keyword">as</span> shape: Shapes)</span></span> -&gt; <span class="type">HelperViewFactoryProtocol</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> shape &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> .square:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> square = <span class="type">Square</span>(parentView: parentView)</span><br><span class="line">            <span class="keyword">return</span> square</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> .circle:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> circle = <span class="type">Circle</span>(parentView: parentView)</span><br><span class="line">            <span class="keyword">return</span> circle</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> .rectangle:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> rectangle = <span class="type">Rectangle</span>(parentView: parentView)</span><br><span class="line">            <span class="keyword">return</span> rectangle</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共的工厂方法来展示形状</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createShape</span><span class="params">(<span class="number">_</span> shape: Shapes, on view: UIView)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> shapeFactory = <span class="type">ShapeFactory</span>(parentView: view)</span><br><span class="line">    shapeFactory.create(<span class="keyword">as</span>: shape).display()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择公共的工厂方法来展示形状</span></span><br><span class="line"><span class="comment">// 严格来说，工厂方法应该返回相关类中的一个。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getShape</span><span class="params">(<span class="number">_</span> shape: Shapes, on view: UIView)</span></span> -&gt; <span class="type">HelperViewFactoryProtocol</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> shapeFactory = <span class="type">ShapeFactory</span>(parentView: view)</span><br><span class="line">    <span class="keyword">return</span> shapeFactory.create(<span class="keyword">as</span>: shape)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意到：我已经写下一个类工厂和两个工厂方法来让你思考。严格说，一个工厂方法应该返回对应类的对象，这些类有着共同的基类或者协议。我的目的是在视图上绘制一个形状，所以我更倾心使用 <code>createShape(_:view:)</code> 这个方法。提供这种可选方式（该方法），在需要时可用于试验和探索新的可能性。</p><p>最后，我展示了两个工厂方法绘制形状的使用方式。UI 开发者不用知道形状类是如何被编码出来的。尤其是他/她不必为形状类如何被初始化而担忧。<code>ViewController.swift</code> 文件中的代码很容易阅读。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">//在加载视图后进行添加设置，一般是从nib</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// 废弃掉那些可以被重新创建的资源</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">drawCircle</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 仅仅用于绘制形状</span></span><br><span class="line">        createShape(.circle, on: view)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">drawSquare</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制图形</span></span><br><span class="line">        createShape(.square, on: view)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">drawRectangle</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从工厂获取一个对象并使用它来绘制一个形状</span></span><br><span class="line">        <span class="keyword">let</span> rectangle = getShape(.rectangle, on: view)</span><br><span class="line">        rectangle.display()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>大部分 iOS 开发者熟悉单例模式。回想一下 <code>UNUserNotificationCenter.current()</code>，<code>UIApplication.shared</code> 或 <code>FileManager.default</code> 如果你想要发送通知，或者在 Safari 里面打开一个 URL，或者操作 iOS 文件，你必须分别使用它们各自的单例。单例可以很好的用于保护共享资源，提供有且仅有一个对象实例进入一些系统，并且支持对象执行一些应用级类型的协作。正如我们将要看到的，单例也可以用来封装 iOS 内建的其它单例，添加一些值操作功能。</p><p>作为一个单例，我们需要确保这个类：</p><ul><li>声明和初始化一个 static 的类的常量属性，然后命名那个属性为 <code>shared</code> 来表明这个类的实例是一个单例（默认是共有的）；</li><li>为我们想要控制和保护的一些资源声明一个<em>私有的</em>属性。且只能通过 <code>shared</code> 共享；</li><li>声明一个私有初始化方法，只有我们的单例类能够初始化它，在 <code>init</code> 的内部，初始化我们想要用于控制的共享资源；</li></ul><p>通过定义一个 <code>shared</code> 静态常量来创建一个类的 <code>private</code> 初始化方法。我们要确保这个类只有一个实例，该类只能初始化一次，并且共享的实例在应用的任何地方都能获取。就这样我们创建了一个<em>单例</em>！</p><p>这个单例项目的代码，在 <a href="https://github.com/appcoda/SingletonInSwift" target="_blank" rel="noopener"><strong>GitHub</strong></a> 可下载，展示了一个开发者如何安全的、高效的存储用户的偏好。这是个简单的 Demo，该 Demo 能够记录用户的密码文本，偏好设置可设置为可见或隐藏。不过事后发现，这个功能并不是个好想法，我只是需要一个例子来向你展示我代码的工作机制。这段代码<em>完全是</em>出于教学的目的。我建议你<strong>永远不要</strong>让你的密码暴露。你可以看到用户可以设置他们的的密码偏好 — 且密码偏好被存储在 <code>UserDefaults</code>:</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/07/Show_Pwd.gif" alt=""></p><p>当用户关闭应用并且再次打开后，注意到他/她的密码偏好被记录了：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/07/Remember_Pwd_Setting.gif" alt=""></p><p>让我向你展示 <code>PreferencesSingleton.swift</code> 文件中的代码片段，在行内注释里，你将会看到我想准确表达的意思。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPreferences</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类的初始化方法创建一个静态的，常量实例。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">UserPreferences</span>()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这是一个私有的，收我们保护的资源共享的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> userPreferences: <span class="type">UserDefaults</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 一个私有的初始化方法只能被类本身调用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取 iOS 共享单例。我们在这里包装了它。</span></span><br><span class="line">        userPreferences = <span class="type">UserDefaults</span>.standard</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125; <span class="comment">// end class UserPreferences</span></span><br></pre></td></tr></table></figure><p>应用启动的时候需要初始化静态属性，但是全局变量默认是懒加载。你可能会担心上面这段代码在执行的时候出错，不过就我对 Swift 的了解来说，这段代码完全没问题。</p><p>你也许会问，“为什么要通过包装另一个<code>UserDefaults</code> 单例的方式来创建一个单例？” 首先，我主要目的是要向你展示在 Swift 中创建和使用单例的最佳做法。 用户偏好是一个资源类型，应该有一个单一的入口。所以在这个例子中，很明显我们应该使用 <code>UserDefaults</code>。其次，想一下你曾多少次看到在应用中 <code>UserDefaults</code> 被滥用。</p><p>在一些项目应用代码中，我看到 <code>UserDefaults</code>(或者之前的 <code>NSUserDefaults</code>)的使用缺乏条理和原由。用户偏好属性对应的每个键都是字符串引用。刚才，我在代码中发现了一个 bug。我把“switch”拼写成了“swithc”，由于我对代码进行了复制和粘贴，在发现问题前，我已经创建了不少“swithc”的实例。 如果其他开发者在这个应用开始或者继续使用“switch”作为一个键来存储对应的值呢？应用的当前状态是无法被正确保存的。 我们经常使用 <code>UserDefaults</code> 的 strings 以键值映射的方式保存应用的状态。这是一个好的写法。这可以让值的意思清晰明确、简单易懂，还便于记忆。但也不是说通过 strings 来描述是没有任何风险的。</p><p>在我讨论的“swithc”与“switch”中。大多数人可能已经明白了被称为“stringly-typed”的那些代码, 用 strings 作为唯一的标识符会产生细微的不同，最终会因为拼写错误带来灾难性的错误。Swift 编译器不能帮助我们避免“stringly-typed”这类的错误。</p><p>解决“stringly-typed”错误的方式在于把 Swift <code>enum</code> 设置成 string 类型。这么做不仅可以让我们标准化字符串的使用，而且可让我们对其进行分类管理。让我们再次回到 <code>PreferencesSingleton.swift</code>:<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPreferences</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Preferences</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">UserCredentials</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> passwordVisibile</span><br><span class="line">            <span class="keyword">case</span> password</span><br><span class="line">            <span class="keyword">case</span> username</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">AppState</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> appFirstRun</span><br><span class="line">            <span class="keyword">case</span> dateLastRun</span><br><span class="line">            <span class="keyword">case</span> currentVersion</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="comment">// end enum Preferences</span></span><br></pre></td></tr></table></figure></p><p>我们从单例模式的定义开始，向你介绍清楚在我的应用中，为什么使用一个单例来封装 <code>UserDefaults</code>。我们可以通过添加值的方式来增添新的功能，但通过简单的对 <code>UserDefaults</code> 的包装却能增强代码的健壮性。在获取和设置用户偏好时，你脑中应该要马上想到进行错误校验。在这里，我想实现一个关于用户偏好的功能，设置密码的可见性。看到下面的代码。内容都在 <code>PreferencesSingleton.swift</code> 文件：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPreferences</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Preferences</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">UserCredentials</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> passwordVisibile</span><br><span class="line">            <span class="keyword">case</span> password</span><br><span class="line">            <span class="keyword">case</span> username</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">AppState</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> appFirstRun</span><br><span class="line">            <span class="keyword">case</span> dateLastRun</span><br><span class="line">            <span class="keyword">case</span> currentVersion</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="comment">// end enum Preferences</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个静态、常量实例并初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">UserPreferences</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是一个私有的，被保护的共享资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> userPreferences: <span class="type">UserDefaults</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有类本身能调用的一个私有初始化方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 获取 iOS 共享单例。我们在这里包装它</span></span><br><span class="line">        userPreferences = <span class="type">UserDefaults</span>.standard</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setBooleanForKey</span><span class="params">(<span class="number">_</span> boolean:Bool, key:String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> key != <span class="string">""</span> &#123;</span><br><span class="line">            userPreferences.<span class="keyword">set</span>(boolean, forKey: key)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getBooleanForKey</span><span class="params">(<span class="number">_</span> key:String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> isBooleanValue = userPreferences.value(forKey: key) <span class="keyword">as</span>! <span class="type">Bool</span>? &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Key <span class="subst">\(key)</span> is <span class="subst">\(isBooleanValue)</span>"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Key <span class="subst">\(key)</span> is false"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isPasswordVisible</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> isVisible = userPreferences.bool(forKey: <span class="type">Preferences</span>.<span class="type">UserCredentials</span>.passwordVisibile.rawValue)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> isVisible &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>来到 <code>ViewController.swift</code> 文件，你将看到，访问并使用结构良好的单例是多么的容易：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> passwordTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> passwordVisibleSwitch: <span class="type">UISwitch</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"><span class="comment">// 在加载视图后（一般通过 nib 来进行）进行其它的额外设置。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="type">UserPreferences</span>.shared.isPasswordVisible() &#123;</span><br><span class="line">            passwordVisibleSwitch.isOn = <span class="literal">true</span></span><br><span class="line">            passwordTextField.isSecureTextEntry = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            passwordVisibleSwitch.isOn = <span class="literal">false</span></span><br><span class="line">            passwordTextField.isSecureTextEntry = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line"><span class="comment">// 可以销毁那些能被重新创建的资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">passwordVisibleSwitched</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> pwdSwitch:<span class="type">UISwitch</span> = sender <span class="keyword">as</span>! <span class="type">UISwitch</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> pwdSwitch.isOn &#123;</span><br><span class="line">            passwordTextField.isSecureTextEntry = <span class="literal">false</span></span><br><span class="line">            <span class="type">UserPreferences</span>.shared.setPasswordVisibity(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            passwordTextField.isSecureTextEntry = <span class="literal">true</span></span><br><span class="line">            <span class="type">UserPreferences</span>.shared.setPasswordVisibity(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>有些评论家声称设计模式在一些编程语言中的使用缺乏证明，相同的设计模式在代码中反复出现是很槽糕的一件事情。我并不同意这个说法。期望一个编程语言对<em>每件事情</em>的处理都有其对应的特性是很愚蠢的。这很可能会导致一个臃肿的语言，像 C++ 一样正在变得更大、更复杂，以致很难被学习、使用与维护。认识并解决反复出现的问题是人的一种积极性格并且这确实值得我们强化。有一些事情，人们尝试却失败了很多次，通过学习总结前人经验，对一些相同的问题进行抽象和标准化，让这些好的解决方案散播出去的方面，设计模式成为了一个成功案例。</p><p>像 Swift 这样的简单紧凑的语言和设计模式这样一系列最佳实践的组合是一个理想中的、令人开心的方法。风格统一的代码一般来说都具有较好的可读性和易维护性。不过也要记住，在数以百万的开发者不断地讨论和分享下，设计模式也在不断的发展变化，这些美好事物被万维网联系在一起，这种开发人员的讨论持续的引领着集体智慧的自我调节。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Andrew Jaffee，&lt;a href=&quot;https://www.appcoda.com/design-pattern-creational/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-07-24&lt;br&gt;译者：&lt;a href=&quot;https://github.com/Adolf-L&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigLuo&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;“Gang of Four” (“GoF”) Erich Gamma，Richard Helm，Ralph Johonson，和 John Vlissides 在他们“&lt;a href=&quot;https://smile.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式：面向对象软件设计复用的基本原理&lt;/a&gt;” 的重要著作里整理了大概 23 种经典的设计模式 。本文会介绍 GoF 总结的两种创建型（creational）模式：&lt;em&gt;工厂方法&lt;/em&gt;和&lt;em&gt;单例方法&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
    
      <category term="Design Patterns" scheme="https://swift.gg/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>Never</title>
    <link href="https://swift.gg/2018/08/30/never/"/>
    <id>https://swift.gg/2018/08/30/never/</id>
    <published>2018-08-30T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Matt，<a href="https://nshipster.com/never/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-07-30<br>译者：<a href="https://github.com/mobilefellow" target="_blank" rel="noopener">雨谨</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="undefined">wongzigii</a>，<a href="undefined">Firecrest</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p><code>Never</code> 是一个约定，表示一件事在过去或未来的任何时段都不会发生。它是时间轴上的一种逻辑上的不可能，在任何方向延展开去都没有可能。这就是为什么在代码中看到 <a href="https://github.com/search?q=%22this+will+never+happen%22&amp;type=Code" target="_blank" rel="noopener">这样的注释</a> 会特别让人不安。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个不会发生</span></span><br></pre></td></tr></table></figure><p>所有编译器的教科书都会告诉你，这样一句注释不能也不会对编译出的代码产生任何影响。<a href="https://en.wikipedia.org/wiki/Murphy%27s_law" target="_blank" rel="noopener">墨菲定理</a> 告诉你并非如此，注释以下的代码一定会被触发。</p><p>那 Swift 是如何在这种无法预测的、混乱的开发过程中保证安全呢？答案难以置信：“<strong>什么都不做</strong>”，以及“<strong>崩溃</strong>”。</p><hr><p>使用 <code>Never</code> 替换 <code>@noreturn</code> 修饰符，是由 <a href="https://github.com/jckarter" target="_blank" rel="noopener">Joe Groff</a> 在 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0102-noreturn-bottom-type.md" target="_blank" rel="noopener">SE-0102: “Remove @noreturn attribute and introduce an empty Never type”</a> 中提出的。</p><p>在 Swift 3 之前，那些要中断执行的函数，比如 <code>fatalError(_:file:line:)</code>，<code>abort()</code> 和 <code>exit(_:)</code>，需要使用 <code>@noreturn</code> 修饰符来声明，这会告诉编译器，执行完成后不用返回调用这个函数的位置。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &lt; 3.0</span></span><br><span class="line"><span class="meta">@noreturn</span> <span class="function"><span class="keyword">func</span> <span class="title">fatalError</span><span class="params">(<span class="number">_</span> message: <span class="params">()</span></span></span> -&gt; <span class="type">String</span> = <span class="type">String</span>(),</span><br><span class="line">                               file: <span class="type">StaticString</span> = #file,</span><br><span class="line">                               line: <span class="type">UInt</span> = #line)</span><br></pre></td></tr></table></figure><p>从 Swift 3 开始，<code>fatalError</code> 和它的相关函数都被声明为返回 <code>Never</code> 类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &gt;= 3.0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fatalError</span><span class="params">(<span class="number">_</span> message: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span> = <span class="type">String</span>(),</span><br><span class="line">                     file: <span class="type">StaticString</span> = #file,</span><br><span class="line">                     line: <span class="type">UInt</span> = #line) -&gt; <span class="type">Never</span></span><br></pre></td></tr></table></figure><p>作为一个注释的替代品，它肯定是很复杂的，对吗？NO！事实上，恰恰相反，<code>Never</code> 可以说是整个 Swift 标准库中最简单的一个类型：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Never</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="无实例类型（Uninhabited-Types）"><a href="#无实例类型（Uninhabited-Types）" class="headerlink" title="无实例类型（Uninhabited Types）"></a>无实例类型（<code>Uninhabited Types</code>）</h2><p><code>Never</code> 是一个<em>无实例</em>（<em>Uninhabited</em>）类型，也就是说它没有任何值。或者换句话说，无实例类型是无法被构建的。</p><p>在 Swift 中，没有定义任何 <code>case</code> 的枚举是最常见的一种无实例类型。跟结构体和类不同，枚举没有初始化方法。跟协议也不同，枚举是一个具体的类型，可以包含属性、方法、泛型约束和嵌套类型。正因如此，Swift 标准库广泛使用无实例的枚举类型来做诸如 <a href="https://github.com/apple/swift/blob/a4230ab2ad37e37edc9ed86cd1510b7c016a769d/stdlib/public/core/Unicode.swift#L918" target="_blank" rel="noopener">定义命名空间</a> 以及 <a href="https://github.com/apple/swift/blob/a6952decab6f918a9df3c6fa342153a9f9204f8e/stdlib/public/core/MemoryLayout.swift#L43" target="_blank" rel="noopener">标识类型的含义</a> 之类的事情。</p><p>但 <code>Never</code> 并不这样。它没有什么花哨的东西，它的特别之处就在于，它就是它自己（或者说，它什么都不是）。</p><p>试想一个返回值为无实例类型的函数：因为无实例类型没有任何值，所以这个函数无法正常的返回。（它要如何生成这个返回值呢？）所以，这个函数要么停止运行，要么无休止的一直运行下去。</p><h2 id="消除泛型中的不可能状态"><a href="#消除泛型中的不可能状态" class="headerlink" title="消除泛型中的不可能状态"></a>消除泛型中的不可能状态</h2><p>从理论角度上说，<code>Never</code> 确实很有意思，但它在实际应用中又能帮我们做什么呢？</p><p>做不了什么，或者说在 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0215-conform-never-to-hashable-and-equatable.md#conform-never-to-equatable-and-hashable" target="_blank" rel="noopener">SE-0215: Conform Never to Equatable and Hashable</a> 推出以前，做不了什么。</p><p><a href="https://github.com/mdiep" target="_blank" rel="noopener">Matt Diephouse</a> 在提案中解释了为什么让这个令人费解的类型去遵守 <code>Equatable</code> 和其他协议：</p><blockquote><p><code>Never</code> 在表示不可能执行的代码方面非常有用。大部分人熟悉它，是因为它是 <code>fatalError</code> 等方法的返回值，但 <code>Never</code> 在泛型方面也非常有用。比如说，一个 <code>Result</code> 类型可能使用 <code>Never</code> 作为它的 <code>Value</code>，表示某种东西一直是错误的，或者使用 <code>Never</code> 作为它的 <code>Error</code>，表示某种东西一直不是错误的。</p></blockquote><p>Swift 没有标准的 <code>Result</code> 类型，大部分情况下它们是这个样子的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">Value</span>, <span class="title">Error</span>: <span class="title">Swift</span>.<span class="title">Error</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">Value</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Result</code> 类型被用来封装异步操作生成的返回值和异常（同步操作可以使用 <code>throw</code> 来返回异常）。</p><p>比如说，一个发送异步 HTTP 请求的函数可能使用 <code>Result</code> 类型来存储响应或错误：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(<span class="number">_</span> request: Request, completion: <span class="params">(Result&lt;Response, Error&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这个方法后，你可以使用 <code>switch</code> 来分别处理它的 <code>.success</code> 和 <code>.failure</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fetch(request) &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Success: <span class="subst">\(value)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Failure: <span class="subst">\(error)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设有一个函数会在它的 <code>completion</code> 中永远返回成功结果：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alwaysSucceeds</span><span class="params">(<span class="number">_</span> completion: <span class="params">(Result&lt;String, Never&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completion(.success(<span class="string">"yes!"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>Result</code> 的 <code>Error</code> 类型指定为 <code>Never</code> 后，我们可以使用类型检测体系来表明失败是永远不可能发生的。这样做的好处在于，你不需要处理 <code>.failure</code>，Swift 可以推断出这个 <code>switch</code> 语句已经处理了所有情况。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">alwaysSucceeds &#123; (result) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> string):</span><br><span class="line">        <span class="built_in">print</span>(string)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个例子是让 <code>Never</code> 遵循 <code>Comparable</code> 协议，这段代码把 <code>Never</code> 用到了极致：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Never</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt; (lhs: Never, rhs: Never) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (lhs, rhs) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>Never</code> 是一个无实例类型，所以它没有任何可能的值。所以当我们使用 <code>switch</code> 遍历它的 <code>lhs</code> 和 <code>rhs</code> 时，Swift 可以确定所有的可能性都遍历了。既然所有的可能性 — 实际上这里不存在任何值 — 都返回了 <code>Bool</code>，那么这个方法就可以正常编译。</p><p><em>工整！</em></p><h2 id="使用-Never-作为兜底类型"><a href="#使用-Never-作为兜底类型" class="headerlink" title="使用 Never 作为兜底类型"></a>使用 <code>Never</code> 作为兜底类型</h2><p><strong>实际上，关于 <code>Never</code> 的 Swift Evolution 提案中已经暗示了这个类型在未来可能有更多用处：</strong></p><blockquote><p>一个无实例类型可以作为其他任意类型的子类型 — 如果某个表达式根本不可能产生任何结果，那么我们就不需要关心这个表达式的类型到底是什么。如果编译器支持这一特性，就可以实现很多有用的功能……</p></blockquote><h3 id="解包或者死亡"><a href="#解包或者死亡" class="headerlink" title="解包或者死亡"></a>解包或者死亡</h3><p>强制解包操作（<code>!</code>）是 Swift 中最具争议的部分之一。（在代码中使用这个操作符）往好了说，是有意为之（在异常时故意让程序崩溃）；往坏了说，可能表示使用者没有认真思考。在缺乏其他信息的情况下，很难看出这两者的区别。</p><p>比如，下面的代码假定数组一定不为空，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array: [<span class="type">Int</span>]</span><br><span class="line"><span class="keyword">let</span> firstIem = array.first!</span><br></pre></td></tr></table></figure><p>为了避免强制解包，你可以使用带条件赋值的 <code>guard</code> 语句：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array: [<span class="type">Int</span>]</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> firstItem = array.first <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"array cannot be empty"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未来，如果 <code>Never</code> 成为兜底类型，它就可以用在 <code>nil-coalescing operator</code> 表达式的右边。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未来的 Swift 写法? 🔮</span></span><br><span class="line"><span class="keyword">let</span> firstItem = array.first ?? <span class="built_in">fatalError</span>(<span class="string">"array cannot be empty"</span>)</span><br></pre></td></tr></table></figure><p>如果你想现在就使用这种模式，可以手动重载 <code>??</code> 运算符（但是……）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> ?? &lt;T&gt;<span class="params">(lhs: T?, rhs: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Never</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> lhs &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> value?:</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        rhs()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在拒绝 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0217-bangbang.md#on-forced-unwraps" target="_blank" rel="noopener">SE-0217: Introducing the !! “Unwrap or Die” operator to the Swift Standard Library</a> 的<a href="https://forums.swift.org/t/se-0217-the-unwrap-or-die-operator/14107/222" target="_blank" rel="noopener">原因说明</a>中, <a href="https://github.com/jckarter" target="_blank" rel="noopener">Joe Groff</a> 提到，“我们发现重载 [?? for Never] 会对类型检测的性能产生难以接受的影响”。所以，不建议你在自己的代码中添加上面的代码。</p></blockquote><h3 id="表达式风格的-Throw"><a href="#表达式风格的-Throw" class="headerlink" title="表达式风格的 Throw"></a>表达式风格的 Throw</h3><p>类似的，如果 <code>throw</code> 可以从语句变成一个返回 <code>Never</code>的表达式，你就可以在 <code>??</code> 右边使用 <code>throw</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未来的 Swift 写法? 🔮</span></span><br><span class="line"><span class="keyword">let</span> firstItem = array.first ?? <span class="keyword">throw</span> <span class="type">Error</span>.empty</span><br></pre></td></tr></table></figure><h3 id="带类型的-Throw"><a href="#带类型的-Throw" class="headerlink" title="带类型的 Throw"></a>带类型的 <code>Throw</code></h3><p>继续研究下去：如果函数声明的 <code>throw</code> 关键字支持类型约束，那么 <code>Never</code> 可以用来表明某个函数绝对不会抛出异常（类似于在上面的 <code>Result</code> 例子）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未来的 Swift 写法? 🔮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">neverThrows</span><span class="params">()</span></span> <span class="keyword">throws</span>&lt;<span class="type">Never</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">neverThrows() <span class="comment">// 无需使用 `try` ，因为编译器保证它一定成功（可能）</span></span><br></pre></td></tr></table></figure><hr><p>声称某个事情永远不可能发生，就像是向整个宇宙发出邀请，来证明它是错的一样。情态逻辑（modal logic）或者信念逻辑（doxastic logic）允许保面子式的妥协（“<em>它当时是对的，或者我是这么认为的！</em>”），但时态逻辑（temporal logic）似乎将这个约定提到了更高的一个标准。</p><p>幸运的是，得益于最不像类型的 <code>Never</code>，Swift 到达了这个高标准。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Matt，&lt;a href=&quot;https://nshipster.com/never/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-07-30&lt;br&gt;译者：&lt;a href=&quot;https://github.com/mobilefellow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;雨谨&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;undefined&quot;&gt;wongzigii&lt;/a&gt;，&lt;a href=&quot;undefined&quot;&gt;Firecrest&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;&lt;code&gt;Never&lt;/code&gt; 是一个约定，表示一件事在过去或未来的任何时段都不会发生。它是时间轴上的一种逻辑上的不可能，在任何方向延展开去都没有可能。这就是为什么在代码中看到 &lt;a href=&quot;https://github.com/search?q=%22this+will+never+happen%22&amp;amp;type=Code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这样的注释&lt;/a&gt; 会特别让人不安。&lt;/p&gt;
    
    </summary>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 4 泛型：如何在你的代码或App里应用泛型</title>
    <link href="https://swift.gg/2018/08/28/swift-generics/"/>
    <id>https://swift.gg/2018/08/28/swift-generics/</id>
    <published>2018-08-28T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://appcoda.com/swift-generics" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-02-14<br>译者：<a href="https://github.com/Adolf-L" target="_blank" rel="noopener">BigLuo</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://muhlenxi.com/" target="_blank" rel="noopener">muhlenXi</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>问题 1：我能否写一个 Swift 函数用于查找在<strong>任意数组</strong>中存储的<strong>任意类型</strong>的<strong>任何实例对象</strong>的位置\索引。</p><p>问题 2：我能否写一个 Swift 函数用于确定在<strong>任意数组</strong>中存储的<strong>任意类型</strong>的<strong>任何实例对象</strong>的类型。</p><p>我所说的 “任何类型”，包括自定义类型，比如我们自己定义的 Class 类型。提示：我知道我能够用 Swift <code>Array</code> 类型的内置方法，如 <code>index</code> 和 <code>contains</code>，但今天我将会用简单代码实例来说明 Swift 泛型中的一些特性。</p><a id="more"></a><p>一般来说，我将<strong>泛型编程</strong>作如下定义：</p><blockquote><p>… a style of computer programming in which algorithms are written in terms of types to-be-specified-later that are then instantiated when needed for specific types provided as parameters. This approach, pioneered by ML in 1973, permits writing common functions or types that differ only in the set of types on which they operate when used, thus reducing duplication.</p></blockquote><blockquote><p>是一种算法机制为 types to-be-specified-later (类型确定滞后)的计算机编程风格，当具体的类型作为参数传入后，该算法机制会对类型进行实例化。这个方法由 “ML” 在 1973 年开创。可以用共有的函数和类型来表示一个类型集合从而来减少函数操作的重复。</p></blockquote><p>特别的指出，来自<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/SwiftProgrammingLanguage/Generics.html" target="_blank" rel="noopener">苹果Swift文档</a> 关于”泛型”话题的说明：</p><blockquote><p>Generic code enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.</p><p>Generics are one of the most powerful features of  Swift , and much of the Swift standard library is built with generic code. … For example,  Swift ’s Array and Dictionary types are both generic collections. You can create an array that holds Int values, or an array that holds String values, or indeed an array for any other type that can be created in  Swift . Similarly, you can create a dictionary to store values of any specified type, and there are no limitations on what that type can be. …</p></blockquote><blockquote><p>泛型编码能让你写出符合需求、支持任意类型，灵活、可重用的函数。你能够编写避免重复和编程风格抽象、清晰、优雅的代码。</p><p>泛型是 Swift 中最强大的特性之一，大量的 Swift 标准库使用了泛型编码。例如， Swift 的数组和字典都是泛型集合。你可以创建一个存有整型值或者字符串值的数组，有必要的话，还可以创建一个任何 Swift 支持类型的数组。类似的，你也可以创建一个字典用于存储任意指定类型的值。</p></blockquote><p>我一直提倡构建可复用，简洁，可维护的代码，对于 Swift 中的泛型，如果运用恰当，能某种程度上帮助我实现上面提到的效果。所以对于上面两个问题，我的答案是 “YES”。</p><h2 id="生活在一个特定类型编码的世界"><a href="#生活在一个特定类型编码的世界" class="headerlink" title="生活在一个特定类型编码的世界"></a>生活在一个特定类型编码的世界</h2><p>让我们写一个 Swift 的方法来说明在一个字符串数组中是否存在特定的一个字符串：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">existsManual</span><span class="params">(item:String, inArray:[String])</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> index:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> found = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (index &lt; inArray.<span class="built_in">count</span> &amp;&amp; found == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> item == inArray[index]</span><br><span class="line">        &#123;</span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> found</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们测试这个方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strings = [<span class="string">"Ishmael"</span>, <span class="string">"Jacob"</span>, <span class="string">"Ezekiel"</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> nameExistsInArray = existsManual(item: <span class="string">"Ishmael"</span>, inArray: strings)</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> nameExistsInArray1 = existsManual(item: <span class="string">"Bubba"</span>, inArray: strings)</span><br><span class="line"><span class="comment">// returns false</span></span><br></pre></td></tr></table></figure><p>在创建了用于查找 <code>String</code> 数组的 <code>existsManual</code> 函数后。假如我决定想要一些类似的函数用于搜索 <code>Integer</code>，<code>Float</code>，和  <code>Double</code> 数组 — 甚至用于查找数组中自定义类呢？我最终花费了宝贵的时间写了很多做同样事情的函数。我需要写很多代码来实现。如果我发现了一个新的/更快的搜索算法呢？又如果在我的搜索算法有一个 bug 呢？我不得不改变我所有的查找方法的版本。我发现这简直是个复用地狱：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">existsManual</span><span class="params">(item:String, inArray:[String])</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">existsManual</span><span class="params">(item:Int, inArray:[Int])</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">existsManual</span><span class="params">(item:Float, inArray:[Float])</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">existsManual</span><span class="params">(item:Double, inArray:[Double])</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//  "Person"  is a custom class we'll create</span></span><br><span class="line"><span class="comment">//  "Person" 是我们将要创建的自定义的类</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">existsManual</span><span class="params">(item:Person, inArray:[Person])</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们已经厌烦了活在一个处理类型的世界里，不得不为每个我们想要查找的数组类型创建新的方法。终究这给我们带来了大量的技术负债。由于现代软件难以置信的复杂性，像你我这样的开发者需要使用更好地实践，更好的技术，更好的方法，用我们的神经元最大程度的控制这种混乱。据估计 Window 7 包含大约 4 千万行代码而 macOS 10.4 (Tiger) 包含大约 8.5 千万行代码，预估像这样的系统潜在行为次数都是不可能的。</p><h2 id="泛型的解决之道"><a href="#泛型的解决之道" class="headerlink" title="泛型的解决之道"></a>泛型的解决之道</h2><p>（再次紧记学习泛型的目的，我们依旧假设 Swift 的数组类型的内置的函数，<code>index</code> 和  <code>contains</code> ，不存在。）</p><p>让我们先尝试写这样一个 Swift 函数，判断 Swift 的标准类型（例如 <code>String</code>，<code>Integer</code>，<code>Float</code> 或 <code>Double</code>）的一个特定实例是否存在于这个 Swift 标准类型的数组中。怎么做呢？</p><p>让我们切换到 Swift 泛型，特别是泛型函数，类型参数，类型约束以及 <code>Equatable</code> 协议。在没有定义任何术语前，我写了一些代码，思考一下你看到的。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exists</span>&lt;T: Equatable&gt;<span class="params">(item: T, inArray: [T])</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> index:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> found = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (index &lt; inArray.<span class="built_in">count</span> &amp;&amp; found == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> item == inArray[index]</span><br><span class="line">        &#123;</span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> found</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们测试下我新写的泛型方法</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFriends:[<span class="type">String</span>] = [<span class="string">"John"</span>, <span class="string">"Dave"</span>, <span class="string">"Jim"</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isOneOfMyFriends = exists(item: <span class="string">"Dave"</span>, inArray: myFriends)</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isOneOfMyFriends1 = exists(item: <span class="string">"Laura"</span>, inArray: myFriends)</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> myNumbers:[<span class="type">Int</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isOneOfMyNumbers = exists(item: <span class="number">3</span>, inArray: myNumbers)</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isOneOfMyNumbers1 = exists(item: <span class="number">0</span>, inArray: myNumbers)</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> myNumbersFloat:[<span class="type">Float</span>] = [<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>,]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isOneOfMyFloatNumbers = exists(item: <span class="number">3.0000</span>, inArray: myNumbersFloat)</span><br><span class="line"><span class="comment">// returns true</span></span><br></pre></td></tr></table></figure><p>我新写 exists 方法是一个泛型函数，这个方法“能正常工作在任何参数类型上”，此外，让我们看看它的函数签名。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exists</span>&lt;T: Equatable &gt;<span class="params">(item: T, inArray: [T])</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>我们看到 <strong><a href="https://docs.Swift.org/Swift-book/LanguageGuide/Generics.html" target="_blank" rel="noopener">那个</a></strong> 函数使用一个占位符类型名字(名叫 <code>T</code>, 在这个案例)而不是真正的类型名（比如：<code>Int</code>，<code>Stirng</code>，或 <code>Double</code>）占位符类型名没有指定 <code>T</code> 必须是什么，但他说明了 <code>[item]</code> 和 <code>[inArray]</code> 必须是相同的类型 <code>T</code> 无论 <code>T</code> 代表什么，每当 [<code>exists(_:_:)</code>] 函数被调用时，真实的类型用于替代 <code>T</code> 被确定下来。</p><p><strong>这个 exists 函数中的占位符类型 <code>T</code> 被称为类型参数</strong>：</p><blockquote><p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/SwiftProgrammingLanguage/Generics.html" target="_blank" rel="noopener">它</a>指定和命名了占位符的类型，直接写在函数名称的后面，在一对尖括号之间(比如 <t>)。</t></p><p>一旦你指定一个类型参数你可以用它来定义函数参数的类型(比如：[<code>item</code>] and [<code>inArray</code>] [<code>exists(_:_:)</code> 函数)或者作为函数返回值的类型，在任何条件下，当函数被调用的时候类型参数会被真实类型替代。</p></blockquote><p>为了强化我们目前已经学到的，下面是一个 Swift 函数，该函数能够找到存储在数组中任何类型实例的索引。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span>&lt;T: Equatable&gt;<span class="params">(item: T, inArray: [T])</span></span> -&gt; <span class="type">Int</span>?</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> index:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> found = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (index &lt; inArray.<span class="built_in">count</span> &amp;&amp; found == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> item == inArray[index]</span><br><span class="line">        &#123;</span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> found</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们测试下它</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFriends:[<span class="type">String</span>] = [<span class="string">"John"</span>, <span class="string">"Dave"</span>, <span class="string">"Jim"</span>, <span class="string">"Arthur"</span>, <span class="string">"Lancelot"</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> findIndexOfFriend = <span class="built_in">find</span>(item: <span class="string">"John"</span>, inArray: myFriends)</span><br><span class="line"><span class="comment">// returns 0</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> findIndexOfFriend1 = <span class="built_in">find</span>(item: <span class="string">"Arthur"</span>, inArray: myFriends)</span><br><span class="line"><span class="comment">// returns 3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> findIndexOfFriend2 = <span class="built_in">find</span>(item: <span class="string">"Guinevere"</span>, inArray: myFriends)</span><br><span class="line"><span class="comment">// returns nil</span></span><br></pre></td></tr></table></figure><h2 id="关于-Equatable-协议"><a href="#关于-Equatable-协议" class="headerlink" title="关于 Equatable 协议"></a>关于 <code>Equatable</code> 协议</h2><p>exists 函数中 <code>&lt;T: Equatable &gt;</code> 标注是什么呢？它叫做类型约束，它规定了”那个类型参数必须继承自一个具体的类，或者遵守一个特定的协议或是协议组合。我指定了 exists 函数参数，<code>item: T</code> 和 <code>inArray: [T]</code>, 必须是类型 <code>T</code>, 而类型 <code>T</code> 必须遵守协议 <code>Equatable</code> 协议，为什么是这样的呢?</p><p>所有的 Swift 内置类型已经被构建支持 <code>Equatable</code> 协议。来自 <a href="https://developer.apple.com/documentation/ Swift / Equatable" target="_blank" rel="noopener">Apple docs</a>:  “遵守 <code>Equatable</code> 协议的类型进行相等比较，使用等于运算符(<code>==</code>)判断相等，或者使用不等运算符(<code>!=</code>)判断不等”。这就是为什么我的泛型函数 “exists” 能够在 Swift 的类型（如 <code>String</code>，<code>Integer</code>，<code>Float</code> 和 <code>Double</code>）上正常工作。所有这些类型都定义了 <code>==</code> 和 <code>!=</code> 运算符。 </p><h2 id="自定义类型和泛型"><a href="#自定义类型和泛型" class="headerlink" title="自定义类型和泛型"></a>自定义类型和泛型</h2><p>假如我声明了一个新的类叫做 “BasicPerson” 如下所示。我能用我的 exists” 函数来找出在数组中是否有 “BasicPerson” 类的一个实例的类型么？不行！为什么不行？看看下面这个代码，我们接下来讨论它：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPerson</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> sex: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(weight: <span class="type">Int</span>, name: <span class="type">String</span>, sex: <span class="type">String</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.weight = weight</span><br><span class="line">        <span class="keyword">self</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="type">Jim</span> = <span class="type">BasicPerson</span>(weight: <span class="number">180</span>, name: <span class="string">"Jim Patterson"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Sam</span> = <span class="type">BasicPerson</span>(weight: <span class="number">120</span>, name: <span class="string">"Sam Patterson"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Sara</span> = <span class="type">BasicPerson</span>(weight: <span class="number">115</span>, name: <span class="string">"Sara Lewis"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> basicPersons = [<span class="type">Jim</span>, <span class="type">Sam</span>, <span class="type">Sara</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isSamABasicPerson = exists(item: <span class="type">Sam</span>, inArray: basicPersons)</span><br></pre></td></tr></table></figure><p>看到最后一行，因为它有一个编译错误：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">error: <span class="keyword">in</span> argument type '[<span class="type">BasicPerson</span>]', '<span class="type">BasicPerson'</span> does not conform to expected type '<span class="type">Equatable'</span></span><br><span class="line"><span class="keyword">let</span> isSamABasicPerson = exists(item: <span class="type">Sam</span>, inArray: basicPersons)</span><br></pre></td></tr></table></figure><p><img src="https://camo.githubusercontent.com/f36f760385795cb9e802f886cda24bbf8bb720ab/68747470733a2f2f617070636f64612e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f30322f73776966742d342d67656e65726963732d312e706e67" alt=""></p><p>这很糟糕了， 在 “BasicPerson” 类型的数组里面，你不能使用 Swift 数组的内建函数 <code>index</code> 和 <code>contains</code>。(你必须定义一个闭包，每当你想使用那两个方法 blah,blah,blah… 这个我就不提了。)</p><p>再次回到问题，为什么报错？</p><p>因为 “BasicPerson” 类没有遵守 <code>Equeatable</code> 协议(这是一个提示，请看下文咯)</p><h2 id="遵守-Equatable-协议"><a href="#遵守-Equatable-协议" class="headerlink" title="遵守 Equatable 协议"></a>遵守 <code>Equatable</code> 协议</h2><p>为了允许我的 “BasicPerson” 类是可以使用我的 “exists” 和 “find” 泛型方法，所有我需要做的是：</p><ul><li>让类遵守 <code>Equatable</code> 协议</li><li>重载类实例的 <code>==</code> 操作符</li></ul><p>注意<a href="https://developer.apple.com/documentation/ Swift / Equatable" target="_blank" rel="noopener">这个</a>“Swift 标准库为所有遵循 <code>Euqatable</code> 协议的类型提供了不等于(!=) 操作符的实现。通过调用自定义的 <code>==</code> 函数获取它的取反结果。</p><p>如果你对操作符重载不熟悉，我建议你阅读这些主题，链接在<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/SwiftProgrammingLanguage/AdvancedOperators.html" target="_blank" rel="noopener">这里</a>和<a href="https://www.appcoda.com/operator-overloading-Swift" target="_blank" rel="noopener">这里的</a>.相信我，你会想知道操作符重载的。</p><blockquote><p>提示：我重命名 “BasicPerson” 类为 “Person” 让他们在相同的 Swift Playground 文件能共存，接着我们来到 “Person” 类。</p></blockquote><p>我将实现 <code>==</code> 操作符，所以它能比较 “Person” 类不同实例间的 “name”, “weight”, 和 “sex” 属性。如果两个 “Person” 类的实例有相同的的三个属性。则他们是相等的。如果有一个属性不同，则他们是不相等的(!=)。这就是为什么我的 “Person” 类遵守了 <code>Equatable</code> 协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lass <span class="type">Person</span>: <span class="type">Equatable</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> weight:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> sex:<span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(weight: <span class="type">Int</span>, name: <span class="type">String</span>, sex: <span class="type">String</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.weight = weight</span><br><span class="line">        <span class="keyword">self</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Person, rhs: Person)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> lhs.weight == rhs.weight &amp;&amp;</span><br><span class="line">            lhs.name == rhs.name &amp;&amp;</span><br><span class="line">            lhs.sex == rhs.sex</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面的 <code>==</code> 重载方法，这需要让 “Person” 遵守 <code>Equatable</code> 协议。注意 <code>==</code> 重载方法中的 <code>lhs</code> 和 <code>rhs</code> 参数。这是通用的，当重载操作符时，代码中等号两边的对象应该与参数中的物理位置一致，如：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lhs == rhs</span><br><span class="line"><span class="keyword">left</span>-hand side == <span class="keyword">right</span>-hand side</span><br></pre></td></tr></table></figure><h2 id="它实用吗？"><a href="#它实用吗？" class="headerlink" title="它实用吗？"></a>它实用吗？</h2><p>如果你跟随着我的指南，你能创建像我写的 “exists” 和 “find” 泛型函数用于任何你创建的新类型，如类或者结构体。让你自定义的类和结构体集合类型遵守 <code>Equatable</code> 协议，像 Swift 里面 <code>Array</code> 中的内置函数 <code>index</code> 和 <code>contains</code>。他们确实有用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">Joe</span> = <span class="type">Person</span>(weight: <span class="number">180</span>, name: <span class="string">"Joe Patterson"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Pam</span> = <span class="type">Person</span>(weight: <span class="number">120</span>, name: <span class="string">"Pam Patterson"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Sue</span> = <span class="type">Person</span>(weight: <span class="number">115</span>, name: <span class="string">"Sue Lewis"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Jeb</span> = <span class="type">Person</span>(weight: <span class="number">180</span>, name: <span class="string">"Jeb Patterson"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Bob</span> = <span class="type">Person</span>(weight: <span class="number">200</span>, name: <span class="string">"Bob Smith"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> myPeople:<span class="type">Array</span> = [<span class="type">Joe</span>, <span class="type">Pam</span>, <span class="type">Sue</span>, <span class="type">Jeb</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> indexOfOneOfMyPeople = <span class="built_in">find</span>(item: <span class="type">Jeb</span>, inArray: myPeople)</span><br><span class="line"><span class="comment">// returns 3 from custom generic function</span></span><br><span class="line"><span class="comment">// 返回 3 源自自定义泛型函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> indexOfOneOfMyPeople1 = myPeople.index(of: <span class="type">Jeb</span>)</span><br><span class="line"><span class="comment">// returns 3 from built-in Swift member function</span></span><br><span class="line"><span class="comment">// 返回 3 源自 Swift 内建成员函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isSueOneOfMyPeople = exists(item: <span class="type">Sue</span>, inArray: myPeople)</span><br><span class="line"><span class="comment">// returns true from custom generic function</span></span><br><span class="line"><span class="comment">// 返回 true 源自自定义泛型函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isSueOneOfMyPeople1 = myPeople.<span class="built_in">contains</span>(<span class="type">Sue</span>)</span><br><span class="line"><span class="comment">// returns true from built-in Swift member function</span></span><br><span class="line"><span class="comment">// 返回 true 源自 Swift 内建成员函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> indexOfBob = <span class="built_in">find</span>(item: <span class="type">Bob</span>, inArray: myPeople)</span><br><span class="line"><span class="comment">// returns nil from custom generic function</span></span><br><span class="line"><span class="comment">// 返回 nil 源自自定义泛型函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> indexOfBob1 = myPeople.index(of: <span class="type">Bob</span>)</span><br><span class="line"><span class="comment">// returns nil from built-in Swift member function</span></span><br><span class="line"><span class="comment">// 返回 nil 源自 Swift 内建成员函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isBobOneOfMyPeople1 = exists(item: <span class="type">Bob</span>, inArray: myPeople)</span><br><span class="line"><span class="comment">// returns false from custom generic function</span></span><br><span class="line"><span class="comment">// 返回 false 源自自定义泛型函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> isBobOneOfMyPeople2 = myPeople.<span class="built_in">contains</span>(<span class="type">Bob</span>)</span><br><span class="line"><span class="comment">// returns false from built-in Swift member function</span></span><br><span class="line"><span class="comment">// 返回 false 源自 Swift 内建成员函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> <span class="type">Joe</span> == <span class="type">Pam</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"they're equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"they're not equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// returns "they're not equal"</span></span><br></pre></td></tr></table></figure><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>苹果提示关于 <code>Equatable</code> 协议的更多好处：</p><blockquote><p>Adding  Equatable  conformance to your custom types means that you can use more convenient APIs when searching for particular instances in a collection.  Equatable  is also the base protocol for the Hashable and Comparable protocols, which allow more uses of your custom type, such as constructing sets or sorting the elements of a collection.</p></blockquote><blockquote><p>让你的自定义类型遵循 Equatable 协议意味着你可以使用许多系统提供的 API 来让你在一个集合里面查找特定一个实例变得更加方便。</p><p>Equatable 协议也是 Hashable 协议和 Comparable 协议的基础协议。这允许你使用更多的自定义类型，比如构建集合或者排序集合中的元素。</p></blockquote><p>比如，如果你遵守了 <code>comparable</code> 协议，你能重载和使用 <code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code> 和 <code>&gt;=</code> 操作符，这真的很 Cool。</p><h2 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h2><p>想一下我们的 “Person” 类，假如我们有一些类似下文所示的实例：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">Joe</span> = <span class="type">Person</span>(weight: <span class="number">180</span>, name: <span class="string">"Joe Patterson"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Pam</span> = <span class="type">Person</span>(weight: <span class="number">120</span>, name: <span class="string">"Pam Patterson"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Sue</span> = <span class="type">Person</span>(weight: <span class="number">115</span>, name: <span class="string">"Sue Lewis"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Jeb</span> = <span class="type">Person</span>(weight: <span class="number">180</span>, name: <span class="string">"Jeb Patterson"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Bob</span> = <span class="type">Person</span>(weight: <span class="number">200</span>, name: <span class="string">"Bob Smith"</span>, sex: <span class="string">"M"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Jan</span> = <span class="type">Person</span>(weight: <span class="number">115</span>, name: <span class="string">"Sue Lewis"</span>, sex: <span class="string">"F"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> <span class="type">Jan</span> == <span class="type">Sue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"they're equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"they're not equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// returns "they're equal" for 2 different objects</span></span><br><span class="line"><span class="comment">// 返回 "they're equal" 对于两个不同的对象</span></span><br></pre></td></tr></table></figure><p>看最后一行，因为这些 “Person” 对象中 “Jan” 和 “Sue” 对象是绝对相等的。即使他们是两个不同的实例对象。你的软件好坏仅仅取决于你的设计。在数据库的术语体系里， “Person” 类集合中，你会需要一个”主键” — 或许在类的设计中，可以添加一个索引变量。比如一个社会安全码、或者你熟知的其他的唯一值来保证 “Person” 类实例在集合 (<code>Array</code>) 中的唯一性，当然啦，你也可以使用 <code>===</code> 操作符。</p><p>享用吧！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文详细讲解了 Swift 中的泛型是什么？ 如何使用泛型？
    
    </summary>
    
      <category term="AppCoda" scheme="https://swift.gg/categories/AppCoda/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>构建第一个 Swift 区块链应用</title>
    <link href="https://swift.gg/2018/08/21/blockchain-introduction/"/>
    <id>https://swift.gg/2018/08/21/blockchain-introduction/</id>
    <published>2018-08-21T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sai Kambampati，<a href="https://appcoda.com/blockchain-introduction/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-05-31<br>译者：<a href="http://daizi.me" target="_blank" rel="noopener">小袋子</a>；校对：<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>区块链作为一项革命性的技术，开始受到越来越多追捧。为什么呢？因为区块链是许多加密数字货币的底层技术，比如：比特币（BTC），以太坊（ETH）以及莱特币（LTC）。区块链具体是如何工作的？本篇教程会涵盖所有区块链相关的知识，还会教你如何构建 Swift 区块链。下面让我们开始吧！</p><a id="more"></a><h3 id="区块链的工作原理"><a href="#区块链的工作原理" class="headerlink" title="区块链的工作原理"></a>区块链的工作原理</h3><p>顾名思义，区块链是一条由不同区块连接组成的链。每一个块包含三个信息：数据、哈希（hash）、以及前置区块的哈希。</p><p><strong>1、数据</strong> – 由于应用场景不同，存储在区块中的数据由区块链的类型决定。例如，在比特币区块链中，存储的数据是交易信息：转账金额和交易双方的信息。</p><p><strong>2、哈希</strong> – 你可以将哈希看做数字指纹，用来唯一标识一个区块及其数据。哈希的重要之处在于它是一个独特的字母数字代码，通常是 64 个字符。当一个区块被创建时，哈希也随之创建。当一个区块被修改，哈希也随之修改。因此，当你想要查看在区块上所做的任何变更时，哈希就显得非常重要。</p><p><strong>3、前置区块的哈希</strong> – 通过存储前置区块的哈希，你可以还原每个区块连接成区块链的过程！这使得区块链安全性特别高。</p><p>我们来看下这张图片：</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-explained.png" alt="区块链"></p><p>你可以看到，每一个区块包含数据（图片中没有指明）、哈希以及前置区块的哈希。例如，黄色区块包含自身的哈希：H7s6，以及红色区块的哈希：8SD9。这样它们就构成了一条相互连接的链。现在，假如有一个黑客准备恶意篡改红色的区块。请记住，每当块以任何方式被篡改时，该区块的哈希都会改变！当下一个区块检查并发现前置哈希不一致时，黑客将无法访问它，因为他与前置区块的联系被切断了（译者注：即如果黑客想要要篡改一个区块的话，就需要把这个区块后面的所有区块都要改掉，而这个工作量是很难实现的）。</p><p>这使得区块链特别安全，几乎不可能回滚或者篡改任何数据。虽然哈希为保密和隐私提供了巨大的保障，但是还有两个更加安全妥当的措施让区块链更加安全：工作量证明（Proof-of-Work）以及智能合约（Smart Contracts）。本文我不会深入讲解，你可以<a href="https://hackernoon.com/what-on-earth-is-a-smart-contract-2c82e5d89d26" target="_blank" rel="noopener">在这里</a>了解更多相关知识。</p><p>区块链最后一个保证自身安全性的方式是基于其定位。和大多数存储在服务器和数据库的数据不同，区块链使用的是点对点（P2P）网络。P2P 是一种允许任何人加入的网络，并且该网络上的数据会分发给每一个接收者。</p><p>每当有人加入这个网络，他们就会获得一份区块链的完整拷贝。每当有人新建一个区块，就会广播给全网。在将该块添加到链之前，节点会通过几个复杂的程序确定该块是否被篡改。这样，所有人、所有地方都可以使用这个信息。如果你是 <em>HBO 美剧硅谷</em> 的粉丝，对此应该不会感到陌生。在该剧中，主演（Richard）使用一种相似的技术创造了新型互联网（译者注：有趣的是剧中还发行了区块链数字货币 PiedPaperCoin，感兴趣的童鞋可以刷一下这部剧）。</p><p>因为每个人都有区块链或者节点的一份拷贝，他们可以达成一种共识并决定哪部分区块是有效的。因此，如果你想要攻击某个区块，你必须同时攻击网络上 50% 以上的区块（译者：51% 攻击），使得你的区块可以追上并替换原区块链。所以区块链或许是过去十年所创造的最安全的技术之一。</p><h3 id="关于示例程序"><a href="#关于示例程序" class="headerlink" title="关于示例程序"></a>关于示例程序</h3><p>现在你已经对区块链的原理有了初步的认识，那么我们就开始写示例程序吧！你可以在这里下载<a href="https://github.com/appcoda/BlockchainDemo/raw/master/BlockchainStarter.zip" target="_blank" rel="noopener">原始项目</a>。</p><p>如你所见，我们有两个比特币钱包。第一个账户 1065 有 500 BTC，而第二个账户 0217 没有 BTC。我们通过 send 按钮可以发送比特币到另外的账户。为了赚取 BTC，我们可以点击 Mine 按钮，可以获得 50 BTC 的奖励。我们主要工作是查看控制台输出，观察两个账户间的交易过程。</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-2.png" alt="这里写图片描述"></p><p>在左侧导航栏可以看到两个很重要的类：<code>Block</code> 和 <code>Blockchain</code>。目前这两个类都是空实现，我会带着你们在这两个类中写入相关逻辑。下面让我们开始吧！</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-3.png" alt="这里写图片描述"></p><h3 id="在-Swift-中定义区块"><a href="#在-Swift-中定义区块" class="headerlink" title="在 Swift 中定义区块"></a>在 Swift 中定义区块</h3><p>首先打开 <code>Block.swift</code> 并添加定义区块的代码。在此之前，我们需要定义区块是什么。前面我们曾定义过，区块是由三部分组成：哈希、实际记录的数据以及前置区块的哈希。当我们想要构建我们的区块链时，我们必须知道该区块是第一个还是第二个。我们可以很容易地在 Swift 的类中做如下定义：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hash: <span class="type">String</span>!</span><br><span class="line"><span class="keyword">var</span> data: <span class="type">String</span>!</span><br><span class="line"><span class="keyword">var</span> previousHash: <span class="type">String</span>!</span><br><span class="line"><span class="keyword">var</span> index: <span class="type">Int</span>!</span><br></pre></td></tr></table></figure><p>现在需要添加最重要的代码。我曾提过区块在被修改的情况下，哈希也会随之变化，这是区块链如此安全的特性之一。因此我们需要创建一个函数去生成哈希，该哈希由随机字母和数字组成。这个函数只需要几行代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateHash</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NSUUID</span>().uuidString.replacingOccurrences(of: <span class="string">"-"</span>, with: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NSUUID</code> 是一个代表通用唯一值的对象，并且可以桥接成 UUID。它可以快速地生成 32 个字符串。本函数生成一个 UUID，删除其中的连接符，然后返回一个 <code>String</code>，最后将结果作为区块的哈希。<code>Block.swift</code> 现在就像下面：</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-4.png" alt="这里写图片描述"></p><p>现在我们已经定义好了 <code>Block</code> 类，下面来定义 Blockchain 类，首先切换到 <code>Blockchain.swift</code> 。</p><h3 id="在-Swift-中定义区块链"><a href="#在-Swift-中定义区块链" class="headerlink" title="在 Swift 中定义区块链"></a>在 Swift 中定义区块链</h3><p>和之前一样，首先分析区块链的基本原理。用非常基础的术语来说，区块链只是由一连串的区块连接而成，也可以说是一个由多个条目组成的列表。这是不是听起来很熟悉呢？其实这就是数组的定义！而且这个数组是由区块组成的！接下来添加以下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> chain = [<span class="type">Block</span>]()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快速提示： 这个方法可以应用于计算机科学世界里的任何事物。如果你遇到大难题，可以尝试把它分解成若干个小问题，以此来建立起解决问题的方法，正如我们解决在 Swift 中如何添加区块和区块链的问题。</span><br></pre></td></tr></table></figure><p>你会注意到数组里面是我们前面定义的 <code>Block</code> 类，这就是区块链所需要的所有变量。为了完成功能，我们还需要在类中添加两个函数。请尝试着根据我之前教过的方法解答这个问题。</p><blockquote><p>区块链中的两个主要函数是什么？</p></blockquote><p>我希望你能认真思考并回答这个问题！实际上，区块链的两个主要功能是创建创世区块（最初的始块），以及在其结尾添加新的区块。当然现在我不打算实现分叉区块链和添加智能合约的功能，但你必须了解这两个是基本功能！将以下代码添加到 <code>Blockchain.swift</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createGenesisBlock</span><span class="params">(data:String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> genesisBlock = <span class="type">Block</span>()</span><br><span class="line">    genesisBlock.hash = genesisBlock.generateHash()</span><br><span class="line">    genesisBlock.data = data</span><br><span class="line">    genesisBlock.previousHash = <span class="string">"0000"</span></span><br><span class="line">    genesisBlock.index = <span class="number">0</span></span><br><span class="line">    chain.append(genesisBlock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createBlock</span><span class="params">(data:String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newBlock = <span class="type">Block</span>()</span><br><span class="line">    newBlock.hash = newBlock.generateHash()</span><br><span class="line">    newBlock.data = data</span><br><span class="line">    newBlock.previousHash = chain[chain.<span class="built_in">count</span>-<span class="number">1</span>].hash</span><br><span class="line">    newBlock.index = chain.<span class="built_in">count</span></span><br><span class="line">    chain.append(newBlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、我们添加的第一个函数的作用是创建创世区块。为此，我们创建了一个以区块数据为入参的函数。然后定义了一个类型为 <code>Block</code> 的变量 <code>genesisBlock</code>，它拥有此前在 <code>Block.swift</code> 中定义的所有变量和函数。我们将 <code>generateHash()</code> 赋值给哈希，将输入的 <code>data</code> 参数赋值给数据。由于这是第一个区块，我们将前置区块的哈希设为 0000，这样我们就可以知道这是起始区块。最后我们将 <code>index</code> 设为 0，并将这个区块加入到区块链中。</p><p>2、我们创建的第二个函数适用于 <code>genesisBlock</code> 之后的所有区块，并且能创建剩余的区块。你会注意到它与第一个函数非常相似。唯一的区别是，我们将 <code>previousHash</code> 的值设置为前一个区块的哈希值，并将 <code>index</code> 设置为它在区块链中的位置。就这样，区块链已经定义好了！你的代码应该看起来跟下图一样！</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-5.png" alt="这里写图片描述"></p><h3 id="钱包后端"><a href="#钱包后端" class="headerlink" title="钱包后端"></a>钱包后端</h3><p>现在切换到 <code>ViewController.swift</code>，我们会发现所有的 outlet 都已经连接好了。我们只需要处理交易，并将其输出到控制台。</p><p>然而在此之前，我们需要稍微研究一下比特币的区块链。比特币是由一个总账户产生的，我们将这个账号的编号称为 0000。当你挖到一个 BTC，意味着你解决了数学问题，因此会发行一定数量的比特币作为奖励。这提供了一个发币的高明方法，并且可以激励更多人去挖矿。在我们的应用，让我们把挖矿奖励设为 100 BTC。首先，在视图控制器中添加所需的变量：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstAccount = <span class="number">1065</span></span><br><span class="line"><span class="keyword">let</span> secondAccount = <span class="number">0217</span></span><br><span class="line"><span class="keyword">let</span> bitcoinChain = <span class="type">Blockchain</span>()</span><br><span class="line"><span class="keyword">let</span> reward = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> accounts: [<span class="type">String</span>: <span class="type">Int</span>] = [<span class="string">"0000"</span>: <span class="number">10000000</span>]</span><br><span class="line"><span class="keyword">let</span> invalidAlert = <span class="type">UIAlertController</span>(title: <span class="string">"Invalid Transaction"</span>, message: <span class="string">"Please check the details of your transaction as we were unable to process this."</span>, preferredStyle: .alert)</span><br></pre></td></tr></table></figure><p>首先定义号码为 1065 和 0217 的两个账号。然后添加一个名为 <code>bitcoinChain</code> 的变量作为我们的区块链，并将 <code>reward</code> 设为 100。我们需要一个主帐户作为所有比特币的来源：即创世帐户 0000。里面有 1000 万个比特币。你可以把这个账户想象成一个银行，所有因奖励产生的 100 个比特币都经此发放到合法账户中。我们还定义了一个提醒弹窗，每当交易无法完成时就会弹出。</p><p>现在，让我们来编写几个运行时需要的通用函数。你能猜出是什么函数吗？</p><p>1、第一个函数是用来处理交易的。我们需要确保交易双方的账户，能够接收或扣除正确的金额，并将这些信息记录到我们的区块链中。</p><p>2、下一个函数是在控制台中打印整个记录 —— 它将显示每个区块及其中的数据。</p><p>3、最后一个是用于验证区块链是否有效的函数，通过校验下一个区块的 <code>previousHash</code> 和上一个区块 <code>hash</code> 是否匹配。由于我们不会演示任何黑客方法，因此在我们的示例程序中，区块链是永远有效的。</p><h3 id="交易函数"><a href="#交易函数" class="headerlink" title="交易函数"></a>交易函数</h3><p>下面是一个通用的交易函数，请在我们定义的变量下方输入以下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transaction</span><span class="params">(from: String, to: String, amount: Int, type: String)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> accounts[from] == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.present(invalidAlert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> accounts[from]!-amount &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.present(invalidAlert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        accounts.updateValue(accounts[from]!-amount, forKey: from)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> accounts[to] == <span class="literal">nil</span> &#123;</span><br><span class="line">        accounts.updateValue(amount, forKey: to)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        accounts.updateValue(accounts[to]!+amount, forKey: to)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> type == <span class="string">"genesis"</span> &#123;</span><br><span class="line">        bitcoinChain.createGenesisBlock(data: <span class="string">"From: <span class="subst">\(from)</span>; To: <span class="subst">\(to)</span>; Amount: <span class="subst">\(amount)</span>BTC"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> type == <span class="string">"normal"</span> &#123;</span><br><span class="line">        bitcoinChain.createBlock(data: <span class="string">"From: <span class="subst">\(from)</span>; To: <span class="subst">\(to)</span>; Amount: <span class="subst">\(amount)</span>BTC"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码量看起来好像很大，但主要是定义了每个交易需要遵循的一些规则。一开始是函数的四个参数：<br><code>to</code>，<code>from</code>，<code>amount</code>，<code>type</code>。前三个参数不需要再解释了，而 <code>Type</code> 主要用于定义交易的类型。总共有两个类型：正常类型（normal） 和创世类型（genesis）。正常类型的交易会发生在账户 1065 和 2017 之间，而创世类型将会涉及到账户 0000。</p><p>1、第一个 <code>if-else</code> 条件语句处理转出账户的信息。如果账户不存在或者余额不足，将会提示交易不合法并返回。</p><p>2、第二个 <code>if-else</code> 条件语句处理转入账户的信息。如果账户不存在，则创建新账户并转入相应的比特币。反之，则向该账户转入正确数量的比特币。</p><p>3、最后一个 <code>if-else</code> 条件语句处理交易类型。如果类型是创世类型，则添加一个创世区块，否则创建一个新的区块存储数据。</p><h3 id="打印函数"><a href="#打印函数" class="headerlink" title="打印函数"></a>打印函数</h3><p>为了确保交易正确执行，在每个交易结束后，我们希望拿到所有交易的清单。以下是我们在交易函数下方的代码，用来打印相关信息：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chainState</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...bitcoinChain.chain.<span class="built_in">count</span>-<span class="number">1</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\tBlock: <span class="subst">\(bitcoinChain.chain[i].index!)</span>\n\tHash: <span class="subst">\(bitcoinChain.chain[i].hash!)</span>\n\tPreviousHash: <span class="subst">\(bitcoinChain.chain[i].previousHash!)</span>\n\tData: <span class="subst">\(bitcoinChain.chain[i].data!)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    redLabel.text = <span class="string">"Balance: <span class="subst">\(accounts[String(describing: firstAccount)</span>]!) BTC"</span></span><br><span class="line">    blueLabel.text = <span class="string">"Balance: <span class="subst">\(accounts[String(describing: secondAccount)</span>]!) BTC"</span></span><br><span class="line">    <span class="built_in">print</span>(accounts)</span><br><span class="line">    <span class="built_in">print</span>(chainValidity())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的循环语句，遍历 <code>bitcoinChain</code> 中的所有区块，并打印区块号码，哈希，前置哈希，以及存储的数据。同时我们更新了界面中的标签（label），这样就可以显示账户中正确的 BTC 数量。最后，打印所有的账户（应该是 3 个），并校验区块链的有效性。</p><p>现在你应该会在函数的最后一行发现一个错误。这是由于我们还没有实现 <code>chainValidity()</code> 函数，让我们马上开始吧。</p><h3 id="有效性函数"><a href="#有效性函数" class="headerlink" title="有效性函数"></a>有效性函数</h3><p>判断一个链是否有效的标准是：前置区块的哈希与当前区块所表示的是否匹配。我们可以再次用循环语句来遍历所有的区块：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chainValidity</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isChainValid = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...bitcoinChain.chain.<span class="built_in">count</span>-<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> bitcoinChain.chain[i].previousHash != bitcoinChain.chain[i-<span class="number">1</span>].hash &#123;</span><br><span class="line">            isChainValid = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Chain is valid: <span class="subst">\(isChainValid)</span>\n"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前一样，我们遍历了 <code>bitcoinChain</code> 中的所有区块，并检查了前置区块的 <code>hash</code> 是否与当前区块的 <code>previousHash</code> 一致。</p><p>就酱！我们已经将定义了所有需要的函数！你的 <code>ViewController.swift</code> 应该如下图一样：</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-6.png" alt="这里写图片描述"></p><p>收尾工作就是连接按钮和函数啦。让我们马上开始最后的部分吧！</p><h3 id="让一切关联起来"><a href="#让一切关联起来" class="headerlink" title="让一切关联起来"></a>让一切关联起来</h3><p>当我们的应用第一次启动时，需要创世账户 0000 发送 50 BTC 到我们的第一个账户。再从第一个账户转账 10 BTC 到第二个账户，这只需要寥寥三行代码。最后 <code>viewDidLoad</code> 中的代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    transaction(from: <span class="string">"0000"</span>, to: <span class="string">"<span class="subst">\(firstAccount)</span>"</span>, amount: <span class="number">50</span>, type: <span class="string">"genesis"</span>)</span><br><span class="line">    transaction(from: <span class="string">"<span class="subst">\(firstAccount)</span>"</span>, to: <span class="string">"<span class="subst">\(secondAccount)</span>"</span>, amount: <span class="number">10</span>, type: <span class="string">"normal"</span>)</span><br><span class="line">    chainState()</span><br><span class="line">    <span class="keyword">self</span>.invalidAlert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用已定义好的函数转账，并调用 <code>chainState()</code> 函数。最后，我们还在 <code>invalidAlert</code> 中添加了一个标题为 OK 的 <code>UIAlertAction</code>。</p><p>现在让我们来实现剩下的四个函数：<code>ReMeNe()</code>、<code>BrimeMeNe()</code>、<code>ReSdEnter()</code>和<code>BuLeScript()</code>。</p><h3 id="挖矿函数"><a href="#挖矿函数" class="headerlink" title="挖矿函数"></a>挖矿函数</h3><p>挖矿函数特别简单，只需要三行代码。添加以下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">redMine</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    transaction(from: <span class="string">"0000"</span>, to: <span class="string">"<span class="subst">\(firstAccount)</span>"</span>, amount: <span class="number">100</span>, type: <span class="string">"normal"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"New block mined by: <span class="subst">\(firstAccount)</span>"</span>)</span><br><span class="line">    chainState()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">blueMine</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    transaction(from: <span class="string">"0000"</span>, to: <span class="string">"<span class="subst">\(secondAccount)</span>"</span>, amount: <span class="number">100</span>, type: <span class="string">"normal"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"New block mined by: <span class="subst">\(secondAccount)</span>"</span>)</span><br><span class="line">    chainState()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一个挖矿函数中，我们使用交易函数从创世账户发送了 100 BTC 到第一个账户。我们打印了挖矿的区块，然后打印了区块链的状态。同样地，在 <code>blueMine</code> 函数中，我们转给了第二个账户 100 BTC。</p><h3 id="发送函数"><a href="#发送函数" class="headerlink" title="发送函数"></a>发送函数</h3><p>发送函数和挖矿函数略微相似：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">redSend</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> redAmount.text == <span class="string">""</span> &#123;</span><br><span class="line">        present(invalidAlert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transaction(from: <span class="string">"<span class="subst">\(firstAccount)</span>"</span>, to: <span class="string">"<span class="subst">\(secondAccount)</span>"</span>, amount: <span class="type">Int</span>(redAmount.text!)!, type: <span class="string">"normal"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(redAmount.text!)</span> BTC sent from <span class="subst">\(firstAccount)</span> to <span class="subst">\(secondAccount)</span>"</span>)</span><br><span class="line">        chainState()</span><br><span class="line">        redAmount.text = <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">blueSend</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> blueAmount.text == <span class="string">""</span> &#123;</span><br><span class="line">        present(invalidAlert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transaction(from: <span class="string">"<span class="subst">\(secondAccount)</span>"</span>, to: <span class="string">"<span class="subst">\(firstAccount)</span>"</span>, amount: <span class="type">Int</span>(blueAmount.text!)!, type: <span class="string">"normal"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(blueAmount.text!)</span> BTC sent from <span class="subst">\(secondAccount)</span> to <span class="subst">\(firstAccount)</span>"</span>)</span><br><span class="line">        chainState()</span><br><span class="line">        blueAmount.text = <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们检查 <code>redAmount</code> 或者 <code>blueAmount</code> 的文本值是否为空。如果为空，则弹出无效交易的提示框。如果不为空，则继续下一步。我们使用交易函数从第一个账户转账到第二个账户（或者反向转账），金额为输入的数量。我们打印转账金额，并调用 <code>chainState()</code> 方法。最后，清空文本框。</p><p>就酱，工作完成！请检查你的代码是否和图中一致：</p><p><img src="https://appcoda.com/wp-content/uploads/2018/05/blockchain-7.png" alt="这里写图片描述"></p><p>现在运行应用并测试一下。从前端看，这就像一个正常的交易应用，但是运行在屏幕背后的可是区块链啊！请尝试使用应用将 BTC 从一个帐户转移到另一个帐户，随意测试，尽情把玩吧！</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在这个教程中，你已经学会了如何使用 Swift 创建区块链，并且创建了你自己的比特币交易系统。请注意，真正加密货币的后端，和我们上面的实现完全不一样，因为它需要用智能合约实现分布式，而本例仅用于学习。</p><p>在这个示例中，我们将区块链技术应用于加密货币，然而你能想到区块链的其他应用场景吗？请留言分享给大家！希望你能学到更多新东西！</p><p>为了参考，你可以从 GitHub 下载<a href="https://github.com/appcoda/BlockchainDemo" target="_blank" rel="noopener">完整的示例</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      构建第一个 Swift 区块链应用
    
    </summary>
    
      <category term="AppCoda" scheme="https://swift.gg/categories/AppCoda/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="区块链" scheme="https://swift.gg/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>在 Swift 中使用 Watch Connectivity — Application Context</title>
    <link href="https://swift.gg/2018/08/15/watch-connectivity-swift-application-context/"/>
    <id>https://swift.gg/2018/08/15/watch-connectivity-swift-application-context/</id>
    <published>2018-08-15T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：codingexplorer，<a href="http://www.codingexplorer.com/watch-connectivity-swift-application-context/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-07-18<br>译者：<a href="http://khala-wan.com" target="_blank" rel="noopener">Khala-wan</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="undefined">wongzigii</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p><img src="http://www.codingexplorer.com/wp-content/uploads/2016/02/Watch-Connectivity-Application-Context.png" alt=""></p><p>在 watchOS 1 时代，<code>WatchKit Extension</code> 位于已配对的 iOS 设备上，这使得宿主 APP 和 watch 之间的数据共享变得简单。类似偏好设置这种最简单的数据，只需要通过 App Groups 功能来存取 <code>NSUserDefaults</code>。目前在手机上留存的其他扩展程序和主 app 之间共享数据仍然应该使用这种方式，例如 <code>Today View Extension</code>，但它已不再适用于 watchOS 的 app。<br>幸运的是，苹果为我们提供了新的 API 来做这件事。相比 App Groups，Watch Connectivity 拥有更强大的功能。它不仅提供了你的 Apple Watch 和与其配对 iPhone 之间连接状态的更多信息，还允许它们之间进行交互消息和 3 种方式的后台传输，这些方式分别是：</p><ol><li>Application Context</li><li>User Info Transfer</li><li>File Transfer</li></ol><p>我们今天先讨论第一种方式：Application Context。</p><a id="more"></a><h2 id="什么是-Application-Context"><a href="#什么是-Application-Context" class="headerlink" title="什么是 Application Context"></a>什么是 Application Context</h2><p>假设你有个 watch app，它有一些可以在 iOS app 端设置的设置项，比如温度的显示单位是摄氏度还是华氏度。对于这样的设置项，除非你希望在用户在设置完成之后立即使用 watch 上的 app，否则将设置项的信息通过后台传输发送到 watch 才会是比较合理的。</p><p>因为它可能不是立即需要的，所以系统可能会在节省电量最多的情况下将其发送出去。你也不需要任何历史记录，因为用户可能并不关心一小时之前的设置是摄氏度。</p><p>这就是 Application Context 的用武之地。它仅用于发送最新的数据。如果你将温度设置项从摄氏度改为华氏度，然后在 Application Context 发送到 watch 之前再将它（或者其他设置项）设置为不同的值，那么最新的值会覆盖之前等待发送的信息。</p><p>如果你确实希望它能保存先前信息的历史记录，而且是以最省电的方式传输。那么可以使用 <code>User Info</code> 方式进行传输。它的使用方式和 Application Context 很相似，但它会将更新操作加入到一个队列中并逐一发送（而不是仅仅覆盖某些内容只发送最新的信息）。具体 <code>User Info</code> 的使用将作为以后另一篇文章的主题来讲。</p><h2 id="设置-iOS-应用程序"><a href="#设置-iOS-应用程序" class="headerlink" title="设置 iOS 应用程序"></a>设置 iOS 应用程序</h2><p>我们将从一个类似于上一篇文章 <a href="http://www.codingexplorer.com/watchos-2-hello-world-app-in-swift/" target="_blank" rel="noopener">watchOS Hello World App in Swift</a> 中的 app 说起。不过在本文中，我们将在这个 iPhone app 上加入一个 <code>UISwitch</code> 控件，并通过更新 watchOS app 上的 WKInterfaceLabel 来说明 <code>UISwitch</code> 的状态。</p><p>首先，在 iOS app 的 <code>viewController</code> 中，我们需要设置一些东西：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?)</span></span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sessionDidBecomeInactive</span><span class="params">(<span class="number">_</span> session: WCSession)</span></span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sessionDidDeactivate</span><span class="params">(<span class="number">_</span> session: WCSession)</span></span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> session: <span class="type">WCSession</span>?</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="type">WCSession</span>.isSupported() &#123;</span><br><span class="line">            session = <span class="type">WCSession</span>.<span class="keyword">default</span></span><br><span class="line">            session?.delegate = <span class="keyword">self</span></span><br><span class="line">            session?.activate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们最先需要导入 <code>WatchConnectivity</code> 框架。没有它，我们所做的都是无用功。接下来，为了响应来自 WCSession 的回调，我们需要将当前这个 <code>ViewController</code> 设置为 <code>WCSession</code> 的代理，为此我们需要让它遵守这个协议，所以在 <code>ViewController</code> 的父类声明后面添加 <code>WCSessionDelegate</code> 协议。</p><p>下一步，我们需要实现 <code>WCSessionDelegate</code> 中的一些方法。对于当前这个 app，它们不是特别必要，但是如果想要快速在 watch app 中切换，你就需要进一步实现它们。</p><p>之后，我们需要创建一个变量用于存储 <code>WCSession</code>。因为 <code>WCSession</code> 实际上是一个单例，技术上我们可以跳过这一步，但每次输入 <code>session?</code> 肯定要比 <code>WCSession.default</code> 更简短。</p><p>你应该在代码运行初期对 session 进行设置。在大多数情况下，这将在程序初始化的时候来做。但由于我们是在 <code>ViewController</code> 中执行此操作，所以最早能执行的地方大概就只有 <code>viewDidLoad</code> 方法中了。一般情况下来说，你不应该在 <code>viewController</code> 中执行这个操作，因为你的 app 希望在屏幕上未加载特定 <code>viewController</code> 时就可以更新它的数据模型。为了简单起见，我在 <code>viewController</code> 中做了这个操作，这仅仅是为了展示如何使用这些 API。如果这个 <code>ViewController</code> 是唯一关心使用 <code>WCSession</code> 的东西，那就没关系。但通常情况并非如此。</p><p>要设置 session，我们需要先根据 <code>WCSession</code> 的 <code>isSupport</code> 方法的返回值来检查是否支持。如果程序在 iPad 上运行的话，这一点尤为重要。目前，你无法将 iPad 与 Apple Watch 配对，因此它会返回 <code>false</code> 表示不支持在 iPad 上使用 <code>WCSession</code>。在 iPhone 上它会返回 <code>true</code>。</p><p>一旦我们完成检查，就可以将 WCSession 的 defaultSession 存储在那里，接着将这个 <code>ViewController</code> 设置为它的代理并激活 session。如果我们可以在初始化程序中执行 <code>isSupported</code> 来测试是否支持，就可以把 session 用作一个常量。而这里的 session 是一个可选值是因为我们不知道程序是否会运行在 <code>iPad</code> 上，所以当支持 <code>WCSession</code> 时，session 的值为 <code>WCSession.defualt</code>，反之则为 <code>nil</code>。这样，当我们在 <code>iPad</code> 上尝试访问 session 中的属性或方法时，它们甚至不会执行，因为 session 为 <code>nil</code>。</p><p>将一个 <code>UISwitch</code> 放在 Storyboard 上，并将其 <code>ValueChanged</code> 方法关联到 <code>ViewController</code> 中。<br>在方法中加入如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">switchValueChanged</span><span class="params">(<span class="number">_</span> sender: UISwitch)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> validSession = session &#123;</span><br><span class="line">        <span class="keyword">let</span> iPhoneAppContext = [<span class="string">"switchStatus"</span>: sender.isOn]</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> validSession.updateApplicationContext(iPhoneAppContext)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Something went wrong"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检查我们是否有一个有效的 session，如果是运行在 iPad 上，那么将跳过整个代码块。 <code>Application Context</code> 是一个 Swift 字典，它以 <code>String</code> 作为 <code>key</code>，<code>AnyObject</code> 作为 <code>value</code> (<code>Dictionary&lt;String, AnyObject&gt;</code>)。 value 必须遵循属性列表的规则，并且只包含某些类型。它和 <code>NSUserDefaults</code> 具有相同的限制，所以在上一篇文章 <a href="http://www.codingexplorer.com/nsuserdefaults-a-swift-introduction/" target="_blank" rel="noopener">NSUserDefaults — A Swift Introduction</a> 中已经介绍过了具体可以使用哪些类型。尽管如此，当我们发送一个 Swift <code>Bool</code> 类型时，其将会被转换为 <code>NSNumber boolean value</code>，所以没关系。</p><p>调用 <code>updateApplicationContext</code> 可能会抛出异常，所以我们需要将它包装在 <code>do-block</code> 中并通过 <code>try</code> 来调用。如果出现异常，我们只是在控制台上打印了一些信息，你还可以设置任何你需要的东西，比如你可能需要让用户知道发生了错误，那就可以显示一个 UIAlerController，同样，如果有必要可以加入异常的清理或恢复代码。这就是为了发送 <code>Application Context</code>，我们所需要的全部准备。</p><h2 id="设置-watchOS-应用程序"><a href="#设置-watchOS-应用程序" class="headerlink" title="设置 watchOS 应用程序"></a>设置 watchOS 应用程序</h2><p>因为我们使用的是之前 <a href="http://www.codingexplorer.com/watchos-2-hello-world-app-in-swift/" target="_blank" rel="noopener">watchOS Hello World App in Swift</a> 文中的 Hello World App，所以部分相同的设置已经替我们完成了。跟 iPhone 类似，我们还需要做一些设置才能使用 <code>WatchConnectivity</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceController</span>: <span class="title">WKInterfaceController</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> session = <span class="type">WCSession</span>.<span class="keyword">default</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awake</span><span class="params">(withContext context: Any?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awake(withContext: context)</span><br><span class="line">        </span><br><span class="line">        session.delegate = <span class="keyword">self</span></span><br><span class="line">        session.activate()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里省略掉了之前 App 中的一些无关代码，只展示与 <code>WatchConnectivity</code> 设置相关的部分。同样，我们需要导入 <code>WatchConnectivity</code> 框架，并让我们的 InterfaceController 遵守 WCSessionDelegate 协议，紧接着，我们将 session 常量初始化为 <code>WCSession</code> 的单例 <code>defaultSession</code>。</p><p>与 iOS 端不同的是，这里我们将 session 声明为一个非可选值的常量。很显然，运行在不低于 <code>watchOS 2</code> 系统上的 Apple Watch 是支持 <code>Watch Connectivity</code> 的，所以我们不需要在 <code>watchOS</code> 端进行相同的测试。 并且我们在声明时就初始化了它，又没有其他平台（如iPad）需要担心，所以我们不需要它是可选的。</p><p>接下来，在代码的初期，我们需要设置 session。在 InterfaceController 中 awakeWithContext 方法是个很好的地方，所以我们在这里做相关设置。和 iOS App 一样，我们设置当前类作为 session 的代理，然后激活 session。</p><p>让我们写一个辅助方法来处理 Application Context 的回调，因为我们可能会多次调用它，而不是仅仅当我们收到一个新 <code>context</code> 时（你很快会看到）。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processApplicationContext</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> iPhoneContext = session.receivedApplicationContext <span class="keyword">as</span>? [<span class="type">String</span> : <span class="type">Bool</span>] &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> iPhoneContext[<span class="string">"switchStatus"</span>] == <span class="literal">true</span> &#123;</span><br><span class="line">            displayLabel.setText(<span class="string">"Switch On"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            displayLabel.setText(<span class="string">"Switch Off"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WCSession</code> 有 2 个与 <code>Application Context</code> 相关的属性，<code>applicationContext</code> 和 <code>receivedApplicationContext</code>。它们的不同之处是：</p><ul><li>applicationContext - 此设备最近一次<strong>发送</strong>的 <code>Application Context</code>。</li><li>receivedApplicationContext - 此设备最近一次<strong>接收</strong>的 <code>Application Context</code>。</li></ul><p>现在，把它俩放到一起来看，至少接收到的看起来很明显。但在我第一次涉及这个时（不记得 WWDC 中 Watch Connectivity的介绍视频的全部内容？），我认为 applicationContext 是从最近的发送或接收来更新的，因为我认为它们是一致的 <code>context</code>。然而我大错特错，我花了一段时间才意识到它们是分开的。我当然能看出来原因，因为我们可能每次都会发送不一样的数据，就像从 Watch 的角度来看，applicationContext 就是 iPhone 端需要的 Watch 相关 <code>context</code>，而 receivedApplicationContext 则是 Watch 端需要的 iPhone 相关 <code>context</code>。无论哪种方式，请记住它们是不同的两个东西，并根据实际情况选择你所需要的那个。</p><p>所以在这个方法中，我们首先尝试将 <code>receivedApplicationContext</code> 由 <code>[String: AnyObject]</code> 类型的字典转换为我们需要的 <code>[String: Bool]</code> 类型。如果转换成功，则再根据字典中布尔值的状态将 displayLabel 的 text 值设置为 “Switch On” 或 “Switch Off”。</p><p>当我们实际接收到一个新的  Application context 时，该 InterfaceController 将会收到我们 WCSession 对象的代理回调来通知我们这个信息，我们将在那里调用这个辅助方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, didReceiveApplicationContext applicationContext: [String : Any])</span></span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async() &#123;</span><br><span class="line">        <span class="keyword">self</span>.processApplicationContext()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，你大概看到了 <code>didReceiveApplicationContext</code> 方法的入参带有它接收到的 <code>Application Context</code> 副本。它存储在上面提到的 <code>receivedApplicationContext</code> 属性中。所以我们并不需要它来调用辅助方法, 因此这个方法不需要传入任何行参。</p><blockquote><p>译者注：<br>其实对于辅助方法 <code>processApplicationContext</code> 来说，增加行参 context 反而更 <strong>函数式</strong>，也更 <strong>Swift</strong>。 通过增加一个 context 的入参，可以让方法内部实现和外部依赖解耦，更加方便我们对它进行单元测试。</p></blockquote><p>那么，调用 <code>dispatch_async</code> 是为了做什么呢？好吧，这些代理回调不在主线程上。你永远不应该在除主线程以外的任何线程更新 iOS 或 watchOS 中的 UI。而我们的辅助方法除了从 <code>receivedApplicationContext</code> 中读取信息之外，主要目的是用来更新 UI 元素。因此，我们要通过 <code>dispatch_async</code> 方法返回主线程来调用该方法。调用 <code>dispatch_async</code> 需要 2 个参数，首先是派发队列（对于主线程，我们通过 <code>dispatch_get_main_queue</code> 方法获取），其次是一个闭包来告诉它需要做什么操作，这里我们只是告诉它去调用辅助方法。</p><p>所以，为什么我们要在辅助方法里这样做，而不是直接在回调方法里面直接处理呢？好吧，当你实际接收到一个新的 <code>Application Context</code> 时，会回调 <code>didReceiveApplicationContext</code> 代理方法。当 <code>WCSession</code> 在关闭时接收到新的 <code>ApplicationContext</code> 会调用 activateSession 方法，在那不久之后也会回调到 <code>didReceiveApplicationContext</code> 方法。在这种情况下，我使用此 ApplicationContext 作为该信息的后备存储。我不确定这是不是一个好的主意，但是对于一个简单的 app 来说，这是合理的， 因为 <code>label</code> 的重点是显示 iPhone 上的 <code>UISwitch</code> 是开启还是关闭。</p><p>那么，当我们的 app 完成加载之后想使用最后一次接收到的值，但是 app 在关闭期间又没有收到新的 <code>context</code>，这种情况该怎么办？我们在视图生命周期的早期设置 label，所以现在 <code>awakeWithContext</code> 看起来应该是这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awake</span><span class="params">(withContext context: Any?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.awake(withContext: context)</span><br><span class="line"> </span><br><span class="line">    processApplicationContext()</span><br><span class="line"> </span><br><span class="line">    session.delegate = <span class="keyword">self</span></span><br><span class="line">    session.activate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 awakeWithContext 肯定在主线程上，我们不需要 <code>dispatch_async</code>。 因此这就是它仅用于在 didReceiveApplicationContext 回调中来调用辅助方法而不是在辅助方法内部使用的原因。</p><p>此时 iOS App 并没有保留该 <code>UISwitch</code> 的状态，所以在启动时保持它们的同步并不那么重要，对于一个有价值的 app 来说，我们应该将 UISwitch 的状态存储在某个地方。比如可以在 iPhone 端使用 WCSession 的 ApplicationContext 属性。（请记住，applicationContext 是从设备<strong>发送</strong>过来的最后一个 <code>context</code>），但如果是在iPad上运行呢？你可以将它存储在 <code>NSUserDefaults</code>，或者其他许多地方，但这些不在如何使用 WatchConnectivity 的讨论范畴内。具体你可以在早期的 <a href="http://www.codingexplorer.com/nsuserdefaults-a-swift-introduction/" target="_blank" rel="noopener">NSUserDefaults — A Swift Introduction</a> 文章中了解到。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是该项目的完整代码：</p><h3 id="ViewController-swift"><a href="#ViewController-swift" class="headerlink" title="ViewController.swift"></a>ViewController.swift</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?)</span></span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sessionDidBecomeInactive</span><span class="params">(<span class="number">_</span> session: WCSession)</span></span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sessionDidDeactivate</span><span class="params">(<span class="number">_</span> session: WCSession)</span></span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> theSwitch: <span class="type">UISwitch</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> session: <span class="type">WCSession</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="type">WCSession</span>.isSupported() &#123;</span><br><span class="line">            session = <span class="type">WCSession</span>.<span class="keyword">default</span></span><br><span class="line">            session?.delegate = <span class="keyword">self</span></span><br><span class="line">            session?.activate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">processApplicationContext</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> iPhoneContext = session?.applicationContext <span class="keyword">as</span>? [<span class="type">String</span> : <span class="type">Bool</span>] &#123;</span><br><span class="line">            <span class="keyword">if</span> iPhoneContext[<span class="string">"switchStatus"</span>] == <span class="literal">true</span> &#123;</span><br><span class="line">                theSwitch.isOn = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                theSwitch.isOn = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">switchValueChanged</span><span class="params">(<span class="number">_</span> sender: UISwitch)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> validSession = session &#123;</span><br><span class="line">            <span class="keyword">let</span> iPhoneAppContext = [<span class="string">"switchStatus"</span>: sender.isOn]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> validSession.updateApplicationContext(iPhoneAppContext)</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Something went wrong"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InterfaceController-swift"><a href="#InterfaceController-swift" class="headerlink" title="InterfaceController.swift"></a>InterfaceController.swift</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> WatchKit</span><br><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceController</span>: <span class="title">WKInterfaceController</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> displayLabel: <span class="type">WKInterfaceLabel</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> session = <span class="type">WCSession</span>.<span class="keyword">default</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awake</span><span class="params">(withContext context: Any?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awake(withContext: context)</span><br><span class="line">        </span><br><span class="line">        processApplicationContext()</span><br><span class="line">        </span><br><span class="line">        session.delegate = <span class="keyword">self</span></span><br><span class="line">        session.activate()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">buttonTapped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//displayLabel.setText("Hello World!")</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, didReceiveApplicationContext applicationContext: [String : Any])</span></span> &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async() &#123;</span><br><span class="line">            <span class="keyword">self</span>.processApplicationContext()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">processApplicationContext</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> iPhoneContext = session.receivedApplicationContext <span class="keyword">as</span>? [<span class="type">String</span> : <span class="type">Bool</span>] &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> iPhoneContext[<span class="string">"switchStatus"</span>] == <span class="literal">true</span> &#123;</span><br><span class="line">                displayLabel.setText(<span class="string">"Switch On"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                displayLabel.setText(<span class="string">"Switch Off"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请记住，这些代码来自 Hello World App，但是我们没有用到 watchOS App 上的 button。所以我只是注释了原始功能的代码。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>以上就是如何使用 Watch Connectivity 的 Application Context 方式进行后台传输的教程。向手机端回传数据也是完全相同的，因为它们具有同样的代理回调和属性。虽然在那种情况下，你可能还需要根据实际情况检查是否存在与该设备配对的 Apple Watch 或者 Watch 上是否安装了对应的 app。</p><p>正如我之前提到的，在 <code>ViewController / InterfaceController</code> 中执行所有代码可能不是最好的主意，但这只是为了简单地展示如何使用 API​​。我个人非常喜欢在自己的 <code>Watch Connectivity manager</code> 实例中执行这些操作。所以我强烈建议你阅读 Natasha The Robot 的文章 <a href="https://www.natashatherobot.com/watchconnectivity-say-hello-to-wcsession/" target="_blank" rel="noopener">WatchConnectivity: Say Hello to WCSession</a>，并关联他的 <a href="https://gist.github.com/NatashaTheRobot/6bcbe79afd7e9572edf6" target="_blank" rel="noopener">GitHub Gist</a>。这将对你使用 WatchConnectivity 很有帮助。</p><p>我希望本文能对你有所帮助。如果有帮到你，请不要犹豫，在 Twitter 或者你选择的社交媒体上分享这篇文章，每个分享对我都是帮助。当然，如果你有任何疑问，请随时通过<a href="http://www.codingexplorer.com/contact/" target="_blank" rel="noopener">联系页面</a>或 Twitter <a href="https://twitter.com/CodingExplorer" target="_blank" rel="noopener">@CodingExplorer</a> 与我联系，我会看看我能做些什么。谢谢！</p><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><ul><li><a href="https://itunes.apple.com/us/book/swift-programming-language/id881256329?mt=11&amp;uo=4&amp;at=10lJ3x&amp;ct=blog-SwiftOperatorOverloading" target="_blank" rel="noopener">The Swift Programming Language – Apple Inc.</a></li><li><a href="https://medium.com/swift-programming/facets-of-swift-part-5-custom-operators-1080bc78ccc" target="_blank" rel="noopener">Facets of Swift, Part 5: Custom Operators — Swift Programming — Medium</a></li><li><a href="http://www.kristinathai.com/watchos-2-tutorial-using-application-context-to-transfer-data-watch-connectivity-2/" target="_blank" rel="noopener">watchOS 2 Tutorial: Using application context to transfer data (Watch    Connectivity #2)</a> by <a href="https://twitter.com/kristinathai" target="_blank" rel="noopener">Kristina Thai</a></li><li><a href="https://www.natashatherobot.com/watchconnectivity-application-context/" target="_blank" rel="noopener">WatchConnectivity: Sharing The Latest Data via Application Context</a> by   <a href="https://twitter.com/natashatherobot" target="_blank" rel="noopener">Natasha The Robot</a></li></ul><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文详细讲解了如何通过 Watch Connectivity 的 Application Context 方式进行 watch 和 配对 iPhone 之间共享数据。
    
    </summary>
    
      <category term="codingexplorer" scheme="https://swift.gg/categories/codingexplorer/"/>
    
    
      <category term="教程" scheme="https://swift.gg/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Swift 4 中的字符串</title>
    <link href="https://swift.gg/2018/08/09/swift-4-strings/"/>
    <id>https://swift.gg/2018/08/09/swift-4-strings/</id>
    <published>2018-08-09T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2017/11/swift-4-strings" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-11-27<br>译者：<a href="https://weibo.com/u/5029986118" target="_blank" rel="noopener">东莞大唐和尚</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="undefined">Firecrest</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>这个系列中其他文章：</p><ol><li><a href="https://oleb.net/blog/2014/07/swift-strings/" target="_blank" rel="noopener">Swift 1 中的字符串</a></li><li><a href="https://oleb.net/blog/2016/08/swift-3-strings/" target="_blank" rel="noopener">Swift 3 中的字符串</a></li><li>Swift 4 中的字符串（本文）</li></ol><p>本文节选自我们的新书《高级 Swift 编程》「字符串」这一章。《高级 Swift 编程》新版本已根据 Swift 4 的新特性修订补充，新版现已上市。</p><a id="more"></a><p>所有的现代编程语言都有对 Unicode 编码字符串的支持，但这通常只意味着它们的原生字符串类型可以存储 Unicode 编码的数据——并不意味着所有像获取字符串长度这样简单的操作都会得到「合情合理」的输出结果。</p><p>实际上，大多数语言，以及用这些语言编写的大多数字符串操作代码，都表现出对Unicode固有复杂性的某种程度的否定。这可能会导致一些令人不开心的错误</p><p>Swift 为了字符串的实现支持 Unicode 做出了巨大的努力。Swift 中的 <a href="https://developer.apple.com/documentation/swift/string" target="_blank" rel="noopener"><code>String</code></a>（字符串）是一系列 <a href="https://developer.apple.com/documentation/swift/character" target="_blank" rel="noopener"><code>Character</code></a> 值（字符）的集合。这里的 <code>Character</code> 指的是人们视为单个字母的可读文本，无论这个字母是由多少个 Unicode 编码字符组成。因此，所有对于 <code>Collection</code>（集合）的操作（比如 <code>count</code> 或者 <code>prefix(5)</code>）也同样是按照用户所理解的字母来操作的。</p><p>这样的设计在正确性上无可挑剔，但这是有代价的，主要是人们对它不熟悉。如果你习惯了熟练操作其他编程语言里字符串的整数索引，Swift 的设计会让你觉得笨重不堪，让你感觉到奇怪。为什么 <code>str[999]</code> 不能获得字符串第一千个字符？为什么 <code>str[idx+1]</code> 不能获得下一个字符？为什么不能用类似 <code>&quot;a&quot;...&quot;z&quot;</code> 的方式遍历一个范围的 <code>Character</code>（字符）？</p><p>同时，这样的设计对代码性能也有一定的影响：<code>String</code> 不支持随意获取。换句话说，获得一个任意字符不是 O(1) 的操作——当字符宽度是个变量的时候，字符串只有查看过前面所有字符之后，才会知道第 n 个字符储存在哪里。</p><p>在本章中，我们一起来详细讨论一下 Swift 中字符串的设计，以及一些获得功能和性能最优的技巧。不过，首先我们要先来学习一下 Unicode 编码的专业知识。</p><h2 id="Unicode：抛弃固定宽度"><a href="#Unicode：抛弃固定宽度" class="headerlink" title="Unicode：抛弃固定宽度"></a>Unicode：抛弃固定宽度</h2><p>本来事情很简单。<a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII编码</a> 的字符串用 0 到 127 之间的一系列整数表示。如果使用 8 比特的二进制数组合表示字符，甚至还多余一个比特！由于每个字符的长度固定，所以 ASCII 编码的字符串是可以随机获取的。</p><p>但是，如果不是英语而是其他国家的语言的话，其中的一些字符 ASCII 编码是不够的（其实即使是说英语的英国也有一个”£”符号）。这些语言中的特殊字符大多数都需要超过 7 比特的编码。在 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859" target="_blank" rel="noopener">ISO 8859</a> 标准中，就用多出来的那个比特定义了 16 种超出 ASCII 编码范围的编码，比如第一部分（ISO8859-1）包括了几种西欧语言的编码，第五部分包括了对西里尔字母语言的编码。</p><p>但这样的做法其实还有局限。如果你想根据 ISO8859 标准，用土耳其语写古希腊语的话，你就不走运了，因为你要么得选择第七部分（拉丁语/希腊语）或者第九部分（土耳其语）。而且，总的来说 8 个比特的编码空间无法涵盖多种语言。例如，第六部分（拉丁语/阿拉伯语）就不包含同样使用阿拉伯字母的乌尔都语和波斯语中的很多字符。同时，越南语虽然使用的也是拉丁字母，但是有很多变音组合，这种情况只有替换掉一些原有 ASCII 编码的字母才可能存储到 8 个比特的空间里。而且，这种方法不适用其他很多东亚语言。</p><p>当固定长度编码空间不足以容纳更多字符时，你要做一个选择：要么提高存储空间，要么采用变长编码。起先，<a href="https://en.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a> 被定义为 2 字节固定宽度的格式，现在我们称之为 <a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set" target="_blank" rel="noopener">UCS-2</a>。彼时梦想尚未照进现实，后来人们发现，要实现大部分的功能，不仅 2 字节不够，甚至4个字节都远远不够。</p><p>所以到了今天，Unicode 编码的宽度是可变的，这种可变有两个不同的含义：一是说 Unicode 标量可能由若干个代码块组成；一是说字符可能由若干个标量组成。</p><p>Unicode 编码的数据可以用多种不同宽度的 <a href="https://www.unicode.org/glossary/#code_unit" target="_blank" rel="noopener">代码单元（<em>code unit</em>）</a> 来表示，最常见的是 8 比特（<a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8</a>）和 16（<a href="https://en.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16</a>）比特。UTF-8 编码的一大优势是它向后兼容 8 比特的 ACSCII 编码，这也是它取代 ASCII 成为互联网上最受欢迎的编码的一大原因。在 Swift 里面用 <code>UInt16</code> 和 <code>UInt8</code> 的数值代表UTC-16和UTF-8的代码单元（别名分别是 <a href="https://developer.apple.com/documentation/swift/unicode.utf8/codeunit" target="_blank" rel="noopener"><code>Unicode.UTF16.CodeUnit</code></a> 和 <a href="https://developer.apple.com/documentation/swift/unicode.utf16/codeunit" target="_blank" rel="noopener"><code>Unicode.UTF8.CodeUnit</code></a>）。</p><p>一个 <a href="https://www.unicode.org/glossary/#code_point" target="_blank" rel="noopener"><em>代码点（code point）</em></a> 指的是 Unicode 编码空间中一个单一的值，可能的范围是 <code>0</code> 到 <code>0x10FFFF</code> (换算成十进制就是 1114111)。现在已使用的代码点大约只有 137000 个，所以还有很多空间可以存储各种 emoji。如果你使用的是 <a href="https://en.wikipedia.org/wiki/UTF-32" target="_blank" rel="noopener">UTF-32</a> 编码，那么一个代码点就是一个代码块；如果使用的是 UTF-8 编码，一个代码点可能有 1 到 4 个代码块组成。最初的 256 个 Unicode 编码的代码点对应着 Latin-1 中的字母。</p><p><a href="https://www.unicode.org/glossary/#unicode_scalar_value" target="_blank" rel="noopener">Unicode 标量</a> 跟代码点基本一样，但是也有一点不一样。除开 <code>0xD800-0xDFFF</code> 中间的 2048 个代理代码点（<a href="https://en.wikipedia.org/wiki/UTF-16#U.2BD800_to_U.2BDFFF" target="_blank" rel="noopener"><em>surrogate code points</em></a>）之外，他们都是一样的。这 2048 个代理代码点是 UTF-16 中用作表示配对的前缀或尾缀编码。标量在 Swift 中用 <code>\u{xxxx}</code> 表示，xxxx 代表十进制的数字。所以欧元符号在Swift里可以表示为 <code>&quot;€&quot;</code> 或 <code>&quot;\u{20AC}&quot;</code>。与之对应的 Swift 类型是 <a href="https://developer.apple.com/documentation/swift/unicode.scalar" target="_blank" rel="noopener"><code>Unicode.Scalar</code></a>，一个 <a href="https://developer.apple.com/documentation/swift/uint32" target="_blank" rel="noopener"><code>UInt32</code></a> 数值的封装。</p><p>为了用一个代码单元代表一个 Unicode scalar，你需要一个 21 比特的编码机制（通常会达到 32 比特，比如 UTF-32），但是即便这样你也无法得到一个固定宽度的编码：最终表示字符的时候，Unicode 仍然是一个宽度可变的编码格式。屏幕上显示的一个字符，也就是用户通常认为的一个字符，可能需要多个 scalar 组合而成。Unicode 编码里把这种用户理解的字符称之为 <a href="https://www.unicode.org/glossary/#extended_grapheme_cluster" target="_blank" rel="noopener">（扩展）字位集</a> (extended grapheme cluster)。</p><p>标量组成字位集的规则决定了如何分词。例如，如果你按了一下键盘上的退格键，你觉得你的文本编辑器就应该删除掉一个字位集，即使那个“字符”是由多个 Unicode scalars 组成，且每个 scalar 在计算机内存上还由数量不等的代码块组成的。Swift中用 <code>Character</code> 类型代表字位集。<code>Character</code> 类型可以由任意数量的 Scalars 组成，只要它们形成一个用户看到的字符。在下一部分，我们会看到几个这样的例子。</p><h2 id="字位集和规范对等（Canonical-Equivalence）"><a href="#字位集和规范对等（Canonical-Equivalence）" class="headerlink" title="字位集和规范对等（Canonical Equivalence）"></a>字位集和规范对等（Canonical Equivalence）</h2><h3 id="组合符号"><a href="#组合符号" class="headerlink" title="组合符号"></a>组合符号</h3><p>这里有一个快速了解 <code>String</code> 类型如何处理 Unicode 编码数据的方法：写 “é” 的两种不同方法。Unicode 编码中定义为 <a href="https://codepoints.net/U+00E9" target="_blank" rel="noopener">U+00E9</a>，<em>Latin small letter e with acute</em>（拉丁字母小写 e 加重音符号），单一值。但是你也可以写一个正常的 <a href="https://codepoints.net/U+0065" target="_blank" rel="noopener">小写 e</a>，再跟上一个 <a href="https://codepoints.net/U+0301" target="_blank" rel="noopener">U+0301</a>，<em>combining acute accent</em>（重音符号）。在这两种情况中，显示的都是 é，用户当然会认为这两个 “résumé” 无论使用什么方式打出来的，肯定是相等的，长度也都是 6 个字符。这就是 Unicode 编码规范中所说的 <a href="https://www.unicode.org/glossary/#canonical_equivalent" target="_blank" rel="noopener">规范对等（Canonically Equivalent）</a>。</p><p>而且，在 Swift 语言里，代码行为和用户预期是一致的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> single = <span class="string">"Pok\u&#123;00E9&#125;mon"</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="string">"Poke\u&#123;0301&#125;mon"</span></span><br></pre></td></tr></table></figure><p>它们显示也是完全一致的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(single, double) <span class="comment">// → ("Pokémon", "Pokémon")</span></span><br></pre></td></tr></table></figure><p>它们的字符数也是一样的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">single.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br><span class="line">double.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br></pre></td></tr></table></figure><p>因此，比较起来，它们也是相等的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">single == double <span class="comment">// → true</span></span><br></pre></td></tr></table></figure><p>只有当你通过底层的显示方式查看的时候，才能看到它们的不同之处：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">single.utf16.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br><span class="line">double.utf16.<span class="built_in">count</span> <span class="comment">// → 8</span></span><br></pre></td></tr></table></figure><p>这一点和 Foundation 中的 <a href="https://developer.apple.com/documentation/foundation/nsstring" target="_blank" rel="noopener"><code>NSString</code></a> 对比一下：在 <code>NSString</code> 中，两个字符串是不相等的，它们的 <code>length</code> （很多程序员都用这个方法来确定字符串显示在屏幕上的长度）也是不同的。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nssingle = single <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">nssingle.length <span class="comment">// → 7</span></span><br><span class="line"><span class="keyword">let</span> nsdouble = double <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">nsdouble.length <span class="comment">// → 8</span></span><br><span class="line">nssingle == nsdouble <span class="comment">// → false</span></span><br></pre></td></tr></table></figure><p>这里，<code>==</code> 是定义为比较两个 <code>NSObject</code> ：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension <span class="built_in">NSObject</span>: Equatable &#123;</span><br><span class="line">    <span class="keyword">static</span> func ==(lhs: <span class="built_in">NSObject</span>, rhs: <span class="built_in">NSObject</span>) -&gt; Bool &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.isEqual(rhs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>NSString</code> 中，这个操作会比较两个 UTF-16 代码块。很多其他语言里面的字符串 API 也是这样的。如果你想做的是一个规范比较（cannonical comparison），你必须用 <code>NSString.compare(_:)</code> 。没听说过这个方法？将来遇到一些找不出来的 bug ，以及一些怒气冲冲的国外用户的时候，够你受的。</p><p>当然，只比较代码单元有一个很大的优点是：速度快！在 Swift 里，你也可以通过 <code>utf16</code> 视图来实现这一点：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">single.utf16.elementsEqual(double.utf16) <span class="comment">// → false</span></span><br></pre></td></tr></table></figure><p>为什么 Unicode 编码要支持同一字符的多种展现方式呢？因为 Latin-1 中已经有了类似 é 和 ñ 这样的字母，只有灵活的组合方式才能让长度可变的 Unicode 代码点兼容 Latin-1。</p><p>虽然使用起来会有一些麻烦，但是它使得两种编码之间的转换变得简单快速。</p><p>而且抛弃变音形式也没有什么用，因为这种组合不仅仅只是两个两个的，有时候甚至是多种变音符号组合。例如，约鲁巴语中有一个字符是 ọ́ ，可以用三种不同方式写出来：一个 ó 加一点，一个 ọ 加一个重音，或者一个 o  加一个重音和一点。而且，对最后一种方式来说，两个变音符号的顺序无关紧要！所以，下面几种形式的写法都是相等的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> chars: [<span class="type">Character</span>] = [</span><br><span class="line">    <span class="string">"\u&#123;1ECD&#125;\u&#123;300&#125;"</span>,      <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;F2&#125;\u&#123;323&#125;"</span>,        <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;6F&#125;\u&#123;323&#125;\u&#123;300&#125;"</span>, <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;6F&#125;\u&#123;300&#125;\u&#123;323&#125;"</span>  <span class="comment">// ọ́</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> allEqual = chars.<span class="built_in">dropFirst</span>()</span><br><span class="line">    .all(matching: &#123; $<span class="number">0</span> == chars.first &#125;) <span class="comment">// → true</span></span><br></pre></td></tr></table></figure><p><code>all(matching:)</code> 方法用来检测条件是否对序列中的所有元素都为真：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">all</span><span class="params">(matching predicate: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">try</span> !predicate(element) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，一些变音符号可以加无穷个。这一点，<a href="http://knowyourmeme.com/memes/zalgo" target="_blank" rel="noopener">网上流传很广</a> 的一个颜文字表现得很好：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> zalgo = <span class="string">"s̼̐͗͜o̠̦̤ͯͥ̒ͫ́ͅo̺̪͖̗̽ͩ̃͟ͅn̢͔͖͇͇͉̫̰ͪ͑"</span></span><br><span class="line"></span><br><span class="line">zalgo.<span class="built_in">count</span> <span class="comment">// → 4</span></span><br><span class="line">zalgo.utf16.<span class="built_in">count</span> <span class="comment">// → 36</span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>zalgo.count</code> 返回值是 4（正确的），而 <code>zalgo.utf16.count</code> 返回值是 36。如果你的代码连网上的颜文字都无法正确处理，那它有什么好的？</p><p>Unicode 编码的字位分割规则甚至在你处理纯 ASCII 编码的字符的时候也有影响，回车 <a href="https://codepoints.net/U+000D" target="_blank" rel="noopener">CR</a> 和 换行 <a href="https://codepoints.net/U+000A" target="_blank" rel="noopener">LF</a> 这一个字符对在 Windows 系统上通常表示新开一行，但它们其实只是一个字位：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CR+LF is a single Character</span></span><br><span class="line"><span class="keyword">let</span> crlf = <span class="string">"\r\n"</span></span><br><span class="line">crlf.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><h3 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h3><p>许多其他编程语言处理包含 emoji 的字符串的时候会让人意外。许多 emoji 的 Unicode 标量无法存储在一个 UTF-16 的代码单元里面。有些语言（例如 Java 或者 C#）把字符串当做 UTF-16 代码块的集合，这些语言定义<a href="https://emojipedia.org/face-with-tears-of-joy/" target="_blank" rel="noopener">“😂”</a>为两个 “字符” 的长度。Swift 处理上述情况更为合理：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oneEmoji = <span class="string">"😂"</span> <span class="comment">// U+1F602</span></span><br><span class="line">oneEmoji.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，重要的是字符串如何展现给程序的，<strong>不是</strong>字符串在内存中是如何存储的。对于非 ASCII 的字符串，Swift 内部用的是 UTF-16 的编码，这只是内部的实现细节。公共 API 还是基于字位集（grapheme cluster）的。</p></blockquote><p>有些 emoji 由多个标量组成。emoji 中的国旗是由两个对应 ISO 国家代码的<a href="https://en.wikipedia.org/wiki/Regional_Indicator_Symbol" target="_blank" rel="noopener">地区标识符号（reginal indicator symbols）</a>组成的。Swift 里将一个国旗视为一个 <code>Character</code> ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flags = <span class="string">"🇧🇷🇳🇿"</span></span><br><span class="line">flags.<span class="built_in">count</span> <span class="comment">// → 2</span></span><br></pre></td></tr></table></figure><p>要检查一个字符串由几个 Unicode 标量组成，需要使用 <a href="https://developer.apple.com/documentation/swift/string/1539070-unicodescalars" target="_blank" rel="noopener"><code>unicodeScalars</code></a> 视图。这里，我们将 scalar 的值格式化为十进制的数字，这是代码点的普遍格式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">flags.unicodeScalars.<span class="built_in">map</span> &#123;</span><br><span class="line">    <span class="string">"U+<span class="subst">\(String($<span class="number">0</span>.value, radix: <span class="number">16</span>, uppercase: <span class="literal">true</span>)</span>)"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// → ["U+1F1E7", "U+1F1F7", "U+1F1F3", "U+1F1FF"]</span></span><br></pre></td></tr></table></figure><p>肤色是由一个基础的角色符号（例如👧）加上一个肤色修饰符（例如🏽）组成的，Swift 里是这么处理的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> skinTone = <span class="string">"👧🏽"</span> <span class="comment">// 👧 + 🏽</span></span><br><span class="line">skinTone.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><p>这次我们用 Foundation API 里面的 <a href="https://oleb.net/blog/2016/01/icu-text-transforms/" target="_blank" rel="noopener">ICU string transform</a> 把 Unicode 标量转换成官方的 Unicode 名称：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StringTransform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> toUnicodeName = <span class="type">StringTransform</span>(rawValue: <span class="string">"Any-Name"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Unicode</span>.<span class="title">Scalar</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The scalar’s Unicode name, e.g. "LATIN CAPITAL LETTER A".</span></span><br><span class="line">    <span class="keyword">var</span> unicodeName: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// Force-unwrapping is safe because this transform always succeeds</span></span><br><span class="line">        <span class="keyword">let</span> name = <span class="type">String</span>(<span class="keyword">self</span>).applyingTransform(.toUnicodeName,</span><br><span class="line">            <span class="built_in">reverse</span>: <span class="literal">false</span>)!</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The string transform returns the name wrapped in "\\N&#123;...&#125;". Remove those.</span></span><br><span class="line">        <span class="keyword">let</span> prefixPattern = <span class="string">"\\N&#123;"</span></span><br><span class="line">        <span class="keyword">let</span> suffixPattern = <span class="string">"&#125;"</span></span><br><span class="line">        <span class="keyword">let</span> prefixLength = name.hasPrefix(prefixPattern) ? prefixPattern.<span class="built_in">count</span> : <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> suffixLength = name.hasSuffix(suffixPattern) ? suffixPattern.<span class="built_in">count</span> : <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(name.<span class="built_in">dropFirst</span>(prefixLength).<span class="built_in">dropLast</span>(suffixLength))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skinTone.unicodeScalars.<span class="built_in">map</span> &#123; $<span class="number">0</span>.unicodeName &#125;</span><br><span class="line"><span class="comment">// → ["GIRL", "EMOJI MODIFIER FITZPATRICK TYPE-4"]</span></span><br></pre></td></tr></table></figure><p>这段代码里面最重要的是对 <code>applyingTransform(.toUnicodeName,...)</code> 的调用。其他的代码只是把转换方法返回的名字清理了一下，移除了括号。这段代码很保守：先是检查了字符串是否符合期望的格式，然后计算了从头到尾的字符数。如果将来转换方法返回的名字格式发生了变化，最好输出原字符串，而不是移除多余字符后的字符串。</p><p>注意我们是如何使用标准的集合（<code>Collection</code>）方法 <code>dropFirst</code> 和 <code>droplast</code> 进行移除操作的。如果你想对字符串进行操作，但是又不想对字符串进行手动索引，这就是一个很好的例子。这个方法同样也很高效，因为 <code>dropFisrt</code> 和 <code>dropLast</code> 方法返回的是 <code>Substring</code> 值，它们只是原字符串的一部分。在我们最后一步创建一个新的 <code>String</code> 字符串，赋值为这个 substring 之前，它是不占用新的内存的。关于这一点，我们在这一章的后面还有很多东西会涉及到。</p><p>Emoji 里面对家庭和夫妻的表示（例如 <a href="https://emojipedia.org/family-man-woman-girl-boy/" target="_blank" rel="noopener">👨‍👩‍👧‍👦</a> 和 <a href="https://emojipedia.org/couple-with-heart-woman-woman/" target="_blank" rel="noopener">👩‍❤️‍👩</a>）是 Unicode 编码标准面临的又一个挑战。由于性别以及人数的可能组合太多，为每种可能的组合都做一个代码点肯定会有问题。再加上每个人物角色的肤色的问题，这样做几乎不可行。Unicode 编码是这样解决这个问题的，它将这种 emoji 定义为一系列由零宽度连接符（<a href="https://codepoints.net/U+200D" target="_blank" rel="noopener"><em>zero-width joiner</em></a>）联系起来的 emoji 。这样下来，这个家庭 👨‍👩‍👧‍👦 emoji 其实就是 <a href="https://emojipedia.org/man/" target="_blank" rel="noopener"><em>man</em> 👨</a> + ZWJ + <a href="https://emojipedia.org/woman/" target="_blank" rel="noopener"><em>woman</em> 👩</a> + ZWJ + <a href="https://emojipedia.org/girl/" target="_blank" rel="noopener"><em>girl</em> 👧</a> + ZWJ + <a href="https://emojipedia.org/boy/" target="_blank" rel="noopener"><em>boy</em> 👦</a>。而零宽度连接符的作用就是让操作系统知道这个 emoji 应该只是一个字素。</p><p>我们可以验证一下到底是不是这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> family1 = <span class="string">"👨‍👩‍👧‍👦"</span></span><br><span class="line"><span class="keyword">let</span> family2 = <span class="string">"👨\u&#123;200D&#125;👩\u&#123;200D&#125;👧\u&#123;200D&#125;👦"</span></span><br><span class="line">family1 == family2 <span class="comment">// → true</span></span><br></pre></td></tr></table></figure><p>在 Swift 里，这样一个 emoji 也同样被认为是一个字符 <code>Character</code> ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">family1.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">family2.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><p>2016年新引入的职业类型 emoji 也是这种情况。例如女性消防队员 <a href="https://emojipedia.org/female-firefighter/" target="_blank" rel="noopener">👩‍🚒</a> 就是 <a href="https://emojipedia.org/woman/" target="_blank" rel="noopener"><em>woman</em> 👩</a> + ZWJ + <a href="https://emojipedia.org/fire-engine/" target="_blank" rel="noopener"><em>fire engine</em> 🚒</a>。男性医生就是 <a href="https://emojipedia.org/man/" target="_blank" rel="noopener"><em>man</em> 👨</a> + ZWJ + <a href="https://emojipedia.org/staff-of-aesculapius/" target="_blank" rel="noopener"><em>staff of aesculapius</em> ⚕</a>（译者注：阿斯克勒庇厄斯，是古希腊神话中的医神，一条蛇绕着一个柱子指医疗相关职业）。</p><p>将这些一系列零宽度连接符连接起来的 emoji 渲染为一个字素是操作系统的工作。2017年，Apple 的操作系统表示支持 Unicode 编码标准下的 RGI 系列（“<a href="https://unicode.org/emoji/charts/emoji-zwj-sequences.html" target="_blank" rel="noopener">recommended for general interchange</a>”）。如果没有字位可以正确表示这个序列，那文本渲染系统会回退，显示为每个单个的字素。</p><p>注意这里又可能会导致一个理解偏差，即用户所认为的字符和 Swift 所认为的字位集之间的偏差。我们上面所有的例子都是担心编程语言会把字符<strong>数多了</strong>，但这里正好相反。举例来说，上面那个家庭的 emoji 里面涉及到的肤色 emoji 还未被收录到 RGI 集合里面。但尽管大多数操作系统都把这系列 emoji 渲染成多个字素，但 Swift 仍旧只把它们看做一个字符，因为 Unicode 编码的分词规则和渲染无关：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Family with skin tones is rendered as multiple glyphs</span></span><br><span class="line"><span class="comment">// on most platforms in 2017</span></span><br><span class="line"><span class="keyword">let</span> family3 = <span class="string">"👱🏾\u&#123;200D&#125;👩🏽\u&#123;200D&#125;👧🏿\u&#123;200D&#125;👦🏻"</span> <span class="comment">// → "👱🏾‍👩🏽‍👧🏿‍👦🏻"</span></span><br><span class="line"><span class="comment">// But Swift still counts it as a single Character</span></span><br><span class="line">family3.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.emojipedia.org/diverse-emoji-families-come-to-windows/" target="_blank" rel="noopener">Windows 系统已经可以</a>把这些 emoji 渲染为一个字素了，其他操作系统厂家肯定也会尽快支持。但是，有一点是不变的：无论一个字符串的 API 如何精心设计，都无法完美支持每一个细小的案例，因为文本太复杂了。</p><blockquote><p>过去 Swift 很难跟得上 Unicode 编码标准改变的步伐。Swift 3 渲染肤色和零宽度连接符系列 emoji 是错误的，因为当时的分词算法是根据上一个版本的 Unicode 编码标准。自 Swift 4 起，Swift 开始启用操作系统的 <a href="http://site.icu-project.org" target="_blank" rel="noopener">ICU</a> 库。因此，只要用户更新他们的操作系统，你的程序就会采用最新的 Unicode 编码标准。硬币的另一面是，你开发中看到的和用户看到的东西可能是不一样的。</p></blockquote><p>编程语言如果全面考虑 Unicode 编码复杂性的话，在处理文本的时候会引发很多问题。上面这么多例子我们只是谈及其中的一个问题：字符串的长度。如果一个编程语言不是按字素集处理字符串，而这个字符串又包含很多字符序列的话，这时候一个简简单单的反序输出字符串的操作会变得多么复杂。</p><p>这不是个新问题，但是 emoji 的流行使得糟糕的文本处理方法造成的问题更容易浮出表面，即使你的用户群大部分是说英语的。而且，错误的级别也大大提升：十年前，弄错一个变音符号的字母可能只会造成 1 个字符数的误差，现在如果弄错了 emoji 的话很可能就是 10 个字符数的误差。例如，一个四人家庭的 emoji 在 UTF-16 编码下是 11 个字符，在 UTF-8 编码下就是 25 个字符了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">family1.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">family1.utf16.<span class="built_in">count</span> <span class="comment">// → 11</span></span><br><span class="line">family1.utf8.<span class="built_in">count</span> <span class="comment">// → 25</span></span><br></pre></td></tr></table></figure><p>也不是说其他编程语言就完全没有符合 Unicode 编码标准的 API，大部分还是有的。例如，<code>NSString</code> 就有一个 <a href="https://developer.apple.com/documentation/foundation/nsstring/1416774-enumeratesubstrings" target="_blank" rel="noopener"><code>enumerateSubstrings</code></a> 的方法可以按照字位集遍历一个字符串。但是缺省设置很重要，而 Swift 的原则就是缺省情况下，就按正确的方式来做。而且如果你需要低一个抽象级别去看，<code>String</code> 也提供不同的视图，然你可以直接从 Unicode 标量或者代码块的级别操作。下面的内容里我们还会涉及到这一点。</p><h2 id="字符串和集合"><a href="#字符串和集合" class="headerlink" title="字符串和集合"></a>字符串和集合</h2><p>我们已经看到，<code>String</code> 是一个 <code>Character</code> 值的集合。在 Swift 语言发展的前三年里，<code>String</code> 这个类在遵守还是不遵守 <code>Collection</code> 集合协议这个问题上左右摇摆了几次。坚持不要遵守集合协议的人认为，如果遵守的话，程序员会认为所有通用的集合处理算法用在字符串上是绝对安全的，也绝对符合 Unicode 编码标准的，但是显然有一些特例存在。</p><p>举一个简单的例子，两个集合相加，得到的新的集合的长度肯定是两个子集合长度的和。但是在字符串中，如果第一个字符串的后缀和第二个字符串的前缀形成了一个字位集，长度就会有变化了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flagLetterJ = <span class="string">"🇯"</span></span><br><span class="line"><span class="keyword">let</span> flagLetterP = <span class="string">"🇵"</span></span><br><span class="line"><span class="keyword">let</span> flag = flagLetterJ + flagLetterP <span class="comment">// → "🇯🇵"</span></span><br><span class="line">flag.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">flag.<span class="built_in">count</span> == flagLetterJ.<span class="built_in">count</span> + flagLetterP.<span class="built_in">count</span> <span class="comment">// → false</span></span><br></pre></td></tr></table></figure><p>出于这种考虑，在 Swift 2 和 Swift 3 中，<code>String</code> 并没有被算作一个集合。这个特性是作为 <code>String</code> 的一个 <a href="https://developer.apple.com/documentation/swift/string/1540072-characters" target="_blank" rel="noopener"><code>characters</code></a> 视图存在的，和其他几个集合视图一样：<a href="https://developer.apple.com/documentation/swift/string/1539070-unicodescalars" target="_blank" rel="noopener"><code>unicodeScalars</code></a>，<a href="https://developer.apple.com/documentation/swift/string/1539703-utf8" target="_blank" rel="noopener"><code>utf8</code></a> 和 <a href="https://developer.apple.com/documentation/swift/string/1541301-utf16" target="_blank" rel="noopener"><code>utf16</code></a>。选择一个特定的视图，就相当于让程序员转换到另一种“处理集合”的模式，相应的，程序员就必须考虑到这种模式下可能产生的问题。</p><p>但是，在实际应用中，这个改变提升了学习成本，降低了可用性；单单为了保证在那些极端个例中的正确性（其实在真实应用中很少遇到，除非你写的是个文本编辑器的应用）做出这样的改变太不值得了。因此，在 Swift 4 中，<code>String</code> 再次成了一个集合。<code>characters</code> 视图还在，但是只是为了向后兼容 Swift 3。</p><h3 id="双向获取，而非任意获取"><a href="#双向获取，而非任意获取" class="headerlink" title="双向获取，而非任意获取"></a>双向获取，而非任意获取</h3><p>然而，<code>String</code> 并<strong>不是</strong>一个可以任意获取的集合，原因的话，上一部分的几个例子已经展现的很清楚。一个字符到底是第几个字符取决于它前面有多少个 Unicode scalar，这样的情况下，根本不可能实现任意获取。由于这个原因，Swift 里面的字符串遵守双向获取（<a href="https://developer.apple.com/documentation/swift/bidirectionalcollection" target="_blank" rel="noopener"><code>BidirectionalCollection</code></a>）规则。可以从字符串的两头数，代码会根据相邻字符的组成，跳过正确数量的字节。但是，每次访问只能上移或者下移一个字符。</p><p>在写处理字符串的代码的时候，要考虑到这种方式的操作对代码性能的影响。那些依靠任意获取来保证代码性能的算法对 Unicode 编码的字符串并不合适。我们看一个例子，我们要获取一个字符串所有 prefix 的列表。我们只需要得到一个从零到字符串长度的一系列整数，然后根据每个长度的整数在字符串中找到对应长度的 prefix：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allPrefixes1: [<span class="type">Substring</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>...<span class="keyword">self</span>.<span class="built_in">count</span>).<span class="built_in">map</span>(<span class="keyword">self</span>.<span class="keyword">prefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="string">"Hello"</span></span><br><span class="line">hello.allPrefixes1 <span class="comment">// → ["", "H", "He", "Hel", "Hell", "Hello"]</span></span><br></pre></td></tr></table></figure><p>尽管这段代码看起来很简单，但是运行性能很低。它先是遍历了字符串一次，计算出字符串的长度，这还 OK。但是每次对 <a href="https://developer.apple.com/documentation/swift/substring/2893985-prefix" target="_blank" rel="noopener"><code>prefix</code></a> 进行 n+1 的调用都是一次 <em>O(n)</em> 操作，因为 <code>prefix</code> 方法需要从字符串的开头往后找出所需数量的字符。而在一个线性运算里进行另一个线性运算就意味着算法已经成了 <em>O(n2)</em> ——随着字符串长度的增加，算法所需的时间是呈指数级增长的。</p><p>如果可能的话，一个高性能的算法应该是遍历字符串一次，然后通过对字符串索引的操作得到想要的子字符串。下面是相同算法的另一个版本：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allPrefixes2: [<span class="type">Substring</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">""</span>] + <span class="keyword">self</span>.<span class="built_in">indices</span>.<span class="built_in">map</span> &#123; index <span class="keyword">in</span> <span class="keyword">self</span>[...index] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello.allPrefixes2 <span class="comment">// → ["", "H", "He", "Hel", "Hell", "Hello"]</span></span><br></pre></td></tr></table></figure><p>这段代码只需要遍历字符串一次，得到字符串的索引（<a href="https://developer.apple.com/documentation/swift/bidirectionalcollection/1785188-indices" target="_blank" rel="noopener"><code>indices</code></a>）集合。一旦完成之后，之后再 <code>map</code> 内的操作就只是 <em>O(1)</em>。整个算法也只是 <em>O(n)</em>。</p><h3 id="范围可替换，不可变"><a href="#范围可替换，不可变" class="headerlink" title="范围可替换，不可变"></a>范围可替换，不可变</h3><p><code>String</code> 还遵从于 <a href="https://developer.apple.com/documentation/swift/rangereplaceablecollection" target="_blank" rel="noopener"><code>RangeReplaceableCollection</code></a> （范围可替换）的集合操作。也就是说，你可以先按字符串索引的形式定义出一个范围，然后通过调用 <a href="https://developer.apple.com/documentation/swift/string/1641462-replacesubrange" target="_blank" rel="noopener"><code>replaceSubrange</code></a> （替换子范围）方法，替换掉字符串中的一些字符。这里有一个例子。替换的字符串可以有不同的长度，甚至还可以是空的（这时候就相当于调用 <a href="https://developer.apple.com/documentation/swift/string/2893740-removesubrange" target="_blank" rel="noopener"><code>removeSubrange</code></a> 方法了）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello, world!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> comma = greeting.index(of: <span class="string">","</span>) &#123;</span><br><span class="line">    greeting[..&lt;comma] <span class="comment">// → "Hello"</span></span><br><span class="line">    greeting.replaceSubrange(comma..., with: <span class="string">" again."</span>)</span><br><span class="line">&#125;</span><br><span class="line">greeting <span class="comment">// → "Hello again."</span></span><br></pre></td></tr></table></figure><p>同样，这里也要注意一个问题，如果替换的字符串和原字符串中相邻的字符形成了新的字位集，那结果可能就会有点出人意料了。</p><p>字符串无法提供的一个类集合特性是：<a href="https://developer.apple.com/documentation/swift/mutablecollection" target="_blank" rel="noopener"><code>MutableCollection</code></a>。该协议给集合除 <code>get</code> 之外，添加了一个通过下标进行单一元素 <code>set</code> 的特性。这并不是说字符串是不可变的——我们上面已经看到了，有好几种变化的方法。你无法完成的是使用下标操作符替换其中的一个字符。许多人直觉认为用下标操作符替换一个字符是即时发生的，就像数组 <a href="https://developer.apple.com/documentation/swift/array" target="_blank" rel="noopener"><code>Array</code></a> 里面的替换一样。但是，因为字符串里的字符长度是不定的，所以替换一个字符的时间和字符串的长度呈线性关系：替换一个元素的宽度会把其他所有元素在内存中的位置重新洗牌。而且，替换元素索引后面的元素索引在洗牌之后都变了，这也是跟人们的直觉相违背的。出于这些原因，你必须使用 <code>replaceSubrange</code> 进行替换，即使你变化只是一个元素。</p><h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h2><p>大多数编程语言都是用整数作为字符串的下标，例如 <code>str[5]</code> 就会返回 <code>str</code> 的第六个“字符”（无论这个语言定义的“字符”是什么）。Swift 却不允许这样。为什么呢？原因可能你已经听了很多遍了：下标应该是使用固定时间的(无论是直觉上，还是根据集合协议)，但是查询第 n 个“字符”的操作必须查询它前面所有的字节。</p><p><a href="https://developer.apple.com/documentation/swift/string.index" target="_blank" rel="noopener">字符串索引（<code>String.Index</code>）</a> 是字符串及其视图使用的索引类型。它是个不透明值（opaque value，内部使用的值，开发者一般不直接使用），本质上存储的是从字符串开头算起的字节偏移量。如果你想计算第 n 个字符的索引，它还是一个 <em>O(n)</em> 的操作，而且你还是必须从字符串的开头开始算起，但是一旦你有了一个正确的索引之后，对这个字符串进行下标操作就只需要 <em>O(1)</em> 次了。关键是，找到现有索引后面的元素的索引的操作也会变得很快，因为你只需要从已有索引字节后面开始算起了——没有必要从字符串开头开始了。这也是为什么有序（向前或是向后）访问字符串里的字符效率很高的原因。</p><p>字符串索引操作的依据跟你在其他集合里使用的所有 API 一样。因为我们最常用的集合：数组，使用的是整数索引，我们通常使用简单的算术来操作，所以有一点很容易忘记： <a href="https://developer.apple.com/documentation/swift/string/1782583-index" target="_blank" rel="noopener"><code>index(after:)</code></a> 方法返回的是下一个字符的索引：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"abcdef"</span></span><br><span class="line"><span class="keyword">let</span> second = s.index(after: s.startIndex)</span><br><span class="line">s[second] <span class="comment">// → "b"</span></span><br></pre></td></tr></table></figure><p>使用 <a href="https://developer.apple.com/documentation/swift/string/1786175-index" target="_blank" rel="noopener"><code>index(_:offsetBy:)</code></a>方法，你可以通过一次操作，自动地访问多个字符，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Advance 4 more characters</span></span><br><span class="line"><span class="keyword">let</span> sixth = s.index(second, offsetBy: <span class="number">4</span>)</span><br><span class="line">s[sixth] <span class="comment">// → "f"</span></span><br></pre></td></tr></table></figure><p>如果可能超出字符串末尾，你可以加一个 <a href="https://developer.apple.com/documentation/swift/anybidirectionalcollection/1781464-index" target="_blank" rel="noopener"><code>limitedBy:</code></a> 参数。如果在访问到目标索引之前到达了字符串的末尾，这个方法会返回一个 <code>nil</code> 值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> safeIdx = s.index(s.startIndex, offsetBy: <span class="number">400</span>, limitedBy: s.endIndex)</span><br><span class="line">safeIdx <span class="comment">// → nil</span></span><br></pre></td></tr></table></figure><p>比起简单的整数索引，这无疑使用了更多的代码。<strong>这是 Swift 故意的。</strong>如果 Swift 允许对字符串进行整数索引，那不小心写出性能烂到爆的代码（比如在一个循环中使用整数的下标操作）的诱惑太大了。</p><p>然而，对一个习惯于处理固定宽度字符的人来说，刚开始使用 Swift 处理字符串会有些挑战——没有了整数索引怎么搞？而且确实，一些看起来简单的任务处理起来还得大动干戈，比如提取字符串的前四个字符：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">s[..&lt;s.index(s.startIndex, offsetBy: <span class="number">4</span>)] <span class="comment">// → "abcd"</span></span><br></pre></td></tr></table></figure><p>不过谢天谢地，你可以使用集合的接口来获取字符串，这意味着许多适用于数组的方法同样也适用于字符串。比如上面那个例子，如果使用 <code>prefix</code> 方法就简单得多了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">s.<span class="keyword">prefix</span>(<span class="number">4</span>) <span class="comment">// → "abcd"</span></span><br></pre></td></tr></table></figure><p>（注意，上面的几个方法返回的都是子字符串 <a href="https://developer.apple.com/documentation/swift/substring" target="_blank" rel="noopener"><code>Substring</code></a>，你可以使用一个 <code>String.init</code> 把它转换为字符串。关于这一部分，我们下一部分会讲更多。）</p><p>没有整数索引，循环访问字符串里的字符也很简单，用 <code>for</code> 循环。如果你想按顺序排列，使用 <a href="https://developer.apple.com/documentation/swift/sequence/1641222-enumerated" target="_blank" rel="noopener"><code>enumerated()</code></a>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i, <span class="built_in">c</span>) <span class="keyword">in</span> s.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(i)</span>: <span class="subst">\(<span class="built_in">c</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者如果你想找到一个特定的字符，你可以使用 <a href="https://developer.apple.com/documentation/swift/string/2893264-index" target="_blank" rel="noopener"><code>index(of:)</code></a>:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">"Hello!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> idx = hello.index(of: <span class="string">"!"</span>) &#123;</span><br><span class="line">    hello.insert(contentsOf: <span class="string">", world"</span>, at: idx)</span><br><span class="line">&#125;</span><br><span class="line">hello <span class="comment">// → "Hello, world!"</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swift/string/2893571-insert" target="_blank" rel="noopener"><code>insert(contentsOf:at:)</code></a> 方法可以在指定索引前插入相同类型的另一个集合（比如说字符串里的字符）。并不一定是另一个字符串，你可以很容易地把一个字符的数组插入到一个字符串里。</p><h2 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h2><p>和其他的集合一样，字符串有一个特定的切片类型或者说子序列类型（<a href="https://developer.apple.com/documentation/swift/collection/1641276-subsequence" target="_blank" rel="noopener"><code>SubSequence</code></a>）：子字符串（<a href="https://developer.apple.com/documentation/swift/substring" target="_blank" rel="noopener"><code>Substring</code></a>）。子字符串就像是一个数组切片（<a href="https://developer.apple.com/documentation/swift/arrayslice" target="_blank" rel="noopener"><code>ArraySlice</code></a>）：它是原字符串的一个视图，起始索引和结束索引不同。子字符串共享原字符串的文本存储空间。这是一个很大的优势，对一个字符串进行切片操作不占用内存空间。在下面的例子中，创建<code>firstWord</code>变量不占用内存：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence = <span class="string">"The quick brown fox jumped over the lazy dog."</span></span><br><span class="line"><span class="keyword">let</span> firstSpace = sentence.index(of: <span class="string">" "</span>) ?? sentence.endIndex</span><br><span class="line"><span class="keyword">let</span> firstWord = sentence[..&lt;firstSpace] <span class="comment">// → "The"</span></span><br><span class="line">type(of: firstWord) <span class="comment">// → Substring.Type</span></span><br></pre></td></tr></table></figure><p>切片操作不占用内存意义重大，特别是在一个循环中，比如你要通过循环访问整个字符串（可能会很长）来提取其中的字符。比如在文本中找到一个单词使用的次数，比如解析一个 CSV 文件。这里有一个非常有用的字符串处理操作：split。<code>split</code> 是 <code>Collection</code> 集合中定义的一个方法，它会返回一个子序列的数组（即 <code>[Substring]</code> ）。它最常见的变种就像是这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(separator: Element, maxSplits: Int = Int.<span class="built_in">max</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        omittingEmptySubsequences: Bool = <span class="literal">true</span>)</span></span> -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以这样使用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> poem = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    Over the wintry</span></span><br><span class="line"><span class="string">    forest, winds howl in rage</span></span><br><span class="line"><span class="string">    with no leaves to blow.</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line"><span class="keyword">let</span> lines = poem.<span class="built_in">split</span>(separator: <span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">// → ["Over the wintry", "forest, winds howl in rage", "with no leaves to blow."]</span></span><br><span class="line">type(of: lines) <span class="comment">// → Array&lt;Substring&gt;.Type</span></span><br></pre></td></tr></table></figure><p>这个跟 <code>String</code> 继承自 <code>NSString</code> 的 <a href="https://developer.apple.com/documentation/swift/stringprotocol/2923413-components" target="_blank" rel="noopener"><code>components(separatedBy:)</code></a> 方法的功能类似，你还可以用一些额外设置比如是否抛弃空的组件。而且在这个操作中，所有输入字符串都没有创建新的复制。因为还有其他<code>split</code>方法的变种可以完成操作，除了比较字符以外，<code>split</code> 还可以完成更多的事情。下面这个例子是文本换行算法的一个原始的实现，最后的代码计算了行的长度：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">wrapped</span><span class="params">(after: Int = <span class="number">70</span>)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> lines = <span class="keyword">self</span>.<span class="built_in">split</span>(omittingEmptySubsequences: <span class="literal">false</span>) &#123;</span><br><span class="line">            character <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> character &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"\n"</span>, <span class="string">" "</span> <span class="keyword">where</span> i &gt;= after:</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lines.joined(separator: <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sentence.wrapped(after: <span class="number">15</span>)</span><br><span class="line"><span class="comment">// → "The quick brown\nfox jumped over\nthe lazy dog."</span></span><br></pre></td></tr></table></figure><p>或者，考虑写另外一个版本，可以拿到一个包含多个分隔符的序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">split</span>&lt;S: Sequence&gt;<span class="params">(separators: S)</span></span> -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">        <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">S</span>.<span class="type">Element</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">split</span> &#123; separators.<span class="built_in">contains</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，你还可以这么写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="string">"Hello, world!"</span>.<span class="built_in">split</span>(separators: <span class="string">",! "</span>) <span class="comment">// → ["Hello", "world"]</span></span><br></pre></td></tr></table></figure><h3 id="字符串协议-StringProtocol"><a href="#字符串协议-StringProtocol" class="headerlink" title="字符串协议 StringProtocol"></a>字符串协议 <code>StringProtocol</code></h3><p><code>Substring</code> 和 <code>String</code> 几乎有着相同的接口，因为两种类型都遵守一个共同的字符串协议（<a href="https://developer.apple.com/documentation/swift/stringprotocol" target="_blank" rel="noopener"><code>StringProtocol</code></a>）。因为几乎所有的字符串API 都是在 <a href="https://developer.apple.com/documentation/swift/stringprotocol" target="_blank" rel="noopener"><code>StringProtocol</code></a> 中定义的，所以操作 <code>Substring</code> 跟操作 <code>String</code> 没有什么大的区别。但是，在有些情况下，你还必须把子字符串转换为字符串的类型；就像所有的切片（slice）一样，子字符串只是为了短时间内的存储，为了防止一次操作定义太多个复制。如果操作结束之后，你还想保留结果，将数据传到另一个子系统里，你应该创建一个新的字符串。你可以用一个 <code>Substring</code> 的值初始化一个 <code>String</code>，就像我们在这个例子中做的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastWord</span><span class="params">(<span class="keyword">in</span> input: String)</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="comment">// Process the input, working on substrings</span></span><br><span class="line">    <span class="keyword">let</span> words = input.<span class="built_in">split</span>(separators: [<span class="string">","</span>, <span class="string">" "</span>])</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> lastWord = words.last <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="comment">// Convert to String for return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(lastWord)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lastWord(<span class="keyword">in</span>: <span class="string">"one, two, three, four, five"</span>) <span class="comment">// → "five"</span></span><br></pre></td></tr></table></figure><p>不建议子字符串长期存储背后的原因是子字符串一直关联着原字符串。即使一个超长字符串的子字符串只有一个字符，只要子字符串还在使用，那原先的字符串就还会在内存里，即使原字符串的生命周期已经结束。因此，长期存储子字符串可能导致内存泄漏，因为有时候原字符串已经无法访问了，但是还在占用内存。</p><p>操作过程中使用子字符串，操作结束的时候才创建新的字符串，通过这种方式，我们把占用内存的动作推迟到了最后一刻，而且保证了我们只会创建必要的字符串。在上面的例子当中，我们把整个字符串（可能会很长）分成了一个个的子字符串，但是在最后只是创建了一个很短的字符串。（例子中的算法可能效率不是那么高，暂时忽略一下；从后先前找到第一个分隔符可能是个更好的方法。）</p><p>遇到只接受 <code>Substring</code> 类型的方法，但是你想传递一个 <code>String</code> 的类型，这种情况很少见（大部分的方法都接受 <code>String</code> 类型或者接受所有符合字符串协议的类型），但是如果你确实需要传递一个 <code>String</code> 的类型，最便捷的方法是使用范围操作符：<code>...</code>（range operator），不限定范围：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子字符串和原字符串的起始和结束的索引完全一致 </span></span><br><span class="line"><span class="keyword">let</span> substring = sentence[...]</span><br></pre></td></tr></table></figure><hr><p><code>Substring</code> 类型是 Swift 4 中的新特性。在 Swift 3 中，<code>String.CharacterView</code> 是自己独有的切片类型（slice type）。这么做的优势是用户只需要了解一种类型，但这也意味这如果存储一个子字符串，整个原字符串也会占据内存，即使它正常情况下应该已经被释放了。Swift 4 损失了一点便捷，换来的是的方便的切片操作和可预测的内存使用。</p><p>要求 <code>Substring</code> 到 <code>String</code> 的转换必须明确写出，Swift 团队认为这没那么烦人。如果实际应用中大家都觉得问题很大，他们也会考虑直接在编译器中写一个 <code>Substring</code> 和 <code>String</code> 之间的<a href="https://github.com/apple/swift/blob/master/docs/StringManifesto.md#substrings" target="_blank" rel="noopener">模糊子类型关系（implicit subtype relationship）</a>，就像 <code>Int</code> 是 <code>Optional&lt;Int&gt;</code> 的子类型一样。这样你就可以随意传递 <code>Substring</code> 类型，编译器会帮你完成类型转换。</p><hr><p>你可能会倾向于充分利用字符串协议，把你所有的 API 写成接受所有遵守字符串协议的实例，而不是仅仅接受 <code>String</code> 字符串。但 Swift 团队的建议是，<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170626/037828.html" target="_blank" rel="noopener">别这样</a>：</p><blockquote><p>总的来说，我们建议继续使用字符串变量。 使用字符串变量，大多数的 API 都会比把它们写成通用类型（这个操作本身就有一些代价）更加简洁清晰，用户在必要的时候进行一些转换并不需要花费很大的精力。</p></blockquote><p>一些 API 极有可能和子字符串一起使用，同时无法泛化到适用于整个序列 <code>Sequence</code> 或集合 <code>Collection</code> 的级别，这些 API 可以不受这条规则的限制。一个例子就是标准库中的 <a href="https://developer.apple.com/documentation/swift/sequence/1641243-joined" target="_blank" rel="noopener"><code>joined</code></a> 方法。Swift 4 中，针对遵守字符串协议的元素组成的序列（<code>Sequence</code>）添加了一个重载（<code>overload</code>）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">StringProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 两个元素中间加上一个特定分隔符后</span></span><br><span class="line">    <span class="comment">/// 合并序列中所有元素，返回一个新的字符串</span></span><br><span class="line">    <span class="comment">/// Returns a new string by concatenating the elements of the sequence,</span></span><br><span class="line">    <span class="comment">/// adding the given separator between each element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">joined</span><span class="params">(separator: String = <span class="string">""</span>)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，你就可以直接对一个子字符串的数组调用 <code>joined</code> 方法了，没必要遍历一次数组并且把每个子字符串转换为新的字符串。这样，一切都很方便快速。</p><p>数值类型初始器（number type initializer）可以将字符串转换为一个数字。在 Swift 4 中，它也接受遵守字符串协议的值。如果你要处理一个子字符串的数组的话，这个方法很顺手：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> commaSeparatedNumbers = <span class="string">"1,2,3,4,5"</span></span><br><span class="line"><span class="keyword">let</span> numbers = commaSeparatedNumbers</span><br><span class="line">    .<span class="built_in">split</span>(separator: <span class="string">","</span>).flatMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125;</span><br><span class="line"><span class="comment">// → [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>由于子字符串的生命周期很短，所以不建议方法的返回值是子字符串，除非是序列 <code>Sequence</code> 或集合 <code>Collection</code> 的一些返回切片的 API。如果你写了一个类似的方法，只对字符串有意义，那让它的返回值是子字符串，好让读者明白这个方法并不会产生复制，不会占用内存。创建新字符串的方法需要占用内存，比如 <a href="https://developer.apple.com/documentation/swift/stringprotocol/2908613-uppercased" target="_blank" rel="noopener"><code>uppercased()</code></a>，这类的方法应该返回 <code>String</code> 字符串类型的值。</p><p>如果你想为字符串类型扩展新的功能， 好的办法是将扩展放在字符串协议 <code>StringProtocol</code> 上，保证 API 在字符串和子字符串层面的一致性。字符权协议的设计初衷就是替换原先在字符串基础上做的扩展功能。如果你想把现有的扩展从字符串转移到字符串协议上，你要做的唯一改变就是，把传递 <code>Self</code> 给只接受具体 <code>String</code> 值的 API替换为 <code>String(Self)</code>。</p><p>需要记住的一点是，从 Swift 4 开始，如果你有一些自定义的字符串类型，不建议遵守字符串协议<code>StringProtocol</code>。官方文档明确警告：</p><blockquote><p>不要做任何新的遵守字符串协议 <code>StringProtocol</code> 的声明。只有标准库里的 <code>String</code> 和 <code>Substring</code> 是有效的遵守类型。</p></blockquote><p>允许开发者写自己的字符串类型（比如有特殊的存储优化或性能优化）是终极目标，但是现阶段协议的设计还没有最终确定，所以现在就启用它可能会导致你的代码在 Swift 5里无法正常运行。</p><p><code>… &lt;SNIP&gt;  &lt;内容有删减&gt;…</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Swift 语言里的字符串跟其他所有的主流编程语言里的字符串差异很大。当你习惯于把字符串当做代码块的数组后，你得花点时间转化思维，习惯 Swift 的处理方法：它把遵守 Unicode 编码标准放在<strong>简洁</strong>前面。</p><p>总的来讲，我们认为 Swift 的选择是正确的。Unicode 编码文本比其他编程语言所认为的要复杂得多。长远来看，处理你可能写出来的 bug 的时间肯定比学习新的索引方式（忘记整数索引）所需的时间多。</p><p>我们已经习惯于任意获取“字符”，以至于我们都忘了其实这个特性在真正的字符串处理的代码里很少用到。我们希望通过这一章里的例子可以说服大家，对于大多数常规的操作，简单的按序遍历也完全 OK。强迫你清楚地写出你想在哪个层面（字位集，Unicode scalar，UTF-16 代码块，UTF-8 代码块）处理字符串是另一项安全措施；读你代码的人会对你心存感激的。</p><p>2016年7月，Chris Lattner 谈到了 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html" target="_blank" rel="noopener">Swift 语言字符串处理的目标</a>，他最后是这么说的：</p><blockquote><p>我们的目标是在字符串处理上超越 Perl。</p></blockquote><p>当然 Swift 4 还没有实现这个目标——很多想要的特性还没实现，包括把 Foundation 库中的诸多字符串 API 转移到标准库，正则表达式的自然语言支持，字符串格式化和解析 API，更强大的字符串插入功能。好消息是 Swift 团队已经表示 <a href="https://github.com/apple/swift/blob/master/docs/StringManifesto.md" target="_blank" rel="noopener">会在将来解决所有这些问题</a>。</p><hr><p>如果喜欢本文的话，请考虑<a href="https://gumroad.com/a/507458675" target="_blank" rel="noopener">购买全书</a>。谢谢！</p><p>全书中第一张是本文的两本。讨论了其他的一些问题，包括如何使用以及什么时候使用字符串的代码块视图，如何和 Foundation里的处理字符串的 API（例如 <a href="https://developer.apple.com/documentation/foundation/nsregularexpression" target="_blank" rel="noopener"><code>NSRegularExpression</code></a> 或者 <a href="https://developer.apple.com/documentation/foundation/nsattributedstring" target="_blank" rel="noopener"><code>NSAttributedString</code></a>） 配合处理。贴别是后面这个问题很难，而且很容易犯错。除此之外还讨论了其他标准库里面机遇字符串的 API，例如文本输出流（<a href="https://developer.apple.com/documentation/swift/textoutputstream" target="_blank" rel="noopener"><code>TextOutputStream</code></a>）或自定义字符串转换（<a href="https://developer.apple.com/documentation/swift/customstringconvertible" target="_blank" rel="noopener"><code>CustomStringConvertible</code></a>）。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2017/11/swift-4-strings&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-11-27&lt;br&gt;译者：&lt;a href=&quot;https://weibo.com/u/5029986118&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;东莞大唐和尚&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;，&lt;a href=&quot;undefined&quot;&gt;Firecrest&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;这个系列中其他文章：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://oleb.net/blog/2014/07/swift-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift 1 中的字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://oleb.net/blog/2016/08/swift-3-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift 3 中的字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Swift 4 中的字符串（本文）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文节选自我们的新书《高级 Swift 编程》「字符串」这一章。《高级 Swift 编程》新版本已根据 Swift 4 的新特性修订补充，新版现已上市。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemannh" scheme="https://swift.gg/categories/Ole-Begemannh/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>剖析 ARM 64 架构中的 objc_msgSend</title>
    <link href="https://swift.gg/2018/08/06/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64/"/>
    <id>https://swift.gg/2018/08/06/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64/</id>
    <published>2018-08-06T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-30<br>译者：<a href="undefined">BigNerdCoding</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>很高兴，我又回来了。在刚刚过去的 WWDC 期间，我在 CocoaConf Next Door 做个一个关于剖析 ARM64 上 <code>objc_msgSend</code> 运行流程的发言。现在我将整理后的内容重新发布到 Friday Q&amp;A 上。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>每个 Objective-C 对象都会指向一个类，而每个类又包含一个方法列表。每个方法则由选择器（<code>selector</code>）、函数指针和一些元数据（<code>metadata</code>）构成。<code>objc_msgSend</code> 职责就是接收对象（<code>object</code>）和选择器（<code>selector</code>），根据选择器名称找到对应方法的函数指针并跳转执行该函数。</p><p>查找过程相对来说还是比较复杂的。若某个方法在当前类中未找到，就需要沿着继承链继续在父类中查找。如果在父类中也未查询到的话，则会触发 runtime 机制中的消息转发机制。任何对象在接收到第一条消息后都会触发类方法 <code>+initialize</code> 。</p><p>因为每次方法调用都会触发上述流程，所以在常见场景下的查找速度必须非常快。显然这与复杂的操作过程之间存在一定冲突。</p><p>为了解决这对矛盾提高查询速度，Objective-C 采用了方法缓存策略。每个类都会使用哈希表将其方法按照 Selector - IMPs（函数指针） 键值对关系缓存起来。这样在查询方法时，runtime 首先会直接去哈希表中查询。如果哈希表中不存在的话则转而执行原有复杂、缓慢的处理流程，并将最终结果缓存起来已备下次使用。</p><p><code>objc_msgSend</code> 用汇编语言进行实现，具体理由有两个：首先纯 C 语言无法实现这么一个函数：接收不定个数且未知类型的参数作为入参跳转至任意函数指针（即调用实现）；其次，执行速度对 <code>objc_msgSend</code> 来说非常重要，汇编语言能最大化提升该项指标。</p><p>当然，使用汇编语言实现整个复杂的消息处理过程是不现实的，而且也没这种必要。因为有些流程一旦触发程序都会变慢，无论采用何种语言层面的实现。整个消息处理流程代码可以分为两个部分：通过汇编代码实现的快速路径部分（fast path） ，C 语言实现的慢路径流程（slow path）。其中汇编代码对应缓存表中查询方法部分并且未命中时跳转 C 代码来进行下一步处理。</p><p>因此，<code>objc_msgSend</code> 代码处理流程大致如下：</p><ol><li>获取消息对象所对应的类信息</li><li>获取类所对应的方法缓存</li><li>在方法缓存中查询 <em>selector</em> 对象的函数实现</li><li>如果查询失败则调用 C 代码进行下一步处理</li><li>跳转到 IMP 所指的函数实现</li></ol><p>下面开始分析其具体实现。</p><h2 id="执行过程的指令"><a href="#执行过程的指令" class="headerlink" title="执行过程的指令"></a>执行过程的指令</h2><p><em>objc_msgSend</em> 在不同情形下执行路径不尽相同。对于向 <code>nil</code> 发送消息，标记指针（tagged pointers），哈希表冲突会相应特殊代码中进行处理。下面我将通过最常见也是最简单的情形来解释 <code>objc_msgSend</code>  的执行，即处理 non-nil、non-tagged 消息并且哈希表也能命中该方法。我会在该过程中标记出那些需要注意的处理路径<em>岔路口</em>，然后回过头来进行详细讲解。</p><p>我将列出单条或一组指令，然后在下面紧接相关解释内容。</p><p>每条指令前面都会有一个地址偏移量，可以将其看作一个指示跳转位置的标记量。</p><p>ARM64 架构中包含 31 个 64 位整型寄存器，对应符号表示为 x0 - x30 。每个寄存器的低 32 位也可以通过 w0 到 w30 进行访问，就像它也是一个单独的寄存器。其中 x0 到 x7 被用来保存函数调用时的前 8 个参数。这意味着 <code>objc_msgSend</code> 函数中的 <code>self</code> 参数保存在 x0 而 <code>_cmd</code> 保存在 x1 。</p><p>起始指令如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000 cmp     x0, #0x0</span><br><span class="line">0x0004 b.le    0x6c</span><br></pre></td></tr></table></figure><p>该段指令是将 <code>self</code> 与 0 进行有符号比较，如果 <code>self</code> 不大于 0 的话则会进行跳转处理。等于 0 其实就相当于 <code>nil</code> 对象，也就是说此时会调用向 <em>nil</em> 发送消息情形下对应的特定代码。另外，该指令也被用于标记指针（<code>tagged pointers</code>）的处理。ARM64 通过设置最高位为 1 来标记 Tagged Pointers（x86-64 则是最低位），此时对应有符号数比为负。对于普通指针来说，上述处理分支都会不被触发。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0008 ldr    x13, [x0]</span><br></pre></td></tr></table></figure><p>该指令将 x0 中所表示的 <em>self</em> 的 isa 地址加载到 x13 寄存器中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x000c and    x16, x13, #0xffffffff8</span><br></pre></td></tr></table></figure><p>因为 ARM64 架构下能够使用 <a href="(http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html)[http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html]"><code>non-pointer isas</code></a> 技术，所以与之前相比 isa 字段不仅可以包含指向 Class 的信息，它还能利用多余比特位存储其它有效信息（例如，引用计数）。这里通过 AND 逻辑运算去除低位的冗余信息得到最终的 Class 的地址并将其存入 x13 寄存器中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0010 ldp    x10, x11, [x16, #0x10]</span><br></pre></td></tr></table></figure><p>这是整个 <code>objc_msgSend</code> 处理流程中我最喜欢的指令。该指令会将 Class 中的方法缓存哈希表加载到 x10 和 x11 两个寄存器中。<code>ldp</code> 指令会将有效的内存信息加载到该指令的前两个寄存器中，而第三个参数则对应该信息的内存地址。在该例中缓存哈希表地址为 x16 寄存器中地址偏移 16 后所处位置。缓存对象数据结构类似于：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述 <code>ldp</code> 指令中，x10 中保存了 <code>_buckets</code> 值，而 x11 寄存器的高 32 位保存的是 <code>_occupied</code> 低 32 位则保存了 <code>_mask</code> 。</p><p><code>_occupied</code> 表示哈希表中的元素的数量，在 <code>objc_msgSend</code> 处理过程中没有太大的作用。而 <code>_mask</code> 则相对重要：它将哈希表大小描述为了一个便于进行与操作的掩码。<code>_mask</code> 值为 2^n - 1 ，换句话说它的二进制表示将以一组 1 作为结尾，形如 000000001111111 。该值为查询 selector 的哈希表索引以及标记表尾的必要条件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0014 and    w12, w1, w11</span><br></pre></td></tr></table></figure><p>该指令用于计算 <code>_cmd</code> 所传递过来的 <code>selector</code> 在哈希表中的起始位置。因为 <code>_cmd</code> 保存在 x1 寄存器中，所以 w1 寄存器则包含了 <code>_cmd</code> 的低 32 位信息。而 w11 寄存器保存了上面提到的 <code>_mask</code> 信息。通过 AND 指令我们将这两个寄存器中数值<em>与操作</em>结果保存到 w12 寄存器中。计算结果相当于 <code>_cmd % table_size</code>  ，但是它却避免了模操作的昂贵开销。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0018 add    x12, x10, x12, lsl #4</span><br></pre></td></tr></table></figure><p>仅仅得到索引是不够，为了从表中加载数据，我们需要得到最终的实际地址。而这正是该指令的目的。因为哈希表的 bucket 都是 16 个比特位，所以这里先对 x12 寄存器中的索引值左移 4 位也就是乘以 16 ，然后再将其与表首地址相加后的确切 bucket 地址信息保存到 x12 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x001c ldp    x9, x17, [x12]</span><br></pre></td></tr></table></figure><p>再一次通过 <code>ldp</code> 指令，将上一步保存在 x12 寄存器中 bucket 对应的信息加载到 x9 和 x17 寄存器中。因为 bucket 由 selector 和 IMP 两部分构成，所以 x9 对应保存了 selector 信息而 x17 则保存了 IMP 信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0020 cmp    x9, x1</span><br><span class="line">0x0024 b.ne   0x2c</span><br></pre></td></tr></table></figure><p>该段指令会将 x9 寄存器中的内容和 x1 中的 <code>_cmd</code> 进行对比，如果它们不等则意味着 bucket 中不包含我们所操作的 selector ，并且在此时跳转到 0x2c 处执行对应的未匹配处理。如果相同的话则表示命中，继续执行下一条指令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0028 br    x17</span><br></pre></td></tr></table></figure><p>该指令为无条件跳转到 x17 寄存器所指位置，也就是跳转到 IMP 所指处执行具体实现代码。此时 <code>objc_msgSend</code> 处理流程中最快的路径已经结束。其余参数所做寄存器都没有被干扰，目标方法会接受传入的全部参数，一切行如直接调用目标函数。</p><p>在最理想的情形下，<code>objc_msgSend</code> 处理流程最快可以在 3 纳秒内执行完毕。</p><p>在介绍完理想的最快情形后，接下来我们需要关注其余几种情形。首先，我们来看下当方法未缓存时的处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x002c cbz    x9, __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><p>前面提到 x9 寄存器包含了加载后的 selector 信息。将寄存器中的信息与零进行比较，如果等于 0 的话就跳转到 <code>__objc_msgSend_uncached</code> 代码处。因为等于 0 就意味着 bucket 为空也就是说方法查询失败，selector 对应的方法没有被缓存到哈希表中。此时我们需要调用 C 语言代码进行更为复杂的处理，也就是 <code>__objc_msgSend_uncached</code> 。如果仅仅只是方法不匹配且 bucket 不为空的话，则需要继续进行方法查找。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0030 cmp    x12, x10</span><br><span class="line">0x0034 b.eq   0x40</span><br></pre></td></tr></table></figure><p>该指令将 x12 寄存器中的当前 bucket 地址与 x10 寄存器中的哈希表首地址进行比较。如果两者内容匹配上了，则我们从哈希表的末尾进行反向查询。虽然我还没弄明白此时为什么没有采用常见的正向遍历查询，但是有理由认为可能这样速度更快。</p><p>0x40 表示匹配后跳转目的地址。如果两者不匹配则继续执行下面的指令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0038 ldp    x9, x17, [x12, #-0x10]!</span><br></pre></td></tr></table></figure><p>再一次代码通过 ldp 指令加载缓存信息，只不过地址为距当前 bucket  偏移 -0x10 所指位置。该指令中的 ！符号表示寄存器回写操作，也就是说会使用计算后的结果更新 x12 寄存器。将其用数学方式表示就是：x12 -= 16，将 x12 中表示的地址前移 16 个单位。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x003c b      0x20</span><br></pre></td></tr></table></figure><p>加载新的 bucket 信息后，代码重新跳转到 0x20 处循环查询过程，直到出现下列情形：找到匹配项，bucket 为空，再次回到了哈希表的起始处。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0040 add    x12, x12, w11, uxtw #4</span><br></pre></td></tr></table></figure><p>当查询到匹配想后会触发该指令。此时 x12 寄存器为最新的 bucket 地址，而 w11 保存了包含哈希表大小的掩码值。该指令将 w11 左移 4 位后将两个值进行叠加得到哈希表尾地址，并将结果保存到 x12 寄存器中，然后接着恢复查询操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0044 ldp    x9, x17, [x12]</span><br></pre></td></tr></table></figure><p>该指令为加载新 bucket 信息到 x9，x17 寄存器中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0048 cmp    x9, x1</span><br><span class="line">0x004c b.ne   0x54</span><br><span class="line">0x0050 br     x17</span><br></pre></td></tr></table></figure><p>该段指令与前面的 0x0020 处的功能一致，只要寄存器内容匹配上了就跳转到对应 IMP 位置执行代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0054 cbz    x9, __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><p>同样的，若不匹配则执行与前面 0x002c 一样的处理流程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0058 cmp    x12, x10</span><br><span class="line">0x005c b.eq   0x68</span><br></pre></td></tr></table></figure><p>该指令与 0x0030 处一致，只不过如果此时 x12 寄存器内容依旧是哈希表首地址的话程序会跳转到 0x68 处进行处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0068 b      __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><p>这种情况一般不太容易发生，因为它会导致哈希表持续膨胀。此时哈希表的查询效率会下降而去潜在哈希碰撞的可能性会变高。</p><p>至于原因，源码中的注释是这些写的：</p><blockquote><p>Clone scanning loop to miss instead of hang when cache is corrupt. The slow path may detect any corruption and halt later.<br>当缓存损坏时，需要跳出上面的循环查询流程而不是进入挂起状态。 转而执行慢速路径流程去检测任何可能的损坏并终止代码执行。</p></blockquote><p>我怀疑这种情况很常见，但很显然苹果公司的员工已经看到内存损坏会让哈希表充满无效内容所以在此处跳转到 C 代码中进行错误诊断。</p><p>此项检查的存在应该将对未损坏的缓存的影响降低到最小。去除该检查，原来的循环处理流程可以被重用，这会节省一点指令缓存空间。 无论如何，该处理程序器并不是常见的情况。 只会在哈希表的开始位置查询到所需的选择子或者发生了哈希碰撞时才会被调用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0060 ldp    x9, x17, [x12, #-0x10]!</span><br><span class="line">0x0064 b      0x48</span><br></pre></td></tr></table></figure><p>该段指令与之前功能一致，加载新 bucket 信息到 x9，x17 寄存器中。更新 x12 中的地址，并跳转到 0x48 处重复查找流程。</p><p>objc_msgSend 的主要处理流程到此告一段落，剩下 Tagged Pointer 和 <code>nil</code> 两个特殊情形的处理。</p><h2 id="标记指针的处理"><a href="#标记指针的处理" class="headerlink" title="标记指针的处理"></a>标记指针的处理</h2><p>我们回到第一组汇编指令的跳转处来讲解标记指针（<code>Tagged Pointer</code>）的处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x006c b.eq    0xa4</span><br></pre></td></tr></table></figure><p>当参数 <em>self</em> 不大于 0 时，该指令就会被触发。其中小于 0 对应标记指针，而等于零则对应 <code>nil</code> 。这两种情形有各自的处理流程，所以第一步就是要区分出到底是哪种情形。若为 <em>nil</em> 情形则跳转到 0xa4 处进行处理，否则继续执行。</p><p>在继续讲解之前，先简单讨论下标记指针工作原理。 标记指针支持多个类。其中高 4 位（在 ARM64 上）指明了“对象”的类信息，本质上就是 Tagged Pointer 的 isa 。当然 4 个比特位不足以容纳一个类指针，实际上这些信息都被存在了一张特殊表中。我们可以以高 4 位的值为索引去表中查询真正的类信息。</p><p>这还不是全部，标记指针（至少在 ARM64 上）支持拓展类。当高 4 位全为 1 时，紧接着的 8 个比特位将被用作拓展类表中的索引值。 这样在运行时支持更多的标记指针类，不过代价就是能存储的有效信息会变少。</p><p>下面继续指令的执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0070 mov    x10, #-0x1000000000000000</span><br></pre></td></tr></table></figure><p>该指令将一个整形值（高 4 位为 1 ，其余全为 0）写入 x10 寄存器中。这将用作下一步提取 <code>self</code> 标记位的掩码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0074 cmp    x0, x10</span><br><span class="line">0x0078 b.hs   0x90</span><br></pre></td></tr></table></figure><p>这一步时检查拓展标记指针内容。如果 <code>self</code> 大于或者等于 x10 中的值，则意味这 <code>self</code> 的高 4 位也全部为 1 。此时代码会跳转到 0x90 处理拓展类部分的内容，否则就继续执行下面的指令去主标记指针表中的查询类信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x007c adrp   x10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class="line">0x0080 add    x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br></pre></td></tr></table></figure><p>该段指令主要就是加载 <code>_objc_debug_taggedpointer_classes@PAGE</code>  所指的主标记指针表地址。因为 ARM64 上的指针是 64 位宽，而指令只有 32 位宽，所以需要采用类 RISC 标准技术通过两个指令来加载符号地址。</p><p>x86 架构则不存在该问题，因为它采用可变长度指令集。它可以通过一个 10 字节长的指令处理上面的问题：2 个字节用来区分具体指令和寄存器，剩下 8 个字节用来保存指针地址。</p><p>而在定长指令集机器上，我们只能通过一组命令加以应对。例如，上例就是通过两条指令实现 64 位指针地址的加载操作。adrp 指令加载高 32 位信息然后再通过 add 指令将其与低 32 位进行求和。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0084 lsr    x11, x0, #60</span><br></pre></td></tr></table></figure><p>因为索引值保存在 x0 的高 4 位中，所以该指令将 x0 进行右移 60 位取出对应的索引值（取值范围为 0-15）并保存到 x11 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0088 ldr    x16, [x10, x11, lsl #3]</span><br></pre></td></tr></table></figure><p>根据索引值获取标记指针的类信息并保存到 x16 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x008c b      0x10</span><br></pre></td></tr></table></figure><p>获得类信息后程序会无条件跳回 0x10 处，并复用主分支中的代码进行方法查询处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0090 adrp   x10, _objc_debug_taggedpointer_ext_classes@PAGE</span><br><span class="line">0x0094 add    x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</span><br></pre></td></tr></table></figure><p>该段指令与前面加载主标记指针表功能一样，只不过此时它用于处理前面提到的拓展表分支。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0098 ubfx   x11, x0, #52, #8</span><br></pre></td></tr></table></figure><p>该指令只要是取出 <em>self</em> 中从第 52 位开始的 8 位信息作为拓展表的索引值，并将其保存到 x11 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x009c ldr    x16, [x10, x11, lsl #3]</span><br></pre></td></tr></table></figure><p>再一次，我们将获得的类信息加载到 x16 中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00a0 b      0x10</span><br></pre></td></tr></table></figure><p>最后，我们同样跳回到 0x10 处。</p><p>接下来，我们来看 <code>nil</code> 情形的处理过程。</p><h2 id="nil-的处理"><a href="#nil-的处理" class="headerlink" title="nil 的处理"></a><code>nil</code> 的处理</h2><p>作为最后一个特殊情况，下面就是 <code>nil</code> 情形下被执行的所有指令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00a4 mov    x1, #0x0</span><br><span class="line">0x00a8 movi   d0, #0000000000000000</span><br><span class="line">0x00ac movi   d1, #0000000000000000</span><br><span class="line">0x00b0 movi   d2, #0000000000000000</span><br><span class="line">0x00b4 movi   d3, #0000000000000000</span><br><span class="line">0x00b8 ret</span><br></pre></td></tr></table></figure><p><code>nil</code> 情形的处理与其他情形完全不同，它不会进行类查询和方法派发，而仅仅返回 0 给调用者。</p><p>该段指令最麻烦的事情是 <code>objc_msgSend</code> 不知道具体的返回值类型。是整型值、浮点值、亦或者是什么都不返回。</p><p>幸运的是，所有用于设置返回值的寄存器都能被安全覆写，即使此次调用过程不会使用到。整型返回值被保存在 x0 和 x1 中，而浮点值则保存在向量寄存器 v0 - v3 中。同时使用多个寄存器可以返回一个小型结构体类型返回值。</p><p>在处理 <code>nil</code> 情形时，上诉指令会将 x1 以及 v0 - v3 中的值全部清空并设置为 0。其中 d0 - d3 分别对应向量寄存器 v0 - v3 的后半部分，通过将其设置为 0 清除了后半部分然后在通过 movi 清除所有的寄存器内容。清空返回值寄存器后，控制权将重新回到调用方。</p><p>如果返回值为比较大的结构体，那么寄存器可能就变的不够用了。此时就需要调用者做出一些配合。调用者会在一开始为该结构体分配一块内存，然后将其地址提前写入到 x8 寄存器中。在设置返回值的时候，直接往该地址中写数据即可。<br>因为该内存大小对 <code>objc_msgSend</code> 是透明的，因此不能对其进行清空操作。取而代之的操作就是在调用 <code>objc_msgSend</code>  之前编译器会将其设置为 0 。</p><p>以上就是 <code>nil</code> 情形的处理，<code>objc_msgSend</code> 流程到此也宣告结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>深入框架底层还是很有趣的，而 <code>objc_msgSend</code>  就像一件艺术品，值得细细玩味。</p><p>今天的内容到此结束，下次再会为大家带来一些更好的内容。Friday Q&amp;A 很多内容都是由读者驱动而来，所以欢迎大家在下面积极发言。</p><h3 id="汇编指令校对者注"><a href="#汇编指令校对者注" class="headerlink" title="汇编指令校对者注"></a>汇编指令校对者注</h3><ol><li><code>#0x0</code>：“#”修饰的数字表示立即数，可简单理解为数值，而非地址：</li><li><code>b</code> ：跳转指令，b.le 指比较结果小于等于的时候跳转至某内存地址；</li><li><code>ldr</code> ：从内存中读取数据到寄存器；</li><li><code>and</code>：arm 的 <code>and</code> 指令，需要3个操作数，例如 <code>AND R0，R0，#3</code> 是将 R0 寄存器的值与数字3（0x0000003）逻辑与，将结果存储为 R0 寄存器</li><li><code>add</code>：<code>ADD[con][S] Rd,Rn,operand</code>，将 operand 数据与 Rn 的值相加，结果保存到 Rd 寄存器；</li><li><code>lsl</code>： 逻辑左移指令，可以结合 <code>add</code> 指令一起使用，如<code>ADDS R0,R1,R2,LSL#2</code>，将 R2 寄存器左移 2 位，接着 R1 和 R2 值相加，将结果存储到 R0 中；</li><li><code>cbz</code>：c对应compare，b就是上面的跳转，z对应0 zero，因此这条命令当比较结果为零（Zero）就跳转至之后的指令；</li><li><code>UXTW</code>： 32 位的逻辑左移指令，更多请见<a href="http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20140407/212142.html" target="_blank" rel="noopener">[llvm] r205861</a>;</li><li><code>LSR</code>： 逻辑右移；</li><li><code>UBFX</code>：<code>UBFX{cond} Rd, Rn, #lsb, #width</code> 从一个寄存器中提取位域，cond —可选，条件码 ；Rd — 目标寄存器 ；Rn — 源寄存器 ；lsb —位域的最低有效位的位置，范围是 0 - 31； width — 位域的宽度，范围是1到 32-lsb</li></ol><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-06-30&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;BigNerdCoding&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;，&lt;a href=&quot;http://codebuild.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shanks&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;很高兴，我又回来了。在刚刚过去的 WWDC 期间，我在 CocoaConf Next Door 做个一个关于剖析 ARM64 上 &lt;code&gt;objc_msgSend&lt;/code&gt; 运行流程的发言。现在我将整理后的内容重新发布到 Friday Q&amp;amp;A 上。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 4 弱引用实现</title>
    <link href="https://swift.gg/2018/08/02/swift-4-weak-references/"/>
    <id>https://swift.gg/2018/08/02/swift-4-weak-references/</id>
    <published>2018-08-02T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2017-09-22-swift-4-weak-references.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-09-22<br>译者：<a href="undefined">BigNerdCoding</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Swift 开源不久我就写了篇关于弱引用实现的<a href="https://mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html" target="_blank" rel="noopener">文章</a>。时移势易，Swift 4 中的弱引用实现已经与旧文不一致了。应 Guillaume Lessard 建议，今天我将会介绍新版实现，并比较其与老版的区别。</p><a id="more"></a><h2 id="旧实现"><a href="#旧实现" class="headerlink" title="旧实现"></a>旧实现</h2><p>考虑到有些人可能已经忘记了旧实现并且不愿重看前面的文章，下面我们就一起简要的回顾下之前的实现方式。</p><p>在旧实现中，Swift 对象有两个引用计数：强引用计数和弱引用计数。当强引用计数为 0 而弱引用计数不为 0 时，对象会被销毁，但是内存并不会被立即释放。内存中会保留弱引用指向的僵尸对象。</p><p>在加载弱引用时，运行时会对引用对象进行检查。如果是僵尸对象，则会对弱引用计数进行递减操作。一旦弱引用计数为 0，对象内存将会被释放。换句话说，僵尸对象的所有弱引用被加载访问后僵尸对象才会真正被清空。</p><p>虽然我喜欢该实现的简单性，但它有一些缺陷。其中一个就是，僵尸对象可能会长时间停留在内存中。对于那些拥有很多实例的类（因为它们包含许多属性，或使用类似 ManagedBuffer 分配了内联的额外内存），这会造成严重的内存浪费。</p><p>另外，在写完旧文后我还发现：对于并发读取，该实现是非线程安全的。虽然已经有补丁修复了这个问题，但从相关讨论可以看出，开发者希望找到一个更好的实现方式，避免出现类似问题。</p><h2 id="对象数据"><a href="#对象数据" class="headerlink" title="对象数据"></a>对象数据</h2><p>Swift 中的 “对象” 其实是由一组数据构成。</p><p>首先，最容易想到的就是源码中声明的那些可直接访问的存储属性。</p><p>其次就是对象的类信息。该信息主要被用于动态派发和 <strong>type(of: )</strong> 内置函数。虽然动态派发和 <strong>type(of: )</strong> 内置函数从侧面暗示了它的存在，但是实际上该信息大多是被隐藏的。</p><p>第三种就是各种引用计数信息。除非你进行一些非常规操作，例如，读取对象的原始内存或说服编译器让你调用 CFGetRetainCount，否则这些信息对你来说是完全透明不可见的。</p><p>第四种就是 Objective-C 运行时存储的辅助信息，例如 Objective-C 弱引用列表（Objective-C 的弱引用实现是通过单独追踪每个弱引用）和关联对象。</p><p>那么这些信息最终都存储在哪里呢？</p><p>在 Objective-C 中，类信息和存储属性（例如，实例变量）内联在对象内存中。其中类信息位于指针所在第一块内存，其后才是实例变量。辅助类信息则保存在外部表中。当你需要操作关联对象时，运行时机制会使用内存地址去一个大的哈希表中查找它。为了实现多线程安全，该表在操作时会加锁，所以存在一定程度访问速度问题。引用计数的保存位置，则取决于具体操作系统版本和 CPU 架构，它有时位于对象内存中，而有时又存储在外部表中。</p><p>在 Swift 旧有实现中，类信息，引用计数和存储属性全部内联在对象内存中。而辅助信息则依旧存储在单独的外部表中。</p><p>下面我们不妨将具体实现代码先放一边，仔细思考下：理论上应该如何存储这些信息呢？</p><p>每种存储方案都有利弊。将数据存储在对象内存中虽然能提高访问速度，但是会让内存空间变得吃紧。与之相对，外部存储方案则是通过牺牲速度来换空间。</p><p>Objective-C 传统存储方案不将对象引用计数保存在内存中，部分原因正是基于此。因为在 Objective-C 引入引用计数概念时，设备的性能远不如现在，而且内存容量也极为有限。Objective-C 程序中大多数对象只有一个所有者，即引用计数为 1 。此时在对象内存中腾出 4 个字节空间存储该引用计数 1 是很浪费的。而外部表方案中，数值 1 可以通过缺省默认值方式表示从而减少内存消耗。</p><p>每次进行动态方法派发时都需要对象的类信息，所有作为最常用信息，类信息应该直接保存在内存中，存在外部表中是不合适的。</p><p>而实例变量这类存储属性在编译期就确定了，而且有现实的访问速度需求，所以存在对象内存中也是最合理的设计。另外，当对象没有存储属性时，系统不会为其分配内存空间也就不存在浪费问题。</p><p>每个对象都需要保留引用计数。虽然不是每个对象的引用计数都为 1，但它依旧是一个相对常见的情形，加上现在内存足够，它可以直接保存在内存中。</p><p>大多数对象都不会有弱引用或关联对象数据，所有它们应该保存在外部以期节约内存空间。</p><p>对于那些有弱引用或关联对象数据的对象来说，访问速度确实不够快但这是合理的权衡结果。那么问题来了，该旧实现有没有改进空间和可行方法呢？</p><h2 id="Side-Tables"><a href="#Side-Tables" class="headerlink" title="Side Tables"></a>Side Tables</h2><p>在 Swift 弱引用的新版实现代码中，引入了 <em>side tables</em> 概念来改进上诉缺陷。</p><p>Side table 本质就是用于保存额外信息的单独内存块，并且它还是可选的。也就是说，对于那些无需保存额外信息的对象来说并没有多余开销。</p><p>每个对象都有一个指向其对应 side table 的指针，而 side table 也有一个指针指向该对象。另外，side table 可以存储关联的对象数据等其他信息。</p><p>为了避免 side table 带来的 8 字节空间开销，Swift 做了一个漂亮的优化。通常内存中的第一个字（Word）是类信息，第二个字则是引用计数。当对象存在 side table 需求时，第二个字将保存指向 side table 的指针。因为引用计数是必要信息，所以此时会将引用计数保存到 side table 中。至于程序运行时到底是哪种情形，则由该块内存中的一个标志位进行区分。</p><p>通过将弱引用从指向对象本身改为指向 side table ，Swift 得以在保留原有引用计数设计的同时修复了旧设计中的缺陷。</p><p>因为 side table 比较小并且弱引用不再指向对象本身，这样之前大型僵尸对象的内存空间将能立即释放从而降低了内存浪费。同时该实现也让线程安全问题变得更易解决：不再需要提前将弱引用置空。因为 side table 比较小，指向它的弱引用可以持续保留，直到这些引用自身被覆写或销毁。</p><p>这里需要提醒一下，当前 side table 实现中只保存引用计数和指向原始对象的指针。类似保存关联对象等用途只是一个猜想和假设。因为 Swift 还没有内建关联对象功能，而 Objective-C API 仍在使用全局表。</p><p>该技术还有不少潜力可挖，也许在不久的将来能看到其应用在关联对象等内容上。我希望它能为类拓展中的存储属性和其他有趣的功能打开一扇新窗。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>因为 Swift 已经开源，所有相关代码都能直接访问。</p><p>关于 side table 的大部分代码都在 <a href="https://github.com/apple/swift/blob/c262440e70896299118a0a050c8a834e1270b606/stdlib/public/SwiftShims/RefCount.h" target="_blank" rel="noopener">stdlib/public/SwiftShims/RefCount.h</a> 。</p><p>高层级的弱引用 API 以及相关注释都在 <a href="https://github.com/apple/swift/blob/c262440e70896299118a0a050c8a834e1270b606/stdlib/public/runtime/WeakReference.h" target="_blank" rel="noopener">swift/stdlib/public/runtime/WeakReference.h</a>。</p><p>更多关于堆对象的实现和注释在 <a href="https://github.com/apple/swift/blob/c262440e70896299118a0a050c8a834e1270b606/stdlib/public/runtime/HeapObject.cpp" target="_blank" rel="noopener">stdlib/public/runtime/HeapObject.cpp</a>。</p><p>上述链接其实带着版本信息，以便后面的读者也能找到本文内容当时的上下文。如果你想看最新的实现代码，你在点击链接后切换到 master 分支即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>弱引用是一个重要的语言特性。Swift 最初的实现方式非常聪明，也有一些不错的特性，但是同时也存在一些问题。通过引入 side table，Swift 开发工程师在保留原有特点的同时还解决了这些缺陷。Side table 的实现也为将来更多新特性创造了更多可能性。</p><p>今天内容到此为止。下次我还会带来与编程和代码相关的新内容。当然你也可以将你感兴趣的话题<a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发送给我</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2017-09-22-swift-4-weak-references.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-09-22&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;BigNerdCoding&lt;/a&gt;；校对：&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/Cee&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cee&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 开源不久我就写了篇关于弱引用实现的&lt;a href=&quot;https://mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;。时移势易，Swift 4 中的弱引用实现已经与旧文不一致了。应 Guillaume Lessard 建议，今天我将会介绍新版实现，并比较其与老版的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="Swift 入门" scheme="https://swift.gg/tags/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>构建一个 @synchronized</title>
    <link href="https://swift.gg/2018/07/30/friday-qa-2015-02-20-lets-build-synchronized/"/>
    <id>https://swift.gg/2018/07/30/friday-qa-2015-02-20-lets-build-synchronized/</id>
    <published>2018-07-30T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-02-20-lets-build-synchronized.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-02-20<br>译者：<a href="undefined">Sunnyyoung</a>；校对：<a href="http://hulizhen.me" target="_blank" rel="noopener">智多芯</a>；定稿：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>上一篇文章讲了线程安全，今天这篇最新一期的 Let’s Build 我会探讨一下如何实现 Objective-C 中的 <code>@synchronized</code>。本文基于 Swift 实现，Objective-C 版本大体上也差不多。</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p><code>@synchronized</code> 在 Objective-C 中是一种控制结构。它接受一个对象指针作为参数，后面跟着一段代码块。对象指针充当锁，在任何时候 <code>@synchronized</code> 代码块中只允许有一个线程使用该对象指针。</p><p>这是一种使用锁进行多线程编程的简单方法。举个例子，你可以使用 <code>NSLock</code> 来保护对 NSMutableArray 的操作：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array;</span><br><span class="line"><span class="built_in">NSLock</span> *arrayLock;</span><br><span class="line"></span><br><span class="line">[arrayLock lock];</span><br><span class="line">[array addObject: obj];</span><br><span class="line">[arrayLock unlock];</span><br></pre></td></tr></table></figure><p>也可以使用 <code>@synchronized</code> 来将数组本身加锁：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(array) &#123;</span><br><span class="line">    [array addObject: obj];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我个人更喜欢显式的锁，这样做既可以使事情更清楚，<code>@synchronized</code> 的性能没那么好，原因如下图所示。但它（<code>@synchronized</code>）使用很方便，不管怎样，实现起来都很有意思。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Swift 版本的 <code>@synchronized</code> 是一个函数。它接受一个对象和一个闭包，并使用持有的锁调用闭包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">synchronized</span><span class="params">(obj: AnyObject, f: Void -&gt; Void)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是，如何将任意对象变成锁？</p><p>在一个理想的世界里（从实现这个函数的角度来看），每个对象都会为锁留出一些额外空间。在这个额外的小空间里 <code>synchronized</code> 可以使用适当的 <code>lock</code> 和 <code>unlock</code> 方法。然而实际上并没有这种额外空间。这可能是件好事，因为这会增大对象占用的内存空间，但是大多数对象永远都不会用到这个特性。</p><p>另一种方法是用一张表来记录对象到锁的映射。<code>synchronized</code> 可以查找表中的锁，然后执行 <code>lock</code> 和 <code>unlock</code> 操作。这种方法的问题是表本身需要保证线程安全，它要么需要自己的锁，要么需要某种特殊的无锁数据结构。为表单独设置一个锁要容易得多。</p><p>为了防止锁不断累积常驻，表需要跟踪锁的使用情况，并在不再需要锁的时候销毁或者复用。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>要实现将对象映射到锁的表，<code>NSMapTable</code> 非常合适。它可以把原始对象的地址设置成键（key），并且可以保存对键（key）和值（value）的弱引用，从而允许系统自动回收未被使用的锁。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> locksTable = <span class="type">NSMapTable</span>.weakToWeakObjectsMapTable()</span><br></pre></td></tr></table></figure><p>表中存储的对象是 <code>NSRecursiveLock</code> 实例。因为它是一个类，所以可以直接用在 <code>NSMapTable</code> 中，这点 <code>pthread_mutex_t</code> 就做不到。<code>@synchronized</code> 支持递归语义，我们的实现一样支持。</p><p>表本身也需要一个锁。自旋锁（spinlock）在这种情况下很适合使用，因为对表的访问是短暂的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> locksTableLock = <span class="type">OS_SPINLOCK_INIT</span></span><br></pre></td></tr></table></figure><p>有了这个表，我们就可以实现以下方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">synchronized</span><span class="params">(obj: AnyObject, f: Void -&gt; Void)</span></span> &#123;</span><br></pre></td></tr></table></figure><p>它所做的第一件事就是在 <code>locksTable</code> 中找出与 <code>obj</code> 对应的锁，执行操作之前必须持有 <code>locksTableLock</code> 锁：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">OSSpinLockLock</span>(&amp;locksTableLock)</span><br><span class="line"><span class="keyword">var</span> lock = locksTable.objectForKey(obj) <span class="keyword">as</span>! <span class="type">NSRecursiveLock</span>?</span><br></pre></td></tr></table></figure><p>如果表中没有找到对应锁，则创建一个新锁并保存到表中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> lock == <span class="literal">nil</span> &#123;</span><br><span class="line">    lock = <span class="type">NSRecursiveLock</span>()</span><br><span class="line">    locksTable.setObject(lock!, forKey: obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了锁之后主表锁就可以释放了。为了避免死锁这必须要在调用 <code>f</code> 之前完成：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">OSSpinLockUnlock</span>(&amp;locksTableLock)</span><br></pre></td></tr></table></figure><p>现在我们可以调用 <code>f</code> 了，在调用前后分别进行加锁和解锁操作：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    lock!.lock()</span><br><span class="line">    f()</span><br><span class="line">    lock!.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对比苹果的方案"><a href="#对比苹果的方案" class="headerlink" title="对比苹果的方案"></a>对比苹果的方案</h2><p>苹果实现 <code>@synchronized</code> 的方案可以在 Objective-C runtime 源码中找到:</p><p><a href="http://www.opensource.apple.com/source/objc4/objc4-646/runtime/objc-sync.mm" target="_blank" rel="noopener">http://www.opensource.apple.com/source/objc4/objc4-646/runtime/objc-sync.mm</a></p><p>它的主要目标是性能，因此不像上面那个玩具般的例子那么简单。对比它们之间有什么异同是一件非常有趣的事。</p><p>基本概念是相同的。存在一个全局表，它将对象指针映射到锁，然后该锁在 <code>@synchronized</code> 代码块前后进行加锁解锁操作。</p><p>对于底层的锁对象，Apple 使用配置为递归锁的 <code>pthread_mutex_t</code>。<code>NSRecursiveLock</code> 内部很可能也使用了 <code>pthread_mutex_t</code>，直接使用就省去了中间环节，并避免了运行时对 Foundation 的依赖。</p><p>表本身的实现是一个链表而不是一个哈希表。常见的情况是在任何给定的时间里只存在少数几个锁，所以链表的性能表现很不错，可能比哈希表性能更好。每个线程缓存了最近在当前线程查找的锁，从而进一步提高性能。</p><p>苹果的实现并不是只有一个全局表，而是在一个数组里保存了 16 个表。对象根据地址映射到不同的表，这减少了不同对象 <code>@synchronized</code> 操作导致的不必要的资源竞争，因为它们很可能使用的是两个不同的全局表。</p><p>苹果的实现没有使用弱指针引用（这会大量增加额外开销），而是为每个锁保留一个内部的引用计数。当引用计数达到零时，该锁可以给新对象重新使用。未使用的锁不会被销毁，但复用意味着在任何时间锁的总数都不能超过激活锁的数量，也就是说锁的数量不随着新对象的创建无限制增长。</p><p>苹果的实现方案非常巧妙，性能也不错。但与使用单独的显式锁相比，它仍然会带来一些不可避免的额外开销。尤其是：</p><ol><li>如果不相关的对象刚好被分配到同一个全局表中，那么它们仍然可能存在资源竞争。</li><li>通常情况下在线程缓存中查找一个不存在的锁时，必须获取并释放一个自旋锁。</li><li>必须做更多的工作来查找全局表中对象的锁。</li><li>即使不需要，每个加锁/解锁周期都会产生递归语义方面的开销。</li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>@synchronized</code> 是一个有趣的语言结构，实现起来并不简单。它的作用是实现线程安全，但它的实现本身也需要同步操作来保证线程安全。我们使用全局锁来保护对锁表的访问，苹果的实现中则使用不同的技巧来提高性能。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-02-20-lets-build-synchronized.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2015-02-20&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;Sunnyyoung&lt;/a&gt;；校对：&lt;a href=&quot;http://hulizhen.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;智多芯&lt;/a&gt;；定稿：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;上一篇文章讲了线程安全，今天这篇最新一期的 Let’s Build 我会探讨一下如何实现 Objective-C 中的 &lt;code&gt;@synchronized&lt;/code&gt;。本文基于 Swift 实现，Objective-C 版本大体上也差不多。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Block 形式的通知中心观察者是否需要手动注销</title>
    <link href="https://swift.gg/2018/07/26/notificationcenter-removeobserver/"/>
    <id>https://swift.gg/2018/07/26/notificationcenter-removeobserver/</id>
    <published>2018-07-26T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2018/01/notificationcenter-removeobserver/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-01-05<br>译者：<a href="undefined">BigNerdCoding</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>简单回答：需要 （在 iOS 11.2 上验证过）</p><p>几周之前，我在 twitter 上提出了一个<a href="https://twitter.com/olebegemann/status/938085544780877824" target="_blank" rel="noopener">问题</a>：</p><blockquote><p>在 iOS 11 中是否还需要手动移除基于 block 形式的通知观察者？苹果开发文档中比较模糊。<a href="https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver" target="_blank" rel="noopener"><code>addObserver(forName:object:queue:using:)</code></a> 中说需要，而 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver" target="_blank" rel="noopener"><code>removeObserver(_:)</code></a> 中又表明 iOS 9 之后都不在需要。</p></blockquote><p>虽然我没有统计准确的数字，但是大致看来持不同意见的人差不多五五开。</p><p>所以下面我们就来具体测试验证一下。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>首先，我所说的基于 block 的接口声明是 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver" target="_blank" rel="noopener"><code>NotificationCenter.addObserver(forName: object: queue: using:)</code></a> 。使用该 API 我们在通知中心注册了一个函数用于处理对应的通知，并且得到一个表示观察者的返回值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> observation: <span class="type">Any</span>? = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        observation = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(</span><br><span class="line">            forName: myNotification, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123; notification <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Received <span class="subst">\(notification.name.rawValue)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是：当代码中的返回值 <em>observation</em> 销毁时（例如，MyObserver 实例对象析构了），通知中心会不会自动忽略并停止调用处理函数呢？毕竟基于 <a href="https://developer.apple.com/documentation/swift/key_path_expressions" target="_blank" rel="noopener">KeyPath</a> 的 <a href="http://skyefreeman.io/programming/2017/06/28/kvo-in-ios11.html" target="_blank" rel="noopener">KVO 新接口</a>当观察者销毁后，响应处理不再被调用，所以通知可能也被理解成是这样进行的。</p><p>或者，我们依旧需要手动调用 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver" target="_blank" rel="noopener"><code>NotificationCenter.removeObserver(_:)</code></a>（例如，在 MyObserver 的析构函数 <strong>deinit</strong> 手动注销）？</p><h2 id="文档中的说明"><a href="#文档中的说明" class="headerlink" title="文档中的说明"></a>文档中的说明</h2><p>基于 selector 形式的观察接口 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1415360-addobserver" target="_blank" rel="noopener"><code>addObserver(_:selector:name:object:)</code></a> 的手动注销操作在 iOS 9 和 OSX 10.11 之后已经变成可选了。然而在 <a href="https://developer.apple.com/library/archive/releasenotes/Foundation/RN-FoundationOlderNotes/index.html#10_11NotificationCenter" target="_blank" rel="noopener">Foundation 发布注意事项</a>中明确表明 Block 形式的接口依然需要进行手动注销操作。</p><blockquote><p>通过 <code>-[NSNotificationCenter addObserverForName:object:queue:usingBlock:_]</code> 形式添加的block类型观察者在无用时依然需要进行注销操作，因为系统会保留对该观察者的强引用。</p></blockquote><p>该文档发布之后是否存在新变化呢？</p><p>在 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver" target="_blank" rel="noopener"><code>addObserver(forName:object:queue:using:)</code></a> 文档说明部分也明确指出了注销操作是必要的：</p><blockquote><p>所有通过 <code>addObserver(forName:object:queue:using:)</code> 创建的观察者在析构之前都需要调用 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver" target="_blank" rel="noopener"><code>removeObserver(_:)</code></a> 或者 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1407263-removeobserver" target="_blank" rel="noopener"><code>removeObserver(_:name:object:)</code></a> 进行注销操作。</p></blockquote><p>然而 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver" target="_blank" rel="noopener"><code>removeObserver(_:)</code></a> 文档说明处似乎与之相反：</p><blockquote><p>如果你的 APP 运行在 iOS 9 或者 macOS 10.11 及最新的版本上的话则不需要注销这个观察者在它的析构方法。</p></blockquote><p>该文档中并没有对 selector 或者 block 进行区分说明，也就是说该操作同时适用于两者。</p><h2 id="进行测试验证"><a href="#进行测试验证" class="headerlink" title="进行测试验证"></a>进行测试验证</h2><p>通过我写的<a href="https://github.com/ole/NotificationUnregistering" target="_blank" rel="noopener">测试应用</a>，你可以得到验证上诉问题（通过 Xcode 的终端输出）。</p><p>下面是我发现的：</p><ul><li>基于block 形式的观察者依然需要进行手动注销操作（即使在 iOS 11.2 上），所以 <code>removeObserver (_:)</code> 文档存在明显的误导。</li><li>如果没有进行注销操作的话，那么 block 就会被一直持有而且依然能够被相关通知触发执行。此时该行为对 APP 的潜在威胁取决于 block 内部持有的对象。</li><li>即使你在 <em>deinit</em> 中调用了注销操作，你依旧需要注意 block 中不能捕获 self 引用，否则会造成循环引用此时 <em>deinit</em> 也永远不会得到执行。</li></ul><h2 id="自动注销"><a href="#自动注销" class="headerlink" title="自动注销"></a>自动注销</h2><p>处理这个问题最好的方式是什么呢？我的建议是：对观察对象进行一次封装。该封装类型的指责就是保持观察者对象并且在析构函数中自动将其注销。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Wraps the observer token received from </span></span><br><span class="line"><span class="comment">/// NotificationCenter.addObserver(forName:object:queue:using:)</span></span><br><span class="line"><span class="comment">/// and unregisters it in deinit.</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationToken</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> notificationCenter: <span class="type">NotificationCenter</span></span><br><span class="line">    <span class="keyword">let</span> token: <span class="type">Any</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(notificationCenter: <span class="type">NotificationCenter</span> = .<span class="keyword">default</span>, token: <span class="type">Any</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.notificationCenter = notificationCenter</span><br><span class="line">        <span class="keyword">self</span>.token = token</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        notificationCenter.removeObserver(token)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过封装处理，我们将观察者的生命周期和该类型实例进行了绑定。接下来我们只需要将该封装类型实例通过私有属性进行保存，那么其持有者就会 <em>deinit</em> 触发时销毁该封装实例紧接着销毁观察者实例对象。这样就不需要在代码中对其进行手动注销操作了。另外我们还可以将该实例声明为 <code>Optional &lt;Notification​Token&gt;</code> ，这样通过将其设置为 nil 也能进行手动注销操作。该模式被称为<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" target="_blank" rel="noopener"> <strong>资源获取即初始化</strong> （RAII）</a>。</p><p>接下来让我们为 <code>NotificationCenter</code> 编写一个便利点的方法，它为我们承担了包装观察接口的任务。 </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NotificationCenter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Convenience wrapper for addObserver(forName:object:queue:using:)</span></span><br><span class="line">    <span class="comment">/// that returns our custom NotificationToken.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">observe</span><span class="params">(name: NSNotification.Name?, object obj: Any?, </span></span></span><br><span class="line"><span class="function"><span class="params">    queue: OperationQueue?, using block: @escaping <span class="params">(Notification)</span></span></span> -&gt; ())</span><br><span class="line">    -&gt; <span class="type">NotificationToken</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> token = addObserver(forName: name, object: obj, queue: queue, using: block)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NotificationToken</span>(notificationCenter: <span class="keyword">self</span>, token: token)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此时将原有的 <code>addObserver(forName:​object:​queue:​using:)</code> 替换为新 API ，并将得到 <em>NotificationToken</em> 实例通过属性保存的话，你将不再需要手动注销操作了。</p><p>Chris 和 Florian 也在 <a href="https://talk.objc.io/episodes/S01E27-typed-notifications-part-1" target="_blank" rel="noopener"><strong>Swift Talk episode 27: Typed Notifications</strong></a> 中提到过该技术，我向你强烈的推荐它。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2018/01/notificationcenter-removeobserver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-01-05&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;BigNerdCoding&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;简单回答：需要 （在 iOS 11.2 上验证过）&lt;/p&gt;
&lt;p&gt;几周之前，我在 twitter 上提出了一个&lt;a href=&quot;https://twitter.com/olebegemann/status/938085544780877824&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;问题&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 iOS 11 中是否还需要手动移除基于 block 形式的通知观察者？苹果开发文档中比较模糊。&lt;a href=&quot;https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;addObserver(forName:object:queue:using:)&lt;/code&gt;&lt;/a&gt; 中说需要，而 &lt;a href=&quot;https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;removeObserver(_:)&lt;/code&gt;&lt;/a&gt; 中又表明 iOS 9 之后都不在需要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然我没有统计准确的数字，但是大致看来持不同意见的人差不多五五开。&lt;/p&gt;
&lt;p&gt;所以下面我们就来具体测试验证一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>在 Swift 中使用马尔可夫链生成文本</title>
    <link href="https://swift.gg/2018/07/23/friday-qa-2018-04-27-generating-text-with-markov-chains-in-swift/"/>
    <id>https://swift.gg/2018/07/23/friday-qa-2018-04-27-generating-text-with-markov-chains-in-swift/</id>
    <published>2018-07-23T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2018-04-27-generating-text-with-markov-chains-in-swift.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-28<br>译者：<a href="http://wuqiuhao.github.io" target="_blank" rel="noopener">Hale</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/u/2d46948e84e3" target="_blank" rel="noopener">mmoaay</a>，<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>马尔可夫链可用于快速生成真实但无意义的文本。今天，我将使用这种技术来创建一个基于这篇博客内容的文本生成器。这个灵感来源于读者 Jordan Pittman。</p><a id="more"></a><h2 id="马尔可夫链"><a href="#马尔可夫链" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h2><p>理论上讲，马尔可夫链是一种状态机，每一个状态转换都有一个与之相关的概率。你可以选择一个起始状态，然后随机地转换成其他状态，通过转移概率来加权，直到到达一个终止状态。</p><p>马尔可夫链有着<a href="https://en.wikipedia.org/wiki/Markov_chain#Steady-state_analysis_and_limiting_distributions" target="_blank" rel="noopener">广泛的应用</a>，但最有趣的是用于文本生成。在本文生成领域，每个状态是文本的一部分，通常是一个单词。状态和转换是由一些语料库生成的，然后遍历整个链并为每个状态输出单词来生成文本。这样生成的文本通常没有实际意义，因为该链不包含足够的信息来保留语料库的任何潜在含义及语法结构，但是缺乏意义本身却给文本带来了意料之外的乐趣。</p><h2 id="构建算法"><a href="#构建算法" class="headerlink" title="构建算法"></a>构建算法</h2><p>链中的节点由 <code>Word</code> 类的实例表示，此类将会为它所表示的单词保存一个字符串，同时持有一组指向其他单词的链接。</p><p>我们如何表示这一组链接呢？最直接的方法是采用某种计数的集合，它将存储其他 <code>Word</code> 实例以及在输入语料库中转换次数的计数。不过，从这样一个集合中随机选择一个链接可能会非常棘手。一个简单的方法是生成一个范围从 0 到集合元素总计数之间的随机数，然后遍历该集合直到取到很多的链接，然后选中你想要的链接。虽然这个方式简单，但可能比较耗时。另一种方法是预先生成一个数组，用于存储数组中每个链接的累积总数，然后对 0 和总数之间的随机数进行二分搜索。这相对来说更繁琐一些，但执行效率更高。如果你追求更好的方案，你其实可以做更多的预处理，并最终得到一个可以在<a href="http://www.keithschwarz.com/darts-dice-coins/" target="_blank" rel="noopener">常量时间内完成查询的紧凑结构</a>。</p><p>最终，我决定偷懒使用一种在空间上极其浪费，但在时间上效率很高且易于实现的结构。该结构每个 <code>Word</code> 包含一个后续 <code>Words</code> 的数组。如果一个链接被指向多次，那么将会保存重复的 <code>Words</code> 数组。在数组中选择一个随机索引，根据索引返回具有适当权重的随机元素。</p><p><code>Word</code> 类结构如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span> </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> str: <span class="type">String</span>?</span><br><span class="line">   <span class="keyword">var</span> links: [<span class="type">Word</span>] = []</span><br><span class="line"></span><br><span class="line">   <span class="keyword">init</span>(str: <span class="type">String</span>?) &#123;</span><br><span class="line">       <span class="keyword">self</span>.str = str</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">randomNext</span><span class="params">()</span></span> -&gt; <span class="type">Word</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> index = arc4random_uniform(<span class="type">UInt32</span>(links.<span class="built_in">count</span>))</span><br><span class="line">       <span class="keyword">return</span> links[<span class="type">Int</span>(index)]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>links</code> 数组可能会导致大量循环引用。为了避免内存泄漏，我们需要手动清理那些内存。</p><p>我们引入 <code>Chain</code> 类，它将管理链中所有的 <code>Words</code> 。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> words: [<span class="type">String</span>?: <span class="type">Word</span>] = [:]</span><br></pre></td></tr></table></figure><p>在 <code>deinit</code> 方法中，清除所有的 <code>links</code> 数组，以消除所有的循环引用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words.values &#123;</span><br><span class="line">        word.links = []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有这一步，许多单词实例的内存都会泄漏。</p><p>现在让我们看看如何将单词添加到链中。<code>add</code> 方法需要一个字符串数组，该数组中每一个元素都保存着一个单词（或调用者希望使用的其他任何字符串）:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> words: [String])</span></span> &#123;</span><br></pre></td></tr></table></figure><p>如果链中没有单词，那么提前返回。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> words.isEmpty &#123; <span class="keyword">return</span> &#125;</span><br></pre></td></tr></table></figure><p>我们想要遍历那些成对的单词，遍历规则是第二个元素的第一个单词紧随第一个元素后面的单词。例如，在句子 “Help, I’m being oppressed,” 中，我们要迭代 <code>(&quot;Help&quot;, &quot;I&#39;m&quot;)</code> ， <code>(&quot;I&#39;m&quot;, &quot;being&quot;)</code> ， <code>(&quot;being&quot;, &quot;oppressed&quot;)</code> 。</p><p>实际上，还需要多做一点事情，因为我们需要编码句子的开头和结尾。我们将句子的开头和结尾用 <code>nil</code> 表示，所以我们要迭代的实际序列是 <code>(nil, &quot;Help&quot;)</code> ， <code>(&quot;Help&quot;, &quot;I&#39;m&quot;)</code> ， <code>(&quot;I&#39;m&quot;, &quot;being&quot;)</code> ， <code>(&quot;being&quot;, &quot;oppressed&quot;)</code> ， <code>(&quot;oppressed&quot;, nil)</code> 。</p><p>为了允许值为 <code>nil</code> ， 我们的数组声明为 <code>String?</code> 类型，而不是 <code>String</code>  类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> words = words <span class="keyword">as</span> [<span class="type">String</span>?]</span><br></pre></td></tr></table></figure><p>接下来构造两个数组，一个头部添加 <code>nil</code>，另一个尾部添加 <code>nil</code>。把它们通过 <code>zip</code> 合并在一起生成我们想要的序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wordPairs = <span class="built_in">zip</span>([<span class="literal">nil</span>] + words, words + [<span class="literal">nil</span>])</span><br><span class="line"><span class="keyword">for</span> (first, second) <span class="keyword">in</span> wordPairs &#123;</span><br></pre></td></tr></table></figure><p>对于这一对中的每个单词，我们使用一个辅助方法来获取相应的 <code>Word</code> 对象：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstWord = word(first)</span><br><span class="line"><span class="keyword">let</span> secondWord = word(second)</span><br></pre></td></tr></table></figure><p>然后把第二个单词添加到第一个单词的链接中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">        firstWord.links.append(secondWord)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Word</code> 辅助方法从 <code>words</code> 字典中提取实例，如果实例不存在就创建一个新实例并将其放入字典中。这样就不用担心字符串匹配不到单词：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">word</span><span class="params">(<span class="number">_</span> str: String?)</span></span> -&gt; <span class="type">Word</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> word = words[str] &#123;</span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> word = <span class="type">Word</span>(str: str)</span><br><span class="line">        words[str] = word</span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后生成我们要的单词序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br></pre></td></tr></table></figure><p>我们将逐个生成单词，并将他们存储在下面的数组中:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result: [<span class="type">String</span>] = []</span><br></pre></td></tr></table></figure><p>这是一个无限循环。因为退出条件没有清晰的映射到循环条件，代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br></pre></td></tr></table></figure><p>在 <code>result</code> 中获取最后一个字符串构成 <code>Word</code> 实例。这很好地处理了当 <code>result</code> 为空时的初始情况，因为一旦 <code>last</code> 取值为 <code>nil</code> 就表示第一个单词：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currentWord = word(result.last)</span><br></pre></td></tr></table></figure><p>随机获取链接的词：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nextWord = currentWord.randomNext()</span><br></pre></td></tr></table></figure><p>如果链接的单词不是结尾，将其追加到 <code>result</code> 中。如果是结束，则终止循环：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> str = nextWord.str &#123;</span><br><span class="line">        result.append(str)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回包含所有单词的 <code>result</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一件事：我们正在使用 <code>String?</code> 作为 <code>words</code> 的键类型，但 <code>Optional</code> 不符合 <code>Hashable</code> 协议。下面是一个扩展，当它的封装类型遵循 <code>Hashable</code> 时添加 <code>Optional</code> 对 <code>Hashable</code> 的实现：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span>: <span class="title">Hashable</span> <span class="title">where</span> <span class="title">Wrapped</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> wrapped?: <span class="keyword">return</span> wrapped.hashValue</span><br><span class="line">        <span class="keyword">case</span> .<span class="keyword">none</span>: <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>备注：Swift 4.2 中 <code>Optional</code> 类型已默认实现 <code>Hashable</code> 协议</p></blockquote><h2 id="生成输入数据"><a href="#生成输入数据" class="headerlink" title="生成输入数据"></a>生成输入数据</h2><p>以上就是马尔可夫链的结构，下面我们输入一些真实文本试试看。</p><p>我决定从 <code>RSS</code> 提要中提取文本。还有什么比用我自己博客全文作为输入更好的选择呢？</p><p><code>let feedURL = URL(string: &quot;https://www.mikeash.com/pyblog/rss.py?mode=fulltext&quot;)!</code></p><p><code>RSS</code> 是一种 <code>XML</code> 格式，所以我们使用 <code>XMLDocument</code> 来解析它：</p><p><code>let xmlDocument = try! XMLDocument(contentsOf: feedURL, options: [])</code></p><p>文章主体被嵌套在 <code>item</code> 节点下的 <code>description</code> 节点。通过 <code>XPath</code> 查询检索：</p><p><code>let descriptionNodes = try! xmlDocument.nodes(forXPath: &quot;//item/description&quot;)</code></p><p>我们需要 <code>XML</code> 节点中的字符串，所以我们从中提取并过滤掉为 <code>nil</code> 的内容。</p><p><code>let descriptionHTMLs = descriptionNodes.compactMap({ $0.stringValue })</code></p><p>我们根本不用关心标签。<code>NSAttributedString</code> 可以解析 <code>HTML</code> 并生成一个 <code>AttributedString</code>，然后我们可以过滤它：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> descriptionStrings = descriptionHTMLs.<span class="built_in">map</span>(&#123;</span><br><span class="line">   <span class="type">NSAttributedString</span>(html: $<span class="number">0</span>.data(using: .utf8)!, options: [:], documentAttributes: <span class="literal">nil</span>)!.string</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们需要一个将字符串分解成若干部分的函数。我们的目的是生成 String 数组，每个数组对应文本里的一句话。一段文本可能会有很多句话，所以 <code>wordSequences</code> 函数会返回一个 String 的二维数组：</p><p><code>func wordSequences(in str: String) -&gt; [[String]] {</code></p><p>然后我们将处理结果存储在一个局部变量中：</p><p><code>var result: [[String]] = []</code></p><p>将字符串分解成句子并不简单。你可以直接搜索标点符号，但需要考虑到像 <code>“Mr. Jock, TV quiz Ph.D., bags few lynx.”</code> 这样的句子，按照标点符号会被分割成四段，但这是一个完整的句子。</p><p><code>NSString</code> 提供了一些智能检查字符串部分的方法，前提是你需要 <code>import Foundation</code> 。我们会枚举 <code>str</code> 包含的句子，并让 <code>Foundation</code> 进行处理：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">str.enumerateSubstrings(<span class="keyword">in</span>: str.startIndex..., options: .bySentences, &#123; substring, substringRange, enclosingRange, stop <span class="keyword">in</span></span><br></pre></td></tr></table></figure><p>在将句子拆分成单词的时候会遇到相似的问题。<code>NSString</code> 也提供了一种用于枚举词的方法，但是存在一些问题，例如丢失标点符号。我最终决定用一种愚蠢的方式来进行单词分割，只按空格进行分割。这意味着你最终将包含标点符号的单词作为字符串的一部分。与标点符号被删除相比，这更多地限制了马尔可夫链，但另一方面，输出会包含合理的标点符号。我觉得这个折中方案还不错。</p><p>一些换行符会进入数据集，我们首先将这些换行符移除：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> words = substring!.<span class="built_in">split</span>(separator: <span class="string">" "</span>).<span class="built_in">map</span>(&#123;</span><br><span class="line">    $<span class="number">0</span>.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.newlines)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>分割的句子最终被添加到 <code>result</code> 中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    result.append(words)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>枚举完成后，根据输入的句子计算出 <code>result</code> ，然后将其返回给调用者：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到主代码。现在已经有办法将字符串转换为句子列表，我们就可以继续构建自己的马尔可夫链。首先我们创建一个空的 <code>Chain</code> 对象：</p><p><code>let chain = Chain()</code></p><p>然后我们遍历所有的字符串，提取句子，并将它们添加到链中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> str <span class="keyword">in</span> descriptionStrings &#123;</span><br><span class="line">   <span class="keyword">for</span> sentence <span class="keyword">in</span> wordSequences(<span class="keyword">in</span>: str) &#123;</span><br><span class="line">       chain.add(sentence)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步当然是生成一些新句子！我们调用 <code>generate()</code>，然后用空格连接结果。输出结果可能命中也可能不命中（考虑到该技术的随机性，这并不奇怪），所以我们会多生成一些：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span> ..&lt; <span class="number">200</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"\""</span> + chain.generate().joined(separator: <span class="string">" "</span>) + <span class="string">"\""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h2><p>为了演示，下面是这个程序的一些示例输出：</p><ul><li>“We’re ready to be small, weak references in New York City.”</li><li>“It thus makes no values?”</li><li>“Simple JSON tasks, it’s wasteful if you can be.”</li><li>“Another problem, but it would make things more programming-related mystery goo.”</li><li>“The escalating delays after excessive focus on Friday, September 29th.”</li><li>“You may not set.”</li><li>“Declare conformance to use = Self.init() to detect the requested values.”</li><li>“The tagged pointer is inlined at this nature; even hundreds of software and writing out at 64 bits wide.”</li><li>“We’re ready to express that it works by reader ideas, so the decoding methods for great while, it’s inaccessible to 0xa4, which takes care of increasing addresses as the timing.”</li><li>“APIs which is mostly a one-sided use it yourself?”</li><li>“There’s no surprise.”</li><li>“I wasn’t sure why I’ve been called ‘zero-cost’ in control both take serious effort to miss instead of ARC and games.”</li><li>“For now, we can look at the filesystem.”</li><li>“The intent is intended as reader-writer locks.”</li><li>“For example, we can use of the code?”</li><li>“Swift’s generics can all fields of Swift programming, with them is no parameters are static subscript, these instantiate self = cluster.reduce(0, +) / Double(cluster.count)”</li><li>“However, the common case, you to the left-hand side tables.”</li></ul><p>上面有很多无意义的句子，所以你必须深入挖掘才能找到有意义的句子，但不可否认马尔可夫链可以产生一些非常有趣的输出。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>马尔可夫链有许多实际用途，在用于生成文本时它可能显得比较有趣但不是很实用。除了展示了其娱乐性之外，该代码还说明了在没有明确引用关系的情况下如何处理循环引用，如何灵活地使用 <code>NSString</code> 提供的枚举方法从文本中提取特征，以及简要说明了条件一致性（<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0143-conditional-conformances.md" target="_blank" rel="noopener">conditional conformances</a>）的优点。</p><p>今天就讲这些。期待下次一起分享更多的乐趣，在娱乐中进行学习。<code>Friday Q&amp;A</code> 是由读者的想法驱动的，所以如果你有一些想在这里看到的话题，请给我<a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发送邮件</a>！</p><blockquote><p>你喜欢这篇文章吗？我正在卖收录了这些文章的一本书！第二卷和第三卷现在也出来了！包括 ePub，PDF，实体版以及 iBook 和 Kindle。<a href="https://www.mikeash.com/book.html" target="_blank" rel="noopener">点击这里查看更多信息</a>。</p></blockquote><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了使用 Swift 来构造马尔可夫链结构，并使用该结构指定输入数据源随机生成文本。
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift Package Manager 重写 macOS 部署目标</title>
    <link href="https://swift.gg/2018/07/19/swift-3-1-package-manager-deployment-target/"/>
    <id>https://swift.gg/2018/07/19/swift-3-1-package-manager-deployment-target/</id>
    <published>2018-07-19T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2017/04/swift-3-1-package-manager-deployment-target/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-04-07<br>译者：<a href="undefined">EyreFree</a>；校对：<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>，<a href="undefined">Firecrest</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Swift 3.1 修复了 <a href="https://swift.org/package-manager/" target="_blank" rel="noopener">Swift Package Manager</a> 无法重写 MacOS 部署目标的 Bug。</p><p>当你在 macOS 上执行 <code>swift build</code> 命令时，包管理器目前（Swift 3.0 和 3.1）会将部署目标硬编码为 macOS 10.10 ¹  现已证明是命令参数的一个 <a href="https://bugs.swift.org/browse/SR-2535" target="_blank" rel="noopener">Bug</a> 引起的 Swift 3.0 中无法重写部署目标这个问题。</p><a id="more"></a><p>因此，你不能轻松编译用到了最新 API 的代码 ²  举个栗子，假设有一个非常简单的包，只包含几行代码在一个源文件中。这个程序用到了 macOS 10.12 引入的新的 <a href="https://oleb.net/blog/2016/07/measurements-and-units/" target="_blank" rel="noopener">单位和测量类型</a> 来将一个值从以 km/h 转换为 m/s ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.swift</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> kph = <span class="type">Measurement</span>(value: <span class="number">100</span>,</span><br><span class="line">    unit: <span class="type">UnitSpeed</span>.kilometersPerHour)</span><br><span class="line"><span class="keyword">let</span> mps = kph.converted(to: .metersPerSecond)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(kph)</span> is <span class="subst">\(mps)</span>"</span>)</span><br></pre></td></tr></table></figure><p>在 macOS（Swift 3.0 或 3.1）上用 <code>swift build</code> 命令编译上面这段代码会报错，因为这段代码用到的 API 在 macOS 10.10 上不可用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swift build</span><br><span class="line">Compile Swift Module <span class="string">'Units'</span> (1 sources)</span><br><span class="line">main.swift:3:11: error: <span class="string">'Measurement'</span> is only available on OS X 10.12 or newer</span><br><span class="line"><span class="built_in">let</span> kph = Measurement(value: 100,</span><br><span class="line">          ^</span><br><span class="line">main.swift:3:11: note: add <span class="string">'if #available'</span> version check</span><br><span class="line"><span class="built_in">let</span> kph = Measurement(value: 100,</span><br><span class="line">          ^</span><br><span class="line">...</span><br><span class="line">&lt;unknown&gt;:0: error: build had 1 <span class="built_in">command</span> failures</span><br><span class="line">error: <span class="built_in">exit</span>(1): /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift-build-tool -f .build/debug.yaml</span><br></pre></td></tr></table></figure><p>在 Swift 3.1 中，你可以在命令行中修改部署目标，如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swift build -Xswiftc <span class="string">"-target"</span> \</span><br><span class="line">    -Xswiftc <span class="string">"x86_64-apple-macosx10.12"</span></span><br><span class="line">Compile Swift Module <span class="string">'Units'</span> (1 sources)</span><br><span class="line">Linking ./.build/debug/Units</span><br></pre></td></tr></table></figure><p>现在，你可以正常执行之前的这段代码了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ .build/debug/Units</span><br><span class="line">100.0 km/h is 27.7778 m/s</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>除了部署目标，另一个常见的自定义编译设置例子是传递一个 <code>DEBUG</code> 标志给编译器，所以可以在你的代码中使用 <code>#if DEBUG/#endif</code> 代码段作为标志传递给编译器，从而来判断是否处于 Debug 模式 - 当前包管理器并没有在 Debug 构建模式下自动完成这些工作。你可以通过 <code>swift build -Xswiftc &quot;-D&quot; -Xswiftc &quot;DEBUG&quot;</code> 命令实现这一目的。</p><p>这仍然不够理想 - 你在每次执行 <code>swift build</code> 或 <code>swift test</code> 命令时都需要手动输入命令行参数 - 但至少这是可行的。</p><p>对于包管理器来说能够在包配置清单中指定自定义编译设置是 <a href="https://lists.swift.org/pipermail/swift-evolution-announce/2017-January/000307.html" target="_blank" rel="noopener">Swift 4 路线图</a>的一部分。我猜我们很快就会看到一个和这一特性有关的 <a href="https://apple.github.io/swift-evolution/" target="_blank" rel="noopener">Swift 发展提案</a>。</p><hr><ol><li>你可以通过添加如下代码段到你的 <code>main.swift</code> 文件然后编译并执行对应包的方式来验证这一点：</li></ol><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> os(macOS)</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"macOS deployment target:"</span>, __MAC_OS_X_VERSION_MIN_REQUIRED)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>如果在 macOS 执行，将会打印：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">macOS deployment target: 101000</span><br></pre></td></tr></table></figure><ol start="2"><li>你必须把所有依赖新 API 的代码用 <code>if #available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *) { ... }</code> 或类似的 block 进行包裹。</li></ol><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2017/04/swift-3-1-package-manager-deployment-target/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-04-07&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;EyreFree&lt;/a&gt;；校对：&lt;a href=&quot;https://weibo.com/1743643682/profile?topnav=1&amp;amp;wvr=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;liberalism&lt;/a&gt;，&lt;a href=&quot;undefined&quot;&gt;Firecrest&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 3.1 修复了 &lt;a href=&quot;https://swift.org/package-manager/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift Package Manager&lt;/a&gt; 无法重写 MacOS 部署目标的 Bug。&lt;/p&gt;
&lt;p&gt;当你在 macOS 上执行 &lt;code&gt;swift build&lt;/code&gt; 命令时，包管理器目前（Swift 3.0 和 3.1）会将部署目标硬编码为 macOS 10.10 ¹  现已证明是命令参数的一个 &lt;a href=&quot;https://bugs.swift.org/browse/SR-2535&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bug&lt;/a&gt; 引起的 Swift 3.0 中无法重写部署目标这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>何时用 struct？何时用 class？</title>
    <link href="https://swift.gg/2018/07/16/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes/"/>
    <id>https://swift.gg/2018/07/16/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes/</id>
    <published>2018-07-16T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-07-17<br>译者：<a href="http://muhlenxi.com/" target="_blank" rel="noopener">muhlenXi</a>；校对：<a href="undefined">Firecrest</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>在 Swift 的世界中，有一个热议很久的主题，何时使用 <code>class</code> 和何时使用 <code>struct</code> ，今天，我想发表一下我自己的观点。</p><a id="more"></a><h2 id="值类型-VS-引用类型"><a href="#值类型-VS-引用类型" class="headerlink" title="值类型 VS 引用类型"></a>值类型 VS 引用类型</h2><p>事实上，这个问题的答案很简单：当你需要值语义的时候用 <code>struct</code> ，当你需要引用语义的时候就用 <code>class</code> 。</p><p>好了，下周同一时间请再次访问我的博客……</p><p><strong>等等</strong></p><p>怎么了？</p><p><strong>这没有回答上述中的问题</strong></p><p>你什么意思？答案就在那儿。</p><p><strong>是的，但是……</strong></p><p>但是什么？</p><p><strong>那什么是值语义，什么是引用语义呢？</strong></p><p>昂，你提醒了我。我确实应该讲解一下。</p><p><strong>还有它们和 struct、class 的关系</strong></p><p>好吧。</p><p>这些问题的核心就是数据和数据的存储位置。我们用局部变量、参数、属性和全局变量来存储数据。存储数据有两种最基本的方式。</p><p>对于值语义，数据是直接保存在变量中。对于引用语义，数据保存在其他地方，变量存储的是该数据的引用地址。当我们访问数据时，这种差异不一定很明显。但是拷贝数据时就完全不一样了。对于值语义，你得到的是该数据的拷贝。对于引用语义，你得到的是该数据的引用地址拷贝。</p><p>这有些抽象，我们通过一个示例来了解一下。先暂时跳过 Swift 的示例，一起来看一个 Objective-C 的示例：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SomeClass</span> : <span class="title">NSObject</span> </span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> number;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SomeClass</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> SomeStruct &#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SomeClass *reference = [[SomeClass alloc] init];</span><br><span class="line">reference.number = <span class="number">42</span>;</span><br><span class="line">SomeClass *reference2 = reference;</span><br><span class="line">reference.number = <span class="number">43</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"The number in reference2 is %d"</span>, reference2.number);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> SomeStruct value = &#123;&#125;;</span><br><span class="line">value.number = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">struct</span> SomeStruct value2 = value;</span><br><span class="line">value.number = <span class="number">43</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"The number in value2 is %d"</span>, value2.number);</span><br></pre></td></tr></table></figure><p>打印的结果如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">The number <span class="keyword">in</span> reference2 is <span class="number">43</span></span><br><span class="line">The number <span class="keyword">in</span> value2 is <span class="number">42</span></span><br></pre></td></tr></table></figure><p>为什么打印结果会不一样?</p><p>代码 <code>SomeClass *reference = [[SomeClass alloc] init]</code> 在内存中创建了 SomeClass 类的一个新实例，然后将该实例的引用放到 reference 变量中。代码 <code>reference2 = reference</code> 将 reference 变量的值（实例的引用）赋值给新的 reference2 变量。然后 <code>reference.number = 43</code> 将两个变量指向的对象（同一个对象）的 number 属性修改为 43。 这就导致打印的 reference2 的值也是 43。</p><p>代码 <code>struct SomeStruct value = {}</code> 创建  SomeStruct 结构体的一个新实例并赋值给变量 value。代码 <code>value2 = value</code> 拷贝 value 的值到 变量 value2 中。每个变量包含各自的数据块。而代码 <code>value.number = 43</code> 仅仅修改 value 变量的值。所以，value2 变量的值仍然是 42。</p><p>用 Swift 实现这个例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reference = <span class="type">SomeClass</span>()</span><br><span class="line">reference.number = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> reference2 = reference</span><br><span class="line">reference.number = <span class="number">43</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The number in reference2 is <span class="subst">\(reference2.number)</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="type">SomeStruct</span>()</span><br><span class="line">value.number = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> value2 = value</span><br><span class="line">value.number = <span class="number">43</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The number in value2 is <span class="subst">\(value2.number)</span>"</span>)</span><br></pre></td></tr></table></figure><p>和之前一样，打印如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">The</span> number <span class="keyword">in</span> reference2 <span class="keyword">is</span> <span class="number">43</span></span><br><span class="line"><span class="type">The</span> number <span class="keyword">in</span> value2 <span class="keyword">is</span> <span class="number">42</span></span><br></pre></td></tr></table></figure><h2 id="使用值类型的经验"><a href="#使用值类型的经验" class="headerlink" title="使用值类型的经验"></a>使用值类型的经验</h2><p>值类型不是新出的类型。但是对于很多人来说，他们<em>感觉上</em>很新。这是怎么回事？</p><p>大部分 Objective-C 代码不会用到 struct。我们通常操作的是 CGRect 、 CGPoint 和友元，很少自己定义结构体。一方面，结构体不实用，无法做函数式的引用赋值。在 Objective-C 中，正确保存对象的引用到 struct 中是很困难的，尤其是使用 ARC 的时候。</p><p>大部分语言没有类似 struct 结构体的东西。像 Python 和 JavaScript 这样“一切皆对象”的语言都只有引用类型。如果你是从这样的语言转到 Swift，值类型这个概念可能对你来说更加陌生。</p><p>不过等一下！有一个地方几乎所有的语言都会使用值类型：数值（number）！只要你写过一段时间代码，无论是什么语言，肯定能理解下面这段代码的行为：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> x2 = x</span><br><span class="line">x++</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"x=<span class="subst">\(x)</span> x2=<span class="subst">\(x2)</span>"</span>)</span><br><span class="line"><span class="comment">// prints: x=43 x2=42</span></span><br></pre></td></tr></table></figure><p>这对我们来说是非常明显和自然的，我们甚至没有意识到它的行为与众不同。但是它确确实实是值类型。从你编程的第一天开始就一直在使用值类型，即使你没有意识到这一点。</p><p>由于许多语言的核心是“一切皆对象”，number 其实是用引用类型来实现的。然而，它们是不可变引用类型，不可变引用类型和值类型的差异是很难察觉的。它们的行为和值类型一样，即使它们不是以这种方式实现。</p><p>这是理解值类型和引用类型的重要部分。就语言语义方面，区别是很重要的。当修改数据时，如果你的数据是不可变的，那么值类型/引用类型之间的区别就消失了，或者至少变成纯粹的性能问题而不是语义问题。</p><p>Objective-C 中也有类似的东西，就是标记指针（tagged pointers）。标记指针把对象直接存储在指针值中，因此它实际上是值类型，拷贝指针相当于拷贝对象。Objective-C 的库只会把不可变类型存储到标记指针中，所以使用的时候感受不到区别。有些 NSNumber 是引用类型，有些是值类型，但是使用上没有区别。</p><h2 id="做出选择"><a href="#做出选择" class="headerlink" title="做出选择"></a>做出选择</h2><p>既然我们已经知道值类型是如何工作的，那么你自己的数据类型该用什么呢？</p><p>这两者之间的根本区别在于，当你使用 <code>=</code> 时会发生什么。值类型会得到该对象的副本，引用类型仅仅得到该对象的引用。</p><p>因此，决定使用哪一个的基本问题是：是否需要拷贝？是否需要经常拷贝？</p><p>首先来看一些毫无争议的例子。Integer 显然是可拷贝的，它应该是值类型。网络套接字（Network sockets）明显是不可拷贝的，它应该是引用类型。再比如使用 (x, y) 实数对表示的坐标（Points）是可拷贝的，它应该是值类型。代表磁盘的控制器是明显不可拷贝的，它应该是引用类型。</p><p>有些类型理论上<em>可以</em>拷贝，但是这种拷贝可能不是你想要的。这种情况下，它们应该是引用类型。举个例子，屏幕上的按钮在代码层面可以拷贝，但是拷贝的按钮和原始按钮并不一样。点击拷贝的按钮并不会触发原始按钮，拷贝的按钮在屏幕上的位置也和原始按钮不一样。如果你需要把按钮当成参数传递，或者将它赋值给一个新变量，那你需要的是原始按钮的引用，只有明确声明的时候才进行拷贝。因此，按钮应该是引用类型。</p><p>视图和窗口控制器也类似。它们可以支持拷贝，但一般来说这不是你期望的行为，它们应该是引用类型。</p><p>接着谈谈模型（model）类型。假设你有一个 User 类型，用来表示系统中的用户，然后用 Crime 类型来表示 User 的操作。这两个类型看起来都可以拷贝，可以设置成值类型。但是，如果你的程序需要更新 User 的 Crime 并且能把改动同步到其他代码，那最好用一个用户控制器（User Controller）来管理 User，显然这个用户控制器应该是引用类型。</p><p>集合是个有趣的例子。集合包括数组、字典、字符串等类型。它们是可拷贝的吗？显然是。是否需要经常拷贝？这就不好说了</p><p>大部分语言的回答是“No”，它们的集合是引用类型。比如 Objective-C、Java、Python、JavaScript 以及一些我能想到的语言。（一个例外是 C++ 的 STL 集合，但是 C++ 是语言中的疯子，它做的每件事都很奇怪。）</p><p>Swift 是可拷贝的。这意味着 <code>Array</code> 、 <code>Dictionary</code> 和 <code>String</code> 是结构体而不是类。可以将他们的拷贝作为参数来使用。如果拷贝付出的代价很小，这么做就完全合理。Swift 为了实现这个功能花了很大功夫。。</p><h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>嵌套值类型和引用类型有四种方式。哪怕只用到了其中一种，你的生活都会变得更加有趣。</p><ol><li>包含其他引用类型的引用类型，这没什么特别的。如果持有内部或外部值的引用，就可以修改这个值。改动会同步到所有持有者。</li><li>包含其他值类型的值类型，这样做的结果是一个更庞大的值类型。当内部值是外部值的一部分时，如果你将外部值存储到某个新地方，整个值类型都会被拷贝，包括内部值。如果你将内部值储存到新地方，那就只拷贝内部值。</li><li>包含值类型的引用类型，被引用的值会变大。外部值的引用可以操作整个对象，包括内部值。修改内部值时，外部值引用的持有者都会同步改动。如果你将内部值储存到新地方，它会被拷贝。</li><li>包含引用类型的值类型，这就有点复杂了。你可能会遇到意料之外的行为。这有利有弊，取决于你的使用方式。如果你将一个引用类型放到值类型中，然后拷贝这个值类型到一个新地方，拷贝中的内部对象的引用值是相同的，它们都指向相同的地方。下面是一个示例：</li></ol><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">42</span></span><br><span class="line">    <span class="keyword">var</span> inner = <span class="type">Inner</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> outer = <span class="type">Outer</span>()</span><br><span class="line"><span class="keyword">var</span> outer2 = outer</span><br><span class="line">outer.value = <span class="number">43</span></span><br><span class="line">outer.inner.value = <span class="number">43</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"outer2.value=<span class="subst">\(outer2.value)</span> outer2.inner.value=<span class="subst">\(outer2.inner.value)</span>"</span>)</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">outer2.value=<span class="number">42</span> outer2.inner.value=<span class="number">43</span></span><br></pre></td></tr></table></figure><p><code>outer2</code> 是 <code>outer</code> 的拷贝，它仅仅拷贝了 <code>inner</code> 的引用，因此两个结构体的 <code>inner</code> 共享一个存储空间。因此更新 <code>outer.inner.value</code> 的值会影响 <code>outer2.inner.value</code> 的值。神奇！</p><p>如果使用得当，上面的这种行为使编程变得很方便，它允许你创建一个支持写时复制的 <code>struct</code> ，允许你不需要拷贝大量的数据就可以实现值语义。这就是 Swift 的集合工作机制，你也可以创建自己的集合。如果想了解更多，可以阅读 <a href="https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html" target="_blank" rel="noopener">一起来构建 Swift Array</a>。</p><p>这种行为也相当危险。举个例子，你有一个可拷贝的 Person 类，所以它可以是 <code>struct</code> 类型，为了怀旧，你决定用 <code>NSString</code> 类型来保存姓名：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> name: <span class="type">NSString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后生成一对夫妇的实例，分别给每个实例的姓名赋值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="type">NSMutableString</span>()</span><br><span class="line">name.appendString(<span class="string">"Bob"</span>)</span><br><span class="line">name.appendString(<span class="string">" "</span>)</span><br><span class="line">name.appendString(<span class="string">"Josephsonson"</span>)</span><br><span class="line"><span class="keyword">let</span> bob = <span class="type">Person</span>(name: name)</span><br><span class="line"></span><br><span class="line">name.appendString(<span class="string">", Jr."</span>)</span><br><span class="line"><span class="keyword">let</span> bobjr = <span class="type">Person</span>(name: name)</span><br></pre></td></tr></table></figure><p>打印他们的姓名：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line"><span class="built_in">print</span>(bobjr.name)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Bob</span> <span class="type">Josephsonson</span>, <span class="type">Jr</span>.</span><br><span class="line"><span class="type">Bob</span> <span class="type">Josephsonson</span>, <span class="type">Jr</span>.</span><br></pre></td></tr></table></figure><p>喔！</p><p>发生了什么？与 Swift 中的 <code>String</code> 类型不同，<code>NSString</code> 是一个引用类型，是不可变的，但是它有一个可变的子类 <code>NSMutableString</code> 。构建 bob 时，生成了一个被 name 中字符串所持有的引用。随后改变 这个字符串时，改动被同步到了 bob 中。虽然 bob 是用 <code>let</code> 声明值类型，但是此处的赋值操作显然改变了 bob。事实上，这没有覆写 bob，只不过是改变了 bob 持有的引用的数据。因为 name 是 bob 的一部分数据，从语义上看，就好像覆写了 bob。</p><p>这种行为在 Objective-C 中一直存在。每个有经验的 Objective-C 开发者都能避免这种行为。因为一个 <code>NSString</code> 实际上可能是一个 <code>NSMutableString</code> 。为了防止这种行为，可以声明一个 <code>copy</code> 的属性或者在初始化的时候显式的调用 <code>copy</code> 方法。在许多 Cocoa 的集合中可以发现这种做法。</p><p>Swift 的解决方法很简单：用值类型而不是引用类型。在这种情况下，声明 name 为 <code>String</code> 类型即可。这样就不用担心无意中出现存储共享的问题。</p><p>有些情况下，解决方法可能没有这么简单。举个例子，你可能会创建一个 包含引用类型变量 view 的 <code>struct</code> ，并且它不能改变为值类型。这<em>也许</em>表示你的类型不应该是 <code>struct</code> ，因为你无论如何也不能实现值语义。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>移动值语义类型的数据时，新数据是原数据的拷贝。然而，引用语义类型的数据得到的是原数据的引用拷贝。这意味着你可以在任何地方通过引用覆写原数据。而值语义只能通过改变原数据来改变原数据的值。选择类型时，要考虑该类型是否适合拷贝和倾向于拷贝的固有类型。最后，注意值类型中嵌套的引用类型，如果你不留心将会发生一些糟糕的事情。</p><p>今天的内容到此结束，这次是真的结束了，下次再见。你们的建议对 Friday Q&amp;A  是最好的鼓励，所以如果你关于这个主题有什么好的想法，请<a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发邮件到这里</a>。</p><blockquote><p>你喜欢这篇文章么？我的书里还有更多有意思的内容！第二卷 和 第三卷正在出售中！包括 ePub，PDF，纸质版，iBooks 和 Kindle，<a href="https://www.mikeash.com/book.html" target="_blank" rel="noopener">点击查看更多信息</a>。</p></blockquote><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2015-07-17&lt;br&gt;译者：&lt;a href=&quot;http://muhlenxi.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;muhlenXi&lt;/a&gt;；校对：&lt;a href=&quot;undefined&quot;&gt;Firecrest&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/Cee&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cee&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在 Swift 的世界中，有一个热议很久的主题，何时使用 &lt;code&gt;class&lt;/code&gt; 和何时使用 &lt;code&gt;struct&lt;/code&gt; ，今天，我想发表一下我自己的观点。&lt;/p&gt;
    
    </summary>
    
      <category term="mikeash.com" scheme="https://swift.gg/categories/mikeash-com/"/>
    
    
      <category term="Swift 入门" scheme="https://swift.gg/tags/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>关于注释</title>
    <link href="https://swift.gg/2018/07/11/on-comments/"/>
    <id>https://swift.gg/2018/07/11/on-comments/</id>
    <published>2018-07-11T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2017/03/on-comments/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-03-22<br>译者：<a href="undefined">TonyHan</a>；校对：<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>，<a href="undefined">Firecrest</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>写代码的过程中，复杂性是最大的敌人。对于大型的软件项目来说，维护多层抽象并且让在代码库中工作的开发者正确的理解这些概念是很重要的。</p><p>注释可以对管理代码复杂性起到一定作用，但也会对代码产生不良影响。</p><p>我对注释的看法来自于两个事实：1）注释并不复杂。2）注释通常在语法高亮中使用柔和的色彩。因为它们不参与编译，并且因为它们并不醒目，所以在更改代码时，很容易忽略它们。如果更改了代码但不更新注释，便得到了一份无法准确描述代码功能的注释。</p><a id="more"></a><p>理想的情况下，可以在代码审查中对注释及时修正，但是实际开发中很难做到这一点。代码审查工具也会有语法高亮显示，这同样会让注释显得不醒目。另外，由于代码审查只会显示被改动的几行代码，只有当注释在改动的附近时，这些已经不适用的注释才会被观察到。如果在一个方法中不起眼的位置修改了一行代码，使得方法的前提条件发生了变化，审查代码的人则很难注意到，也不会告知你去更新注释。</p><p>这里有一些避免最常见注释误区的技巧，其中一些在<a href="http://www.strongopinionsweaklytyped.com/blog/2014/08/27/beware-the-siren-song-of-comments/" target="_blank" rel="noopener">我的老领导的博客</a>中提到过，其他的安德鲁没有想到是因为他是 Ruby（一门动态类型的语言） 程序员。</p><ol><li><p>良好的命名习惯！优秀注释的第一步就是避免使用单字母、抽象或模糊的名字。名字越精确，所需的注释就越少。</p></li><li><p>如果方法有前提条件，并且添加了一个断言，来使得传入非法参数的情况崩溃（至少在调试的时候！）。如果只接受正整数，则写一些类似这样的代码：<code>precondition(int &gt; 0)</code>。</p></li><li><p>编译时的断言比运行时的断言更好。如果方法仅接受非空数组，则可以提前使用判断：<code>precondition(!array.isEmpty)</code>。但是也可以使用一种永远不能表达为空数组的<a href="https://github.com/khanlou/NonEmptyArray" target="_blank" rel="noopener">类型</a>。调用你 API 时永远不可能传入空的组数作为参数。<br>同样，如果是 bool 类型的参数，能不能通过命名两个枚举选项来更好的表达？<a href="http://khanlou.com/2017/03/that-one-optional-property/" target="_blank" rel="noopener">你的选项是否以枚举的方式更好的表达出来？</a><a href="http://wiki.c2.com/?IntentionRevealingNames" target="_blank" rel="noopener">使用命名来表达意图。</a></p></li><li><p>标记出黑科技、临时代码和原型代码。我经常使用类似于 <code>hack_</code> 的前缀代码来标记出此功能实现地并不完美。在 Swift 的方法命名中使用下划线显得不伦不类，我能感觉到我代码变得更糟，于是我会想要修复它。我们最近写了一个前缀为 <code>shouldReallyBeInTheCoordinator_</code> 的函数，这是因为需要代码审查，但是代码并不在正确的类中。当糟糕的代码变成丑陋的代码，代码库的需求和你自己的感觉会统一起来。其他的好前缀比如：<code>perf_</code> 和 <code>temp_</code>。</p></li><li><p>你可以在方法名中添加 ID 来进行 bug 的追踪，这样它们就会在堆栈中出现。UIKit 框架在少数情况下也使用了数字。比如以下：</p></li></ol><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-[<span class="built_in">UIViewController</span> _hackFor11408026_beginAppearanceTransition:animated:]</span><br></pre></td></tr></table></figure><ol start="6"><li><p>不要担心在方法名里描述为何如此命名。你可以将方法命名为 <code>updateFrameOnNextTickBecauseAutoLayoutHasntCompletedYet(frame: CGRect)</code>。编译器并不关心方法命名的长短，代码读的次数比写的次数多得多。注释只是文字，方法名也是。将来维护代码的人肯定会赞同你详细的命名。</p></li><li><p>设置一个辅助函数，例如 <code>TODO(date: Date, message: String)</code> ，如果 TODO 将来一直没有被修改，则会打印错误日志（甚至更进一步，在调试中崩溃）。可以参考 Jordan Rose 的另一个<a href="https://twitter.com/UINT_MIN/status/836316697388695552" target="_blank" rel="noopener">例子</a>。</p></li><li><p>将所有的算法需求编码到测试中。如果以上几条都无法使用，并且无法依赖前提条件、类型或方法名来解决某个问题，那就写一个测试用例。这对边界情况特别适用。如果有人重写这部分代码，测试将会失败，他便会知道需要在新代码也要处理此种情况。</p></li></ol><p>切记：这并不是写复杂代码并且不加注释的借口。如果要跳过注释，那么代码必须清晰。对我而言，注释是最后的手段。如果我能找到任何其他的方式来将我的意图传达给下一个程序员，我都不会添加注释。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul><li><a href="http://ericasadun.com/2016/11/03/swift-holy-war-comments-are-not-an-anti-pattern/" target="_blank" rel="noopener">Erica Sadun 的关于为何注释是有益的</a>。</li></ul><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2017/03/on-comments/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-03-22&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;TonyHan&lt;/a&gt;；校对：&lt;a href=&quot;https://weibo.com/1743643682/profile?topnav=1&amp;amp;wvr=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;liberalism&lt;/a&gt;，&lt;a href=&quot;undefined&quot;&gt;Firecrest&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;写代码的过程中，复杂性是最大的敌人。对于大型的软件项目来说，维护多层抽象并且让在代码库中工作的开发者正确的理解这些概念是很重要的。&lt;/p&gt;
&lt;p&gt;注释可以对管理代码复杂性起到一定作用，但也会对代码产生不良影响。&lt;/p&gt;
&lt;p&gt;我对注释的看法来自于两个事实：1）注释并不复杂。2）注释通常在语法高亮中使用柔和的色彩。因为它们不参与编译，并且因为它们并不醒目，所以在更改代码时，很容易忽略它们。如果更改了代码但不更新注释，便得到了一份无法准确描述代码功能的注释。&lt;/p&gt;
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用类型来让你自己更可靠</title>
    <link href="https://swift.gg/2018/07/03/using-types-to-keep-yourself-honest/"/>
    <id>https://swift.gg/2018/07/03/using-types-to-keep-yourself-honest/</id>
    <published>2018-07-03T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：MATTHIJS HOLLEMANS，<a href="http://machinethink.net/blog/using-types-to-keep-yourself-honest/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016-03-25<br>译者：<a href="undefined">TonyHan</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>这篇文章展示了如何利用 Swift 的类型系统来使你的程序更具表现力和健壮性。</p><p>在最近一周左右的时间里，我一直在倒腾 Swift 的机器学习算法。我们可以通过使用矩阵来简洁有效地实现这些算法。</p><p>如果你忘记了线性代数，那只需将矩阵看作数字表格。</p><p>当提到 “M 是一个 4 乘 3 的矩阵”，意思是指 M 是一个 4 行 3 列的数字表格。关于矩阵你就需要了解这些（译者注:即可将其看作是表格），就可以理解本文后面的讲解。</p><a id="more"></a><p>下面是一个 4×3 矩阵的例子：</p><p><img src="/img/articles/using-types-to-keep-yourself-honest/Matrix.png1530582060.2468634" alt="Matrix"></p><p>下面写代码创建一个 <code>矩阵结构体</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rows: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> columns: <span class="type">Int</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经常需要对矩阵的操作是将它们相乘，因此我创建了一个函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(m1: Matrix, <span class="number">_</span> m2: Matrix)</span></span> -&gt; <span class="type">Matrix</span> &#123;</span><br><span class="line">  <span class="comment">// bunch of math...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一切可能看起来很简单，但是还有些让我很烦的东西。</p><p>即便 m1 和 m2 都是 Matrix 对象，但是实际上它们可能具有不同数量的行和列。这可能是一个问题。</p><p>例如，使用矩阵乘法，两个矩阵的大小必须以特定方式匹配。</p><p><img src="/img/articles/using-types-to-keep-yourself-honest/MatrixMultiplication.png1530582060.3889682" alt="MatrixMultiplication"></p><p>第一个矩阵中的列数必须与第二个矩阵中的行数相同。如果第一个矩阵的大小为 <code>U × V</code>，则第二个矩阵的大小必须为 <code>V × W</code>。这就是数学上规定的。</p><p>结果是大小为 <code>U × W</code> 的新矩阵。如果矩阵的大小不匹配这种特定的方式，我们就不能将它们相乘。</p><p>例如，以下将工作正常：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>(rows: <span class="number">4</span>, columns: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>(rows: <span class="number">3</span>, columns: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">C</span> = multiply(<span class="type">A</span>, <span class="type">B</span>)                <span class="comment">// gives a 4×2 matrix</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在数学中，矩阵通常用大写表示，我在这里遵循变量名称的惯例。</p></blockquote><p>由于 <code>A.columns == B.rows</code>，因此可以将 <code>A</code> 与 <code>B</code> 进行乘法。相反地，以下就不是有效的操作：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">D</span> = multiply(<span class="type">B</span>, <span class="type">A</span>)</span><br></pre></td></tr></table></figure><p>矩阵 <code>B</code> 中的列数与矩阵 <code>A</code> 中的行数不匹配。也就是 <code>B.columns！= A.rows</code>。从数学定义来说，矩阵B和A相乘没有任何意义。</p><p>目前，捕捉这些错误的唯一方法是在运行时触发断言：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(m1: Matrix, <span class="number">_</span> m2: Matrix)</span></span> -&gt; <span class="type">Matrix</span> &#123;</span><br><span class="line">  <span class="comment">// do the matrices have the correct sizes?</span></span><br><span class="line">  <span class="built_in">precondition</span>(m1.columns == m2.rows)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// bunch of math...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做当然可以，但我并不喜欢。Swift 静态类型的重点在于编译器可以在编译期间发现尽可能多的编程错误。如果我们可以使编译器也捕获这种错误，这就会很棒。</p><p>事实证明是可以的！在本文中，我将探讨如何使用 Swift 的类型系统来避免这样的错误。</p><h2 id="不太好的实现"><a href="#不太好的实现" class="headerlink" title="不太好的实现"></a>不太好的实现</h2><p>解决这个问题的比较原始的方法是为不同大小的矩阵创建不同的结构体：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix_4x3</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix_3x2</span>()</span><br></pre></td></tr></table></figure><p>但是，还需要一个将这些特定类型作为参数的 <code>multiply()</code> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(m1: Matrix_4x3, <span class="number">_</span> m2: Matrix_3x2)</span></span> -&gt; <span class="type">Matrix_4x2</span></span><br></pre></td></tr></table></figure><p>这似乎有点傻，导致了很多重复的代码。</p><p>更糟糕的是，编译时可能并不知道矩阵的大小。在机器学习问题中，我们经常需要从文件中加载数据集，但并不会提前知道有多少行。</p><p>所以这不是一个可行的解决方案。然而，为不同大小的矩阵声明不同类型的思路还是有希望的…</p><h2 id="通用的解决方案"><a href="#通用的解决方案" class="headerlink" title="通用的解决方案"></a>通用的解决方案</h2><p>我们希望将矩阵的维度以某种方式并入 Matrix 的类型，而不需要任何矩阵代码，如 <code>multiply()</code> 知道其具体大小。</p><p>定义以下 Matrix：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&lt;<span class="title">R</span>,<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rows: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> columns: <span class="type">Int</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它现在有两个通用参数 <code>R</code> 和 <code>C</code>，其中 <code>R</code> 表示行数，<code>C</code> 表示列数。</p><p>我们可以这样定义 <code>multiply()</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span>&lt;U,V,W&gt;<span class="params">(m1: Matrix&lt;U,V&gt;, <span class="number">_</span> m2: Matrix&lt;V,W&gt;)</span></span> -&gt; <span class="type">Matrix</span>&lt;<span class="type">U</span>,<span class="type">W</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// bunch of math...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">Matrix</span>(rows: m1.rows, columns: m2.columns)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意获取矩阵乘法规则的方法：大小为 <code>U × V</code> 的矩阵乘以大小为 <code>V × W</code> 的矩阵，得到 <code>U × W</code> 大小的新矩阵。</p><p>下面是如何使用新的 <code>Matrix</code> 的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumExamples</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumFeatures</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OneDimensional</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;(rows: <span class="number">20</span>, columns: <span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>&lt;<span class="type">NumFeatures</span>, <span class="type">OneDimensional</span>&gt;(rows: <span class="number">10</span>, columns: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>我们创建了三种新的类型 - 名为 <code>NumExamples</code> ，<code>NumFeatures</code> 和 <code>OneDimensional</code> —— 来表示矩阵的可能维数。注意我如何给出这些类型的描述性名称，从而更容易展现出它们的用途。</p><p><code>NumExamples</code> 和 <code>NumFeatures</code> 的名称来自机器学习，因为我将在其中使用这些矩阵。<code>NumExamples</code> 是数据集中的对象数目，<code>NumFeatures</code> 是每个示例的属性数。(当然，如果你要使用这些矩阵来做别的事情，你可以使用不同的名字。）</p><p><code>OneDimensional</code> 意指矩阵 <code>B</code> 只有一列。在线性代数中，我们称之为列向量而不是矩阵。为了使我们的代码更清晰，如果我们可以这样写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">ColumnVector</span>&lt;<span class="type">Rows</span>&gt; = <span class="type">Matrix</span>&lt;<span class="type">Rows</span>, <span class="type">OneDimensional</span>&gt;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">RowVector</span>&lt;<span class="type">Columns</span>&gt; = <span class="type">Matrix</span>&lt;<span class="type">OneDimensional</span>, <span class="type">Columns</span>&gt;</span><br></pre></td></tr></table></figure><p>类型别名会将 <code>ColumnVector</code> 和 <code>RowVector</code> 标记成 <code>Matrix</code> 的特殊情况。但不幸的是，Swift 2.2 中不支持这种语法。即将发布(<strong>原文日期=2016/03/25</strong>)的 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md" target="_blank" rel="noopener">Swift 3.0</a> 中可能会支持。</p><p>不管怎样让我们回到本例中。当你写下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">C</span> = multiply(<span class="type">A</span>, <span class="type">B</span>)</span><br></pre></td></tr></table></figure><p>它便会按照预期给出了一个新的 20×1矩阵。然而，与之前不同的是，无效的乘法尝试会导致编译器错误：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">D</span> = multiply(<span class="type">B</span>, <span class="type">A</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: cannot convert value of type 'Matrix&lt;NumFeatures, OneDimensional&gt;'</span></span><br><span class="line"><span class="comment">// to expected argument type 'Matrix&lt;_, _&gt;'</span></span><br></pre></td></tr></table></figure><p>错误消息有点模糊，但是使用 Swift 的类型系统来捕获这种错误是极好的。而不是在运行时崩溃应用程序，现在不可能将两个不具有正确维度的矩阵相乘。现在已经实现禁止将两个不具有正确维度的矩阵相乘，避免了在运行时崩溃。</p><p>果真如此么？我们仍然可以骗过编译器：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;(rows: <span class="number">20</span>, columns: <span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>&lt;<span class="type">NumFeatures</span>, <span class="type">OneDimensional</span>&gt;(rows: <span class="number">500</span>, columns: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>通过将 <code>B</code> 的行数改为 500，我们仍然处于与之前相同的情况。现在 <code>multiply(A, B)</code> 不再有效。</p><p>只有这些额外的类型是不够的…我们需要确保类型 <code>NumFeatures</code> 无论它在哪里使用，总会以某种方式引用相同的数字。</p><h2 id="使用协议弥补"><a href="#使用协议弥补" class="headerlink" title="使用协议弥补"></a>使用协议弥补</h2><p>我们可以像这样做：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumExamples</span> </span>&#123; <span class="keyword">let</span> size = <span class="number">20</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumFeatures</span> </span>&#123; <span class="keyword">let</span> size = <span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure><p>但是运行时这些维度的大小便被固定了。请记住，我们希望能够在运行时设置矩阵大小，例如通过从文件读取数据集——而且我们可能不知道该文件中有多少数据。对矩阵大小进行硬编码不是一种好办法。</p><p>相反，让我们定义一个新协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Dimension</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> size: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是 <code>Matrix</code> 变成了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&lt;<span class="title">R</span>: <span class="title">Dimension</span>, <span class="title">C</span>: <span class="title">Dimension</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rows: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> columns: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">self</span>.rows = <span class="type">R</span>.size</span><br><span class="line">    <span class="keyword">self</span>.columns = <span class="type">C</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>init(rows:columns:)</code> 方法已经被去掉。矩阵的大小直接由泛型 <code>R</code> 和 <code>C</code> 决定。</p><p>最后一步是使我们的维度类型符合新协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumExamples</span>: <span class="title">Dimension</span> </span>&#123; <span class="keyword">static</span> <span class="keyword">var</span> size = <span class="number">20</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumFeatures</span>: <span class="title">Dimension</span> </span>&#123; <span class="keyword">static</span> <span class="keyword">var</span> size = <span class="number">10</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OneDimensional</span>: <span class="title">Dimension</span> </span>&#123; <span class="keyword">static</span> <span class="keyword">var</span> size = <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>然后可以如下实现 <code>multiply()</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span>&lt;U: Dimension, V: Dimension, W: Dimension&gt;</span></span><br><span class="line"><span class="function">             <span class="params">(m1: Matrix&lt;U,V&gt;, <span class="number">_</span> m2: Matrix&lt;V,W&gt;)</span></span> -&gt; <span class="type">Matrix</span>&lt;<span class="type">U</span>,<span class="type">W</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// bunch of math...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">Matrix</span>&lt;<span class="type">U</span>,<span class="type">W</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，矩阵 m1 和 m2 不可能不匹配。编译器根本不会接受这种情况。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>&lt;<span class="type">NumFeatures</span>, <span class="type">OneDimensional</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">C</span> = multiply(<span class="type">A</span>, <span class="type">B</span>)   <span class="comment">// yay!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">D</span> = multiply(<span class="type">B</span>, <span class="type">A</span>)   <span class="comment">// compiler error</span></span><br></pre></td></tr></table></figure><p>这样就不会出现无意的错误。当然，你仍然可以通过这样做来欺骗系统：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;()</span><br><span class="line"><span class="type">NumFeatures</span>.size = <span class="number">500</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>&lt;<span class="type">NumFeatures</span>, <span class="type">OneDimensional</span>&gt;()</span><br></pre></td></tr></table></figure><p>即便 Swift 的类型系统也无法阻止出于恶意的行为。（也许在 <code>multiply()</code> 中保留 <code>precondition()</code> 是明智的。）</p><p>顺便说一句，你实际上需要有改变 <code>NumFeatures.size</code> 的能力。但你使用时应该多加小心。正如直到我们运行该程序才能知道它特定大小，它也没有理由会一直保持不变。例如，你可能需要使用相同的流程来处理不同大小的多个数据集。</p><p>当然，你可以使用矩阵来做更多事情，而不仅仅是乘以它们。以下是这些维度类型用处的另一个示例：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processData</span>&lt;M: Dimension, N: Dimension&gt;</span></span><br><span class="line"><span class="function">                <span class="params">(X: Matrix&lt;M, N&gt;, <span class="number">_</span> y: Matrix&lt;M, OneDimensional&gt;)</span></span> </span><br><span class="line">                -&gt; <span class="type">Matrix</span>&lt;<span class="type">OneDimensional</span>, <span class="type">N</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// do impressive stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">X</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> y = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">OneDimensional</span>&gt;()</span><br><span class="line">processData(<span class="type">X</span>, y)</span><br></pre></td></tr></table></figure><p>该函数采用矩阵 <code>X</code> 和列向量 <code>y</code> ，并对它们进行一些处理。例如，可能会训练学习系统。这里的约束是 <code>X</code> 和 <code>y</code> 必须具有相同的行数。多亏了我们的维度类型，编译器可以强制执行该约束。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们使用类型来更好地告诉编译器我们的程序正在做什么。这有助于编译器捕获错误。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：MATTHIJS HOLLEMANS，&lt;a href=&quot;http://machinethink.net/blog/using-types-to-keep-yourself-honest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-03-25&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;TonyHan&lt;/a&gt;；校对：&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;这篇文章展示了如何利用 Swift 的类型系统来使你的程序更具表现力和健壮性。&lt;/p&gt;
&lt;p&gt;在最近一周左右的时间里，我一直在倒腾 Swift 的机器学习算法。我们可以通过使用矩阵来简洁有效地实现这些算法。&lt;/p&gt;
&lt;p&gt;如果你忘记了线性代数，那只需将矩阵看作数字表格。&lt;/p&gt;
&lt;p&gt;当提到 “M 是一个 4 乘 3 的矩阵”，意思是指 M 是一个 4 行 3 列的数字表格。关于矩阵你就需要了解这些（译者注:即可将其看作是表格），就可以理解本文后面的讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="machinethink" scheme="https://swift.gg/categories/machinethink/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的强制编译时报错</title>
    <link href="https://swift.gg/2018/06/25/forcing-compiler-errors-in-swift/"/>
    <id>https://swift.gg/2018/06/25/forcing-compiler-errors-in-swift/</id>
    <published>2018-06-25T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Erica Sadun，<a href="https://ericasadun.com/2018/04/18/forcing-compiler-errors-in-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-18<br>译者：<a href="http://wuqiuhao.github.io" target="_blank" rel="noopener">Hale</a>；校对：<a href="undefined">梁杰</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>得益于<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0196-diagnostic-directives.md" target="_blank" rel="noopener">SE-0196</a>，Swift 4.2 将引进 <code>#warning()</code> 和 <code>#error()</code> 两个编译指令。这两个指令允许你在编译期间合并诊断消息和抛出错误。下面这个例子来自已被确定接受的提议并且已经被实施。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#warning(<span class="string">"this is incomplete"</span>)</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> <span class="type">MY_BUILD_CONFIG</span> &amp;&amp; <span class="type">MY_OTHER_BUILD_CONFIG</span></span><br><span class="line">  #error(<span class="string">"MY_BUILD_CONFIG and MY_OTHER_BUILD_CONFIG cannot both be set"</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><code>#error</code> 指令的例子使用条件编译标志（用-D选项设置）来检察编译是否产生了配置冲突。</p><p>我(原文作者)已经写了很多关于我不喜欢在Swift中使用蛇形命名法（THINGS_LIKE_THIS）的文章。但不可避免的，开发者们都喜欢使用蛇形命名法则来定义条件编译标志。无论是 <code>MY_BUILD_CONFIG</code> 、 <code>MY_OTHER_BUILD_CONFIG</code> 还是 <code>DEBUG</code> 。虽然这是行业标准，但感觉这和Swift的美学存在冲突。</p><p>我也写过关于如何不显示使用 <code>DEBUG</code> 标志来<a href="https://ericasadun.com/2018/04/15/writing-swift-adventures-in-compiler-mods/" target="_blank" rel="noopener">检测调试条件的提议</a>。这边我附上了提议的链接，你们可以点击查看更多该提议的相关内容。</p><p>言归正传，Swift新近提出的 <code>#error</code> 和 <code>#warning</code> 指令，在当前的实践基础上有了很大进步。它们通常依赖于运行时的反馈而非编译时。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> !<span class="type">DEBUG</span></span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">"This code is incomplete. Please fix before release."</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>这个代码块中的缩进样式是 Swift 默认的，主要是为了避免条件编译块中出现轻微的<a href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming" target="_blank" rel="noopener">Pyramid of doom</a>)(金字塔厄运)。但如果把里面的代码缩进，在这个条件块的周围代码还是纵向增长的，主观上感觉有点丑。为了避免这种情况，一些编码人员采用内联方式，用最少的条件块和更简洁的方法强制编译时（而不是运行时）报错。</p><p>以下是我从 John Estropia 那发现的一个例子（他借鉴于他的同事）。他使用条件编译指令来设置 <code>TODO</code> 或 <code>FIXME</code> 等类型别名，然后在需要的地方使用它们。在 debug 环境时，编译能够通过而在 release 环境下编译就会报错：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span> </span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">typealias</span> <span class="type">TODO</span>&lt;<span class="type">T</span>&gt; = <span class="type">T</span></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Remove this later"</span>) <span class="keyword">as</span> <span class="type">TODO</span></span><br></pre></td></tr></table></figure><p>这个主意很棒。<code>TODO</code> 类型别名将支持 debug 过程中在想要注释的行末尾使用 <code>as TODO</code> ，在 release 编译环境下就会抛出异常。这确保了所有用 <code>TODO</code> 标注的点能够实现编译时反馈。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">error: <span class="type">ManyWays</span>.playground:<span class="number">5</span>:<span class="number">31</span>: error: use of undeclared type '<span class="type">TODO'</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Remove this later"</span>) <span class="keyword">as</span> <span class="type">TODO</span></span><br></pre></td></tr></table></figure><p>虽然不是很美观，但这很有效。它包含了关于代码调用的位置信息和你要发送的信息。如果我正在使用这个方法，我可能会创建一个 <code>todo</code> 方法，而不是直接使用上面的方法。在下面的例子中，我使用驼峰式命名使调用看起来更具有指令性，而不像标准的全局函数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">enum</span> <span class="title">IssueLevel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">    mildImportance,</span><br><span class="line">    moderateImportance,</span><br><span class="line">    highImportance,</span><br><span class="line">    criticalImportance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">ToDo</span><span class="params">(<span class="number">_</span> level: IssueLevel, <span class="number">_</span> string: String)</span></span> &#123;&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供编译错误、描述信息和优先级</span></span><br><span class="line"><span class="type">ToDo</span>(.highImportance, <span class="string">"Remove this later"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: ManyWays.playground:13:1: error: use of unresolved identifier 'ToDo'</span></span><br><span class="line"><span class="comment">// ToDo(.highImportance, "Remove this later")</span></span><br></pre></td></tr></table></figure><p>这种方式最大的好处就是从 debug 环境到 release 环境，只需通过 <code>#if</code> 进行判断。这种做法很诱人，只要确保全局都在需要标注的地方使用，然后在切换到 release 之前解决或移除所有的标注即可。</p><p>目前，Swift 不支持用 <code>#message</code> 指令来执行类似的任务。很多开发者将警告视为错误，他们无法在两者之间进行细微的区分。如果 <code>#warning</code> 被发布了，你就可以使用 <code>#warning</code> 实现类似“fix me”的反馈了。进一步改良的话，<code>#messageOrDie</code> （或者其他叫法，命名真的很难）可以在 debug build 时发送警告消息，在 release build 时报出错误，通过 <code>断言</code> 来判断申明是否发生。</p><p>Dave DeLong 为结构性项目语义提供了另一种方法。他介绍了一个 <code>Fatal</code> 类型为开发中一些比较常见的结果判断例如 <code>noImplemented</code>、<code>unreachable</code> 和 <code>mustOverride</code> 等提供<a href="https://forums.swift.org/t/introducing-namespacing-for-common-swift-error-scenarios/10773" target="_blank" rel="noopener">运行时线索</a>,它没有用“you need to remember to implement this”这样的提示，而是以运行时奔溃的形式，通过上报完整的位置和方法信息来解释。另一个检索被命名为 <code>silenceXcode()</code> 允许你添加你认为永远不会实现的一些方法，如果你使用了它也会报错。</p><p>Swift 仍有很大的空间来扩展这方面的支持。我不介意看到这两种方式都被添加到未来 Swift 的实现中。一种用于编译时（像 <code>#messageOrDie</code> ）另一种用于运行时（像 <code>Fatal</code> 命名空间的静态检索方法）</p><p>你们怎么看待这些？在 Swift 中还有哪些部分是元编程开发过程中（像宏）让你感到困惑的？我很想知道还有哪些已经确定发布的特性能够更好地支持开发。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了Swift4.2即将发布的
    
    </summary>
    
      <category term="iAchieved.it" scheme="https://swift.gg/categories/iAchieved-it/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>重新实现可选类型的隐式解包</title>
    <link href="https://swift.gg/2018/06/19/swift-org-blog-iuo/"/>
    <id>https://swift.gg/2018/06/19/swift-org-blog-iuo/</id>
    <published>2018-06-19T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mark Lacey，<a href="https://swift.org/blog/iuo/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-26<br>译者：<a href="undefined">灰s</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="undefined"> mmoaay</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>今年早些时候，Swift 编译器实现了一种新的可选类型隐式解包 (IUOs)，在最近的 Swift <a href="https://swift.org/download/#snapshots" target="_blank" rel="noopener">测试版本</a> 中开放使用。它实现了 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md" target="_blank" rel="noopener"> SE-0054 - Abolish ImplicitlyUnwrappedOptional Type</a>。对于 Swift 来说，这是一次重大的改变，消除了类型检测中的一些矛盾，并且阐明了处理这些值的规则，使语义保持一致且易于推理。更多信息可以阅读这条提案的 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md#motivation" target="_blank" rel="noopener">动机</a>。</p><p>主要变化是，当引用一个被声明为隐式解包可选的基础类型 <code>T</code> 时，在诊断信息中会打印 <code>T?</code>，而不是之前的 <code>T!</code>。你可能会遇到源代码兼容性问题，需要修改代码之后才能编译成功。</p><a id="more"></a><h2 id="隐式解包是声明的一部分"><a href="#隐式解包是声明的一部分" class="headerlink" title="隐式解包是声明的一部分"></a>隐式解包是声明的一部分</h2><p><em>可选类型的隐式解包</em> 在编译时会根据需要自动解包。要声明一个可选类型的隐式解包，需要将类型后面的 <code>?</code> 改成 <code>!</code>。  </p><p>在很多人的认知中，隐式解包的可选类型与常规可选类型并不属于同一个类别。在 Swift 3 中，它们也确实不一样：像 <code>var a: Int?</code>  这样的声明，会创建一个拥有 <code>Optional&lt;Int&gt;</code> 类型的 <code>a</code>；像 <code>var b: String!</code>  这样的声明，会创建一个拥有 <code>ImplicitlyUnwrappedOptional&lt;String&gt;</code> 类型的 <code>b</code> 。  </p><p>在 IUOs 的新模型中，你需要将 <code>!</code> 视为 <code>?</code> 的同义词，它只是在声明中添加一个标志让编译器知道被声明的值可以进行隐式解包。  </p><p>换句话说，对于 <code>String!</code> 的理解你可以认为是 “这个值拥有 <code>Optional&lt;String&gt;</code> 类型并且携带了信息说在需要的时候它可以被隐式的解包。”  </p><p>这种思维模型与新的实现相匹配。现在，任何地方你申明了 <code>T!</code> ，编译器都会将它看做 <code>T?</code> 类型，然后在申明的内部表示中添加一个标签使得类型检测器知道当需要的时候可以对它进行隐式解包。  </p><p>这一变化最明显的结果就是对于申明为 <code>T!</code> 的变量，你将看到关于 <code>T?</code> 的诊断而不是 <code>T!</code>。 在诊断中看到 <code>T?</code> 而不是 <code>T!</code> 可能需要一点时间去适应它，但是拥抱这一新的思维模型将会一直帮助你。</p><p><strong>为了便于理解，译者自己做了配图，展示新旧 Swift 的区别：</strong>  </p><p><img src="/img/articles/swift-org-blog-iuo/40166397-082f067e-59f1-11e8-931a-3d3d0cb892eb.png1529377151.6054707" alt="old"><br><img src="/img/articles/swift-org-blog-iuo/40166527-52d1029a-59f1-11e8-94f2-44d9dc1660ce.png1529377151.9917665" alt="new"></p><h2 id="源代码兼容性"><a href="#源代码兼容性" class="headerlink" title="源代码兼容性"></a>源代码兼容性</h2><h3 id="强制转换为-T"><a href="#强制转换为-T" class="headerlink" title="强制转换为 T!"></a>强制转换为 <code>T!</code></h3><p>按照 SE-0054 提案，<code>as T!</code> 这样的强制转换已经不再被允许。</p><p>在 Swift 4.1 中，这种形式的强制转换会显示一个弃用警告。多数情况下，使用 <code>as T?</code> 来替代 <code>as T!</code> 或者直接移除该强制转换即可编译成功。</p><p>如果这两种方法都不管用，新的实现中也有对应的特殊处理。具体来说，如果遇到 <code>x as T!</code>，编辑器首先会尝试 <code>x as T?</code>。如果失败，编辑器会用 <code>(x as T?)!</code> 来进行强制解包。</p><p>但是，这种形式的强制转换仍然不推荐使用，在将来的 Swift 版本中有可能会移除这种特殊处理。</p><h3 id="在类型中使用"><a href="#在类型中使用" class="headerlink" title="在类型中使用 !"></a>在类型中使用 <code>!</code></h3><p>强制转换为 <code>T!</code> 作为一个特例存在于一个更普遍的问题中：使用 <code>!</code> 作为类型的一部分。  </p><p>可以在下面三个地方使用 <code>!</code> 作为类型中的一部分：</p><pre><code>1. 属性声明2. 方法的参数类型声明3. 方法的返回值类型声明</code></pre><p>在其它地方使用 <code>!</code> 将被标记成一个错误。Swift 4.1 之前的版本就已经实现了这个检测，但是遗漏了一些情况：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn: (<span class="type">Int</span>!) -&gt; <span class="type">Int</span>! = ...   <span class="comment">// error: not a function declaration!</span></span><br></pre></td></tr></table></figure><p>这里 Swift 4.1 显示了弃用警告，但是仍然默认了隐式解包的行为。在近期测试版本的新实现中，编译器会将 <code>!</code> 视为 <code>?</code>，同时在诊断信息中告诉你发生了什么，以及这种用法会被废弃。  </p><p><strong>译者配图：</strong>  </p><p><img src="/img/articles/swift-org-blog-iuo/40213466-2dd070ba-5a88-11e8-888a-0ca5066f4d36.png1529377152.1436236" alt="old-2"><br><img src="/img/articles/swift-org-blog-iuo/40213471-336db9ba-5a88-11e8-9b8e-11287e1bfccd.png1529377152.292037" alt="new-2"></p><h3 id="隐式解包可选类型的-map-方法"><a href="#隐式解包可选类型的-map-方法" class="headerlink" title="隐式解包可选类型的 map 方法"></a>隐式解包可选类型的 map 方法</h3><p>以前的代码是这样的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> values: [<span class="type">Any</span>]! = [<span class="type">C</span>()]</span><br><span class="line"><span class="keyword">let</span> transformed = values.<span class="built_in">map</span> &#123; $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">C</span> &#125;</span><br></pre></td></tr></table></figure><p>上面的代码会对 <code>values</code> 强制解包，然后对数组调用 <code>map(_:)</code> 方法。即使你在 <code>ImplicitlyUnwrappedOptional</code> 的扩展中定义了 <code>map(_:)</code> 方法也无法覆盖默认方法，因为它并不会像你想的那样，在 <code>ImplicitlyUnwrappedOptional</code> 中执行方法查找。  </p><p>在新的实现中，因为 <code>!</code> 和 <code>?</code> 是同义词，编译器会尝试使用 <code>Optional&lt;T&gt;</code> 中的 <code>map(_:)</code> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> transformed = values.<span class="built_in">map</span> &#123; $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">C</span> &#125; <span class="comment">// calls Optional.map; $0 has type [Any]</span></span><br></pre></td></tr></table></figure><p>并且显示： <code>warning: cast from &#39;[Any]&#39; to unrelated type &#39;C&#39; always fails</code>。  </p><p>这样从语义上就通过了类型检测，我们不需要对 <code>values</code> 进行强制解包。  </p><p>你可以使用可选链制造一个可选的数组来解决这个问题：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> transformed = values?.<span class="built_in">map</span> &#123; $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">C</span> &#125; <span class="comment">// transformed 的类型是 Optional&lt;[C]&gt;</span></span><br></pre></td></tr></table></figure><p>或者对 <code>values</code> 进行强制解包来得到一个数组：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> transformed = values!.<span class="built_in">map</span> &#123; $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">C</span> &#125; <span class="comment">// transformed has type [C]</span></span><br></pre></td></tr></table></figure><p>注意，大部分情况下你不需要修改代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values: [<span class="type">Int</span>]! = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> transformed = values.<span class="built_in">map</span> &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>它将继续按照老版本的方式工作，因为在这里将表达式看作 <code>Optional</code> 执行 <code>map(_:)</code> 方法无法进行类型检测。取而代之，我们会对 <code>values</code> 进行强制解包，并对返回的数组执行 <code>map(_:)</code> 方法。</p><h3 id="无法推断类型"><a href="#无法推断类型" class="headerlink" title="无法推断类型"></a>无法推断类型</h3><p>因为隐式解包可选不再是一个类型，所以不能被推断成一种类型或者类型的任何部分。</p><p>在下面的例子中，尽管右边的赋值包含一个被声明为隐式解包的值，左边类型推断仅表示这个值（或者返回值）是一个可选类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">Int</span>!</span><br><span class="line"><span class="keyword">let</span> y = x   <span class="comment">// y has type Int?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forcedResult</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>! &#123; ... &#125;</span><br><span class="line"><span class="keyword">let</span> getValue = forcedResult    <span class="comment">// getValue 的类型是 () -&gt; Int?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">id</span>&lt;T&gt;<span class="params">(<span class="number">_</span> value: T)</span></span> -&gt; <span class="type">T</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line"><span class="keyword">let</span> z = id(x)   <span class="comment">// z 的类型是 Int?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span>&lt;T&gt;<span class="params">(<span class="number">_</span> fn: <span class="params">()</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span> &#123; <span class="keyword">return</span> fn() &#125;</span><br><span class="line"><span class="keyword">let</span> w: <span class="type">Int</span> = apply(forcedResult)    <span class="comment">// 报错，因为 apply() 返回的是 Int?</span></span><br></pre></td></tr></table></figure><p>还有一些特殊的实例会遇到这个问题，比如 <code>AnyObject</code> 的查找操作，<code>try?</code> 和 <code>switch</code>。</p><h4 id="AnyObject-的查找操作"><a href="#AnyObject-的查找操作" class="headerlink" title="AnyObject 的查找操作"></a>AnyObject 的查找操作</h4><p><code>AnyObject</code> 的查找结果会被当作一个隐式解包的可选类型。如果你查找一个本身就被声明成隐式解包的属性，那么表达式现在就有两层隐式解包 ( <code>property</code> 被声明为 <code>UILabel!</code>)：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLabel</span><span class="params">(object: AnyObject)</span></span> -&gt; <span class="type">UILabel</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> object.property <span class="comment">// forces both optionals, resulting in a UILabel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if let</code> 和 <code>guard let</code> 仅能解包一层可选属性。  </p><p>在下面的例子中，之前的 Swift 版本在经过 <code>if let</code> 进行一层解包之后，推测出 <code>label</code> 的属性为 <code>UILabel!</code>。在测试版本中 Swift 将推测出 <code>UILabel?</code> ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// label is inferred to be UILabel?</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> label = object.property &#123; </span><br><span class="line">   <span class="comment">// Error due to passing a UILabel? where a UILabel is expected</span></span><br><span class="line">  functionTakingLabel(label)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用一个明确的类型来修复这个问题：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Implicitly unwrap object.property due to explicit type.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> label: <span class="type">UILabel</span> = object.property &#123;</span><br><span class="line">  functionTakingLabel(label) <span class="comment">// okay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="try"><a href="#try" class="headerlink" title="try?"></a><code>try?</code></h4><p>类似的，<code>try?</code> 会添加一层可选性，所以当对一个返回值为隐式可选类型的方法使用 <code>try?</code> 时，你可能会发现现在需要更改代码来显式对两层可选性进行解包。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span>! &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x = <span class="keyword">try</span>? test() &#123;</span><br><span class="line">  <span class="keyword">let</span> y: <span class="type">Int</span> = x    <span class="comment">// error: x is an Int?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x: <span class="type">Int</span> = <span class="keyword">try</span>? test() &#123; <span class="comment">// explicitly typed as Int</span></span><br><span class="line">  <span class="keyword">let</span> y: <span class="type">Int</span> = x    <span class="comment">// okay, x is an Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x = <span class="keyword">try</span>? test(), <span class="keyword">let</span> y = x &#123; <span class="comment">// okay, x is Int?, y is Int</span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a><code>switch</code></h4><p>Swift 4.1 可以编译下面这样的代码，因为它将 <code>output</code> 作为隐式解包对待：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchExample</span><span class="params">(input: String!)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> input &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"okay"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fine"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> output:</span><br><span class="line">    <span class="keyword">return</span> output  <span class="comment">// 隐式解包可选值，返回 String</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，如果用下面这种方法实现这个例子，无法编译成功：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchExample</span><span class="params">(input: String!)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> output = input  <span class="comment">// output is inferred to be String?</span></span><br><span class="line">  <span class="keyword">switch</span> input &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"okay"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fine"</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> output  <span class="comment">// error: value of optional type 'String?' not unwrapped;</span></span><br><span class="line">                   <span class="comment">// did you mean to use '!' or '?'?</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在新的实现中，第一个例子中的 <code>output</code> 将被推断成没有隐式解包的 <code>String?</code> 类型。  </p><p>下面是一种修复方法，对值进行强制解包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> output:</span><br><span class="line">   <span class="keyword">return</span> output!</span><br></pre></td></tr></table></figure><p>另一种修复方法是对 non-nil 和 nil 进行显式的模式匹配：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchExample</span><span class="params">(input: String!)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> input &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"okay"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fine"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> output?: <span class="comment">// non-nil case</span></span><br><span class="line">    <span class="keyword">return</span> output   <span class="comment">// okay; output is a String</span></span><br><span class="line">  <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;empty&gt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用可选类型和隐式解包可选类型重载输入输出参数"><a href="#使用可选类型和隐式解包可选类型重载输入输出参数" class="headerlink" title="使用可选类型和隐式解包可选类型重载输入输出参数"></a>使用可选类型和隐式解包可选类型重载输入输出参数</h3><p>如果在 Swift 4.1 中尝试去重载一个函数并且 in-out 参数是隐式解包可选类型，会显示一个弃用警告</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someKindOfOptional</span><span class="params">(<span class="number">_</span>: <span class="keyword">inout</span> Int?)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Warning in Swift 4.1.  Error in new implementation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someKindOfOptional</span><span class="params">(<span class="number">_</span>: <span class="keyword">inout</span> Int!)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Swift 4.1 中，如果 in-out 参数是可选的，那可以直接传入一个隐式解包可选类型的值，反之亦然。这样就可以删除上面的第二个重载（假设两个函数实现完全一致）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someKindOfOptional</span><span class="params">(<span class="number">_</span>: <span class="keyword">inout</span> Int?)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span>! = <span class="number">1</span></span><br><span class="line">someKindOfOptional(&amp;i)   <span class="comment">// 完全没问题，i 的类型是 Optional&lt;Int&gt;</span></span><br></pre></td></tr></table></figure><p>在之后的新版本中，由于 <code>Int!</code> 与 <code>Int?</code> 是同义词，重载的可选性不再有意义。因此，和上面例子中类似的重载都会报错，并且第二个重载（声明为 <code>Int!</code>）必须被删除。</p><h3 id="ImplicitlyUnwrappedOptional-扩展"><a href="#ImplicitlyUnwrappedOptional-扩展" class="headerlink" title="ImplicitlyUnwrappedOptional 扩展"></a>ImplicitlyUnwrappedOptional 扩展</h3><p>现在 <code>ImplicitlyUnwrappedOptional&lt;T&gt;</code> 只是 <code>Optional&lt;T&gt;</code> 的别名，而且不能直接使用，所以尝试给它创建 <code>extension</code> 会编译失败：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1:11: error: 'ImplicitlyUnwrappedOptional' has been renamed to 'Optional'</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImplicitlyUnwrappedOptional</span> </span>&#123;</span><br></pre></td></tr></table></figure><h3 id="nil-桥接"><a href="#nil-桥接" class="headerlink" title="nil 桥接"></a>nil 桥接</h3><p>对 <code>nil</code> 类型的值进行桥接时不会报运行时错误，而是把 <code>nil</code> 桥接为 <code>NSNull</code> 。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>: <span class="title">NSObject</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iuoElement: <span class="type">C</span>! = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> array: [<span class="type">Any</span>] = [iuoElement <span class="keyword">as</span> <span class="type">Any</span>]</span><br><span class="line"><span class="keyword">let</span> ns = array <span class="keyword">as</span> <span class="type">NSArray</span></span><br><span class="line"><span class="keyword">let</span> element = ns[<span class="number">0</span>] <span class="comment">// Swift 4.1: Fatal error: Attempt to bridge</span></span><br><span class="line">                    <span class="comment">// an implicitly unwrapped optional containing nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = element <span class="keyword">as</span>? <span class="type">NSNull</span>, value == <span class="type">NSNull</span>() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"pass"</span>)     <span class="comment">// 新版本中会执行到这里</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"fail"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>隐式解包的可选类型已经被重新实现，它们不再是 <code>Optional&lt;T&gt;</code> 的特殊形式。因此，类型检测的一致性将会更好，编译器的特殊情况也会更少。删除这些特殊情况会减少处理声明时的错误数量。  </p><p>导入的 Object-C API 可能会返回隐式解包的值。你可能会发现在声明 <code>@IBOutlet</code> 属性（或者任何初始化之前不会使用的值）时使用隐式解包会更加方便。不过总体来说，隐式解包能不用最好别用，改用 <code>if let</code> 和 <code>guard let</code> 来显式解包。如果确定有值，就用 <code>!</code> 来显式强制解包。</p><h3 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h3><p>如果你对这篇文章有疑问或者想法，可以在 Swift 论坛中参与<a href="https://forums.swift.org/t/swift-org-blog-reimplementation-of-implicitly-unwrapped-optionals/12175" target="_blank" rel="noopener">相关讨论</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      重新实现隐式解包的原因，会碰到问题。
    
    </summary>
    
      <category term="swift.org" scheme="https://swift.gg/categories/swift-org/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 中内存释放的并发问题</title>
    <link href="https://swift.gg/2018/06/11/friday-qa-2015-05-29-concurrent-memory-deallocation-in-the-objective-c-runtime/"/>
    <id>https://swift.gg/2018/06/11/friday-qa-2015-05-29-concurrent-memory-deallocation-in-the-objective-c-runtime/</id>
    <published>2018-06-11T00:00:00.000Z</published>
    <updated>2018-09-18T06:56:59.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-05-29-concurrent-memory-deallocation-in-the-objective-c-runtime.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-06-05<br>译者：<a href="https://github.com/YangGao1991" target="_blank" rel="noopener">阳仔</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://weibo.com/1743643682/profile?topnav=1&amp;wvr=6" target="_blank" rel="noopener">liberalism</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Objective-C Runtime 是绝大多数 Mac 和 iOS 程序代码的核心。Runtime 的核心就是 <code>objc_msgSend</code> 函数，这个函数最关键的就是方法缓存。我在这篇文章中将会阐述一下，Apple 是如何在不影响性能的情况下，以线程安全的方式来重新分配缓存大小、释放方法缓存。</p><a id="more"></a><h3 id="消息传递的概念"><a href="#消息传递的概念" class="headerlink" title="消息传递的概念"></a>消息传递的概念</h3><p><code>objc_msgSend</code> 会查找被调用的方法的实现，然后去执行。从概念上讲，查找方法的过程如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IMP lookUp(id obj, SEL selector) &#123;</span><br><span class="line">    Class c = object_getClass(obj);</span><br><span class="line"></span><br><span class="line">    while(c) &#123;</span><br><span class="line">        for(int i = 0; i &lt; c-&gt;numMethods; i++) &#123;</span><br><span class="line">            Method m = c-&gt;methods[i];</span><br><span class="line">            if(m.selector == selector) &#123;</span><br><span class="line">                return m.imp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c = c-&gt;superclass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _objc_msgForward;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到源码的版权，一些变量名做了修改。如果你想看看真实的实现代码，可以查看 Objective-C runtime 的<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">开源代码</a>。</p><h3 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h3><p>绝大部分 Objective-C 的代码都用到了消息传递。如果每一次消息传递都需要进行一次完整查找的话，速度将会非常慢。</p><p>解决方法是建立方法的缓存。每个类持有一个哈希表，将方法名映射到方法的实现。这个哈希表需要尽可能地提高读取效率，<code>objc_msgSend</code> 函数使用精心构造的汇编代码来快速实现这个哈希表的查询。这样，在有缓存的情况下，一条消息的传递只需要几纳秒的时间。虽然每条消息第一次被传递的时候还是很慢，但这之后，就会变得很快。</p><p>我们所说的“缓存”，通常来说是指为了加快多次访问最近使用过的资源的速度，而开辟的一块有限大小的区域。例如，你可能会把从网络上下载的图片缓存起来，那么接下来的一段时间，如果再需要使用到这些图片的话，就不需要再去从网络下载了。尽管如此，你也不会希望缓存占用太多的内存空间。所以你可能会限制缓存图片的最大数量。当缓存的图片达到最大数量后，每次缓存新的图片，就会把最旧的那个从缓存中去掉。</p><p>这对于大部分问题来说是一个不错的做法，但它也可能导致性能上的损耗。比如，你设定图片缓存最多缓存 40 张图片，但在某种情况下，你的应用需要一直循环使用 41 张图片，这时你会发现缓存完全不起作用！</p><p>对于我们自己的应用，可以通过测试，调整缓存的大小来避免出现这种情况，但 Objective-C 的 runtime 并不能这样做。方法缓存对性能来说非常重要，并且每个方法的缓存占用的空间都很小，因此，runtime 并不会对缓存空间的大小进行限制，而是会在需要时随时扩大缓存空间，来缓存所有发送过的消息。</p><p>请注意，runtime 的方法缓存有时确实是会刷新的。比如当将新的代码加载到进程时，或者修改了一个类的方法列表时，可能会导致某些缓存的数据失效。这时，相应的旧的缓存数据就会被删除，并重新写入新的缓存数据。</p><h3 id="改变缓存大小，销毁，以及线程问题"><a href="#改变缓存大小，销毁，以及线程问题" class="headerlink" title="改变缓存大小，销毁，以及线程问题"></a>改变缓存大小，销毁，以及线程问题</h3><p>改变缓存大小，从概念上来说比较简单，比如这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *newCache = <span class="built_in">malloc</span>(newSize);</span><br><span class="line">copyEntries(newCache, class-&gt;cache);</span><br><span class="line"><span class="built_in">free</span>(class-&gt;cache);</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">newCache</span>;</span></span><br></pre></td></tr></table></figure><p>实际上，Objective-C runtime 在这个基础上又对代码进行了精简：旧的缓存数据并没有被复制到新的缓存空间中！毕竟，这只是一块缓存空间而已，并没有要求一定要保留其中的数据。在消息发送的时候，新的数据自然又会被缓存下来。因此，事实上，代码是这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(class-&gt;cache);</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br></pre></td></tr></table></figure><p>如果只讲单线程，需要做的就是这么多了，这篇文章到这也可以结束了。但是，Objective-C runtime 肯定要支持多线程操作，这就意味着所有的代码必须保证线程安全。每一个类的缓存数据都可能会被多个线程同时操作，因此，这里的代码必须谨慎处理，才能满足线程安全的条件。</p><p>像上面的写法自然不行。在释放了旧的缓存空间，并且还没有正确赋值新开辟的空间的这段“窗口时间”中，另一个线程就可能访问到非法的地址，这会导致其访问到垃圾数据。此外，如果那块内存没有进行映射的话，就会造成闪退。</p><p>我们如何解决这个问题？典型的做法是使用线程锁，就像这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lock(class-&gt;lock);</span><br><span class="line"><span class="built_in">free</span>(class-&gt;cache);</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line">unlock(class-&gt;lock);</span><br></pre></td></tr></table></figure><p>所有访问都必须由锁控制，包括读操作。这样就意味着，<code>objc_msgSend</code> 方法可能需要获取线程锁，访问缓存空间，然后释放锁。考虑到缓存的查找本身只会占用几纳秒的时间，每次获取、释放锁会增加很多时间的损耗，对性能的影响太大了。</p><p>我们也可以尝试用另外的方法去解决“窗口时间”，比如先分配和赋值新的内存空间，再销毁旧的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line"><span class="built_in">free</span>(oldCache);</span><br></pre></td></tr></table></figure><p>这也许有点用，但并没有解决问题。另一个线程也可能先获取到旧缓存的指针，然后在访问内存前被系统中断。然后，旧的缓存被销毁后，另外的线程又重新启动，这就导致了和前面一样的问题。</p><p>如果我们加一个延迟呢？比如说：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line">after(<span class="number">5</span> <span class="comment">/* seconds */</span>, ^&#123;</span><br><span class="line">    <span class="built_in">free</span>(oldCache);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这似乎是可行的，但还是可以想到一种情况，就是一个线程刚好被中断足够久，以至于五秒的延迟结束了才重新启动。虽然这样的情况及其罕见，但并不是毫无可能。</p><p>如果不是设置一个固定的延迟时间，而是确定等到“窗口时间”结束呢。我们可以给 <code>objc_msgSend</code> 函数增加一个计数器，就像这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gInMsgSend++;</span><br><span class="line">lookUpCache(class-&gt;cache);</span><br><span class="line">gInMsgSend--;</span><br></pre></td></tr></table></figure><p>正确的线程安全的做法需要对计数器使用原子性，以及使用内存屏障，来保证互相依赖的缓存的读取/存储正确进行。这里我们假设计数器已经满足这些条件。</p><p>有了计数器，重新分配缓存的代码就会像这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line"><span class="keyword">while</span>(gInMsgSend)</span><br><span class="line">    ; <span class="comment">// spin</span></span><br><span class="line"><span class="built_in">free</span>(oldCache);</span><br></pre></td></tr></table></figure><p>注意，我们并不需要阻塞 <code>objc_msgSend</code> 执行，就能让这段代码正确工作。在给缓存的指针重新赋值后，一旦某一时刻，确认没有方法在调用 <code>objc_msgSend</code> 了，就可以将旧的缓存空间释放。另一个线程有可能会在旧缓存空间被释放的时候调用 <code>objc_msgSend</code> ，但这个新的调用不会访问到旧的缓存的指针，因此是安全的。</p><p>然而，轮询操作效率较低，且不优雅。事实上，释放旧的缓存空间并不是十分要紧的一件事。内存能够正确释放当然是好的，但晚点再释放也没有什么大不了的。因此，我们可以不使用轮询，而是持有一份未释放的缓存的记录表。每次需要释放缓存时，就清空所有待释放的缓存：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line"></span><br><span class="line">append(gOldCachesList, oldCache);</span><br><span class="line"><span class="keyword">if</span>(!gInMsgSend) &#123;</span><br><span class="line">    <span class="keyword">for</span>(cache in gOldCachesList) &#123;</span><br><span class="line">        <span class="built_in">free</span>(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    gOldCachesList.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一条消息正在传递的话，那这里并不会立刻清空旧的缓存。但没关系，当下次时机来临时，比如消息传递结束或未来的某个时间点，这些过期的缓存都会被清空。</p><p>这个版本已经很接近 Objective-C runtime 的源码了。</p><h3 id="零消耗的标志位"><a href="#零消耗的标志位" class="headerlink" title="零消耗的标志位"></a>零消耗的标志位</h3><p>消息传递中的两部分存在着明显的不同。<code>objc_msgSend</code> 可能每秒钟需要运行数百万次，因此速度必须足够快，最好单次调用只消耗几纳秒的时间。然而，重新分配缓存却是个比较不频繁的操作，而且随着应用的持续运行，该操作也会变得越来越少。一旦应用达到一个稳定状态，不再加载新的代码，不再修改消息列表，这时缓存也就达到了它们所需的最大容量，再也不需要重新分配缓存了。在这之前，可能会发生成百上千次的缓存的重新分配，但相比于 <code>objc_msgSend</code> 来说，调用次数还是很少，因此对性能的要求也很低。</p><p>因此，应当尽可能少的去干预消息传递的过程，尽管这样会让缓存释放的过程变慢。如果在 <code>objc_msgSend</code> 阶段能减少一个 CPU 周期，那么即使每次缓存释放操作都会消耗一百万个 CPU 周期，那也能极大提高效率。</p><p>这么说来，哪怕设置一个全局的计数器，性能损耗的代价还是太高。那意味着 <code>objc_msgSend</code> 过程中需要增加两次内存访问，从而增加很多性能开销。而需要使用原子性以及内存屏障只会让这变得更糟。幸运的是，Objective-C runtime 能够将 <code>objc_msgSend</code> 的性能损耗降到零，代价是会让缓存释放的过程变得慢很多。</p><p>在上面的代码中，我们设置全局计数器的目的是追踪是否有线程处于消息传递的过程中。事实上，线程本身知道自己正在运行什么代码：程序计数器。这是一个记录当前指令的内存地址的 CPU 寄存器。我们可以用它来代替全局的计数器，来检查每个线程是否处于 <code>objc_msgSend</code> 当中。如果所有线程都不处于 <code>objc_msgSend</code> 中，那么旧的缓存就可以被安全释放。这种方法的实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ThreadsInMsgSend</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(thread in GetAllThreads()) &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> pc = thread.GetPC();</span><br><span class="line">        <span class="keyword">if</span>(pc &gt;= objc_msgSend_startAddress &amp;&amp; pc &lt;= objc_msgSend_endAddress) &#123;</span><br><span class="line">            <span class="keyword">return</span> YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bucket_t</span> *oldCache = class-&gt;cache;</span><br><span class="line"><span class="class"><span class="keyword">class</span>-&gt;<span class="title">cache</span> = <span class="title">malloc</span>(<span class="title">newSize</span>);</span></span><br><span class="line"></span><br><span class="line">append(gOldCachesList, oldCache);</span><br><span class="line"><span class="keyword">if</span>(!ThreadsInMsgSend()) &#123;</span><br><span class="line">    <span class="keyword">for</span>(cache in gOldCachesList) &#123;</span><br><span class="line">        <span class="built_in">free</span>(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    gOldCachesList.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objc_msgSend</code> 并不需要额外做任何事情，它可以不用考虑设置标志位，直接访问缓存：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lookUpCache(class-&gt;cache);</span><br></pre></td></tr></table></figure><p>缓存释放的代码效率很低，因为它需要检查进程中所有线程的状态。但这样 <code>objc_msgSend</code> 可以做到与单线程环境中同样高的效率，这是一个值得付出的代价。这就是 Apple 的 runtime 源码实现方式。</p><h3 id="真实代码"><a href="#真实代码" class="headerlink" title="真实代码"></a>真实代码</h3><p>具体的实现可以查看 runtime 源码 <a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-cache.mm" target="_blank" rel="noopener">objc-cache.mm</a> 中的 <code>_collecting_in_critical</code> 函数。</p><p>需要使用程序计数器的入口和出口位置被储存在全局变量中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OBJC_EXPORT <span class="keyword">uintptr_t</span> objc_entryPoints[];</span><br><span class="line">OBJC_EXPORT <span class="keyword">uintptr_t</span> objc_exitPoints[];</span><br></pre></td></tr></table></figure><p>事实上，<code>objc_msgSend</code> 有多种实现方式（比如返回 struct 类型），内部的 <code>cache_getImp</code> 也会直接访问缓存。这些都需要在缓存释放的时候被检查。</p><p><code>_collecting_in_critical</code> 函数没有入参，返回一个 <code>int</code> 类型，被当做一个布尔类型的标志位，指明是否有线程处于关键的函数中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _collecting_in_critical(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>我会跳过该函数中不重要的部分，只介绍最关键的部分。如果你想阅读完整代码，可以查看 <a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-cache.mm" target="_blank" rel="noopener">opensource.apple.com</a>。</p><p>获取线程信息的 API 处于 mach 层。<code>task_threads</code> 能够获取到指定任务（进程在 mach 中的表示）中的所有线程，这里用它来获取当前进程中的线程：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret = task_threads(mach_task_self(), &amp;threads, &amp;number);</span><br></pre></td></tr></table></figure><p>函数会在 <code>threads</code> 中保存 <code>thread_t</code> 数组，在 <code>number</code> 中保存线程的数量。然后会遍历所有线程：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; number; count++)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>获取一个线程的程序计数器是在另外一个单独的函数中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pc = _get_pc_for_thread (threads[count]);</span><br></pre></td></tr></table></figure><p>然后，程序会遍历所有的入口和出口，并逐个进行判断：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (region = <span class="number">0</span>; objc_entryPoints[region] != <span class="number">0</span>; region++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pc &gt;= objc_entryPoints[region]) &amp;&amp;</span><br><span class="line">            (pc &lt;= objc_exitPoints[region])) </span><br><span class="line">        &#123;</span><br><span class="line">            result = TRUE;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历结束后，将结果返回给调用者：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_get_pc_for_thread</code> 函数是怎么工作的呢？它只是简单地调用 <code>thread_get_state</code> 函数来获得目标线程的寄存器状态。之所以要放到一个单独的函数中，是因为寄存器状态的结构体是与具体架构相关的，不同架构都有不同的寄存器。也就是说，这个函数需要对每个支持的架构有一套单独的实现，尽管这些实现差别不大。下面是 x86-64 下的实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> _get_pc_for_thread(<span class="keyword">thread_t</span> thread)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">x86_thread_state64_t</span>            state;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = x86_THREAD_STATE64_COUNT;</span><br><span class="line">    <span class="keyword">kern_return_t</span> okay = thread_get_state (thread, x86_THREAD_STATE64, (<span class="keyword">thread_state_t</span>)&amp;state, &amp;count);</span><br><span class="line">    <span class="keyword">return</span> (okay == KERN_SUCCESS) ? state.__rip : PC_SENTINEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rip 是 x86-64 下程序计数器的寄存器名字。“R”代表“register”，“IP”代表“instruction pointer”。</p><p>上面所说的入口和出口的代码位置，与其函数一同定义在汇编文件中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.private_extern _objc_entryPoints</span><br><span class="line">_objc_entryPoints:</span><br><span class="line">    .quad   _cache_getImp</span><br><span class="line">    .quad   _objc_msgSend</span><br><span class="line">    .quad   _objc_msgSend_fpret</span><br><span class="line">    .quad   _objc_msgSend_fp2ret</span><br><span class="line">    .quad   _objc_msgSend_stret</span><br><span class="line">    .quad   _objc_msgSendSuper</span><br><span class="line">    .quad   _objc_msgSendSuper_stret</span><br><span class="line">    .quad   _objc_msgSendSuper2</span><br><span class="line">    .quad   _objc_msgSendSuper2_stret</span><br><span class="line">    .quad   <span class="number">0</span></span><br><span class="line"></span><br><span class="line">.private_extern _objc_exitPoints</span><br><span class="line">_objc_exitPoints:</span><br><span class="line">    .quad   LExit_cache_getImp</span><br><span class="line">    .quad   LExit_objc_msgSend</span><br><span class="line">    .quad   LExit_objc_msgSend_fpret</span><br><span class="line">    .quad   LExit_objc_msgSend_fp2ret</span><br><span class="line">    .quad   LExit_objc_msgSend_stret</span><br><span class="line">    .quad   LExit_objc_msgSendSuper</span><br><span class="line">    .quad   LExit_objc_msgSendSuper_stret</span><br><span class="line">    .quad   LExit_objc_msgSendSuper2</span><br><span class="line">    .quad   LExit_objc_msgSendSuper2_stret</span><br><span class="line">    .quad   <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>_collecting_in_critical</code> 的用法和上面我们假设的例子很相似。它在释放缓存之前被调用。事实上，runtime 有两种工作模式：一种是如果其他线程正在调用相关函数的话，就把垃圾内存的清理工作留到下一次调用；另一种是一直轮询，直到确认没有线程正在调用，然后再进行销毁：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Synchronize collection with objc_msgSend and other cache readers</span></span><br><span class="line"><span class="keyword">if</span> (!collectALot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_collecting_in_critical ()) &#123;</span><br><span class="line">        <span class="comment">// objc_msgSend (or other cache reader) is currently looking in</span></span><br><span class="line">        <span class="comment">// the cache and might still be using some garbage.</span></span><br><span class="line">        <span class="keyword">if</span> (PrintCaches) &#123;</span><br><span class="line">            _objc_inform (<span class="string">"CACHES: not collecting; "</span></span><br><span class="line">                          <span class="string">"objc_msgSend in progress"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No excuses.</span></span><br><span class="line">    <span class="keyword">while</span> (_collecting_in_critical()) </span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free garbage here</span></span><br></pre></td></tr></table></figure><p>第一种将垃圾内存留到下一次调用时清理的模式，是在正常的重新分配缓存大小时采用；第二种始终清理垃圾内存的模式，是在需要刷新所有类的所有缓存时使用，因为这样往往会产生大量的垃圾内存。以我阅读代码来看，这种情况只会在开启一项日志调试功能时发生。日志调试会将所有的消息发送记录到文件中，消息缓存会影响这一日志，因此需要全部刷新。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>性能和线程安全经常会互相冲突。不同部分的代码对同一块内存的访问方式往往不同，也就允许我们以更加有效率的方式来实现线程安全。方式之一是用一个全局标志位或者计数器来指明对内存的改动操作是否安全。在 Objective-C runtime 中，Apple 更进一步，使用了各个线程的程序计数器来判断线程是否正在进行不安全的操作。这是一个很专业的案例，这种做法想要用到其他地方也不是很有用，但研究它的原理本身就是一件很有意思的事情。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-05-29-concurrent-memory-deallocation-in-the-objective-c-runtime.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2015-06-05&lt;br&gt;译者：&lt;a href=&quot;https://github.com/YangGao1991&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阳仔&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://weibo.com/1743643682/profile?topnav=1&amp;amp;wvr=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;liberalism&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Objective-C Runtime 是绝大多数 Mac 和 iOS 程序代码的核心。Runtime 的核心就是 &lt;code&gt;objc_msgSend&lt;/code&gt; 函数，这个函数最关键的就是方法缓存。我在这篇文章中将会阐述一下，Apple 是如何在不影响性能的情况下，以线程安全的方式来重新分配缓存大小、释放方法缓存。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
