<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftGG</title>
  
  <subtitle>走心的 Swift 翻译组</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swift.gg/"/>
  <updated>2019-02-21T03:45:03.800Z</updated>
  <id>https://swift.gg/</id>
  
  <author>
    <name>SwiftGG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 5 字符串插值之美</title>
    <link href="https://swift.gg/2019/02/21/the-beauty-of-swift-5-string-interpolation/"/>
    <id>https://swift.gg/2019/02/21/the-beauty-of-swift-5-string-interpolation/</id>
    <published>2019-02-21T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:03.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Erica Sadun，<a href="https://ericasadun.com/2018/12/12/the-beauty-of-swift-5-string-interpolation/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-12-12<br>译者：<a href="https://www.roczhang.com/" target="_blank" rel="noopener">RocZhang</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>感谢提案 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0228-fix-expressiblebystringinterpolation.md" target="_blank" rel="noopener">SE-0228</a>，让我们能够精确控制字符串插值的打印方式。感谢 Brent 带给我们这个非常棒的功能。让我来分享一些例子。</p><a id="more"></a><p>回想一下在我们要打印可选值的时候，会这样写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="string">"There's <span class="subst">\(value1)</span> and <span class="subst">\(value2)</span>"</span></span><br></pre></td></tr></table></figure><p>但这样写会立即得到一个警告：<br><img src="https://i2.wp.com/ericasadun.com/wp-content/uploads/2018/12/Screen-Shot-2018-12-12-at-2.38.51-PM.png?w=1065&amp;ssl=1" alt=""></p><p>我们可以点击修复按钮来消除这些警告，得到如下的代码。但我们仍然会看到一个类似于这样的输出：“There’s Optional(23) and nil”。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="string">"There's <span class="subst">\(String(describing: value1)</span>) and <span class="subst">\(String(describing: value2)</span>)"</span></span><br></pre></td></tr></table></figure><p>现在我们可以通过下面这种方式去掉输出中的“Optional”，直接打印出“There’s 23 and nil”：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>.<span class="title">StringInterpolation</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 提供 `Optional` 字符串插值</span></span><br><span class="line">  <span class="comment">/// 而不必强制使用 `String(describing:)`</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(<span class="number">_</span> value: T?, <span class="keyword">default</span> defaultValue: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> value = value &#123;</span><br><span class="line">      appendInterpolation(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      appendLiteral(defaultValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// There's 23 and nil</span></span><br><span class="line"><span class="string">"There's <span class="subst">\(value1, <span class="keyword">default</span>: "<span class="literal">nil</span>")</span> and <span class="subst">\(value2, <span class="keyword">default</span>: "<span class="literal">nil</span>")</span>"</span></span><br></pre></td></tr></table></figure><p>我们也可以创建一组样式，从而使可选值能够保持一致的输出展示方式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>.<span class="title">StringInterpolation</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 可选值插值样式</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">OptionalStyle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 有值和没有值两种情况下都包含单词 `Optional`</span></span><br><span class="line">    <span class="keyword">case</span> descriptive</span><br><span class="line">    <span class="comment">/// 有值和没有值两种情况下都去除单词 `Optional`</span></span><br><span class="line">    <span class="keyword">case</span> stripped</span><br><span class="line">    <span class="comment">/// 使用系统的插值方式，在有值时包含单词 `Optional`，没有值时则不包含</span></span><br><span class="line">    <span class="keyword">case</span> `<span class="keyword">default</span>`</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 使用提供的 `optStyle` 样式来插入可选值</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(<span class="number">_</span> value: T?, optStyle style: String.StringInterpolation.OptionalStyle)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> style &#123;</span><br><span class="line">    <span class="comment">// 有值和没有值两种情况下都包含单词 `Optional`</span></span><br><span class="line">    <span class="keyword">case</span> .descriptive:</span><br><span class="line">      <span class="keyword">if</span> value == <span class="literal">nil</span> &#123;</span><br><span class="line">        appendLiteral(<span class="string">"Optional(nil)"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        appendLiteral(<span class="type">String</span>(describing: value))</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 有值和没有值两种情况下都去除单词 `Optional`</span></span><br><span class="line">    <span class="keyword">case</span> .stripped:</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> value = value &#123;</span><br><span class="line">        appendInterpolation(value)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        appendLiteral(<span class="string">"nil"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 使用系统的插值方式，在有值时包含单词 `Optional`，没有值时则不包含</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      appendLiteral(<span class="type">String</span>(describing: value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 使用 `stripped` 样式来对可选值进行插值</span></span><br><span class="line">  <span class="comment">/// 有值和没有值两种情况下都省略单词 `Optional`</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(describing value: T?)</span></span> &#123;</span><br><span class="line">    appendInterpolation(value, optStyle: .stripped)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "There's Optional(23) and nil"</span></span><br><span class="line"><span class="string">"There's <span class="subst">\(value1, optStyle: .<span class="keyword">default</span>)</span> and <span class="subst">\(value2, optStyle: .<span class="keyword">default</span>)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "There's Optional(23) and Optional(nil)"</span></span><br><span class="line"><span class="string">"There's <span class="subst">\(value1, optStyle: .descriptive)</span> and <span class="subst">\(value2, optStyle: .descriptive)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "There's 23 and nil"</span></span><br><span class="line"><span class="string">"There's <span class="subst">\(describing: value1)</span> and <span class="subst">\(describing: value2)</span>"</span></span><br></pre></td></tr></table></figure><p>插值不仅仅用于调整可选值的输出方式，在其他方面也很有用。比如你想控制输出是否带有特定的字符，就不需要写一个带有空字符串的三元表达式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功时包含（感谢 Nate Cook）</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>.<span class="title">StringInterpolation</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 只有 `condition` 的返回值为 `true` 才进行插值</span></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(<span class="keyword">if</span> condition: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>, <span class="number">_</span> literal: <span class="type">StringLiteralType</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> condition() <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    appendLiteral(literal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="string">"Cheese Sandwich <span class="subst">\(isStarred ? "(*)</span>"</span> : <span class="string">""</span>)<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 新写法</span></span><br><span class="line"><span class="string">"</span><span class="type">Cheese</span> <span class="type">Sandwich</span> \(<span class="keyword">if</span>: isStarred, <span class="string">"(*)"</span>)<span class="string">"</span></span><br></pre></td></tr></table></figure><p>我们还可以用字符串插值来做更多有趣的事情。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文对 Swift 5 中 SE-0228 对 String Interpolation 相关功能的改进进行了举例说明，展示了一些控制字符串插值的方式。
    
    </summary>
    
      <category term="Erica Sadun" scheme="https://swift.gg/categories/Erica-Sadun/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>协议中的私有属性</title>
    <link href="https://swift.gg/2019/02/18/protocols-private-properties/"/>
    <id>https://swift.gg/2019/02/18/protocols-private-properties/</id>
    <published>2019-02-18T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:03.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/protocols/2018/09/02/protocols-private-properties/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-09-02<br>译者：<a href="https://github.com/dzyding" target="_blank" rel="noopener">灰s</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://linusling.com" target="_blank" rel="noopener">小铁匠Linus</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>在 Swift 中，协议中声明的属性没有访问控制的能力。如果协议中列出了某个属性，则必须使遵守协议的类型显式声明这些属性。  </p><p>不过有些时候，尽管你会在协议中声明一些属性，但你是要利用这些属性来提供你的实现，并不希望这些属性在类型的外部被使用。让我们看看如何解决这个问题。 </p><a id="more"></a><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>假设你需要创建一个专门的对象来管理你的视图控制器（ViewControllers）导航，比如一个协调器（Coordinator）。  </p><p>每个协调器都有一个根控制器 <code>UINavigationController</code>，并共享一些通用的功能，比如在它上面推进（push）和弹出（pop）其他 ViewController。所以最初它看起来可能是这样 <a href="#foot1" id="1"><sup>[1]</sup></a>：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Coordinator.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Coordinator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> navigationController: <span class="type">UINavigationController</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> childCoordinator: <span class="type">Coordinator</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(viewController: UIViewController, animated: Bool)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(childViewController: UIViewController, animated: Bool)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">(animated: Bool)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Coordinator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(viewController: UIViewController, animated: Bool = <span class="literal">true</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.navigationController.pushViewController(viewController, animated: animated)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(childCoordinator: Coordinator, animated: Bool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.navigationController.present(childCoordinator.navigationController, animated: animated) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>?.childCoordinator = childCoordinator</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">(animated: Bool = <span class="literal">true</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> childCoordinator = <span class="keyword">self</span>.childCoordinator &#123;</span><br><span class="line">      <span class="keyword">self</span>.dismissViewController(animated: animated) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.childCoordinator = <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">self</span>.navigationController.popViewController(animated: animated)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们想要声明一个新的 <code>Coordinator</code> 对象时，会像这样做：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MainCoordinator.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainCoordinator</span>: <span class="title">Coordinator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> navigationController: <span class="type">UINavigationController</span> = <span class="type">UINavigationController</span>()</span><br><span class="line">  <span class="keyword">var</span> childCoordinator: <span class="type">Coordinator</span>?</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">showTutorialPage1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> vc = makeTutorialPage(<span class="number">1</span>, coordinator: <span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.push(viewController: vc)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">showTutorialPage2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> vc = makeTutorialPage(<span class="number">2</span>, coordinator: <span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.push(viewController: vc)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">makeTutorialPage</span><span class="params">(<span class="number">_</span> num: Int, coordinator: Coordinator)</span></span> -&gt; <span class="type">UIViewController</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：泄漏实现细节"><a href="#问题：泄漏实现细节" class="headerlink" title="问题：泄漏实现细节"></a>问题：泄漏实现细节</h2><p>这个解决方案在 <code>protocol</code> 的可见性上有两个问题：  </p><ul><li>每当我们想要声明一个新的 <code>Coordinator</code> 对象，都必须显式的声明一个 <code>let navigationController: UINavigationController</code> 属性和一个 <code>var childCoordinator: Coordinator?</code> 属性。<strong>虽然，在遵守协议的类型现实中，我们并没有显式的使用他们</strong> - 但它们就在那里，因为我们需要它们作为默认的实现来供 <code>protocol Coordinator</code> 正常工作。  </li><li>我们必须声明的这两个属性具有与 <code>MainCoordinator</code> 相同的可见性（在本例中为隐式 <code>internal（内部）</code> 访问控制级别），因为这是 <code>protocol Coordinator</code> 的必备条件。这使得它们对外部可见，就像在编码时可以使用 <code>MainCoordinator</code>。  </li></ul><p>所以问题是我们每次都要声明一些属性——即使它只是一些实现细节，而且这些实现细节会通过外部接口被泄漏，从而允许类的访问者做一些本不应该被允许的事，例如：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mainCoord = <span class="type">MainCoordinator</span>()</span><br><span class="line"><span class="comment">// 访问者不应该被允许直接访问 navigationController ，但是他们可以</span></span><br><span class="line">mainCoord.navigationController.dismissViewController(animated: <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 他们也不应该被允许做这样的事情</span></span><br><span class="line">mainCoord.childCoordinator = mainCoord</span><br></pre></td></tr></table></figure><p>也许你会认为，既然我们不希望它们是可见的，那么可以直接在第一段代码的 <code>protocol</code> 中不声明这两个属性。但是如果我们这样做，将无法通过 <code>extension Coordinator</code> 来提供默认的实现，因为默认的实现需要这两个属性存在以便它们的代码被编译。  </p><p>你可能希望 Swift 允许在协议中申明这些属性为 <code>fileprivate</code>，但是在 Swift 4 中，你不能在 <code>protocols</code> 中使用任何访问控制的关键字。  </p><p>所以我们如何才能解决这个“既要提供用到这个属性的默认实现，有不让这些属性对外暴露”的问题呢？</p><h2 id="一个解决方案"><a href="#一个解决方案" class="headerlink" title="一个解决方案"></a>一个解决方案</h2><p>实现这一点的一个技巧是将这些属性隐藏在中间对象中，并在该对象中将对应的属性声明为 <code>fileprivate</code>。  </p><p>通过这种方式，尽管我们依旧在对应类型的公共接口中声明了属性，但是接口的访问者却不能访问该对象的内部属性。而我们对于协议的默认实现却能够访问它们 —— 只要它们在同一个文件中被声明就行了（因为它们是 <code>fileprivate</code> ）。  </p><p>看起来就像这样：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Coordinator.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoordinatorComponents</span> </span>&#123;</span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">let</span> navigationController: <span class="type">UINavigationController</span> = <span class="type">UINavigationController</span>()</span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">var</span> childCoordinator: <span class="type">Coordinator</span>? = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Coordinator</span>: <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> coordinatorComponents: <span class="type">CoordinatorComponents</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(viewController: UIViewController, animated: Bool)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(childCoordinator: Coordinator, animated: Bool)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">(animated: Bool)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Coordinator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(viewController: UIViewController, animated: Bool = <span class="literal">true</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.coordinatorComponents.navigationController.pushViewController(viewController, animated: animated)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(childCoordinator: Coordinator, animated: Bool = <span class="literal">true</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> childVC = childCoordinator.coordinatorComponents.navigationController</span><br><span class="line">    <span class="keyword">self</span>.coordinatorComponents.navigationController.present(childVC, animated: animated) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>?.coordinatorComponents.childCoordinator = childCoordinator <span class="comment">// retain the child strongly</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">(animated: Bool = <span class="literal">true</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> privateAPI = <span class="keyword">self</span>.coordinatorComponents</span><br><span class="line">    <span class="keyword">if</span> privateAPI.childCoordinator != <span class="literal">nil</span> &#123;</span><br><span class="line">      privateAPI.navigationController.dismiss(animated: animated) &#123; [<span class="keyword">weak</span> privateAPI] <span class="keyword">in</span></span><br><span class="line">        privateAPI?.childCoordinator = <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      privateAPI.navigationController.popViewController(animated: animated)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，遵守协议的 <code>MainCoordinator</code> 类型：  </p><ul><li>仅需要声明一个 <code>let coordinatorComponents = CoordinatorComponents()</code> 属性，并不用知道 <code>CoordinatorComponents</code> 类型的内部有些什么（隐藏了实现细节）。  </li><li>在 <code>MainCoordinator.swift</code> 文件中，不能访问 <code>coordinatorComponents</code> 的任何属性，因为它们被声明为 <code>fileprivate</code>。  </li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainCoordinator</span>: <span class="title">Coordinator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> coordinatorComponents = <span class="type">CoordinatorComponents</span>()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">showTutorialPage1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> vc = makeTutorialPage(<span class="number">1</span>, coordinator: <span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.push(viewController: vc)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">showTutorialPage2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> vc = makeTutorialPage(<span class="number">2</span>, coordinator: <span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.push(viewController: vc)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">makeTutorialPage</span><span class="params">(<span class="number">_</span> num: Int, coordinator: Coordinator)</span></span> -&gt; <span class="type">UIViewController</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你仍然需要在遵守协议的类型中声明 <code>let coordinatorComponents</code> 来提供存储，这个声明必须是可见的（不能是 <code>private</code>），因为这是遵守 <code>protocol Coordinator</code> 所要求的一部分。但是：  </p><ul><li>只需要声明 1 个属性，取代之前的 2 个（在更复杂的情况下会有更多）。  </li><li>更重要的是，即使它可以从遵守协议的类型的实现中访问，也可以从外部接口访问，你却不能对它做任何事情。  </li></ul><p>当然，你仍然可以访问 <code>myMainCoordinator.coordinatorComponents</code>，但是不能使用它做任何事情，因为它所有的属性都是 <code>fileprivate</code> ！  </p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Swift 可能无法提供你想要的所有功能。你可能希望有朝一日 <code>protocols</code> 允许对它声明需要的属性和方法使用访问控制关键字，或者通过某种方式将它们在公共 API 中隐藏。  </p><p>但与此同时，掌握这些技巧和变通方法可以使你的公共 API 更好、更安全，避免泄露实现细节或者访问在实现之外不应该被修改的属性，同时仍然使用 <a href="http://alisoftware.github.io/swift/protocol/2015/11/08/mixins-over-inheritance/" target="_blank" rel="noopener">Mixin pattern</a> 并提供默认实现。  </p><hr><p><a id="foot1" href="#1"><sup>[1]</sup></a>.这是一个简化的例子；不要将注意力集中在 Coordinator 的实现 - 它不是这个例子的重点，更应该关注的是需要在协议中声明公开可访问的属性。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      通过另一种方式来控制协议中属性和方法的访问权限
    
    </summary>
    
      <category term="Olivier Halligon" scheme="https://swift.gg/categories/Olivier-Halligon/"/>
    
      <category term="Swift" scheme="https://swift.gg/categories/Olivier-Halligon/Swift/"/>
    
    
      <category term="协议" scheme="https://swift.gg/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>SwiftSyntax</title>
    <link href="https://swift.gg/2019/01/25/nshipster-swiftsyntax/"/>
    <id>https://swift.gg/2019/01/25/nshipster-swiftsyntax/</id>
    <published>2019-01-25T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:03.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/swiftsyntax/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-10-22<br>译者：<a href="https://dingtz.com/" target="_blank" rel="noopener">jojotov</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p><a href="https://github.com/apple/swift-syntax" target="_blank" rel="noopener">SwiftSyntax</a> 是一个可以分析、生成以及转换 Swift 源代码的 Swift 库。它是基于 <a href="https://github.com/apple/swift/tree/master/lib/Syntax" target="_blank" rel="noopener">libSyntax</a> 库开发的，并于 <a href="https://github.com/apple/swift-syntax/commit/909d336aefacdcbdd45ec6130471644c1ae929f5" target="_blank" rel="noopener">2017 年 8 月</a> 从 Swift 语言的主仓库中分离出来，单独建立了一个仓库。</p><a id="more"></a><p>总的来说，这些库都是为了给结构化编辑（structured editing）提供安全、正确且直观的工具。关于结构化编辑，在 <a href="https://github.com/apple/swift/blob/master/lib/Syntax/README.md#swift-syntax-and-structured-editing-library" target="_blank" rel="noopener">thusly</a> 中有具体的描述:</p><blockquote><p>什么是结构化编辑？结构化编辑是一种编辑的策略，它对源代码的<em>结构</em>更加敏感，而源代码的表示（例如字符或者字节）则没那么重要。这可以细化为以下几个部分：替换标识符，将对全局方法的调用转为对方法的调用，或者根据已定的规则识别并格式化整个源文件。</p></blockquote><p>在写这篇文章时，SwiftSyntax 仍处于在开发中并进行 API 调整的阶段。不过目前你已经可以使用它对 Swift 代码进行一些编程工作。</p><p>目前，<a href="https://github.com/apple/swift/tree/master/lib/Migrator" target="_blank" rel="noopener">Swift Migrator</a> 已经在使用 SwiftSyntax 了，并且在对内和对外层面上，对 SwiftSyntax 的接入也在不断地努力着。</p><h2 id="SwiftSyntax-如何工作？"><a href="#SwiftSyntax-如何工作？" class="headerlink" title="SwiftSyntax 如何工作？"></a>SwiftSyntax 如何工作？</h2><p>为了明白 SwiftSyntax 如何工作，我们首先要回头看看 Swift 编译器的架构：</p><p><img src="https://nshipster.com/assets/swift-compilation-diagram-8af7d0078f72cdaa8f50430e608f15a9d4214f5772439d2fd6904bb5a8a53c60.png" alt=""></p><p>Swift 编译器的主要职责是把 Swift 代码转换为可执行的机器代码。整个过程可以划分为几个离散的步骤，一开始，<a href="https://github.com/apple/swift/tree/master/lib/Parse" target="_blank" rel="noopener">语法分析器</a> 会生成一个抽象语法树（AST）。之后，语义分析器会进行工作并生成一个通过类型检查的 AST。至此步骤，代码会降级到 <a href="https://github.com/apple/swift/blob/master/docs/SIL.rst" target="_blank" rel="noopener">Swift 中间层语言</a>；随后 SIL 会继续转换并优化自身，降级为 <a href="http://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">LLVM IR</a>，并最终编译为机器代码。</p><p>对于我们的讨论来说，最重要的关键点是 SwiftSyntax 的操作目标是编译过程第一步所生成的 AST。但也由于这样，SwiftSyntax 无法告知你任何关于代码的语义或类型信息。</p><p>与 SwiftSyntax 相反，一些如 <a href="https://github.com/apple/swift/tree/master/tools/SourceKit" target="_blank" rel="noopener">SourceKit</a> 之类的工具，操作的目标为更容易理解的 Swift 代码。这可以帮助此类工具实现一些编辑器相关的特性，例如代码补全或者文件之间的跳转。虽然 SwiftSyntax 不能像 SourceKit 一样实现跳转或者补全的功能，但在语法层面上也有很多应用场景，例如代码格式化和语法高亮。</p><h3 id="揭秘-AST"><a href="#揭秘-AST" class="headerlink" title="揭秘 AST"></a>揭秘 AST</h3><p>抽象语法树在抽象层面上比较难以理解。因此我们先生成一个示例来一睹其貌。</p><p>留意一下如下的一行 Swift 代码，它声明了一个名为 <code>one()</code> 的函数，函数返回值为 <code>1</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">one</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>在命令行中对此文件运行 <code>swiftc</code> 命令并传入 <code>-frontend -emit-syntax</code> 参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcrun swiftc -frontend -emit-syntax ./One.swift</span></span><br></pre></td></tr></table></figure><p>运行的结果为一串 JSON 格式的 AST。当你用 JSON 格式来展示时，AST 的结构会表现的更加清晰：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"kind"</span>: <span class="string">"SourceFile"</span>,</span><br><span class="line">    <span class="attr">"layout"</span>: [&#123;</span><br><span class="line">        <span class="attr">"kind"</span>: <span class="string">"CodeBlockItemList"</span>,</span><br><span class="line">        <span class="attr">"layout"</span>: [&#123;</span><br><span class="line">            <span class="attr">"kind"</span>: <span class="string">"CodeBlockItem"</span>,</span><br><span class="line">            <span class="attr">"layout"</span>: [&#123;</span><br><span class="line">                <span class="attr">"kind"</span>: <span class="string">"FunctionDecl"</span>,</span><br><span class="line">                <span class="attr">"layout"</span>: [<span class="literal">null</span>, <span class="literal">null</span>, &#123;</span><br><span class="line">                    <span class="attr">"tokenKind"</span>: &#123;</span><br><span class="line">                        <span class="attr">"kind"</span>: <span class="string">"kw_func"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"leadingTrivia"</span>: [],</span><br><span class="line">                    <span class="attr">"trailingTrivia"</span>: [&#123;</span><br><span class="line">                        <span class="attr">"kind"</span>: <span class="string">"Space"</span>,</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">1</span></span><br><span class="line">                    &#125;],</span><br><span class="line">                    <span class="attr">"presence"</span>: <span class="string">"Present"</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    <span class="attr">"tokenKind"</span>: &#123;</span><br><span class="line">                        <span class="attr">"kind"</span>: <span class="string">"identifier"</span>,</span><br><span class="line">                        <span class="attr">"text"</span>: <span class="string">"one"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"leadingTrivia"</span>: [],</span><br><span class="line">                    <span class="attr">"trailingTrivia"</span>: [],</span><br><span class="line">                    <span class="attr">"presence"</span>: <span class="string">"Present"</span></span><br><span class="line">                &#125;, ...</span><br></pre></td></tr></table></figure><p>Python 中的 <code>json.tool</code> 模块提供了便捷地格式化 JSON 的能力。且几乎所有的 macOS 系统都已经集成了此模块，因此每个人都可以使用它。举个例子，你可以使用如下的命令对编译的输出结果使用 <code>json.tool</code> 格式化：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcrun swiftc -frontend -emit-syntax ./One.swift | python -m json.tool</span></span><br></pre></td></tr></table></figure><p>在最外层，可以看到 <code>SourceFile</code>，它由 <code>CodeBlockItemList</code> 以及 <code>CodeBlockItemList</code> 内部的 <code>CodeBlockItem</code> 这几个部分组成。对于这个示例来说，仅有一个 <code>CodeBlockItem</code> 对应函数的定义（<code>FunctionDecl</code>），其自身包含了几个子组件如函数签名、参数闭包和返回闭包。</p><p>术语 trivia 用于描述任何没有实际语法意义的东西，例如空格。每个标记符（Token）可以有一个或多个行前和行尾的 trivia。例如，在返回的闭包（<code>-&gt; Int</code>）中的 <code>Int</code> 后的空格可以用如下的行尾 trivia 表示：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"kind"</span>: <span class="string">"Space"</span>,</span><br><span class="line">  <span class="attr">"value"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理文件系统限制"><a href="#处理文件系统限制" class="headerlink" title="处理文件系统限制"></a>处理文件系统限制</h3><p>SwiftSyntax 通过代理系统的 <code>swiftc</code> 调用来生成抽象语法树。但是，这也限制了代码必须放在某个文件才能进行处理，而我们却经常需要对以字符串表示的代码进行处理。</p><p>为了解决这个限制，其中一种办法是把代码写入一个临时文件并传入到编译器中。</p><p><a href="https://nshipster.com/nstemporarydirectory/" target="_blank" rel="noopener">我们曾经尝试过写入临时文件</a>，但目前，有更好的 API 可以帮助我们完成这项工作，它由  <a href="https://github.com/apple/swift-package-manager" target="_blank" rel="noopener">Swift Package Manager</a> 本身提供。在你的 <code>Package.swift</code> 文件中，添加如下的包依赖关系，并把 <code>Utility</code> 依赖添加到正确的 target 中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.package(url: <span class="string">"https://github.com/apple/swift-package-manager.git"</span>, from: <span class="string">"0.3.0"</span>),</span><br></pre></td></tr></table></figure><p>现在，你可以像下面这样引入 <code>Basic</code> 模块并使用 <code>TemporaryFile</code> API：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Basic</span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> code: <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tempfile = <span class="keyword">try</span> <span class="type">TemporaryFile</span>(deleteOnClose: <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">defer</span> &#123; tempfile.fileHandle.closeFile() &#125;</span><br><span class="line">tempfile.fileHandle.write(code.data(using: .utf8)!)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(fileURLWithPath: tempfile.path.asString)</span><br><span class="line"><span class="keyword">let</span> sourceFile = <span class="keyword">try</span> <span class="type">SyntaxTreeParser</span>.parse(url)</span><br></pre></td></tr></table></figure><h2 id="我们可以用-SwiftSyntax-做什么"><a href="#我们可以用-SwiftSyntax-做什么" class="headerlink" title="我们可以用 SwiftSyntax 做什么"></a>我们可以用 SwiftSyntax 做什么</h2><p>现在我们对 SwiftSyntax 如何工作已经有了足够的理解，是时候讨论一下几个使用它的方式了！</p><h3 id="编写-Swift-代码：地狱模式"><a href="#编写-Swift-代码：地狱模式" class="headerlink" title="编写 Swift 代码：地狱模式"></a>编写 Swift 代码：地狱模式</h3><p>我们第一个想到，但却是最没有实际意义的 SwiftSyntax 用例就是让编写 Swift 代码的难度提升几个数量级。</p><p>利用 SwiftSyntax 中的 <code>SyntaxFactory</code> APIs，我们可以生成完整的 Swift 代码。不幸的是，编写这样的代码并不像闲庭散步般轻松。</p><p>留意一下如下的示例代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftSyntax</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> structKeyword = <span class="type">SyntaxFactory</span>.makeStructKeyword(trailingTrivia: .spaces(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> identifier = <span class="type">SyntaxFactory</span>.makeIdentifier(<span class="string">"Example"</span>, trailingTrivia: .spaces(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> leftBrace = <span class="type">SyntaxFactory</span>.makeLeftBraceToken()</span><br><span class="line"><span class="keyword">let</span> rightBrace = <span class="type">SyntaxFactory</span>.makeRightBraceToken(leadingTrivia: .newlines(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">let</span> members = <span class="type">MemberDeclBlockSyntax</span> &#123; builder <span class="keyword">in</span></span><br><span class="line">    builder.useLeftBrace(leftBrace)</span><br><span class="line">    builder.useRightBrace(rightBrace)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> structureDeclaration = <span class="type">StructDeclSyntax</span> &#123; builder <span class="keyword">in</span></span><br><span class="line">    builder.useStructKeyword(structKeyword)</span><br><span class="line">    builder.useIdentifier(identifier)</span><br><span class="line">    builder.useMembers(members)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(structureDeclaration)</span><br></pre></td></tr></table></figure><p><em>唷。</em>那最后这段代码让我们得到了什么呢？</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>令人窒息的操作。</em></p><p>这绝不是为了取代 <a href="https://nshipster.com/swift-gyb/" target="_blank" rel="noopener">GYB</a> 来用于每天的代码生成。（事实上，<a href="https://github.com/apple/swift/blob/master/lib/Syntax/SyntaxKind.cpp.gyb" target="_blank" rel="noopener">libSyntax</a> 和 <a href="https://github.com/apple/swift-syntax/blob/master/Sources/SwiftSyntax/SyntaxKind.swift.gyb" target="_blank" rel="noopener">SwiftSyntax</a> 都使用了 <code>gyb</code> 来生成接口。</p><p>但这个接口在某些特殊的问题上却格外有用。例如，你或许会使用 SwiftSyntax 来实现一个 Swift 编译器的 <a href="https://en.wikipedia.org/wiki/Fuzzing" target="_blank" rel="noopener">模糊测试</a>，使用它可以随机生成一个表面有效却实际上非常复杂的程序，以此来进行压力测试。</p><h2 id="重写-Swift-代码"><a href="#重写-Swift-代码" class="headerlink" title="重写 Swift 代码"></a>重写 Swift 代码</h2><p><a href="https://github.com/apple/swift-syntax#example" target="_blank" rel="noopener">在 SwiftSyntax 的 README 中有一个示例</a> 展示了如何编写一个程序来遍历源文件中的整型并把他们的值加 1。</p><p>通过这个，你应该已经推断得出如何使用它来创建一个典型的 <code>swift-format</code> 工具。</p><p>但现在，我们先考虑一个相当<em>没有</em>效率——并且可能在万圣节（🎃）这种需要捣蛋的场景才合适的用例，源代码重写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftSyntax</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZalgoRewriter</span>: <span class="title">SyntaxRewriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(<span class="number">_</span> token: TokenSyntax)</span></span> -&gt; <span class="type">Syntax</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> .stringLiteral(text) = token.tokenKind <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> token</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> token.withKind(.stringLiteral(zalgo(text)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/mattt/b46ab5027f1ee6ab1a45583a41240033" target="_blank" rel="noopener"><code>zalgo</code></a> 函数是用来做什么的？可能不知道会更好……</p><p>不管怎样，在你的源代码中运行这个重写器，可以把所有的文本字符串转换为像下面一样的效果：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Before 👋😄</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, world!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// After 🦑😵</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"H͞͏̟̂ͩel̵ͬ͆͜ĺ͎̪̣͠ơ̡̼͓̋͝, w͎̽̇ͪ͢ǒ̩͔̲̕͝r̷̡̠͓̉͂l̘̳̆ͯ̊d!"</span>)</span><br></pre></td></tr></table></figure><p><em>鬼魅一般，对吧？</em></p><h2 id="高亮-Swift-代码"><a href="#高亮-Swift-代码" class="headerlink" title="高亮 Swift 代码"></a>高亮 Swift 代码</h2><p>让我们用一个真正实用的东西来总结我们对 SwiftSyntax 的探究：一个 Swift 语法高亮工具。</p><p>从语法高亮工具的意义上来说，它可以把源代码按某种方式格式化为显示更为友好的 HTML。</p><p><a href="https://github.com/NSHipster/nshipster.com" target="_blank" rel="noopener">NSHipster 通过 Jekyll 搭建</a>，并使用了 Ruby 的库 <a href="https://github.com/jneen/rouge" target="_blank" rel="noopener">Rouge</a> 来渲染你在每篇文章中看到的示例代码。尽管如此，由于 Swift 的复杂语法和过快迭代，渲染出来的 HTML 并不是 100% 正确。</p><p>不同于 <a href="https://github.com/jneen/rouge/blob/master/lib/rouge/lexers/swift.rb" target="_blank" rel="noopener">处理一堆麻烦的正则表达式</a>，我们可以构造一个 <a href="https://github.com/NSHipster/SwiftSyntaxHighlighter" target="_blank" rel="noopener">语法高亮器</a> 来放大 SwiftSyntax 对语言的理解的优势。</p><p>根据这个核心目的，实现的方法可以很直接：实现一个 <code>SyntaxRewriter</code> 的子类并重写 <code>visit(_:)</code> 方法，这个方法会在遍历源文件的每个标识符时被调用。通过判断每种不同的标识符类型，你可以把相应的可高亮标识符映射为 HTML 标记。</p><p>例如，数字文本可以用类名是 <code>m</code> 开头的 <code>&lt;span&gt;</code> 元素来表示（<code>mf</code> 表示浮点型，<code>mi</code> 表示整型）。如下是对应的在 <code>SyntaxRewriter</code> 子类中的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftSyntax</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwiftSyntaxHighlighter</span>: <span class="title">SyntaxRewriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> html: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(<span class="number">_</span> token: TokenSyntax)</span></span> -&gt; <span class="type">Syntax</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> token.tokenKind &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> .floatingLiteral(<span class="keyword">let</span> string):</span><br><span class="line">            html += <span class="string">"&lt;span class=\"mf\"&gt;<span class="subst">\(string)</span>&lt;/span&gt;"</span></span><br><span class="line">        <span class="keyword">case</span> .integerLiteral(<span class="keyword">let</span> string):</span><br><span class="line">            <span class="keyword">if</span> string.hasPrefix(<span class="string">"0b"</span>) &#123;</span><br><span class="line">                html += <span class="string">"&lt;span class=\"mb\"&gt;<span class="subst">\(string)</span>&lt;/span&gt;"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> string.hasPrefix(<span class="string">"0o"</span>) &#123;</span><br><span class="line">                html += <span class="string">"&lt;span class=\"mo\"&gt;<span class="subst">\(string)</span>&lt;/span&gt;"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> string.hasPrefix(<span class="string">"0x"</span>) &#123;</span><br><span class="line">                html += <span class="string">"&lt;span class=\"mh\"&gt;<span class="subst">\(string)</span>&lt;/span&gt;"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                html += <span class="string">"&lt;span class=\"mi\"&gt;<span class="subst">\(string)</span>&lt;/span&gt;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管 <code>SyntaxRewritere</code> 针对每一种不同类型的语法元素，都已经实现了 <code>visit(:)</code> 方法，但我发现使用一个 <code>switch</code> 语句可以更简单地处理所有工作。（在 <code>default</code> 分支中打印出无法处理的标记符，可以更好地帮助我们找到那些没有处理的情况）。这不是最优雅的实现，但鉴于我对 SwiftSyntax 不足的理解，这是个较好的开端。</p><p>不管怎样，在几个小时的开发工作后，我已经可以在 Swift 大量的语法特性中，生成出比较理想的渲染过的输出。</p><p><img src="https://nshipster.com/assets/swiftsyntaxhightlighter-example-output-829aa64ab4bdf73a2e3070aab017e21e3db37ca0ee35079f0e89e22594806df0.png" alt=""></p><p>这个项目需要一个库和命令行工具的支持。快去 <a href="https://github.com/NSHipster/SwiftSyntaxHighlighter" target="_blank" rel="noopener">尝试一下 </a>然后让我知道你的想法吧！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mattt，&lt;a href=&quot;https://nshipster.com/swiftsyntax/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-10-22&lt;br&gt;译者：&lt;a href=&quot;https://dingtz.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jojotov&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/apple/swift-syntax&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SwiftSyntax&lt;/a&gt; 是一个可以分析、生成以及转换 Swift 源代码的 Swift 库。它是基于 &lt;a href=&quot;https://github.com/apple/swift/tree/master/lib/Syntax&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;libSyntax&lt;/a&gt; 库开发的，并于 &lt;a href=&quot;https://github.com/apple/swift-syntax/commit/909d336aefacdcbdd45ec6130471644c1ae929f5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2017 年 8 月&lt;/a&gt; 从 Swift 语言的主仓库中分离出来，单独建立了一个仓库。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>以流的形式执行 Multipart 请求</title>
    <link href="https://swift.gg/2019/01/21/streaming-multipart-requests/"/>
    <id>https://swift.gg/2019/01/21/streaming-multipart-requests/</id>
    <published>2019-01-21T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:03.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2018/11/streaming-multipart-requests/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-11-14<br>译者：<a href="https://www.jianshu.com/u/076cc5e18bb8" target="_blank" rel="noopener">郑一一</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>Foundation 框架中的 URL 类提供了非常全面的功能，此后还在 iOS 7 中新增了 URLSession 类。尽管如此，基础库中仍然缺少 multipart 文件上传的功能。</p><a id="more"></a><h2 id="什么是-multipart-请求？"><a href="#什么是-multipart-请求？" class="headerlink" title="什么是 multipart 请求？"></a>什么是 multipart 请求？</h2><p>Multipart 编码实际上就是在网络中上传大型文件的方法。在浏览器中，有时候你会选择一个文件作为表单提交内容的一部分。这个文件便是以 multipart 请求的方式实现上传的。</p><p>乍一看，multipart 请求和一般请求差不多。不同之处是 multipart 请求额外为 <code>HTTP</code> 请求体指定了唯一编码。同 JSON 编码（<code>{&quot;key&quot;: &quot;value&quot;}</code>）或者 URL 字符编码 (<code>key=value</code>) 相比，multipart 编码干的事略微有所不同。因为 multipart 请求体实际上只是一串字节流，接收端实体在解析数据时，需要知道字节流中各个部分之间的界限。所以 multipart 请求需要使用 “boundaries” 来解决这个问题。在请求首部的 <code>Content-Type</code> 中，可以定义 boundary：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept: application/json</span><br><span class="line">Content-Type: multipart/form-data; boundary=khanlou.comNczcJGcxe</span><br></pre></td></tr></table></figure><p>Boundary 的具体内容并不重要，唯一需要注意的是：在请求体中，boundary 是不能重复出现（这样才能体现 boundary 的作用）。你可以使用 UUID 作为 boundary。</p><p>请求的每一部分可以是普通数据（比如图片）或者元数据（一般是文本，对应一个名字，组成一个键值对）。如果数据是图片的话，那它看起来应该是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--&lt;boundary&gt;</span><br><span class="line">Content-Disposition: form-data; name=&lt;name&gt;; filename=&lt;filename.jpg&gt;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">&lt;image data&gt;</span><br></pre></td></tr></table></figure><p>如果是普通文本，则是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--&lt;boundary&gt;</span><br><span class="line">Content-Disposition: form-data; name=&lt;name&gt;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">&lt;some text&gt;</span><br></pre></td></tr></table></figure><p>请求结尾会有一个带着两个连字符的 boundary，<code>--&lt;boundary&gt;--</code>。（此处需要注意，所有新行必须是回车换行。）</p><p>以上就是关于 multipart 请求的所有内容，并不是特别复杂。事实上，当在写第一个有关 multipart 编码的客户端实现时，我有些抵触阅读 multipart/form-data 的 <a href="https://tools.ietf.org/html/rfc7578" target="_blank" rel="noopener">RFC</a>。可是在开始阅读之后，我对这个协议的理解更深了。整个文档可读性很强，很轻易就能直达知识的源头。</p><p>我在开源的 <a href="https://github.com/backchannel/BackchannelSDK-iOS" target="_blank" rel="noopener">Backchannel SDK</a> 实现了上述功能。<a href="https://github.com/backchannel/BackchannelSDK-iOS/blob/master/Source/Image%20Chooser/BAKUploadAttachmentRequest.m" target="_blank" rel="noopener"><code>BAKUploadAttachmentRequest</code></a> 和 <a href="https://github.com/backchannel/BackchannelSDK-iOS/blob/master/Source/Image%20Chooser/BAKMultipartRequestBuilder.m" target="_blank" rel="noopener"><code>BAKMultipartRequestBuilder</code></a> 类包含了处理 mulitipart 的方法。在这个项目中，仅仅包含了处理单个文件的情况，并且没有包括元数据。但是作为范例，依旧很好地展示了 mulitipart 请求是如何构建的。可以通过添加额外的实现代码，来支持元数据和多文件的功能。</p><p>无论是使用一个请求上传多个文件，还是多个请求分别对应上传一个文件，来实现多文件上传功能，都会碰到一个问题。这个问题就是，如果你尝试一次性上传很多文件的话，app 将会闪退。这是因为使用 <a href="https://github.com/backchannel/BackchannelSDK-iOS/blob/master/Source/Image%20Chooser/BAKMultipartRequestBuilder.m#L66-L70" target="_blank" rel="noopener">该版本的代码</a>，加载的数据会直接进入内存，在内存暴涨的情况下，即使使用当下性能最强的旗舰手机也会有闪退发生。</p><h2 id="将硬盘中数据以流的形式读取"><a href="#将硬盘中数据以流的形式读取" class="headerlink" title="将硬盘中数据以流的形式读取"></a>将硬盘中数据以流的形式读取</h2><p>最常见的解决方法是将硬盘中的数据以流的形式读取出来。其核心思想是文件的字节数据会一直保存在硬盘里，直到被读取并发往网络。内存中只保留了很小一部分的镜像数据。</p><p>目前，我想出两种方法可以解决这个问题。第一个方法，把 multipart 请求体中的所有数据写到硬盘的一个新文件中，并使用 URLSession 的 <code>uploadTask(with request: URLRequest, fromFile fileURL: URL)</code> 方法将文件转化为流。这个方法可以奏效，但我并不想为每一个请求新建一个新文件保存到硬盘中。因为这意味着在请求发出后，还需要删除这个文件。</p><p>第二种方法是将内存和硬盘的数据合并在一起，并通过统一的接口向网络输出数据。</p><p>如果你觉得第二种方法听起来像是 <a href="http://khanlou.com/2015/10/clustering/" target="_blank" rel="noopener">类簇</a>，恭喜你，完全正确。很多常用 Cocoa 类都允许创建子类，并实现一些父类方法，使其和父类表现一致。回想一下 <code>NSArray</code> 的 <code>-count</code> 属性和 <code>-objectAtIndex:</code> 方法。因为 <code>NSArray</code> 的所有其它方法都是基于 <code>-count</code> 属性和 <code>-objectAtIndex:</code> 方法实现的，你可以非常轻易地创建优化版本的 <code>NSArray</code> 子类。</p><p>你可以创建一个 <code>NSData</code> 子类，它无需真正从硬盘读取数据，而只是创建一个指针直接指向硬盘中的数据。这样做的好处是是不需要把数据载入内存中进行读取。这种方法称为内存映射，基于 Unix 方法 <code>mmap</code>。你可以通过 <code>.mappedIfSafe</code> 或者 <code>alwaysMapped</code> 选项，来使用 <code>NSData</code> 的这项特性。因为 <code>NSData</code> 是一个类簇，我们将创建一个 <code>ConcatenatedData</code> 子类（就像 <code>FlattenCollection</code> 在 Swift 中的工作方式），该子类会将多个 <code>NSData</code> 对象视作一个连续的 <code>NSData</code>。完成创建以后，我们就做好所有准备来解决这个问题啦。</p><p>通过查看 <code>NSData</code> 所有原生方法，可以发现，需要实现的是 <code>-count</code> 和 <code>-bytes</code>。实现 <code>-count</code> 并不难，我们可以把所有 <code>NSData</code> 对象的大小相加得到；但在实现 <code>-bytes</code> 时则会有个问题。 <code>-bytes</code> 需要返回一个指向一段连续缓冲区的指针，而目前我们并没有这个指针。</p><p>在基础库中，提供了 <code>NSInputStream</code> 类用于处理不连续的数据。非常幸运，<code>NSInputStream</code> 同样是一个类簇。我们可以创建一个子类，将多条流合并。在使用子类时，感觉上就像是一条流。通过使用 <code>+inputStreamWithData:</code> 和 <code>+inputStreamWithURL:</code> 方法，可以轻易地创建一条输入流，用来代表硬盘中的文件和内存中的数据（比如 boundaries）。</p><p>通过阅读最好的第三方网络库源代码，你会发现 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a> 采用了<a href="https://github.com/AFNetworking/AFNetworking/blob/009e3bb6673edc183c4f2baf552ad7cccba94d58/AFNetworking/AFURLRequestSerialization.m#L896-L927" target="_blank" rel="noopener">这种方法</a>。（<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a>，Swift 版本的 AFNetworking，则采用了第一种方法，<a href="https://github.com/Alamofire/Alamofire/blob/ff16ce9e87aeb0ee1f30b28789db1fff01e8fb02/Source/MultipartFormData.swift#L432-L455" target="_blank" rel="noopener">将数据全部加载到内存中</a>，但如果数据量太大，就会写到硬盘的一个文件中。）</p><h2 id="将所有部分拼接起来"><a href="#将所有部分拼接起来" class="headerlink" title="将所有部分拼接起来"></a>将所有部分拼接起来</h2><p>你可以在 <a href="https://gist.github.com/khanlou/8cc2e3cb23ec8d03b1fc187f5922e244" target="_blank" rel="noopener">这里</a> 看看我的串行输入流的实现（是用 Objective-C 实现的，以后我可能还会写一个 Swift 版本的）。</p><p>通过 <code>SKSerialInputStream</code> 类，可以将流组合在一起。下面展示了前缀和后缀属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MultipartComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prefixData: <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> string = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        <span class="subst">\(<span class="keyword">self</span>.boundary)</span></span></span><br><span class="line"><span class="string">        Content-Disposition: form-data; name="</span>\(<span class="keyword">self</span>.name); filename=<span class="string">"<span class="subst">\(<span class="keyword">self</span>.filename)</span>"</span></span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        return string.data(using: .utf8)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    var postfixData: Data &#123;</span></span><br><span class="line"><span class="string">        return "</span>\r\n<span class="string">".data(using: .utf8)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>将元数据和文件的 <code>dataStream</code> 组合在一起，得到一条输入流：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MultipartComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inputStream: <span class="type">NSInputStream</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> streams = [</span><br><span class="line">            <span class="type">NSInputStream</span>(data: prefixData),</span><br><span class="line">            <span class="keyword">self</span>.fileDataStream,</span><br><span class="line">            <span class="type">NSInputStream</span>(data: postfixData),</span><br><span class="line">        ]</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="type">SKSerialInputStream</span>(inputStreams: streams)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建好每一部分输入流之后，就可以把所有流组合在一起，得到一条完整输入流。此外，在请求结尾还需要添加一个 boundary：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RequestBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bodyInputStream: <span class="type">NSInputStream</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> stream = parts</span><br><span class="line">            .<span class="built_in">map</span>(&#123; $<span class="number">0</span>.inputStream &#125;)</span><br><span class="line">            + [<span class="type">NSInputStream</span>(data: <span class="string">"--<span class="subst">\(<span class="keyword">self</span>.boundary)</span>--"</span>.data(using: .utf8))]</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="type">SKSerialInputStream</span>(inputStreams: streams)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，将 <code>bodyInputStream</code> 赋值给 URL 请求的 <code>httpBodyStream</code> 属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urlRequest = <span class="type">URLRequest</span>(url: url)</span><br><span class="line"></span><br><span class="line">urlRequest.httpBodyStream = requestBuilder.bodyInputStream;</span><br></pre></td></tr></table></figure><p>注意，<code>httpBodyStream</code> 和 <code>httpBody</code> 两个属性是互斥的——两个属性不会同时生效。设置 <code>httpBodyStream</code> 会使得 <code>Data</code> 版本 <code>httpBody</code> 失效，反之亦然。</p><p>流文件上传的关键是能够将多条输入流合并成一条流。<code>SKSerialInputStream</code> 类完成了整个工作。尽管说子类化 <code>NSInputStream</code> 有一些困难，可一旦解决这个问题，我们就离成功不远啦。</p><h2 id="子类化过程中需要注意的问题"><a href="#子类化过程中需要注意的问题" class="headerlink" title="子类化过程中需要注意的问题"></a>子类化过程中需要注意的问题</h2><p>子类化 <code>NSInputStream</code> 的过程不会太轻松，甚至可以说很困难。你必须实现 9 个方法。其中的 7 个方法，父类只有一些微不足道的默认实现。而在文档中只提到了 9 个方法中的 3 个，所以你还得实现 6 个 <code>NSStream</code> （<code>NSInputStream</code> 的父类）的方法，其中有 2 个是 run loop 方法，并允许空实现。在这之前，你还需要额外 <a href="http://blog.bjhomer.com/2011/04/subclassing-nsinputstream.html" target="_blank" rel="noopener">实现 3 个私有方法</a>，不过现在不必实现了。此外，还需要定义 3 个<code>只读</code>属性：<code>streamStatus</code>，<code>streamError</code>，<code>delegate</code>。</p><p>在处理完上述子类化相关的细节后，接下来的挑战是创建一个 <code>NSInputStream</code> 子类，其行为应该和 API 使用者所期望的保持一致。然而，这个类状态的重度耦合是不容易被人发现的。</p><p>有一些状态需要保证行为一致。举个例子，<code>hasBytesAvailable</code> 是不同于其它状态的，但还是存在细微的联系。在我最近发现的一个 bug 里，<code>hasBytesAvailable</code> 属性会返回 <code>self.currentIndex != self.inputStreams.count</code>，但是这会造成一个 bug，流会一直处于开启的状态，并最终造成请求超时。修复这个 bug 的办法是改为返回 <code>YES</code>，但我一直没有找到这个 bug 的根源所在。</p><p>另外一个状态 <code>streamStatus</code>，存在许多可能的值，其中比较重要的两个值是 <code>NSStreamStatusOpen</code> 和 <code>NSStreamStatusClosed</code>。</p><p>最后一个比较有意思的状态是字节数，从 <code>read</code> 方法中返回值。这个属性除了会返回正整型数之外，还会返回 -1，-1 代表有错误产生，需要进一步检查非空属性 <code>streamError</code> 来获取更多信息。字节数还可以返回 0，根据文档描述，这是标明流结尾的另外一种方式。</p><p>文档并不会告诉你哪些状态的组合是有意义的。比如说流产生一个 <code>streamError</code>，但状态却是 <code>NSStreamStatusClosed</code>，而不是 <code>NSStreamStatusError</code>，在这种情况下是否会有问题？想要管理好所有的状态非常难，不过到最后终究还是能解决的。</p><p>对于 <code>SKSerialStream</code> 类，是否可以在所有情况下都能正常工作，我还不是特别有信心。但看起来，<code>SKSerialStream</code> 通过使用 URLSession 能很好地支持上传 multipart 数据。如果你在使用这份代码的时候发现任何问题，请务必联系我，我们可以一起不断优化这个类。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2018/11/streaming-multipart-requests/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-11-14&lt;br&gt;译者：&lt;a href=&quot;https://www.jianshu.com/u/076cc5e18bb8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;郑一一&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Foundation 框架中的 URL 类提供了非常全面的功能，此后还在 iOS 7 中新增了 URLSession 类。尽管如此，基础库中仍然缺少 multipart 文件上传的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Khanlou" scheme="https://swift.gg/categories/Khanlou/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="Objective-C" scheme="https://swift.gg/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Language Server Protocol</title>
    <link href="https://swift.gg/2019/01/15/nshipster-language-server-protocol/"/>
    <id>https://swift.gg/2019/01/15/nshipster-language-server-protocol/</id>
    <published>2019-01-15T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:03.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/language-server-protocol/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-11-19<br>译者：<a href="https://github.com/mobilefellow" target="_blank" rel="noopener">雨谨</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>上个月，苹果公司 <a href="https://forums.swift.org/t/new-lsp-language-service-supporting-swift-and-c-family-languages-for-any-editor-and-platform/17024" target="_blank" rel="noopener">在 Swift.org 论坛上宣布</a>，正在着手为 Swift 和 C 语言支持 <a href="https://microsoft.github.io/language-server-protocol/" target="_blank" rel="noopener">Language Server Protocol</a>（语言服务器协议，LSP）。</p><blockquote><p>对于苹果公司而言，为所有 Swift 开发者 —— 包括非苹果平台上的 —— 提供高质量的工具支持非常重要。我们希望与开源社区合作，将精力集中在构建 Xcode 和其他编辑器、其他平台可以共享的公共基础设施上。为实现这一目标，[……]，我们决定支持 LSP。</p><p><em>Argyrios Kyrtzidis，2018 年 10 月 15 日</em></p></blockquote><p><strong>这可能是苹果自 2014 年将 Swift 作为开源软件发布以来，为 Swift 做出的最重要的决定。</strong> 这对于 APP 开发者来说是一件大事，对于其他平台上的 Swift 开发者来说更是一件大事。</p><p>为了理解其中的原因，本周的文章将研究 Language Server Protocol 解决了什么问题，它是如何工作的，以及它的长期影响可能是什么。</p><a id="more"></a><blockquote><p><strong>更新</strong>：sourcekit-lsp 项目现在已经可以 <a href="https://github.com/apple/sourcekit-lsp" target="_blank" rel="noopener">在 GitHub 上访问</a> 了。</p></blockquote><hr><p>想象这样一个矩阵，每一行表示不同的编程语言（Swift、JavaScript、Ruby、Python 等），每一列表示不同的代码编辑器（Xcode、Visual Studio、Vim、Atom 等），这样每个单元格表示特定编辑器对一种语言的支持级别。</p><p><img src="https://nshipster.com/assets/lsp-languages-times-editors-b9a398af0dea85f2ad6dcf5412fbcb451a43bc90091d5e3ab3b1140da9926b3e.svg" alt="lsp-languages-times-editors.svg"></p><p>然后，你就发现各种组合形成了一种支离破碎的兼容。有些编辑器和部分语言深度集成，但除此之外几乎什么都干不了；其他编辑器则比较通用，对很多语言都提供了基本的支持。（IDE 这个术语通常用来描述前者。)</p><p>举个奇葩的例子：<em>你不用 Xcode 来开发 APP，却偏用来干其他事情。</em></p><p>为了更好地支持某一特定的语言，编辑器必须编写一些集成代码（integration code）—— 要么直接写在项目里，要么通过插件。由于不同语言和编辑器的实现机制不一样，因此比方说 Vim 改进了对 Ruby 支持，但这并不能让它更好地支持 Python，也不能让 Ruby 在 Atom 上运行地更好。最终的结果是：大量精力浪费在了不同技术的兼容上。</p><p>我们上面描述的情况通常被称为 <em>M × N 问题</em>，即最终的集成方案数量为编译器数量 M 与语言数量 N 的乘积。Language Server Protocol 所做的事情就是将 M × N 问题变成 <em>M + N 问题</em>。</p><p>编辑器不必实现对每种语言的支持，只需支持 LSP 即可。之后，它就能同等程度地支持所有支持 LSP 的语言。</p><p><img src="https://nshipster.com/assets/lsp-languages-plus-editors-904f780fa4a21e89b5b00bfe5fca39795dd54c1c4c67acf3f0fe095aaf09064d.svg" alt="lsp-languages-plus-editors.svg"></p><blockquote><p>Tomohiro Matsuyama 在 2010 年写的 <a href="https://tkf.github.io/2013/06/04/Emacs-is-dead.html" target="_blank" rel="noopener">“Emacs は死んだ” (<em>“Emacs 已死”</em>)</a> 这篇文章就对这种问题做出了一个很好的论述。Matsuyama 描述了 Emacs 脚本语言的局限性（不支持多线程、底层 API 过少、用户基数太小），他认为编写插件的首选方法应该是与外部程序进行交互，而不是原生实现。</p></blockquote><p>Language Server Protocol 为支持的语言提供了一套通用的功能集，包括：</p><ul><li>语法高亮（Syntax Highlighting）</li><li>自动格式化（Automatic Formatting）</li><li>自动补全（Autocomplete）</li><li>语法（Syntax）</li><li>工具提示（Tooltips）</li><li>内联诊断（Inline Diagnostics）</li><li>跳转到定义（Jump to Definition）</li><li>项目内查找引用（Find References in Project）</li><li>高级文本和符号搜索（Advanced Text and Symbol Search）</li></ul><p>各种工具和编辑器可以将精力用于提升可用性和提供更高级的功能，而不是为每种新技术再造个轮子。</p><h2 id="Language-Server-Protocol-的工作原理"><a href="#Language-Server-Protocol-的工作原理" class="headerlink" title="Language Server Protocol 的工作原理"></a>Language Server Protocol 的工作原理</h2><p>如果你是一个 iOS 程序员，那么一定很熟悉 <em>server</em> 和 <em>protocol</em> 这两个术语在 Web 应用程序的 HTTP + JSON 通信场景下的含义。实际上 Language Server Protocol 差不多也是这么工作的。</p><p>对于 LSP，<em>client</em> 是指编辑器 —— 或者更宽泛一点，是指工具，<em>server</em> 是指本地独立进程里运行的一个外部程序。</p><p>至于名字中包含 <em>protocol</em>，是因为 LSP 类似于一个精简版的 HTTP：</p><ul><li>每个消息都由报头部分和内容部分组成。</li><li>报头部分包含一个必填的 <code>Content-Length</code> 字段，用于说明内容部分的大小（以字节为单位），以及一个可选的 <code>Content-Type</code> 字段（默认值为 <code>application/vscode-jsonrpc; charset=utf-8</code>）。</li><li>内容部分使用 <a href="https://www.jsonrpc.org/specification" target="_blank" rel="noopener">JSON-RPC</a> 描述请求、响应和通知的结构。</li></ul><p>每当工具中发生了什么事情，比如用户需要跳转到符号的定义，工具就会向 server 发送一个请求。server 接收到该请求，然后返回适当的响应。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>: <span class="title">Parent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://nshipster.com/assets/lsp-jump-to-definition-f76ae15d897ab30706c101e7300cd299ad97f6b910ed79ce4890351c2805ae56.gif" alt="lsp-jump-to-definition.gif"></p><p>以下是 LSP 如何在幕后实现这种交互：</p><p>首先，当用户打开 Swift 代码时，若 Swift language server 并未运行，编辑器将在一个独立进程中启动它，并执行一些额外的配置。</p><p>当用户执行 “跳转到定义（jump to definition）” 指令时，编辑器向 Swift language server 发送以下请求：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"textDocument/definition"</span>,</span><br><span class="line">  <span class="attr">"params"</span>: &#123;</span><br><span class="line">    <span class="attr">"textDocument"</span>: &#123;</span><br><span class="line">      <span class="attr">"uri"</span>: <span class="string">"file:///Users/NSHipster/Example.swift"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"position"</span>: &#123;</span><br><span class="line">      <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"character"</span>: <span class="number">13</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到这个请求后，Swift language server 使用 <a href="https://github.com/apple/swift/tree/master/tools/SourceKit" target="_blank" rel="noopener">SourceKit</a> 等编译器工具来标识相应的代码实体，并在代码的上一行找到其声明的位置。然后 language server 用以下消息进行响应:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"result"</span>: &#123;</span><br><span class="line">    <span class="attr">"uri"</span>: <span class="string">"file:///Users/NSHipster/Example.swift"</span>,</span><br><span class="line">    <span class="attr">"range"</span>: &#123;</span><br><span class="line">      <span class="attr">"start"</span>: &#123;</span><br><span class="line">        <span class="attr">"line"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"character"</span>: <span class="number">6</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"end"</span>: &#123;</span><br><span class="line">        <span class="attr">"line"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"character"</span>: <span class="number">12</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，编辑器导航到文件(在本例中，该文件已经打开)，将光标移动到该范围，并高亮显示出来。</p><p>这种方法的美妙之处在于，编辑器完成所有这些操作时，除了 .swift 文件与 Swift 代码相关以外，对 Swift 编程语言一无所知。编辑器需要做的就是与 language server 对话并更新 UI。而且编辑器知道如何做到这一点后，就可以遵循相同的过程，与任何带有 language server 的语言所编写的代码进行交互。</p><h2 id="Clang-LLVM-里的-Language-Server-Protocol"><a href="#Clang-LLVM-里的-Language-Server-Protocol" class="headerlink" title="Clang / LLVM 里的 Language Server Protocol"></a>Clang / LLVM 里的 Language Server Protocol</h2><p>如果你觉得之前的 <em>M + N</em> 图有点眼熟，那可能是因为 LLVM 也采用了同样的方法。</p><p>LLVM 的核心是中间表示（intermediate representation，IR）。LLVM 所支持的语言使用 <em>编译器前端（compiler frontend）</em> 生成 IR，再使用 <em>编译器后端（compiler backend）</em> 将 IR 生成所支持平台的机器码。</p><p><img src="https://nshipster.com/assets/lsp-llvm-ir-34a10847cbe6519370c1b5e92def8f82b2ebde71aa2440c88880283bd5cbaf0a.svg" alt="lsp-llvm-ir.svg"></p><blockquote><p>如果你想了解 Swift 代码编译的更多细节，请查看 <a href="https://nshipster.com/swiftsyntax/" target="_blank" rel="noopener">我们关于 SwiftSyntax 的文章</a>。</p></blockquote><p><a href="https://clang.llvm.org" target="_blank" rel="noopener">Clang</a> 是 C 语言的 LLVM 编译器前端。Swift 与 Objective-C 的互操作性（inter-operability）就是靠它实现的。在最近的 5.0.0 版本中，Clang 添加了一个名为 <a href="https://clang.llvm.org/extra/clangd.html" target="_blank" rel="noopener">Clangd</a> 的新工具，它是 LLVM 对 Language Server Protocol 的实现。</p><p>2018 年 4 月，<a href="http://lists.llvm.org/pipermail/cfe-dev/2018-April/057668.html" target="_blank" rel="noopener">苹果公司向 LLVM 邮件组宣布</a>，将把开发的重心从 <a href="https://clang.llvm.org/doxygen/group__CINDEX.html" target="_blank" rel="noopener">libclang</a> 转向 Clangd，以其作为创建交互工具的主要方式。</p><p>现在你可能会想，<em>“那又怎样？”</em> 苹果公司是 LLVM 项目最重要的支持者之一，该项目创始人 Chris Lattner 已经在苹果公司工作了十多年。苹果公司决定从不透明的 Clang 工具切换到另一个，似乎是一个实现细节了(可以这么说)。</p><p>这个官宣很有趣的一点是，Clangd 似乎完全是在苹果以外开发的，谷歌和其他公司也做出了重大贡献。这个官宣标志着未来工具开发方向的重大转变 —— 六个月后 Swift.org 论坛将证实这一点。</p><h2 id="苹果支持-Language-Server-Protocol-的潜在影响"><a href="#苹果支持-Language-Server-Protocol-的潜在影响" class="headerlink" title="苹果支持 Language Server Protocol 的潜在影响"></a>苹果支持 Language Server Protocol 的潜在影响</h2><p>根据苹果公司 10 月份发布的 LSP 公告，我们预计在未来几周内（撰写本文时，最早 11 月中旬）将看到该项目的首批代码。</p><p>要感受这些发展的全部影响还需要一些时间，但请相信我：你的耐心是值得的。我相信以下是 LSP 在未来几个月和几年将会发生的一些事情。</p><h3 id="Swift-变成一种更加通用的编程语言"><a href="#Swift-变成一种更加通用的编程语言" class="headerlink" title="Swift 变成一种更加通用的编程语言"></a>Swift 变成一种更加通用的编程语言</h3><p>虽然 Swift 主要用于 APP 开发，但它从一开始就被设计成一种功能强大的通用编程语言。在 <a href="https://www.tensorflow.org/swift/" target="_blank" rel="noopener">Swift for TensorFlow</a>、<br><a href="https://github.com/apple/swift-nio" target="_blank" rel="noopener">SwiftNIO</a> 和其他项目中，我们正开始看到 Swift 承诺的在 App Store 之外的使用。</p><p>到目前为止，阻碍 Swift 被主流采用的最大因素之一是它对 Xcode 的依赖。</p><p>人们会有很多质疑，当有那么多优秀的、门槛低很多的替代方案可选的情况下，为什么还要让 Web 开发者或机器学习工程师仅仅为了尝试 Swift 而去下载 Xcode？支持 Language Server Protocol 可以让苹果生态圈以外的人更容易地使用他们熟悉工具去感受 Swift。</p><h3 id="Xcode-变得更好"><a href="#Xcode-变得更好" class="headerlink" title="Xcode 变得更好"></a>Xcode 变得更好</h3><p>支持 LSP 不仅仅是让 Swift 在其他编辑器中运行地更好，Xcode 也将受益匪浅。</p><p>看看苹果 Swift 项目负责人 Ted Kremenek 的 <a href="https://forums.swift.org/t/new-lsp-language-service-supporting-swift-and-c-family-languages-for-any-editor-and-platform/17024/29" target="_blank" rel="noopener">这篇论坛帖子</a>:</p><blockquote><p>@akyrtzi 所描述的 LSP 服务将比今天的 SourceKit 更强大。</p></blockquote><p>LSP 对 Xcode 团队来说是一个机遇，让他们使用一种新的方法实现 Swift 集成，并可以将其应用在语言和工具自 1.0 版本发布以来四年中的所有改进上。</p><h3 id="Xcode（最终）变得更强大"><a href="#Xcode（最终）变得更强大" class="headerlink" title="Xcode（最终）变得更强大"></a>Xcode（最终）变得更强大</h3><p>LSP 的好处并不限于 Swift 和 Objective-C，<a href="https://forums.swift.org/t/new-lsp-language-service-supporting-swift-and-c-family-languages-for-any-editor-and-platform/17024/33" target="_blank" rel="noopener">Argyrios 在那个帖子的另一个留言中指出</a>：</p><blockquote><p>Xcode 使用我们新的 LSP 服务，这意味着它也可以使用其他 LSP 服务，我们对此很感兴趣，不过目前暂无具体计划。</p></blockquote><p>目前的工作重点是改进 Swift。但是，一旦实现了这一点，就应该能相对简单地将这些优化转移到支持 LSP 的其他语言中。</p><hr><p>软件的架构反映了创建它的组织的结构和价值。在某种程度上，反之亦然。</p><p>通过让 Xcode 支持开放的 Language Server Protocol 标准，苹果正在履行其在苹果生态系统之外的平台上实现 Swift 成功的承诺。我认为这是可行的：工具（或缺少工具）通常是技术获得人心的关键决定因素。但或许更重要的是，我认为这一决定表明，公司内部（至少是一小部分）对合作和透明度的意愿有所增强。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mattt，&lt;a href=&quot;https://nshipster.com/language-server-protocol/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-11-19&lt;br&gt;译者：&lt;a href=&quot;https://github.com/mobilefellow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;雨谨&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;上个月，苹果公司 &lt;a href=&quot;https://forums.swift.org/t/new-lsp-language-service-supporting-swift-and-c-family-languages-for-any-editor-and-platform/17024&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在 Swift.org 论坛上宣布&lt;/a&gt;，正在着手为 Swift 和 C 语言支持 &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Language Server Protocol&lt;/a&gt;（语言服务器协议，LSP）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于苹果公司而言，为所有 Swift 开发者 —— 包括非苹果平台上的 —— 提供高质量的工具支持非常重要。我们希望与开源社区合作，将精力集中在构建 Xcode 和其他编辑器、其他平台可以共享的公共基础设施上。为实现这一目标，[……]，我们决定支持 LSP。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Argyrios Kyrtzidis，2018 年 10 月 15 日&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;这可能是苹果自 2014 年将 Swift 作为开源软件发布以来，为 Swift 做出的最重要的决定。&lt;/strong&gt; 这对于 APP 开发者来说是一件大事，对于其他平台上的 Swift 开发者来说更是一件大事。&lt;/p&gt;
&lt;p&gt;为了理解其中的原因，本周的文章将研究 Language Server Protocol 解决了什么问题，它是如何工作的，以及它的长期影响可能是什么。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>Swift 傻瓜技巧 #6：有动画或无动画</title>
    <link href="https://swift.gg/2019/01/07/stupid-swift-tricks-6-animations/"/>
    <id>https://swift.gg/2019/01/07/stupid-swift-tricks-6-animations/</id>
    <published>2019-01-07T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:03.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Wooji Juice，<a href="http://www.wooji-juice.com/blog/stupid-swift-tricks-6-animations.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-11-14<br>译者：<a href="https://github.com/alejx" target="_blank" rel="noopener">石榴</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>流畅的动画一开始就被认为是 iOS 应用的特点之一。这不仅归功于 iOS 系统强大的动画引擎（从而使得 App 能够一边展示流畅的动画一边做着其他的事情），还归功于系统提供的非常方便的动画 API：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无动画</span></span><br><span class="line">doStuff()</span><br><span class="line"><span class="comment">// 有动画</span></span><br><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">1</span>) &#123; doStuff() &#125;</span><br></pre></td></tr></table></figure><p>只需要将你的代码放进 block（闭包）中，就可以让它们拥有流畅的缓入缓出的动画效果。</p><p>然而，如果你使用过这套系统，你可能会遇到一些问题。这个系统可以完美地处理简单的情况，比如让一个东西淡入、淡出，或改变它的颜色，但在更复杂的情况下，这种方法就会开始出现问题。</p><a id="more"></a><p>例如下面这个例子，你想要淡出一个元素，然后删除它。<code>UIView</code> 支持这种操作：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">1</span>, animations:</span><br><span class="line">&#123;</span><br><span class="line">someting.alpha = <span class="number">0</span></span><br><span class="line">&#125;, completion:</span><br><span class="line">&#123;</span><br><span class="line">something.removeFormSuperView()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>但你只能把所有东西都写在 <code>completion</code> block 里时才会工作。在大型项目中，我们需要把复杂的任务拆解成小的方法。但问题就在这些方法中，像在上个例子中的 <code>doStuff()</code>，我们无法在 <code>completion</code> block 中添加代码。</p><p>我们也无法得知动画有多长（甚至都不知道有没有动画），所以如果我们没有办法简单地和动画时间之间同步（如在 <a href="http://www.wooji-juice.com/products/ferrite/" target="_blank" rel="noopener">一个音频编辑软件</a> 中让进度条同步前进）。</p><p>总的来说，我们无法获知关于动画的<em>信息</em>，他们仅仅是执行代码，进行或不进行动画，并不会受我们控制。</p><p>如果我们在视图中添加带有 Auto Layout 的新元素，事情就会变得更复杂：你需要小心地调用 <code>UIView.performWithoutAnimation { }</code>，否则新出现的视图就会从 <code>(x: 0, y: 0, w: 0, h: 0)</code> 瞬移到它们的目标位置。</p><h2 id="视图属性-Animator"><a href="#视图属性-Animator" class="headerlink" title="视图属性 Animator"></a>视图属性 Animator</h2><p>很长时间以来，我一直在改变代码中动画的写法。最开始我写了我自己的 <code>AnimationContext</code> 类来协助，后来苹果提供了他们功能相同的 <code>UIViewPropertyAnimator</code>，现在我会在所有可能的地方使用它。</p><p>一般来说，我发现最有效的方法是写一个「可动画」的方法并显式接受一个 animator 参数：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doStuff</span><span class="params">(with animator: UIViewPropertyAnimator? = <span class="literal">nil</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后我就可以直接调用 <code>doStuff()</code> 不添加动画并完成任务，或调用 <code>doStuff(with: UIViewPropertyAnimator(duration: 1, curve: .easeInOut))</code> 或加其他的参数去完成任务并添加动画。</p><p>（实际情况中，上述方法通常会被称作 <code>reflectCurrentState()</code> 或其他特定领域的名字；该方法执行所有必要的修改，并将视图与最新的数据同步。该方法一般不会被本视图以外的代码调用，而是被视图自己调用，然后会根据需要继续调用其他内部方法，或将 animator 传给其他内部方法。不过这不在本文的讨论范围内。）</p><p><code>doStuff()</code> 可以像之前一样，带有或不带有动画执行一个任务。但现在它带有了更多信息：它知道自己是否执行动画；它可以读取 animator 的 <code>duration</code> 属性（如果有的话）。他可以调用 animator 的 <code>addAnimation</code> 来明确地指定哪些代码需要动画，并直接执行不需要动画的代码；他可以调用 <code>addCompletion</code> 来处理 <code>removeFromSuperView()</code> 或其他方法。</p><p>以上都是相比于之前改进的地方，但也不是没有问题。尤其是它开始变得有点啰嗦：</p><ol><li><code>doStuff(with: ...)</code> 需要写入一个很长的 <code>UIViewPropertyAnimator</code> 构造函数。不是很理想，不过跟下面比起来不算什么：</li><li>在 <code>doStuff()</code> 内部，需要检查 <code>UIViewPropertyAnimator</code> 是否存在并调整代码。</li></ol><p>我们不能简单的依赖 optional chaining（可选链式调用)（如 <code>animator?.addcompletion { something.removeFromSuperview() }</code>），因为如果 animator 是 <code>nil</code> 会导致 block 中的代码被直接跳过，然而无论有没有动画，我们都希望该视图在父视图中被移除。</p><p>为了保证正确的行为，你的代码会类似这个样子：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doStuff</span><span class="params">(with animator: UIViewPropertyAnimator? = <span class="literal">nil</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> animator = animator</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">_</span> <span class="keyword">in</span> something.removeFromSuperview()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">something.removeFromSuperview()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Objective-C 爱好者即使瞧不起 Optional（可选）也笑不出来 – 使用 Objective-C 也不会改善这种情况：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) doStuffWithAnimator: (<span class="keyword">nullable</span> <span class="built_in">UIViewPropertyAnimator</span> *) animator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (animator != <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">[animator addCompletion: ^(<span class="built_in">UIViewAnimatingPosition</span> position)</span><br><span class="line">&#123;</span><br><span class="line">[something removeFromSuperview];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">[something removeFromSuperView];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一旦你在生产环境中想使用这样的代码，你最终会写出更杂乱、更难于阅读和维护的代码。</p><p>幸运的是，我们可以进一步的改进这段代码。</p><h2 id="Optional-不是-Nil-的另一个叫法"><a href="#Optional-不是-Nil-的另一个叫法" class="headerlink" title="Optional 不是 Nil 的另一个叫法"></a>Optional 不是 <code>Nil</code> 的另一个叫法</h2><p>改进这段代码的诀窍就在于，<code>UIViewPropertyAnimator</code> 在这里是 Optional，关键点就在于 Optional 在 Swift 中的意义。</p><p>有的时候人们会抱怨 Swift 的 Optional 非常烦人，因为在 Objective-C 中（Objective-C 中使用 <code>nil</code> 指针来替代 Swift 中的 Optional）你可以直接对指针调用方法。</p><p>Objective-C 不会抱怨指针是不是 <code>nil</code>：如果指针非空，方法会直接被调用；如果是空指针，调用会被无声地忽略掉，不用程序员做其他的事情。</p><p>我不同意这个意见。在 Swift 中，在你知道你在做什么的情况下，你只需要加一个 <code>?</code>，并不是一个很大的负担。但是由于有了 Swift 的 Optional，我们可以做更多事情。</p><p>因为在 Swift 中，Optional 是一个“真实的东西”，而不是“缺少的东西”。无论一个 Optional 的值是什么，就算是 <code>nil</code>，它也是一个枚举值，你可以对它调用方法，调用的方法也会被执行。<a href="http://www.wooji-juice.com/blog/stupid-swift-tricks-5-enums" target="_blank" rel="noopener">讲真的，Swift 的枚举超级好用！</a></p><p>（有趣的是，在 Objective-C 类中对 Swift 的 <code>nil</code> 的底层表示<em>就是</em>空指针，所以它们的效率还是很高的。但是语法层面，它们非常的不同。我们会在接下来利用这个性质。）</p><p>因为在 Swift 中，你可以对几乎所有类型添加拓展，不仅仅是 Objective-C 类。你可以：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> <span class="title">where</span> <span class="title">Wrapped</span> == <span class="title">UIViewPropertyAnimator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    @discardableResult</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addCompletion</span><span class="params">(<span class="number">_</span> block: @escaping <span class="params">(UIViewAnimatingPosition)</span></span></span>-&gt;()) -&gt; <span class="type">Optional</span>&lt;<span class="type">UIViewPropertyAnimator</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> animator = <span class="keyword">self</span></span><br><span class="line">        &#123;</span><br><span class="line">            animator.addCompletion(block)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            block(.end)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码将难看的代码移动到了 Optional 的库中（但只针对 <code>UIViewPropertyAnimator</code>）。现在，你的视图可以：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doStuff</span><span class="params">(with animator: UIViewPropertyAnimator? = <span class="literal">nil</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">animator.addCompletion &#123; <span class="number">_</span> <span class="keyword">in</span> something.removeFromSuperview() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在回调函数总会被执行，无论有没有 animator。</p><p>（注意 <code>animator</code> 和 <code>addCompletion</code> 之间没有 <code>?</code>）</p><p>如果有 animator，block 中的代码会在动画完成时被调用；如果没有 animator，block 中的代码会被立即调用，因为 <code>nil</code> Optional 仍然是 Optional，拥有所有 Optional 的方法，当然也包括我们刚刚添加的方法 – 而不是一个吞下所有的滚落到它表面的方法调用的黑洞。</p><p>我还有类似的拓展方法来执行总是需要被执行的任务，有些是动画的一部分，或其他的立即执行的代码：如果我想让一个元素缓入，我会在把元素放入视图之前将 alpha 值设置成 0，然后调用 <code>animator.perform { something.alpha = 1 }</code> 来保证它无论有没有动画都会变得可见。</p><p>与 Optional 无关，我还在 <code>UIViewPropertyAnimator</code> 中添加了一些静态方法来生成一些常见的动画，如：<code>static func spring(...)</code>、<code>static func linear(...)</code>。Swift 的名称解析方法决定了你可以写出更简洁的代码，如：<code>doStuff(with: .spring(duration: 1))</code>。</p><p>当然，以上只是一些小的代码技巧，而不是重新构想代码或应用结构。但是随着项目的复杂度增加，像这种小的改进也会叠加起来，帮助我们对抗不断增加的复杂度，维持大型项目的可控性。谢谢你，Swift。<a href="https://www.youtube.com/watch?v=9jtU9BbReQk" target="_blank" rel="noopener">Thwift</a>.</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Wooji Juice，&lt;a href=&quot;http://www.wooji-juice.com/blog/stupid-swift-tricks-6-animations.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-11-14&lt;br&gt;译者：&lt;a href=&quot;https://github.com/alejx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;石榴&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/Cee&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cee&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;流畅的动画一开始就被认为是 iOS 应用的特点之一。这不仅归功于 iOS 系统强大的动画引擎（从而使得 App 能够一边展示流畅的动画一边做着其他的事情），还归功于系统提供的非常方便的动画 API：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 无动画&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;doStuff()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 有动画&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;.animate(withDuration: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123; doStuff() &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;只需要将你的代码放进 block（闭包）中，就可以让它们拥有流畅的缓入缓出的动画效果。&lt;/p&gt;
&lt;p&gt;然而，如果你使用过这套系统，你可能会遇到一些问题。这个系统可以完美地处理简单的情况，比如让一个东西淡入、淡出，或改变它的颜色，但在更复杂的情况下，这种方法就会开始出现问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Wooji Juice" scheme="https://swift.gg/categories/Wooji-Juice/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="教程" scheme="https://swift.gg/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hacking Hit Tests</title>
    <link href="https://swift.gg/2018/12/27/hacking-hit-tests/"/>
    <id>https://swift.gg/2018/12/27/hacking-hit-tests/</id>
    <published>2018-12-27T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2018/09/hacking-hit-tests/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-09-07<br>译者：<a href="https://nemocdz.github.io/" target="_blank" rel="noopener">Nemocdz</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>回想 <a href="https://developer.apple.com/videos/play/wwdc2015/408/" target="_blank" rel="noopener">Crusty 教我们使用面向协议编程</a>之前的日子，我们大多使用继承来共享代码的实现。通常在 UIKit 编程中，你可能会用 <code>UIView</code> 的子类去添加一些子视图，重写 <code>-layoutSubviews</code>，然后重复这些工作。也许你还会重写 <code>-drawRect</code>。但当你需要做一些特别的事情时，就需要看看 <code>UIView</code> 中其他可以被重写的方法。</p><a id="more"></a><p><code>UIKit</code> 有个十分古怪的地方，那是它的触摸事件处理系统。它主要包括两个方法，<code>-pointInstide:withEvent:</code> 和 <code>-hitTest:withEvent:</code>。</p><p><code>-pointInside:</code> 会告诉调用者给定点是否包含在指定的视图区域中。而 <code>-hitTest:</code> 用 <code>pointInside:</code> 这个方法来告诉调用者哪个子视图（如果有的话）是当前触摸在给定点的接收者。现在我比较感兴趣的是后面这个方法。</p><p>苹果的文档勉强能够让你理解怎么重新实现这个方法。在你学会怎么重新实现方法之前，你都不能改变它的功能。接下来让我们看一遍 <a href="https://developer.apple.com/documentation/uikit/uiview/1622469-hittest?language=objc" target="_blank" rel="noopener">文档</a>，并尝试重写这个函数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">hitTest</span><span class="params">(<span class="number">_</span> point: CGPoint, with event: UIEvent?)</span></span> -&gt; <span class="type">UIView</span>? &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，让我们从文档的第二段开始吧：</p><blockquote><p>这个方法会忽略那些隐藏的视图，禁用用户交互视图和 alpha 等级小于 0.01 的视图。</p></blockquote><p>让我们通过一些 <code>gurad</code> 语句来快速预处理这些前提条件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? &#123;</span><br><span class="line"></span><br><span class="line">guard isUserInteractionEnabled else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">guard !isHidden else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">guard alpha &gt;= 0.01 else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>相当简单吧。那接下来是？</p><blockquote><p>这个方法调用 <code>pointInside:withEvent:</code> 方法来遍历接收视图层级中每一个子视图，来决定哪个子视图来接收该触摸事件。</p></blockquote><p>逐字阅读文档后，感觉 <code>-pointInside:</code> 会在每一个子视图里被调用（用一个 for 循环），但这并不是完全正确的。</p><p>感谢这个 <a href="https://twitter.com/an0/status/1038254836016394240" target="_blank" rel="noopener">读者</a>。通过他在 <code>-hitTest:</code> 和 <code>-pointInside:</code> 中放置了断点的试验，我们知道 <code>-pointInside:</code> 会在 <code>self</code> 中调用（在有上面那些 guard 的情况下），而不是在每一个子视图中。 所以应该添加另外的 guard 语句，像下面这行代码一样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">self</span>.point(inside: point, with: event) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br></pre></td></tr></table></figure><p><code>-pointInside:</code> 是 <code>UIView</code> 另一个需要重写的方法。它的默认实现会检查传入的某个点是否包含在视图的 <code>bounds</code> 中。如果调用 <code>-pointInside</code> 返回 true，那么意味着触摸事件发生在它的 bounds 中。</p><p>理解完这个小小的差别后，我们可以继续阅读文档了：</p><blockquote><p>如果 <code>-pointInside:withEvnet:</code> 返回 YES，那么子视图的层级也会进行类似的遍历直到找到包含指定点的最前面的视图。</p></blockquote><p>所以，从这里知道我们需要遍历视图树。这意味着循环遍历所有的视图，并调用 <code>-hitTest:</code> 在它们每一个上去找到合适的子视图。在这种情况下，这个方法是递归的。</p><p>为了遍历视图层级，我们需要一个循环。然而，这个方法其中一个更反人类的是需要反向遍历视图。子视图数组中尾部的视图反而会处在 Z 轴中<em>更高</em>的位置，所以它们应该被最先检验。（如果没有这篇 <a href="http://smnh.me/hit-testing-in-ios/" target="_blank" rel="noopener">文章</a>，我可记不起这个点。）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> subview <span class="keyword">in</span> subviews.reversed() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>传入的坐标点会转换到<em>当前</em>视图的坐标系中，而非我们关心子视图中。幸运的是，UIKit 给了一个处理函数，去转换坐标点的参考系到其他任何的视图的 frame 的参考系中。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> subview <span class="keyword">in</span> subviews.reversed() &#123;</span><br><span class="line"><span class="keyword">let</span> convertedPoint = subview.convert(point, from: <span class="keyword">self</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>一旦有了转换后的坐标点，我们就可以很简单地询问每一个子视图该点的目标视图。需要注意的是，如果点处于该视图外部（也就是说，<code>-pointInside:</code> 返回 <em>false</em>），<code>-hitTest</code> 会返回 nil。这时就应该检查层级里的下一个子视图。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> convertedPoint = subview.convert(point, from: <span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> candidate = subview.hitTest(convertedPoint, with: event) &#123;</span><br><span class="line"><span class="keyword">return</span> candidate</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>一旦我们有了合适的循环语句，最后一件需要做的事是 <code>return self</code>。如果视图是可被点击（被我们的 <code>guard</code> 语句断言过的情况），但却没有子视图想要处理这个触摸的话，意味着当前视图，也就是 <code>self</code>，是这个触摸正确的目标。</p><p>这是完整的算法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">hitTest</span><span class="params">(<span class="number">_</span> point: CGPoint, with event: UIEvent?)</span></span> -&gt; <span class="type">UIView</span>? &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> isUserInteractionEnabled <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> !isHidden <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> alpha &gt;= <span class="number">0.01</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">self</span>.point(inside: point, with: event) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> subview <span class="keyword">in</span> subviews.reversed() &#123;</span><br><span class="line"><span class="keyword">let</span> convertedPoint = subview.convert(point, from: <span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> candidate = subview.hitTest(convertedPoint, with: event) &#123;</span><br><span class="line"><span class="keyword">return</span> candidate</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们有了一个参考的实现，可以开始修改它来实现具体的行为。</p><p>在之前的这篇播客<a href="http://khanlou.com/2013/04/changing-the-size-of-a-paging-scroll-view/" target="_blank" rel="noopener">《Changing the size of a paging scroll view》</a>中，我就已经讨论过其中一种行为。我谈到一种“落后并该被废弃”的方法来产生这种效果。本质上，你必须：</p><ol><li>关掉 <code>clipsToBounds</code></li><li>在滑动区域中放一个非隐藏视图</li><li>在非隐藏视图上重写 <code>-hitTest:</code> 来传递所有触摸到 scrollview 中</li></ol><p><code>-hitTest:</code> 方法是这种技术的基石。因为在 UIKit 中，hitTest 方法会代理给每一个视图去实现，决定触摸事件传递给哪个视图接收。这可以让你去重写默认的实现（期望和普通的实现）并替换它为你想做的，甚至返回一个不是原始视图的子视图。多么疯狂。</p><p>让我们看一下另一个例子。如果你已经用过 <a href="http://beacon.party/" target="_blank" rel="noopener">Beacon</a> 今年的版本，你会注意到滑动删除事件行为的物理效果感觉上和其他用原生系统实现的效果有点不一样。这是因为用系统的途径不能完全获得我们想要的表现，所以需要自己重新实现这个功能。</p><p>如你所想，重写滑动和反弹物理效果不需要那么复杂，所以我们用一个 <code>UIScrollView</code> 和将 <code>pagingEnabled</code> 设为 true 来获得尽可能自由的反弹力。用和<a href="http://khanlou.com/2013/04/changing-the-size-of-a-paging-scroll-view/" target="_blank" rel="noopener">这篇旧博客</a>里说的类似的技术，将滑动的视图的 <code>bounds</code> 设置得更小一些并将 <code>panGestureRecognizer</code> 移到事件的 cell 顶层的一个覆盖视图中，来设置一个自定义页面大小。</p><p>然而，当覆盖视图正确的传递触摸事件到 scroll view 时，那里会有覆盖视图不能正确拦截的其他事件。cell 包含着按钮，像 “join event” 按钮和 “delete event” 按钮，都需要接收触摸。有几种自定义实现在 <code>-hitTest:</code> 中可以处理这种情况，其中一种实现就是直接检查这两个按钮的子视图：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">hitTest</span><span class="params">(<span class="number">_</span> point: CGPoint, with event: UIEvent?)</span></span> -&gt; <span class="type">UIView</span>? &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> isUserInteractionEnabled <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> !isHidden <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> alpha &gt;= <span class="number">0.01</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">self</span>.point(inside: point, with: event) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> joinButton.point(inside: convert(point, to: joinButton), with: event) &#123;</span><br><span class="line"><span class="keyword">return</span> joinButton</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isDeleteButtonOpen &amp;&amp; deleteButton.point(inside: convert(point, to: deleteButton), with: event) &#123;</span><br><span class="line"><span class="keyword">return</span> deleteButton</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.hitTest(point, with: event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法会正确地传递正确的点击事件到正确的的按钮中，而且不用打断显示删除按钮的滑动表现。（你可以尝试只忽略 <code>deletionOverlay</code>，不过它不会正确的传递滑动事件。）</p><p><code>-hitTest:</code> 是视图中一个很少重写的地方，但是在需要时，可以提供其他工具很难做到的行为。理解如何自己实现有助于随意替换它。你可以用这个技术去扩大点击的目标区域，去除触摸处理中的某些子视图，而不用把它们从可见的层级中去掉，又或是用一个视图作为另一个将响应触摸的视图的兜底。所有东西都是可能的。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2018/09/hacking-hit-tests/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-09-07&lt;br&gt;译者：&lt;a href=&quot;https://nemocdz.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nemocdz&lt;/a&gt;；校对：&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;回想 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/408/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Crusty 教我们使用面向协议编程&lt;/a&gt;之前的日子，我们大多使用继承来共享代码的实现。通常在 UIKit 编程中，你可能会用 &lt;code&gt;UIView&lt;/code&gt; 的子类去添加一些子视图，重写 &lt;code&gt;-layoutSubviews&lt;/code&gt;，然后重复这些工作。也许你还会重写 &lt;code&gt;-drawRect&lt;/code&gt;。但当你需要做一些特别的事情时，就需要看看 &lt;code&gt;UIView&lt;/code&gt; 中其他可以被重写的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="iOS开发" scheme="https://swift.gg/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>固定大小的数组</title>
    <link href="https://swift.gg/2018/12/24/fixed-sized-arrays/"/>
    <id>https://swift.gg/2018/12/24/fixed-sized-arrays/</id>
    <published>2018-12-24T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Russ Bishop，<a href="http://www.russbishop.net/fixed-sized-arrays" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-10-30<br>译者：<a href="https://github.com/zhongWJ" target="_blank" rel="noopener">zhongWJ</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>假设我们想要用 <code>statfs()</code> 方法来确定某个挂载点所对应的 <code>BSD</code> 设备名。例如挂载点 <code>/Volumes/MyDisk</code> 对应的 <code>BSD</code> 设备是 <code>/dev/disk6s2</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">statfs</span> <span class="title">fsinfo</span>;</span></span><br><span class="line"><span class="keyword">if</span> (statfs(path, &amp;fsinfo) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>同等的 Swift 代码如下，只不过多了个 <code>POSIX</code> 错误帮助方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">posix_expects_zero</span>&lt;R: BinaryInteger&gt;<span class="params">(<span class="number">_</span> f: @autoclosure <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">R</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> returncode = <span class="keyword">try</span> f()</span><br><span class="line">    <span class="keyword">if</span> returncode != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果需要，请在此处替换为自定义的错误类型。</span></span><br><span class="line">        <span class="comment">// NSError 会自动帮我们通过错误码得到对应的 C 字符串错误消息。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="type">NSError</span>(</span><br><span class="line">            domain: <span class="type">NSPOSIXErrorDomain</span>,</span><br><span class="line">            code: <span class="built_in">numericCast</span>(returncode),</span><br><span class="line">            userInfo: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用默认的空初始化方法。Swift 能推断出结构体类型，</span></span><br><span class="line"><span class="comment">// 但为了表示得更清楚，这里显式指定类型</span></span><br><span class="line"><span class="keyword">var</span> fsinfo: statfs = statfs()</span><br><span class="line">statfs(path, &amp;fsinfo)</span><br></pre></td></tr></table></figure><h2 id="C-的引入物"><a href="#C-的引入物" class="headerlink" title="C 的引入物"></a>C 的引入物</h2><p><code>statfs()</code> 函数在 C 语言的定义是 <code>int statfs(const char *path, struct statfs *info)</code>。<code>statfs</code> 结构体有多个字段，但我们只关注 <code>mount-from-name</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">statfs</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">char</span> f_mntfromname[MAXPATHLEN];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在苹果平台上 MAXPATHLEN == PATH_MAX == 1024。</p><p>如果你在代码里硬编码 1024 而不是用更合适的宏，小心我的鬼魂会缠着你和你的家族十二代哦。</p></blockquote><p>噢哦。一个固定大小的数组。当被引入 Swift 中时，它会被当做一个有 1024 个元素的元组：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> f_mntfromname: (<span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>, <span class="type">Int8</span>)</span><br></pre></td></tr></table></figure><p>这个类型不是很实用。那我们能不能做点什么呢？由于这篇博客的存在，你可能已经猜到答案是「<em>是</em>」。</p><h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C 字符串"></a>C 字符串</h2><p>这个固定大小的数组包含了 <code>char</code>。由于文档未曾提及，所以我们并不知道是否通过空字符来表示数组的终止。令人恼火的是，文档暗示在 64 位系统上，<code>f_fstypename</code> 字段是由空字符终止，但对于 mount to/from 两个字段却只字未提。这两个字段是根据被定义为 <code>PATH_MAX</code> 的 <code>MAXPATHLEN</code> 宏来定义的而不是直接根据 <code>PATH_MAX</code> 宏，而 <code>PATH_MAX</code> 宏通常暗示数组由空字符来表示终止。我们是不是应该从中得到一点启发呢？</p><p>对于固定大小的数组，有一些 C API 仍然采用空终止符（所以真实的字符串长度最长可以是 <code>sizeof(array) - 1</code>），而另一些则乐意填充整个缓冲区（所以不以空字符结尾的字符串长度最长可以是 <code>sizeof(array)</code>）。这就是那种有害的绊脚石，它让你的程序看起来运行正常并通过所有测试，然后碰到某些新的 FizzyWizz 硬盘系统会有的奇怪的边界情况时，当突然碰到一个刚好由 1024 个字符组成的名称特别长的 BSD 设备时，结果就是你的程序出现了「<em>可利用内存损坏</em>」错误。</p><p>这些值很有可能是空字符终止的（也可能不是），但我会告诉你如何来处理这个问题，以便在两种情况下都适用。这意味着我们再也不需要考虑这个问题，从而降低大脑负荷。在其他场景复用这个代码的人也不需要再考虑这个问题了。既然有这么大的好处，何不马上开始？</p><p>偏题了，让我们回到正题……</p><h2 id="部分解决方案"><a href="#部分解决方案" class="headerlink" title="部分解决方案"></a>部分解决方案</h2><p>首先我们需要计算字段的偏移量。用新的 <code>MemoryLayout.offset</code> 方法可以得到结果：<code>MemoryLayout&lt;statfs&gt;.offset(of: \Darwin.statfs.f_mntfromname)!</code>。由于结构体和函数名字相同，当我们构造关键路径时，需要提供完整的路径名（fully-qualified name），否则会得到「<em>无法确定有歧义的引用路径</em>」的错误。我们可以强制解包返回值因为我们知道关键路径有效并且字段有偏移量。</p><p>将字段的内存布局偏移量加上 <code>withUnsafePointer</code> 指针就可以得到一个指向结构体字段起始内存的指针。我们可以通过这种方式创建一个字符串对象：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">withUnsafePointer</span>(to: fsinfo, &#123; (ptr) -&gt; <span class="type">String</span>? <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> offset = <span class="type">MemoryLayout</span>&lt;statfs&gt;.offset(of: \<span class="type">Darwin</span>.statfs.f_mntfromname)!</span><br><span class="line">    <span class="keyword">let</span> fieldPtr = (<span class="type">UnsafeRawPointer</span>(ptr) + offset).assumingMemoryBound(to: <span class="type">UInt8</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">if</span> fieldPtr[<span class="built_in">count</span> - <span class="number">1</span>] != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="type">Data</span>(bytes: <span class="type">UnsafeRawPointer</span>(fieldPtr), <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(data: data, encoding: .utf8)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(cString: fieldPtr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们首先快速检查了缓冲区是否是空字符结尾。如果是，就采用 C 字符串这条捷径。反之，为了便于使用 String 的长度限制构造方法，我们创建了一个 Data 实例。看起来用 <code>Data(bytesNoCopy:count:deallocator:)</code> 也行，但 <code>String(data:encoding:)</code> 初始化方法并不保证拷贝 Data 底层的缓冲区，<code>Data</code> 的构造过程也同样如此。虽然这种情况极少见，我们还是谨慎为好。（假如目前的方法会导致性能问题，我可能会花时间调研其他方案。）</p><p>有一种可能情况是，先写入由空字符终止的较短的字符串到缓冲区，剩余的部分则是被垃圾数据填充。由于 Swift 在初始化结构体时会强制清除内存，所以只有当内核拷贝垃圾数据到这块地址时，上述情况才可能发生。我们可以忽略这种情况，因为内核会尽量避免泄漏内核内存到用户空间，否则我们就只能用更耗时的方式了。（将这些字节转换为字符串的方式数不胜数，我这里就不一一列举了。）</p><p>现在我们来实现 <code>statfs</code> 的扩展：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">statfs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mntfromname: <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">mutating</span> <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">withUnsafePointer</span>(to: fsinfo, &#123; (ptr) -&gt; <span class="type">String</span>? <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> offset = <span class="type">MemoryLayout</span>&lt;statfs&gt;.offset(of: \<span class="type">Darwin</span>.statfs.f_mntfromname)!</span><br><span class="line">                <span class="keyword">let</span> fieldPtr = (<span class="type">UnsafeRawPointer</span>(ptr) + offset).assumingMemoryBound(to: <span class="type">UInt8</span>.<span class="keyword">self</span>)</span><br><span class="line">                <span class="keyword">let</span> <span class="built_in">count</span> = <span class="type">Int</span>(<span class="type">MAXPATHLEN</span>)</span><br><span class="line">                <span class="keyword">if</span> fieldPtr[<span class="built_in">count</span> - <span class="number">1</span>] != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> data = <span class="type">Data</span>(bytes: <span class="type">UnsafeRawPointer</span>(fieldPtr), <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="type">String</span>(data: data, encoding: .utf8)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="type">String</span>(cString: fieldPtr)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很管用，但假如我们也想处理别的字段，例如 <code>f_mntoname</code> 呢？复制代码似乎不怎么好，所以让这段代码支持泛型，使之更加通用才对；我们只需要接受 key path 和 count 作为参数，再稍作修改就可以了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fixedArrayToString</span>&lt;T&gt;<span class="params">(t: T, keyPath: PartialKeyPath&lt;T&gt;, <span class="built_in">count</span>: Int)</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">withUnsafePointer</span>(to: t) &#123; (ptr) -&gt; <span class="type">String</span>? <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> offset = <span class="type">MemoryLayout</span>&lt;<span class="type">T</span>&gt;.offset(of: keyPath)!</span><br><span class="line">        <span class="keyword">let</span> fieldPtr = (<span class="type">UnsafeRawPointer</span>(ptr) + offset).assumingMemoryBound(to: <span class="type">UInt8</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">if</span> fieldPtr[<span class="built_in">count</span> - <span class="number">1</span>] != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> data = <span class="type">Data</span>(bytes: <span class="type">UnsafeRawPointer</span>(fieldPtr), <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">String</span>(data: data, encoding: .utf8)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">String</span>(cString: fieldPtr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">statfs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mntfromname: <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fixedArrayToString(</span><br><span class="line">                t: <span class="keyword">self</span>,</span><br><span class="line">                keyPath: \<span class="type">Darwin</span>.statfs.f_mntfromname,</span><br><span class="line">                <span class="built_in">count</span>: <span class="type">Int</span>(<span class="type">MAXPATHLEN</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mntonname: <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fixedArrayToString(</span><br><span class="line">                t: <span class="keyword">self</span>,</span><br><span class="line">                keyPath: \<span class="type">Darwin</span>.statfs.f_mntonname,</span><br><span class="line">                <span class="built_in">count</span>: <span class="type">Int</span>(<span class="type">MAXPATHLEN</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>现在你知道怎么把有 N 个元素的元组变成更实用的东西了吧。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      如何在 Swift 中处理从 C 语言引入的固定大小数组
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 属性观察器</title>
    <link href="https://swift.gg/2018/12/17/swift-property-observers/"/>
    <id>https://swift.gg/2018/12/17/swift-property-observers/</id>
    <published>2018-12-17T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/swift-property-observers/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-08-20<br>译者：<a href="http://wuqiuhao.github.io" target="_blank" rel="noopener">Hale</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>到了 20 世纪 30 年代，Rube Goldberg 已成为家喻户晓的名字，与 <a href="https://upload.wikimedia.org/wikipedia/commons/a/a9/Rube_Goldberg%27s_%22Self-Operating_Napkin%22_%28cropped%29.gif" target="_blank" rel="noopener">“自营餐巾”</a> 等漫画中描绘的奇异复杂和异想天开的发明同义。大约在同一时期，阿尔伯特·爱因斯坦对尼尔斯·玻尔量子力学的普遍解释进行了 <a href="https://en.wikipedia.org/wiki/EPR_paradox" target="_blank" rel="noopener">批判</a>，并从中提出了“鬼魅似的远距作用”这一词汇。</p><p>近一个世纪之后，现代软件开发已经被视为可能成为 Goldbergian 装置的典范——通过量子计算机相信我们会越来越接近这个鬼魅的领域。</p><p>作为软件开发人员，我们提倡尽可能减少代码中的远程操作。这是根据一些众所周知的规范法则得出的，如 <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="noopener">单一职责原则</a>、<a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment" target="_blank" rel="noopener">最少意外原则</a> 和 <a href="https://en.wikipedia.org/wiki/Law_of_Demeter" target="_blank" rel="noopener">笛米特法则</a>。尽管它们可能会对代码产生一定的副作用，但更多的时候这些原则能使代码逻辑变得清晰。</p><p>这是本周关于 Swift 属性观察文章的焦点，它提出了一种内置的轻量级替代方案，适用于更正式的解决方案，如模型 - 视图 - 视图模型（MVVM）函数响应式编程（FRP）。</p><a id="more"></a><p>Swift 中有两种属性：<em>存储属性</em>，它们将状态和对象相关联；<em>计算属性</em>，则根据该状态执行计算。例如，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储属性</span></span><br><span class="line">    <span class="keyword">var</span> stored: <span class="type">String</span> = <span class="string">"stored"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算属性</span></span><br><span class="line">    <span class="keyword">var</span> computed: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"computed"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你声明一个存储属性，你可以使用闭包定义一个 <em>属性观察器</em>，该闭包中的代码会在属性被设值的时候执行。<code>willSet</code> 观察器会在属性被赋新值之前被运行，<code>didSet</code> 观察器则会在属性被赋新值之后运行。无论新值是否等于属性的旧值它们都会被执行。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stored: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"willSet was called"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"stored is now equal to <span class="subst">\(<span class="keyword">self</span>.stored)</span>"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"stored will be set to <span class="subst">\(newValue)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"didSet was called"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"stored is now equal to <span class="subst">\(<span class="keyword">self</span>.stored)</span>"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"stored was previously set to <span class="subst">\(oldValue)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，运行下面的代码在控制台的输出如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="type">S</span>(stored: <span class="string">"first"</span>)</span><br><span class="line">s.stored = <span class="string">"second"</span></span><br></pre></td></tr></table></figure><ul><li>willSet was called</li><li>stored is now equal to first</li><li>stored will be set to second</li><li>didSet was called</li><li>stored is now equal to second</li><li>stored was previously set to first</li></ul><blockquote><p>需要注意的是当属性在初始化方法中进行赋值时，不会触发观察器的代码。从 Swift4.2 开始，你可以将赋值逻辑包装在 <code>defer</code> 代码块来解决这个问题，但这是 <a href="https://twitter.com/jckarter/status/926459181661536256" target="_blank" rel="noopener">一个很快就会被修复的问题</a>，因此你不需要依赖于这种行为。</p></blockquote><p>Swift 的属性观察器从一开始就是语言的一部分。为了更好地理解其原理，让我们快速了解一下它在 Objective-C 中的工作原理。</p><h1 id="Objective-C-中的属性"><a href="#Objective-C-中的属性" class="headerlink" title="Objective-C 中的属性"></a>Objective-C 中的属性</h1><p>从某种意义上说，Objective-C 中的所有属性都是被计算出来的。每次通过点语法访问属性时，都会转换为等效的 getter 或 setter 方法调用。这些调用最终被编译成消息发送，随后再执行读取或写入实例变量的方法。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点语法访问</span></span><br><span class="line">person.name = <span class="string">@"Johnny"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...等价于</span></span><br><span class="line">[person setName:<span class="string">@"Johnny"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...它被编译成</span></span><br><span class="line">objc_msgSend(person, <span class="keyword">@selector</span>(setName:), <span class="string">@"Johnny"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...最终实现</span></span><br><span class="line">person-&gt;_name = <span class="string">@"Johnny"</span>;</span><br></pre></td></tr></table></figure><p>编程过程中我们通常想要避免引入副作用，因为它会导致难以推断程序的行为。但很多 Objective-C 开发者已经依赖于这种特性，他们会根据需要在 getter 或 setter 中注入各种额外的行为。</p><p>Swift 的属性设计使这些模式更加标准化，并对装饰状态访问（存储属性）的副作用和重定向状态访问（计算属性）的副作用进行了区分。对于存储属性，<code>willSet</code> 和 <code>didSet</code> 观察器将替换你在 ivar 访问时的代码。对于计算属性，<code>get</code> 和 <code>set</code> 访问器可能会替换在 Objective-C 中实现的一些 <code>@dynamic</code> 属性。</p><p>正因为如此，我们才可以获取更一致的语义，并更好地保证键值观察（KVO）和健值编码（KVC）等属性交互机制。</p><p>那么你可以使用 Swift 属性观察器做些什么呢？以下是一些供你参考的想法：</p><h1 id="标准化或验证值"><a href="#标准化或验证值" class="headerlink" title="标准化或验证值"></a>标准化或验证值</h1><p>有时，你希望对类型确定的值增加额外的约束。</p><p>例如，你正在开发一个和政府机构对接的应用程序，你需要保证用户填写了所有的必填项并且不包含非法的值才能提交表单。</p><p>如果一个表单要求名称字段使用大写字母且不使用重音符号，你可以使用 <code>didSet</code> 属性观察器自动去除重音符号并转化为大写。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = <span class="keyword">self</span>.name?</span><br><span class="line">                        .applyingTransform(.stripDiacritics,</span><br><span class="line">                                            <span class="built_in">reverse</span>: <span class="literal">false</span>)?</span><br><span class="line">                        .uppercased()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>幸运的是在观察器内部设置属性不会触发额外的回调，所以上面的代码中不会产生无限循环。我们之所以不使用 <code>willSet</code> 观察器是因为即使我们在其回调中进行任何赋值，都会在属性被赋予 <code>newValue</code> 时覆盖。</p><p>虽然这种方法可以解决一次性问题，但像这样需要重复使用的业务逻辑可以封装到一个类型中。</p><p>更好的设计是创建一个 <code>NormalizedText</code> 类型，它封装了要以这种形式输入的文本的规则：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NormalizedText</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Error</span>: <span class="title">Swift</span>.<span class="title">Error</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> empty</span><br><span class="line">        <span class="keyword">case</span> excessiveLength</span><br><span class="line">        <span class="keyword">case</span> unsupportedCharacters</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> maximumLength = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> string: <span class="type">String</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> string.isEmpty &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">Error</span>.empty</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> value = string.applyingTransform(.stripDiacritics,</span><br><span class="line">                                                   <span class="built_in">reverse</span>: <span class="literal">false</span>)?</span><br><span class="line">                                .uppercased(),</span><br><span class="line">              value.canBeConverted(to: .ascii)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="type">Error</span>.unsupportedCharacters</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> value.<span class="built_in">count</span> &lt; <span class="type">NormalizedText</span>.maximumLength <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">Error</span>.excessiveLength</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个可抛出异常的初始化方法可以向调用者发送错误信息，这是 <code>didSet</code> 观察器无法做到的。现在面对 <a href="https://zh.wikipedia.org/wiki/%E5%85%B0%E9%9F%A6%E5%B0%94%E6%99%AE%E5%B0%94%E5%8F%A4%E5%9B%A0%E5%90%89%E5%B0%94%E6%88%88%E6%A0%BC%E9%87%8C%E6%83%A0%E5%B0%94%E6%81%A9%E5%BE%B7%E7%BD%97%E5%B8%83%E5%B0%94%E5%85%B0%E8%92%82%E8%A5%BF%E5%88%A9%E5%A5%A5%E6%88%88%E6%88%88%E6%88%88%E8%B5%AB" target="_blank" rel="noopener">兰韦尔普尔古因吉尔戈格里惠尔恩德罗布尔兰蒂西利奥戈戈戈赫</a> 的 <em>约翰尼</em> 这样的麻烦制造者，我们能为他做些什么！（换言之，以合理的方式传达错误比提供无效的数据更好）</p><h1 id="传播依赖状态"><a href="#传播依赖状态" class="headerlink" title="传播依赖状态"></a>传播依赖状态</h1><p>属性观察器的另一个潜在用例是将状态传播到依赖于视图控制器的组件。</p><p>考虑下面的 <code>Track</code> 模型示例和一个呈现它的 <code>TrackViewController</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Track</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> audioURL: <span class="type">URL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> player: <span class="type">AVPlayer</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> track: <span class="type">Track</span>? &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.player?.pause()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> track = <span class="keyword">self</span>.track <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.title = track.title</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> item = <span class="type">AVPlayerItem</span>(url: track.audioURL)</span><br><span class="line">            <span class="keyword">self</span>.player = <span class="type">AVPlayer</span>(playerItem: item)</span><br><span class="line">            <span class="keyword">self</span>.player?.play()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当视图控制器的 <code>track</code> 属性被赋值，以下事情会自动发生：</p><ul><li>之前轨道的音频都会暂停</li><li>视图控制器的 <code>title</code> 会被设置为新轨道对象的标题</li><li>新轨道对象的音频信息会被加载并播放</li></ul><p>很酷, 对吗?</p><p>你甚至可以像 <a href="https://www.youtube.com/watch?v=TVAhhVrpkwM" target="_blank" rel="noopener"><em>捕鼠记</em> 中描绘的场景</a> 一样，将行为与多个观察属性级联起来。</p><p>当然，观察器也存在一定的副作用，它使得有些复杂的行为难以被推断，这是我们在编程中需要避免的。今后在使用这一特性的同时也需要注意这一点。</p><p>然而，在这摇摇欲坠的抽象塔的顶端，一定限度的系统混乱是诱人的，有时是值得的。一直遵循规则的是波尔理论而非爱因斯坦。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了 Swift 中的属性观察器，并介绍了一些比较常见的适用场景。
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器与 Swift 4.2</title>
    <link href="https://swift.gg/2018/12/13/bloom-filters/"/>
    <id>https://swift.gg/2018/12/13/bloom-filters/</id>
    <published>2018-12-13T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2018/09/bloom-filters/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-09-19<br>译者：<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://linusling.com" target="_blank" rel="noopener">小铁匠Linus</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>Swift 4.2 为哈希的实现带来了一些新的变化。在此之前，哈希交由对象本身全权代理。当你向对象索取 <code>哈希值（hashValue）</code>时，它会把处理好的整型值作为哈希值返回。而现在，实现了 <code>Hashable</code> 协议的对象则描述了它的参数是如何组合，并传递给作为入参的 <code>Hasher</code> 对象。这样做有以下几点好处：</p><ul><li>写出好的哈希算法很难。Swift 的使用者不需要知道如何组合参数来获得更好的哈希值。</li><li>出于不提倡用户以任何形式存储哈希值，以及 <a href="https://twitter.com/jckarter/status/1042453831496327168" target="_blank" rel="noopener">一些安全方面因素</a> 的考虑，哈希值在程序每次运行的时候都应该有所不同。描述性的哈希允许哈希函数的种子在每次程序运行的时候发生改变。</li><li>能实现更多有意思的数据结构，这也是我们这篇文章接下来会聚焦的。</li></ul><a id="more"></a><p>我之前写过一篇关于 <a href="http://khanlou.com/2016/07/implementing-dictionary-in-swift/" target="_blank" rel="noopener">如何使用 Swift 的 <code>Hashable</code> 协议从零实现 <code>Dictionary</code></a> 的文章（先阅读它会帮助你阅读本文，但这不是必须的）。今天，我想谈论一种不同类型的，基于概率性而非明确性的数据结构：布隆过滤器（Bloom Filters）。我们会使用 Swift 4.2 的新特性，包括新的哈希模型来构建它。</p><p>布隆过滤器很怪异。想象这样一种数据结构：</p><ul><li>你能够往里插入数据</li><li>你能够查询一个值是否存在</li><li>只需要少量存储资源就能存储大量对象</li></ul><p>但是：</p><ul><li>你不能枚举其中的对象</li><li>它有时会出现误报（但不会出现漏报）</li><li>你不能从中移除数据</li></ul><p>什么时候会想要这种数据结构呢？Medium 使用它们来 <a href="https://blog.medium.com/what-are-bloom-filters-1ec2a50c68ff" target="_blank" rel="noopener">跟踪博文的阅读状态</a>。必应使用它们做 <a href="https://www.youtube.com/watch?v=80LKF2qph6I" target="_blank" rel="noopener">搜索索引</a>。你可以使用它们来构建一个缓存，在无需访问数据库的情况下就能判断用户名是否有效（例如在 @-mention 中）。像服务器这样可能拥有巨大的规模，却不一定有巨大资源的场景中，它们会非常有用。</p><p>（如果你之前做过图形方面的工作，可能好奇它是如何与 <a href="https://en.wikipedia.org/wiki/Bloom_(shader_effect" target="_blank" rel="noopener">高光过滤器</a>) 产生联系的。答案是没有联系。高光过滤器（bloom filters）是小写的 b，而布隆过滤器（Bloom Filters）是由一个叫布隆的人命名的。完全是个巧合。）</p><p>那它们是如何运作的呢？</p><p>将对象放入布隆过滤器如同将它放入集合或字典：计算对象的哈希值，并根据存储数组的大小对哈希值求余。就这点而言，使用布隆过滤器只需要修改该索引处的值：将 false 改为 true，而不用像使用集合或字典那样，把对象存放到索引位置。</p><p>我们先通过一个简单的例子来理解过滤器是如果运作的，之后再对它进行扩展。想象一个拥有 8 个 false 值的布尔数组（或称之为 <a href="https://gist.github.com/natecook1000/552dc3d23d2fc4a54d2e9fcd309e59e9" target="_blank" rel="noopener">比特数组</a>）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |</span><br><span class="line">---------------------------------</span><br><span class="line">|   |   |   |   |   |   |   |   |</span><br></pre></td></tr></table></figure><p>它代表了我们的布隆过滤器。我想要插入字符串“soroush”。它的哈希值是 9192644045266971309，当这个值余 8 时得到 5。我们修改那一位的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |</span><br><span class="line">---------------------------------</span><br><span class="line">|   |   |   |   |   | * |   |   |</span><br></pre></td></tr></table></figure><p>接下来我想要插入字符串“swift”，它的哈希值是 7052914221234348788，余 8 得 4，修改索引 4 的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |</span><br><span class="line">---------------------------------</span><br><span class="line">|   |   |   |   | * | * |   |   |</span><br></pre></td></tr></table></figure><p>要测试布隆过滤器是否包含“soroush”，我再次计算它的哈希值并求余，仍旧得到余数 5，对应值是 true。“soroush”确实在布隆过滤器中。</p><p>然而仅仅测试能够通过的用例是不够的，我们需要写一些会导致失败的用例。测试字符串“khanlou”取余得到的索引值是 2，因此我们知道它不在布隆过滤器中。到此为止一切都好。接下去一个测试：对“hashable”字符串取余得到的索引值是 5，这就发生了一次冲突！即使这个值从来没有被加入过，过滤器仍返回了 true。这便是布隆过滤器会发生误报的例子。</p><p>有两个主要的策略可以尽可能减少误报。第一个策略，也是两个策略中相对有趣的：我们可以使用不同的哈希函数计算两次或三次哈希值而非一次。只要它们都是表现良好的哈希函数（均匀分布，一致性，最小的碰撞几率），我们就能为每个值生成多个索引改变布尔值。这次，我们计算两次“soroush”的哈希值，生成 2 个索引并改变布尔值。这时，当我们检查“khanlou”是否在布隆过滤器中，其中一个哈希值可能会和“soroush”的一个哈希值冲突，但两个值同时发生冲突的可能性就会变得很小。你可以把这个数字扩大。在下面的代码我会做 3 次哈希计算，但你可以做更多次。</p><p>当然，如果你计算更多次哈希值，每个元素在布尔数组中会占据更多的空间。事实上，现在的数据几乎不占用空间。8 个布尔值的数组对应 1 字节。所以第二个减小误报的策略是扩大数组的规模。我们能将数组变得足够大而不用担心它的空间消耗。下面的代码中我们会默认使用 512 比特大小的数组。</p><p>现在，即使同时使用这些策略，你依然会得到冲突，即误报，但冲突的几率会减小。这是布隆过滤器的一个缺陷，但在合适的场景用它来节省速度与空间是一笔不错的交易。</p><p>在开始具体的代码之前我有另外三点想要谈谈。首先，你不能改变布隆过滤器的大小。当你对哈希值取余时，这是在破坏信息，在不保留原始哈希值的情况下你不能回溯之前的信息 —— 保留原始值相当于否决了这个数据结构节约空间的优势。</p><p>其次，你能看到想要枚举布隆过滤器所有的值是多么异想天开。你不再拥有这些值，只是它们以哈希形式存在的替代品。</p><p>最后，你同样能看到想要从布隆过滤器中移除元素是不可能的。如果想将布尔值变回 false，你并不知道是哪些值将它变为 true。是准备移除的值还是其它值？这样做会造成漏报和误报。（这对你来说可能是值得权衡的）你可以在每个索引上保留计数而非布尔值来解决这个问题，虽然保留计数还是会带来存储问题，但根据使用场景的不同，这样做或许是值得的。</p><p>废话不多说，让我们开始着手编码。我在这里做的一些决策和你可能会做的有所不同，第一个不同就是要不要让对象支持范型。我认为让对象包含更多关于它需要存储内容的元数据是有意义的，但如果你发现这样做限制太多，你可以改变它。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BloomFilter</span>&lt;<span class="title">Element</span>: <span class="title">Hashable</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要存储两种主要的数据。第一个是 <code>data</code>，用于表示比特数组。它存储了所有和哈希值有关的标记：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> data: [<span class="type">Bool</span>]</span><br></pre></td></tr></table></figure><p>接下来，我们需要不同的哈希函数。一些布隆过滤器确实会使用不同的方法计算哈希值，但我觉得使用相同的算法，同时混入一个随机生成的值会更简单。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> seeds: [<span class="type">Int</span>]</span><br></pre></td></tr></table></figure><p>当初始化布隆过滤器时，我们需要初始化这两个实例变量。比特数组会简单的重复 <code>false</code> 值来初始化，而种子值则使用 Swift 4.2 的新 API <code>Int.random</code> 来生成我们需要的种子值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(size: <span class="type">Int</span>, hashCount: <span class="type">Int</span>) &#123;</span><br><span class="line">data = <span class="type">Array</span>(repeating: <span class="literal">false</span>, <span class="built_in">count</span>: size)</span><br><span class="line">seeds = (<span class="number">0</span>..&lt;hashCount).<span class="built_in">map</span>(&#123; <span class="number">_</span> <span class="keyword">in</span> <span class="type">Int</span>.random(<span class="keyword">in</span>: <span class="number">0</span>..&lt;<span class="type">Int</span>.<span class="built_in">max</span>) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，创建一个带有默认值的便利构造器。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line"><span class="keyword">self</span>.<span class="keyword">init</span>(size: <span class="number">512</span>, hashCount: <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要实现两个主要的方法：<code>insert</code> 和 <code>contains</code>。它们都需要接收元素作为参数并为每一个种子值计算出对应的哈希值。私有的帮助方法会很有用。由于种子值代表了“不同的”哈希函数，我们就需要为每一个种子生成对应的哈希值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">hashes</span><span class="params">(<span class="keyword">for</span> element: Element)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line"><span class="keyword">return</span> seeds.<span class="built_in">map</span>(&#123; seed -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现函数主体，我们需要创建一个 <code>Hasher</code> 对象（Swift 4.2 新特性），将想要进行哈希计算的对象传给它。带上种子确保了生成的哈希值不会冲突。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">hashes</span><span class="params">(<span class="keyword">for</span> element: Element)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line"><span class="keyword">return</span> seeds.<span class="built_in">map</span>(&#123; seed -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">var</span> hasher = <span class="type">Hasher</span>()</span><br><span class="line">hasher.combine(element)</span><br><span class="line">hasher.combine(seed)</span><br><span class="line"><span class="keyword">let</span> hashValue = <span class="built_in">abs</span>(hasher.finalize())</span><br><span class="line"><span class="keyword">return</span> hashValue</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，注意哈希值的绝对值。哈希计算有可能产生负数，这会导致我们的数组访问崩溃。取绝对值操作减少了 1 比特的信息熵，对我们来说是有益的。</p><p>理想的情况是你能够使用种子来初始化 <code>Hasher</code> 而不是把它混合进去。Swift 的 <code>Hasher</code> 会在每次程序启动的时候被分配一个不同的种子（除非你 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0206-hashable-enhancements.md#effect-on-abi-stability" target="_blank" rel="noopener">设置固定的环境变量</a> 让种子在不同启动间保持一致，而这样做通常是一些测试目的），意味着你不能把这些值写到磁盘上。如果我们控制了 <code>Hasher</code> 的种子，我们就能将这些值写到磁盘上了。而就像这个布隆过滤器展示的那样，它应该只被用于内存缓存。</p><p><code>hashes(for:)</code> 方法完成了很多繁重的工作，让 <code>insert</code> 方法非常简洁：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> element: Element)</span></span> &#123;</span><br><span class="line">hashes(<span class="keyword">for</span>: element)</span><br><span class="line">.forEach(&#123; hash <span class="keyword">in</span></span><br><span class="line">data[hash % data.<span class="built_in">count</span>] = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成所有的哈希值，分别余上 <code>data</code> 数组的长度，并设置对应索引位的值为 <code>true</code>。</p><p><code>contains</code> 方法也同样简单，同时也给了我们使用 Swift 4.2 另一个新特性 <code>allSatisfy</code> 的机会。这个新方法可以判断序列中的所有对象是否都通过了某项用 block 表示的测试：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(<span class="number">_</span> element: Element)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> hashes(<span class="keyword">for</span>: element)</span><br><span class="line">.allSatisfy(&#123; hash <span class="keyword">in</span></span><br><span class="line">data[hash % data.<span class="built_in">count</span>]</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>data[hash % data.count]</code> 的结果已经是布尔值了，它与 <code>allSatisfy</code> 十分契合。</p><p>你也可以添加 <code>isEmpty</code> 方法用来检测 <code>data</code> 中的所有值是否都是 false。</p><p>布隆过滤器是一种奇怪的数据结构。我们接触的大多数数据结构都是明确性的。当把一个对象放入字典中时，你知道那个值之后一直在那儿。而布隆过滤器是概率性的，牺牲确定性来换取空间和速度。布隆过滤器不是你会每天用的数据结构，但当你确实需要它时，就会感受到有它真好。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文描述了如何使用 Swift 4.2 新特性 Hashable 实现布隆过滤器。
    
    </summary>
    
      <category term="Khanlou" scheme="https://swift.gg/categories/Khanlou/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>让我们构建一个Swift.Array</title>
    <link href="https://swift.gg/2018/12/06/friday-qa-2015-04-17-lets-build-swiftarray/"/>
    <id>https://swift.gg/2018/12/06/friday-qa-2015-04-17-lets-build-swiftarray/</id>
    <published>2018-12-06T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-04-17<br>译者：<a href="https://github.com/dzyding" target="_blank" rel="noopener">灰s</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>Swift 1.2 现已经作为 Xcode 6.3 的一部分而发布，在新的 API 中有一个允许我们使用值类型建立高效的数据结构，比如 Swift 标准库中的 <code>Array</code> 类型。今天，我们将重新现实 <code>Array</code> 的核心功能。</p><a id="more"></a><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>在我们开始之前，快速的复习一下值类型和引用类型。在 objc 以及大部分其他面向对象的语言中，我们所使用对象的指针或者引用都属于 <strong>引用类型</strong>。你可以把一个对象的引用赋值给一个变量：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">MyClass *a = ...;</span><br></pre></td></tr></table></figure><p>现在你可以将这个变量的值复制给另一个变量：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">MyClass *b = a;</span><br></pre></td></tr></table></figure><p>现在 a 和 b 都指向同一个对象。如果这个对象是可变的，那么对其中一个变量的改变同样会发生在另一个变量上。</p><p><strong>值类型</strong> 就是类似 Objective-C 中 <code>int</code> 这样的存在。使用值类型，变量包含的是真实的值，并不是值的引用。当你用 = 给另一个变量赋值，是将值的拷贝副本赋值给了另一个变量。比如：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure><p>现在，b 的值是 43，但是 a 依然是 42。  </p><p>在 Swift 中，<code>class</code> 属于引用类型，<code>struct</code> 属于值类型。<br>如果你使用 = 将一个 <code>class</code> 实例的引用赋值给另一个变量，你将得到这个实例的一个新引用。对这个实例的修改对每一个引用可见。<br>如果你使用 = 将一个 <code>struct</code> 实例的引用赋值给另一个变量，你将得到这个实例的一个副本，与原始数据相互独立。  </p><p>与大多数语言不同，Swift 标准库中的数组和字典都是值类型。比如：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b.append(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>在大部分语言中，这段代码（或者等效的代码）运行以后， a 和 b 将都是一个指向数组 <code>[1, 2, 3, 4]</code> 的引用。但是在 Swift 中，a 是指向数组 <code>[1, 2, 3]</code> 的引用，b 是指向数组 <code>[1, 2, 3, 4]</code> 的引用。</p><h2 id="值类型的实现"><a href="#值类型的实现" class="headerlink" title="值类型的实现"></a>值类型的实现</h2><p>如果你的对象拥有的属性是固定的，在 Swift 中把它申明成值类型是很简单的：只需要把所有的属性放入一个 <code>struct</code> 中即可。比如，如果你需要一个 2D 的 <code>Point</code> 值类型，你可以简单的申明一个 <code>struct</code> 包含 x 和 y ：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很快的，你就申明了一个值类型。但是如何实现类似 <code>Array</code> 这样的值类型呢？你无法把数组里面所有数据放入 <code>struct</code> 的申明中，因为在写代码的过程中你无法预料你将会在数组中放多少数据。你可以创建一个指针指向所有的数据：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ptr: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，你需要在该 <code>struct</code> 每次<strong>分配</strong>和<strong>销毁</strong>的时候进行一些特殊操作。  </p><ul><li>在分配的过程中，你需要把包含的数据拷贝一份放到一个新的内存地址，这时新的 <code>struct</code> 就不会和原数据共享同一份数据了。  </li><li>在销毁的过程中，<code>ptr</code> 指针也需要正常销毁。  </li></ul><p>在 Swift 中不允许对 <code>struct</code> 的分配和销毁过程进行自定义。</p><p>销毁操作可以使用一个 <code>class</code> 实现，它提供了 <code>deinit</code>。同时可以在这里对指针进行销毁。<code>class</code> 并不是值类型，但是我们可以将 <code>class</code> 作为一个内部属性提供给 <code>struct</code> 使用，并把数组作为 <code>struct</code> 暴露给外部接口。看起来就像这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayImpl</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ptr: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        ptr.destroy(...)</span><br><span class="line">        ptr.dealloc(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> impl: <span class="type">ArrayImpl</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时在 <code>Array</code> 中申明的方法，它的实际操作都是在 <code>ArrayImpl</code> 上进行的。</p><p>到这里就可以结束了吗？尽管我们使用的是 <code>struct</code>， 但是使用的依旧是引用类型。如果将这个 <code>struct</code> 拷贝一份，我们将获得一个新的 <code>struct</code>，持有的仍然是之前的 <code>ArrayImpl</code>。由于我们无法自定义 <code>struct</code> 的分配过程，所以没有办法同样把 <code>ArrayImpl</code> 也拷贝一份。  </p><p>这个问题的解决方法是放弃在分配的过程中进行拷贝，而是在 <code>ArrayImpl</code> 发生改变的时候进行拷贝。关键在于，就算一个拷贝副本与原始数据共享一个引用，但是只要这个引用的数据不发生改变，值类型的语义就依旧成立。只有当这个共享数据的值发生改变时，值类型和引用类型才有了明显的区别。  </p><p>比如，在实现 <code>append</code> 方法的时候你可以先对 <code>ArrayImpl</code> 进行 <code>copy</code> (假设 <code>ArrayImpl</code> 的实现中有一个 <code>copy</code> 方法，那么将 <code>impl</code> 引用改为原始值的 <code>copy</code>)：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(value: T)</span></span> &#123;</span><br><span class="line">    impl = impl.copy()</span><br><span class="line">    impl.append(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 Array 就是一个值类型了。尽管 a 和 b 在刚赋值完时仍然共享同一个 <code>impl</code> 引用 ，但是任何会改变 <code>impl</code> 的方法都将对其进行一次 <code>copy</code>，因此保留了不共享数据的错觉。  </p><p>现在可以正常工作了，但是效率却非常低。比如：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a: [<span class="type">Int</span>] = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">1000</span> &#123;</span><br><span class="line">    a.append(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管使用者无法看到它，但是它将在循环的每次迭代中复制内存中的数据，然后立即销毁之前的数据内存。如何才能优化它呢？</p><h2 id="isUniquelyReferenced"><a href="#isUniquelyReferenced" class="headerlink" title="isUniquelyReferenced"></a>isUniquelyReferenced</h2><p>这是一个 Swift 1.2 中新引入的 API。它漂亮的实现了它字面上的意思。赋予它一个对象的引用然后它将告诉你这个引用是否为独立的。具体来说，当这个对象有且仅有一个强引用时，就会返回 <code>true</code>。  </p><p>我们猜测这个 API 会检查对象的引用计数，并且在引用计数为 1 的时候返回 <code>true</code> 。那 Swift 为什么不直接提供一个接口来查询引用计数呢？可能在实现上这个接口不太好做，并且引用计数属于比较容易被滥用的信息，所以 Swift 提供了这个封装过的，更加安全的接口。</p><p>使用这个 API，之前对 <code>append</code> 方法的实现将可以改成只有在需要的时候才对内存中的数据进行复制: </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(value: T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !isUniquelyReferencedNonObjc(&amp;impl) &#123;</span><br><span class="line">            impl = impl.copy()</span><br><span class="line">        &#125;</span><br><span class="line">        impl.append(value)</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">这个 <span class="type">API</span> 实际上是一组三个方法中的一个。存在于 <span class="type">Xcode</span> 自带的 <span class="type">Swift</span> 标准库中:  </span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isUniquelyReferenced</span>&lt;T : NonObjectiveCBase&gt;<span class="params">(<span class="keyword">inout</span> object: T)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isUniquelyReferencedNonObjC</span>&lt;T&gt;<span class="params">(<span class="keyword">inout</span> object: T?)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isUniquelyReferencedNonObjC</span>&lt;T&gt;<span class="params">(<span class="keyword">inout</span> object: T)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>这些方法只能作用在纯 Swift class 中，并不支持 @objc 类型。第一个方法必须确保 T 为 <code>NonObjectiveCBase</code> 的子类。另外两个方法对参数的类型并不做要求，只是当类型为 @objc 时直接返回 false。  </p><p>我无法让我的代码以 <code>NonObjectiveCBase</code> 类型来编译，所以使用了 <code>isUniquelyReferencedNonObjC</code> 来代替。从功能上来说，它们并没有区别。  </p><blockquote><p>译者注：<br>文章中所阐述的 <code>isUniquelyReferencedNonObjC</code> API 已经在 Swift 3.1 的时候被替换为 <code>isKnownUniquelyReferenced</code><br>详情可以参考 swift-evolution 中的这条 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0125-remove-nonobjectivecbase.md" target="_blank" rel="noopener">建议</a></p></blockquote><h2 id="ArrayImpl"><a href="#ArrayImpl" class="headerlink" title="ArrayImpl"></a>ArrayImpl</h2><p>让我们开始实现 Swift.Array，首先从 <code>ArrayImpl</code> 开始，然后才是 <code>Array</code>。  </p><p>在这里我并不会重新实现 <code>Array</code> 完整的 API，只是实现满足其正常运行的基本功能，并展示它涉及的原理。  </p><p><code>ArrayImpl</code> 有三个属性：指针，数组元素的总数，以及已申请内存空间中的剩余容量。只有指针和元素的总数是必须的，但是相比申请更多的内存空间，实时监控剩余容量并按需申请，我们可以避免一大笔昂贵的内存重新分配。下面是类开始的部分：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayImpl</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> space: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> ptr: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">T</span>&gt;</span><br></pre></td></tr></table></figure><p>在 <code>init</code> 方法中需要一个计数和一个指针，然后将指针所指向的内容复制到新的对象。方法提供了默认值 0 和 nil ，所以 <code>init</code> 可以在不传入任何参数的情况下被用来创建一个拥有空数组的实例：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">init</span>(<span class="built_in">count</span>: <span class="type">Int</span> = <span class="number">0</span>, ptr: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">T</span>&gt; = <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="built_in">count</span> = <span class="built_in">count</span></span><br><span class="line">            <span class="keyword">self</span>.space = <span class="built_in">count</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.ptr = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">T</span>&gt;.alloc(<span class="built_in">count</span>)</span><br><span class="line">            <span class="keyword">self</span>.ptr.initializeFrom(ptr, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">        &#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">`initializeFrom` 方法可以将数据复制到新的指针。注意区分 `<span class="type">UnsafeMutablePointer</span>` 处于不同赋值方式之间的不同，这对于确保它们正常工作以及避免崩溃十分重要。不同之处在于数据内存是否被处理为初始化或未初始化。在调用 `alloc` 时，生成的指针处于未初始化的状态，并且可能被垃圾数据填满。一个简单的赋值，例如 `ptr.memory = ...` ，此时是不合法的，因为赋值操作将会在复制新的值之前析构已经存在的值。如果是类似 `int` 这样的基础数据类型将没什么问题，但是如果你操作的是一个复杂数据类型它将崩溃。在这里 `initializeFrom` 将目标指针视为未初始化的内存，而这正是它的本质。  </span><br><span class="line"></span><br><span class="line">接下来是一个改变过的 `append` 方法。它做的第一件事是检查指针是否需要重新分配。如果没有剩余的空间可用，我们需要一块新的内存：</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(obj: T)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> space == <span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="comment">// 在新的内存分配中，我们将申请两倍的容量，并且最小值为 16 :</span></span><br><span class="line">                <span class="keyword">let</span> newSpace = <span class="built_in">max</span>(space * <span class="number">2</span>, <span class="number">16</span>)</span><br><span class="line">                <span class="keyword">let</span> newPtr = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">T</span>&gt;.alloc(newSpace)</span><br><span class="line">                <span class="comment">// 从旧的内存中将数据拷贝到新的地址</span></span><br><span class="line">                newPtr.moveInitializeFrom(ptr, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                这是另一种赋值，它不仅把目的指针看做是未初始化的，并且会把数据源销毁。  </span></span><br><span class="line"><span class="comment">                它节省了我们单独写代码来销毁旧内存的操作，同时可能更加高效。  </span></span><br><span class="line"><span class="comment">                随着数据的移动完成，旧指针将可以被释放，新的数据将被赋值给类的属性：</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                ptr.dealloc(space)</span><br><span class="line">                ptr = newPtr</span><br><span class="line">                space = newSpace</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 现在我们确信有足够的空间，所以可以把新的值放在内存的最后面并且递增 count 属性的值:</span></span><br><span class="line">            (ptr + <span class="built_in">count</span>).initialize(obj)</span><br><span class="line">            <span class="built_in">count</span>++</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>改变过的 <code>remove</code> 方法将更为简洁，因为没有必要重新分配内存。首先，他将在移除一个值之前先将其销毁：  </p><blockquote><p>译者注：<br>这里的 # 号不用理会，在早期的 Swift 版本中它表示内外参数同名）**</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(# index: Int)</span></span> &#123;</span><br><span class="line">    (ptr + index).destroy()</span><br><span class="line">    <span class="comment">// moveInitializeFrom 方法负责将所有在被移除元素之后的元素往前挪一个位置</span></span><br><span class="line">    (ptr + index).moveInitializeFrom(ptr + index + <span class="number">1</span>, <span class="built_in">count</span>: <span class="built_in">count</span> - index - <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 递减 count 属性的值来体现这次删除操作</span></span><br><span class="line">    <span class="built_in">count</span>--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们同样需要一个 <code>copy</code> 方法来确保当需要的时候可以从数据内存中复制一份。实际关于复制的代码存在于 <code>init</code> 方法中，所以我们只需要创建一个实例也就相当于执行了一次复制：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">()</span></span> -&gt; <span class="type">ArrayImpl</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">ArrayImpl</span>&lt;<span class="type">T</span>&gt;(<span class="built_in">count</span>: <span class="built_in">count</span>, ptr: ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就基本上完成了所有的事情。我们只需要确保在它自己将要被销毁，调用 <code>deinit</code> 方法之后销毁所有数组中的元素并释放指针：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        ptr.destroy(<span class="built_in">count</span>)</span><br><span class="line">        ptr.dealloc(space)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们把它移到 <code>Array struct</code>。它唯一的属性就是一个 <code>ArrayImpl</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&lt;<span class="title">T</span>&gt;: <span class="title">SequenceType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> impl: <span class="type">ArrayImpl</span>&lt;<span class="type">T</span>&gt; = <span class="type">ArrayImpl</span>&lt;<span class="type">T</span>&gt;()</span><br></pre></td></tr></table></figure><p>所有 <code>mutating</code> 类型的方法都将以检查 <code>impl</code> 是不是独立的引用为开始，并在不是的时候进行复制操作。将把它封装成一个函数提供给其他的方法使用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">ensureUnique</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="built_in">isUniquelyReferencedNonObjC</span>(&amp;impl) &#123;</span><br><span class="line">        impl = impl.copy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>append</code> 方法现在只调用了 <code>ensureUnique</code> 方法，然后调用 <code>ArrayImpl</code> 的 <code>append</code> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(value: T)</span></span> &#123;</span><br><span class="line">    ensureUnique()</span><br><span class="line">    impl.append(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remove</code> 方法也是一样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(# index: Int)</span></span> &#123;</span><br><span class="line">    ensureUnique()</span><br><span class="line">    impl.remove(index: index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>count</code> 属性直接通过 <code>ArrayImpl&#39;s</code> 来返回：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> impl.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下标操作直接通过底层指针来进行访问。如果我们是在写真实的代码，在这里我们会需要进行一个范围的检查（<code>remove</code> 方法中也是），但是在这个例子中我们将它省略了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> impl.ptr[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">set</span> &#123;</span><br><span class="line">        ensureUnique()</span><br><span class="line">        impl.ptr[index] = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，<code>Array</code> 遵循 <code>SequenceType</code> 协议以支持 <code>for in</code> 循环。其必须实现 <code>Generator typealias</code> 和 <code>generate</code> 方法。内置的 <code>GeneratorOf</code> 类型使其很容易实现。<code>GeneratorOf</code> 使用一个代码块确保在其每次被访问的时候返回集合中的下一个元素，或者当到达结尾的时候返回 <code>nil</code>，并创造一个 <code>GeneratorType</code> 来封装该代码块：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Generator</span> = <span class="type">GeneratorOf</span>&lt;<span class="type">T</span>&gt;</span><br></pre></td></tr></table></figure><p><code>generate</code> 方法从 0 开始递增直到运行至结尾，然后开始返回 <code>nil</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">Generator</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">GeneratorOf</span>&lt;<span class="type">T</span>&gt;(&#123;</span><br><span class="line">            <span class="keyword">if</span> index &lt; <span class="keyword">self</span>.<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>[index++]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是它的全部！</p><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>我们的 <code>Array</code> 是一个符合 <code>CollectionType</code> 协议的通用 <code>struct</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&lt;<span class="title">T</span>&gt;: <span class="title">CollectionType</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>它唯一拥有的属性是一个底层 <code>ArrayImpl</code> 的引用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> impl: <span class="type">ArrayImpl</span>&lt;<span class="type">T</span>&gt; = <span class="type">ArrayImpl</span>&lt;<span class="type">T</span>&gt;()</span><br></pre></td></tr></table></figure><p>任何一个方法如果会改变这个数组必须先检查这个 <code>impl</code> 是否为一个独立的引用，并在它不是的时候进行复制。这个功能被封装成一个私有的方法提供给其他的方法使用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">ensureUnique</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="built_in">isUniquelyReferencedNonObjC</span>(&amp;impl) &#123;</span><br><span class="line">        impl = impl.copy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>append</code> 方法会使用 <code>ensureUnique</code> 然后调用 <code>impl</code> 中的 <code>append</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(value: T)</span></span> &#123;</span><br><span class="line">    ensureUnique()</span><br><span class="line">    impl.append(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remove</code> 的实现基本是相同的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(# index: Int)</span></span> &#123;</span><br><span class="line">    ensureUnique()</span><br><span class="line">    impl.remove(index: index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>count</code> 属性是一个计算性属性，它将直接通过 <code>impl</code> 来调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> impl.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下标操作将直接通过 <code>impl</code> 来修改底层的数据存储。通常这种直接从类的外部进行访问的方式是一个坏主意，但是 <code>Array</code> 和 <code>ArrayImpl</code> 联系的太过紧密，所以看起来并不是很糟糕。<code>subscript</code> 中 <code>set</code> 的部分会改变数组，所以需要使用 <code>ensureUnique</code> 来保持值语义：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> impl.ptr[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">set</span> &#123;</span><br><span class="line">        ensureUnique()</span><br><span class="line">        impl.ptr[index] = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CollectionType</code> 协议需要一个 <code>Index typealias</code>。对于 <code>Array</code> 来说，这个索引类型就是 <code>Int</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>它同时也需要一些属性来提供一个开始和结束的索引。对于 <code>Array</code> 俩说，开始的索引为 0 ，结束的索引就是数组中元素的个数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CollectionType</code> 协议包含 <code>SequenceType</code> 协议，它使得对象可以被用于 <code>for/in</code> 循环。它的工作原理是让序列提供一个生成器，该生成器是一个可以返回序列中连续元素的对象。生成器的类型由采用协议的类型来定义。<code>Array</code> 中采用的是 <code>GeneratorOf</code>，它是一个简单的封装用来支持使用一个闭包创建生成器：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Generator</span> = <span class="type">GeneratorOf</span>&lt;<span class="type">T</span>&gt;</span><br></pre></td></tr></table></figure><p><code>generate</code> 方法将会返回一个生成器。它使用 <code>GeneratorOf</code> 并且提供一个闭包来递增下标，直到下标到达数组的结尾。通过在闭包的外面声明一个 <code>index</code>，使它在调用中被捕获，并且它的值持续存在：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">Generator</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">GeneratorOf</span>&lt;<span class="type">T</span>&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> index &lt; <span class="keyword">self</span>.<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>[index++]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了 <code>Array</code> 的实现。</p><h2 id="完整的实现和测试代码"><a href="#完整的实现和测试代码" class="headerlink" title="完整的实现和测试代码"></a>完整的实现和测试代码</h2><p>这里提供了完整的实现，附加一些测试来确保所有的这些正常运行，我放在了 GitHub 上面：  </p><p><a href="https://gist.github.com/mikeash/63a791f2aec3318c7c5c" target="_blank" rel="noopener">https://gist.github.com/mikeash/63a791f2aec3318c7c5c</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在 Swift 1.2 中添加的 <code>isUniquelyReferenced</code> 是一个广受好评的改变，它让我们可以实现很多真正有趣的值类型，包括对标准库中值类型集合的复制。  </p><p>今天就到这里。下次再来找乐趣，功能，以及有趣的功能。如果你有感兴趣的主题，请发给我们！邮箱地址：<a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">mike@mikeash.com</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      简述Swift标准库中Array的实现逻辑
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="Swift 解析" scheme="https://swift.gg/tags/Swift-%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的面向协议编程：是否优于面向对象编程？</title>
    <link href="https://swift.gg/2018/12/03/pop-vs-oop/"/>
    <id>https://swift.gg/2018/12/03/pop-vs-oop/</id>
    <published>2018-12-03T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://www.appcoda.com/pop-vs-oop/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018/03/28<br>译者：<a href="https://github.com/YangGao1991" target="_blank" rel="noopener">阳仔</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://lision.me/" target="_blank" rel="noopener">Lision</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote> <!--此处开始正文--><p>在本文中，我们将深入讨论 Swift 4 中的面向协议编程。这是一个系列两篇文章中的第二篇。如果你还没有读过 <a href="https://www.appcoda.com/protocol-oriented-programming/" target="_blank" rel="noopener">前一篇介绍文章</a>，请在继续阅读本文之前先阅读前一篇。</p><a id="more"></a><p>在本文中，我们将探讨为什么 Swift 被认为是一门“面向协议”的语言；对比面向协议编程（POP）和面向对象编程（OOP）；对比“值语义”和“引用语义”；讨论 local reasoning；用协议实现代理模式；用协议代替类型；使用协议多态性；重审我的面向协议的实际代码；最终讨论为什么我没有 100% 使用 POP 编程。</p><blockquote><p>关于 WWDC 链接的一点说明<br>在这一系列关于 POP 的两篇文章中，我至少添加了三个 Apple Worldwide Developers Conference (WWDC) 视频的链接。在 Safari 中点击这些链接将直接跳转至视频中的具体小节（并往往会从该处开始播放视频）。如果你使用的不是 Safari，则需要浏览视频，手动跳转至某一小节，或者查看该视频的文字版本。</p></blockquote><h2 id="Swift-为什么是“面向协议”的语言？"><a href="#Swift-为什么是“面向协议”的语言？" class="headerlink" title="Swift 为什么是“面向协议”的语言？"></a>Swift 为什么是“面向协议”的语言？</h2><p>我在 <a href="https://www.appcoda.com/protocol-oriented-programming/" target="_blank" rel="noopener">前一篇 POP 介绍文章</a> 中，提到 Apple 声称”从核心上说，Swift 是面向协议的”。相信我，确实是这样的。为什么呢？在回答这个问题之前，让我们先来比较几种编程语言。</p><p>我们最好对其他语言也有所了解，因为在某些情况下这将会有用处，比如在需要将 C++ 库链接到 iOS 应用中的时候。我的很多 iOS 和 OSX 的应用链接了 C++ 的库，因为这些应用有 Windows 平台的版本。这些年，我支持了许多“平台无关”的应用。</p><p>OOP 语言早已支持了接口。接口和 Swift 中的协议很相似，但并不是完全一样。</p><p>这些语言中的接口指定了遵循该接口的类和（或）结构体必须实现哪些方法和（或）属性。我这里使用了“和（或）”，是因为比如 C++ 中没有接口的概念，而是使用抽象类。并且，一个 C++ <code>struct</code> 可以继承自一个类。C# 中的接口允许指定其中的属性和方法，<code>struct</code> 可以遵循接口。Objective-C 中称“协议”而不是“接口”，协议也可以指定要求实现的方法和属性，但只有类可以声明遵循接口，<code>struct</code> 不可以。</p><p>这些接口和 Objective-C 中的协议，并没有方法的具体实现。它们只是指定一些要求，作为遵循该协议的类/结构体实现时的“蓝图”。</p><p>协议构成了 <a href="http://swiftdoc.org" target="_blank" rel="noopener">Swift 标准库</a> 的基础。正如我在 <a href="https://www.appcoda.com/protocol-oriented-programming/" target="_blank" rel="noopener">第一篇文章</a> 中所展示，协议是 POP 方法论和范式的关键所在。</p><p>Swift 中的协议有其他语言都不支持的特点：<a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID521" target="_blank" rel="noopener">协议扩展</a>。以下摘自 Apple 官方描述：</p><blockquote><p>协议可以被扩展，来给遵循该协议的类型提供方法、初始化方法、下标、计算属性的具体实现。这就可以允许协议自身定义一些行为，而不是由各个类型自己去实现，或是由一个全局方法来实现。<br>通过扩展，我们可以为协议所要求的任何方法和计算属性提供一个默认的实现。如果一个遵循该协议的类型为某个方法或属性提供了其自己的实现，那么该实现将会替代协议扩展中的实现。</p></blockquote><p>在上一篇文章中，你已经看到我是怎么使用协议扩展的，在本文中你会再次看到。它们是使得 Swift POP 如此强大的秘诀。</p><p>在 Swift 出现之前，协议在 iOS 中就已经十分重要。还记得我对 iOS 开发人员多年来采用的 UITableViewDataSource 和 UITableViewDelegate 等协议的 <a href="https://appcoda.com/protocol-oriented-programming/" target="_blank" rel="noopener">讨论</a> 吗？再想一想你每天写的 Swift 代码吧。</p><p>用 Swift 编程的时候，不可能不利用 <a href="http://swiftdoc.org" target="_blank" rel="noopener">标准库</a> 中的协议。例如，<code>Array</code> （一个继承了 <a href="http://swiftdoc.org/v3.1/type/Array/hierarchy/" target="_blank" rel="noopener">10 个协议</a> 的 <code>struct</code>），<code>Bool</code> （一个继承了 <a href="http://swiftdoc.org/v3.1/type/Bool/hierarchy/" target="_blank" rel="noopener">7 个协议</a> 的 <code>struct</code>），<code>Comparable</code> （一个 <a href="http://swiftdoc.org/v3.1/protocol/Comparable/hierarchy/" target="_blank" rel="noopener">继承自另一个协议的协议，并且是很多其他 Swift 类型的继承先祖</a>），以及 <code>Equatable</code> （一个 <a href="http://swiftdoc.org/v3.1/protocol/Equatable/hierarchy/" target="_blank" rel="noopener">很多 Swift 协议和类型的继承先祖</a>）。</p><p>花一些时间阅览 <a href="http://swiftdoc.org" target="_blank" rel="noopener">Swift 标准库</a>，跟随链接查看所有类型、协议、操作符、全局变量、函数。一定要看几乎所有页面都会有的 “Inheritance” 一节，并点击 “VIEW PROTOCOL HIERARCHY -&gt;” 链接。你将会看到很多协议，协议的定义，以及协议继承关系的图表。</p><p>记住很重要的一点：大部分 iOS（以及 OSX）SDK 中的代码都是以类继承的层次结构实现的。我相信很多我们使用的核心框架仍然是用 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Cocoa.html" target="_blank" rel="noopener">Objective-C</a>（以及一些 C++ 和 C）编写的，例如 <code>Fundation</code> 和 <code>UIKit</code>。拿 <code>UIKit</code> 中的 <code>UIbutton</code> 举例。利用 Apple 官方文档页面中的“继承自”链接，我们可以从叶节点 <code>UIButton</code> 一直沿着继承链向上查找到根节点 <code>NSObject</code>：<code>UIButton</code> 到 <code>UIControl</code> 到 <code>UIView</code> 到 <code>UIResponder</code> 到 <code>NSObject</code>。可以形象表示为：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/03/UIButton-Inheritance.png" alt=""></p><h2 id="POP-和-OOP"><a href="#POP-和-OOP" class="headerlink" title="POP 和 OOP"></a>POP 和 OOP</h2><p>OOP 的优点已经被开发者们讨论得很多了，所以在这里我只想简单列举一下。如果想了解详尽的内容，可以参考 <a href="http://iosbrain.com/blog/2017/02/26/intro-to-object-oriented-principles-in-swift-3-via-a-message-box-class-hierarchy/" target="_blank" rel="noopener">我写的这篇有关 OOP 在 Swift 中的实现的具体介绍</a>。</p><blockquote><p>注意：如果你读这篇文章的时候还不了解 OOP，我建议你在考虑学习 POP 之前，先学习 OOP。</p></blockquote><p>OOP 的优点包括可重用性，继承，可维护性，对复杂性的隐藏（封装），抽象性，多态性，对一个类的属性和方法的访问权限控制。我这里可能还有所遗漏，因为开发者们已经总结出太多 OOP 的优点了。</p><p>简单地说，OOP 和 POP 都拥有大部分上述的特点，主要的一点不同在于：类只能继承自其它一个类，但协议可以继承自多个协议。</p><p>正是由于 OOP 的继承的特点，我们在开发中最好把继承关系限制为单继承。因为多继承会使代码很快变得一团乱。</p><p>然而，协议却可以继承自一个或多个不同的协议。</p><p>为什么需要推动面向协议编程呢？当我们建立起一个庞大的类层次结构的时候，许多的属性和方法会被继承。开发者更倾向于把一些通用功能增加到顶层的——主要是高层的父类中（并且会一直加下去）。中层和底层的类的职责会更加明确和具体。新的功能会被放到父类中，这经常会使得父类充满了许多额外的，无关的职责，变得“被污染”或是“臃肿”。中层和底层的类也因此继承了很多它们并不需要的功能。</p><p>这些有关 OOP 的担忧并非成文的规定。一个优秀的开发者可以躲避很多刚才提到的陷阱。这需要时间、实践和经验。例如，开发者可以这样解决父类功能臃肿的问题：将其他类的实例添加为当前类的成员变量，而非继承这些类（也就是使用组合代替继承）。</p><p>在 Swift 中使用 POP 还有一个好处：不仅仅是类，值类型也可以遵循协议，比如 <code>struct</code> 和 <code>enum</code>。我们在下面将会讨论使用值类型的一些优点。</p><p>但我的确对遵循多协议的做法有一些顾虑。我们是否只是将代码的复杂性和难度转移成另一种形式了呢？即，将 OOP 继承中的“垂直”的复杂性转移成了 POP 继承中的“水平”的复杂性了呢？</p><p>将之前展示的 <code>UIButton</code> 的类继承结构和 Swift 中的 <code>Array</code> 所遵循的协议进行对比：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/03/Array-Protocol-Tangle.png" alt=""></p><blockquote><p>图像来源：<a href="http://swiftdoc.org/v3.1/type/Array/hierarchy/" target="_blank" rel="noopener">http://swiftdoc.org/v3.1/type/Array/hierarchy/</a></p></blockquote><p>Local reasoning 对这两种情况都不适用，因为个体和关系太多了。</p><h2 id="值语义-vs-引用语义"><a href="#值语义-vs-引用语义" class="headerlink" title="值语义 vs. 引用语义"></a>值语义 vs. 引用语义</h2><p>正如我上一篇文章所提到的，Apple 正在大力推广 POP 和值语义的相关概念（他们还正在推广另一个与 POP 相关的范式，下文会讲到）。上一次，我向你们展示了代码，这次依然会用代码来明确展示“引用语义”和“值语义”的不同意义。请参阅我 <a href="https://www.appcoda.com/protocol-oriented-programming/" target="_blank" rel="noopener">上一周的文章</a> 中的 <code>ObjectThatFlies</code> 协议，以及今天文章中的 <code>List</code>，<code>FIFO</code>，<code>LIFO</code> 以及相关协议。</p><p>Apple 工程师 Alex 说我们 <a href="https://developer.apple.com/videos/play/wwdc2016/419/?time=36" target="_blank" rel="noopener">“应当使用值类型和协议来让应用变得更好”</a>。Apple <a href="https://developer.apple.com/sample-code/swift/downloads/standard-library.zip" target="_blank" rel="noopener">sample playground</a> 中，一节题为“理解值类型”的代码文档这么说：</p><blockquote><p>标准库中的序列和容器使用了值类型，这让写代码变得更加容易。每一个变量都有一个独立的值，对这个值的引用并非共享的。例如，当你向一个函数传递一个数组，这个函数并不会导致调用方对这个数组的拷贝突然被改变。</p></blockquote><p>这当然对所有使用值语义的数据类型都是适用的。我强烈建议你下载并完整阅览整个 playground。</p><p>我并不是要抛弃类这个使用引用语义的概念。我做不到。我自己已经写了太多的基于类的代码。我帮助我的客户整理了数百万行基于类的代码。我同意值类型一般来说比引用类型安全。当我写新的代码，或是重构已有代码的时候，我会考虑在某些个案中积极尝试。</p><p>引用语义下，类实例（引用）会导致 <a href="https://developer.apple.com/videos/play/wwdc2015-414/?time=112" target="_blank" rel="noopener">“意料之外的数据共享”</a>。也有人称之为“意料之外的改变”。有一些 <a href="https://developer.apple.com/videos/play/wwdc2015-414/?time=210" target="_blank" rel="noopener">方法</a> 可以最小化引用语义的副作用，不过我还是会越来越多地使用值语义。</p><p>值语义能够使变量避免受到无法预计的更改，这实在很棒。因为“每个变量有一个独立的值，对这个值的引用是不共享的“，我们能够避免这种无法预计的更改导致的副作用。</p><p>因为 Swift 中的 <code>struct</code> 是一种值类型，并且能够遵循协议，苹果也在大力推进 POP 以取代 OOP，在 <a href="https://developer.apple.com/videos/play/wwdc2016/419/" target="_blank" rel="noopener">面向协议和值编程</a> 你可以找到这背后的原因。</p><h2 id="Local-reasoning"><a href="#Local-reasoning" class="headerlink" title="Local reasoning"></a>Local reasoning</h2><p>让我们探讨一个很棒的主题，Apple 称之为 <a href="https://developer.apple.com/videos/play/wwdc2016-419/?time=41" target="_blank" rel="noopener">“Local reasoning”</a>。这是由 Apple 一位叫 Alex 的工程师在 WWDC 2016 - Session 419，“UIKit 应用中的面向协议和值编程”中提出的。这也是 Apple 与 POP 同时大力推动的概念。</p><p>我认为这不是个新鲜的概念。许多年以前，教授、同事、导师、开发者们都在讨论这些：永远不要写高度超过一个屏幕的函数（即不长于一页，或许更短）；将大的函数拆解成若干小的函数；将大的代码文件拆解成若干小的代码文件；使用有意义的变量名；在写代码之前花点时间去设计代码；保持空格和缩进风格的一致性；将相关的属性和行为整合成类和/或结构体；将相关的类和/或结构体整合进框架或库中。但 Apple 在解释 POP<br>的时候，正式提出了这个概念。Alex 告诉我们：</p><blockquote><p>Local reasoning 意味着，当你看你面前的代码的时候，你不需要去思考，剩下的代码怎样去和这个函数进行交互。也许你之前已经有过这种感觉。例如，当你刚加入一个新的团队，有大量的代码要去看，同时上下文的信息也非常匮乏，你能明白某一个函数的作用吗？做到 Local reasoning 的能力很重要，因为这能够使得维护代码、编写代码、测试代码变得更加容易。</p></blockquote><p>哈哈，你曾经有过这种感觉吗？我曾经读过一些其他人写的真的很好的代码。我也曾经写过一些易读性非常好的代码。说实话，在 30 年的工作经验中，我要去支持和升级的绝大部分现存的代码都不会让我感受到 Alex 所描述的这种感觉。相反，我经常会变得非常困惑，因为当我看一段代码的时候，我往往对这段代码的作用毫无头绪。</p><p>Swift 语言的源代码是开源的。请快速浏览一遍 <a href="https://github.com/apple/swift/blob/master/stdlib/public/SDK/Foundation/NSFastEnumeration.swift" target="_blank" rel="noopener">下列函数</a>，也不要花上三个小时去试图理解它：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Any</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> index + <span class="number">1</span> &gt; <span class="built_in">count</span> &#123;</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line"><span class="comment">// 确保没有 self 的成员变量被捕获</span></span><br><span class="line">        <span class="keyword">let</span> enumeratedObject = enumerable</span><br><span class="line">        <span class="keyword">var</span> localState = state</span><br><span class="line">        <span class="keyword">var</span> localObjects = objects</span><br><span class="line">        </span><br><span class="line">        (<span class="built_in">count</span>, useObjectsBuffer) = <span class="built_in">withUnsafeMutablePointer</span>(to: &amp;localObjects) &#123;</span><br><span class="line">            <span class="keyword">let</span> buffer = <span class="type">AutoreleasingUnsafeMutablePointer</span>&lt;<span class="type">AnyObject</span>?&gt;($<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">withUnsafeMutablePointer</span>(to: &amp;localState) &#123; (statePtr: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">NSFastEnumerationState</span>&gt;) -&gt; (<span class="type">Int</span>, <span class="type">Bool</span>) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> result = enumeratedObject.countByEnumerating(with: statePtr, objects: buffer, <span class="built_in">count</span>: <span class="number">16</span>)</span><br><span class="line">                <span class="keyword">if</span> statePtr.pointee.itemsPtr == buffer &#123;</span><br><span class="line">    <span class="comment">// 大多数 cocoa 类会返回它们自己的内部指针缓存，不使用默认的路径获取值。也有例外的情况，比如 NSDictionary 和 NSSet。</span></span><br><span class="line">    <span class="keyword">return</span> (result, <span class="literal">true</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里是通常情形，比如 NSArray。</span></span><br><span class="line">    <span class="keyword">return</span> (result, <span class="literal">false</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        state = localState <span class="comment">// 重置 state 的值</span></span><br><span class="line">        objects = localObjects <span class="comment">// 将对象指针拷贝回 self </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> &#123; index += <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> !useObjectsBuffer &#123;</span><br><span class="line">        <span class="keyword">return</span> state.itemsPtr![index]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> index &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> objects.<span class="number">0</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> objects.<span class="number">1</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> objects.<span class="number">2</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> objects.<span class="number">3</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> objects.<span class="number">4</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">return</span> objects.<span class="number">5</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">return</span> objects.<span class="number">6</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">return</span> objects.<span class="number">7</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="keyword">return</span> objects.<span class="number">8</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>: <span class="keyword">return</span> objects.<span class="number">9</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">return</span> objects.<span class="number">10</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>: <span class="keyword">return</span> objects.<span class="number">11</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>: <span class="keyword">return</span> objects.<span class="number">12</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>: <span class="keyword">return</span> objects.<span class="number">13</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">14</span>: <span class="keyword">return</span> objects.<span class="number">14</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">15</span>: <span class="keyword">return</span> objects.<span class="number">15</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">fatalError</span>(<span class="string">"Access beyond storage buffer"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你浏览过一遍之后，说实话，你能理解这段代码吗？我并没有。我不得不花些时间多读几遍，并查阅函数定义之类的代码。以我的经验，这种代码是普遍存在的，并且不可避免需要经常修补的。</p><p>现在，让我们考虑理解一种 Swift 类型（不是一个函数）。查看 Swift 中的 <code>Array</code> 的 <a href="http://swiftdoc.org/v3.1/type/Array/" target="_blank" rel="noopener">定义</a>。我的天，它继承了 10 个协议：</p><ul><li><code>BidirectionalCollection</code></li><li><code>Collection</code></li><li><code>CustomDebugStringConvertible</code></li><li><code>CustomReflectable</code></li><li><code>CustomStringConvertible</code></li><li><code>ExpressibleByArrayLiteral</code></li><li><code>MutableCollection</code></li><li><code>RandomAccessCollection</code></li><li><code>RangeReplaceableCollection</code></li><li><code>Sequence</code></li></ul><p>点击下方的“VIEW PROTOCOL HIERARCHY -&gt;”链接按钮——天哪，<a href="http://swiftdoc.org/v3.1/type/Array/hierarchy/" target="_blank" rel="noopener">看这一坨面条一样的线条</a>！</p><p>如果你是在开发一个新项目，并且整个团队能够遵循一套最佳开发指导方案的话，要做到 Local reasoning 会容易很多。少量代码的重构也是做到 local reasoning 的较好的机会。对我来说，像其他大部分事情一样，代码的重构需要慎重和仔细，要做到适度。</p><p>牢记：你几乎一直要面对非常复杂的业务逻辑，这些逻辑如果写成代码，并且要让一个团队新人流畅读懂，需要他/她接收一些业务知识的训练和指导。他/她很可能需要查找一些函数、类、结构体、枚举值、变量的定义。</p><h2 id="代理和协议"><a href="#代理和协议" class="headerlink" title="代理和协议"></a>代理和协议</h2><p>代理模式是 iOS 中广泛使用的模式，其中一个必需的组成部分就是协议。在这里我们不需要再去重复。你可以阅读我有关该主题的 AppCoda <a href="https://www.appcoda.com/swift-delegate/" target="_blank" rel="noopener">博客</a>。</p><h2 id="协议类型以及协议多态性"><a href="#协议类型以及协议多态性" class="headerlink" title="协议类型以及协议多态性"></a>协议类型以及协议多态性</h2><p>在这些主题上我不准备花太多时间。我已经讲过很多有关协议的知识，并向你展示了大量代码。作为任务，我想让你自己研究一下，Swift 协议类型（就像在代理中一样）的重要性，它们能给我们带来的灵活性，以及它们所展示的多态性。</p><p><em>协议类型</em><br>在我 <a href="https://www.appcoda.com/swift-delegate/" target="_blank" rel="noopener">关于代理的文章</a> 中，我定义了一个属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> delegate: <span class="type">LogoDownloaderDelegate</span>?</span><br></pre></td></tr></table></figure><p>其中 <code>LogoDownloaderDelegate</code> 是一个协议。然后，我调用了这个协议的一个方法。</p><p><em>协议多态性</em><br>正如在面向对象中一样，我们可以通过遵循父协议的数据类型，来与多种遵循同一个协议族的子协议的数据类型进行交互。用代码举例来说明：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Top</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> protocolName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Middle</span>: <span class="title">Top</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Bottom</span>: <span class="title">Middle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TopStruct</span> : <span class="title">Top</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> protocolName: <span class="type">String</span> = <span class="string">"TopStruct"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MiddleStruct</span> : <span class="title">Middle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> protocolName: <span class="type">String</span> = <span class="string">"MiddleStruct"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BottomStruct</span> : <span class="title">Bottom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> protocolName: <span class="type">String</span> = <span class="string">"BottomStruct"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> top = <span class="type">TopStruct</span>()</span><br><span class="line"><span class="keyword">let</span> middle = <span class="type">MiddleStruct</span>()</span><br><span class="line"><span class="keyword">let</span> bottom = <span class="type">BottomStruct</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> topStruct: <span class="type">Top</span></span><br><span class="line">topStruct = bottom</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(topStruct)</span>\n"</span>)</span><br><span class="line"><span class="comment">// 输出 "BottomStruct(protocolName: "BottomStruct")"</span></span><br><span class="line"></span><br><span class="line">topStruct = middle</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(topStruct)</span>\n"</span>)</span><br><span class="line"><span class="comment">// 输出 "MiddleStruct(protocolName: "MiddleStruct")"</span></span><br><span class="line"></span><br><span class="line">topStruct = top</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(topStruct)</span>\n"</span>)</span><br><span class="line"><span class="comment">// 输出 "TopStruct(protocolName: "TopStruct")"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> protocolStructs:[<span class="type">Top</span>] = [top,middle,bottom]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> protocolStruct <span class="keyword">in</span> protocolStructs &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(protocolStruct)</span>\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你运行一下 Playground 中的代码，以下是终端的输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BottomStruct(protocolName: &quot;BottomStruct&quot;)</span><br><span class="line"></span><br><span class="line">MiddleStruct(protocolName: &quot;MiddleStruct&quot;)</span><br><span class="line"></span><br><span class="line">TopStruct(protocolName: &quot;TopStruct&quot;)</span><br><span class="line"></span><br><span class="line">TopStruct(protocolName: &quot;TopStruct&quot;)</span><br><span class="line"></span><br><span class="line">MiddleStruct(protocolName: &quot;MiddleStruct&quot;)</span><br><span class="line"></span><br><span class="line">BottomStruct(protocolName: &quot;BottomStruct&quot;)</span><br></pre></td></tr></table></figure><h2 id="真实的-UIKit-应用中的协议"><a href="#真实的-UIKit-应用中的协议" class="headerlink" title="真实的 UIKit 应用中的协议"></a>真实的 UIKit 应用中的协议</h2><p>现在，让我们来看一些实质性的东西，写一些 Swift 4 的代码——这些代码是在我自己的应用中真实使用的。这些代码应当能使你开始思考用协议来构建和/或拓展你的代码。这也就是我在这两篇文章中一直在描述的，“面向协议编程”，或者 POP。</p><p>我选择向你展示如何去扩展或者说是延伸（随便哪种说法）<code>UIKit</code> 的类，因为 1) 你很可能非常习惯使用它们 2) 扩展 iOS SDK 中的类，比如 <code>UIView</code>，是比用你自己的类更加困难一些的。</p><p>所有 <code>UIView</code> 的扩展代码都是用 Xcode 9 工程中的 <em>Single View App</em> 模板写的。</p><p>我使用默认协议扩展来对 <code>UIView</code> 进行扩展——这么做的关键是一种 Apple 称之为 <a href="https://swift.org/blog/conditional-conformance/" target="_blank" rel="noopener">“条件遵循”</a> 的做法（也可以看 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID277" target="_blank" rel="noopener">这里</a>）。因为我只想对 <code>UIView</code> 这个类进行扩展，我们可以让编译器来把这个变成一项强制要求。</p><p>我经常使用 <code>UIView</code> 作为一个容器来组织屏幕上的其他 UI 元素。也有时候，我会用这些容器视图来更好地查看、感觉、排布我的 UI 视图。</p><p>这里是一张 GIF 图片，展示了使用下面创建的三个协议来自定义 <code>UIView</code> 的外观的结果：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/03/Extend-UIView.gif" alt=""></p><p>注意，这里我也遵守了 ”Local reasoning“ 的原则。我每一个基于协议的函数都控制在一屏幕之内。我希望你能阅读每一个函数，因为它们并没有太多代码量，但却很有效。</p><h2 id="为-UIView-添加一个默认的边框"><a href="#为-UIView-添加一个默认的边框" class="headerlink" title="为 UIView 添加一个默认的边框"></a>为 UIView 添加一个默认的边框</h2><p>假设我希望获得很多拥有相同边框的 <code>UIView</code> 实例——例如在一个支持颜色主题的应用中那样。一个这样的例子就是上面那张图片中，最上面那个绿色的视图。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SimpleViewWithBorder</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的："addBorder" 方法只会被添加到 UIView 的实例。</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SimpleViewWithBorder</span> <span class="title">where</span> <span class="title">Self</span> : <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBorder</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        layer.borderColor = <span class="type">UIColor</span>.green.cgColor</span><br><span class="line">        layer.borderWidth = <span class="number">10.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleUIViewWithBorder</span> : <span class="title">UIView</span>, <span class="title">SimpleViewWithBorder</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要创建、配置、显示一个 <code>SimpleUIViewWithBorder</code> 的实例，我在我的 <code>ViewController</code> 子类中的 <code>IBAction</code> 中写了如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">addViewButtonTapped</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> customFrame0 = <span class="type">CGRect</span>(x: <span class="number">110</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">let</span> customView0 = <span class="type">SimpleUIViewWithBorder</span>(frame: customFrame0)</span><br><span class="line">    customView0.addBorder()</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(customView0)</span><br></pre></td></tr></table></figure><p>我不需要为这个 <code>UIView</code> 的子类去创建一个特殊的初始化方法。</p><h2 id="为-UIView-添加一个默认的背景色"><a href="#为-UIView-添加一个默认的背景色" class="headerlink" title="为 UIView 添加一个默认的背景色"></a>为 UIView 添加一个默认的背景色</h2><p>假设我希望很多 <code>UIView</code> 的实例都有相同的背景色。一个这样的例子是上图中，中间的蓝色视图。注意，我向可配置的 <code>UIView</code> 又更进了一步。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ViewWithBackground</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> customBackgroundColor: <span class="type">UIColor</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewWithBackground</span> <span class="title">where</span> <span class="title">Self</span> : <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBackgroundColor</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        backgroundColor = customBackgroundColor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIViewWithBackground</span> : <span class="title">UIView</span>, <span class="title">ViewWithBackground</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> customBackgroundColor: <span class="type">UIColor</span> = .blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要创建、配置、展示一个 <code>UIViewWithBackground</code> 的实例，我在我的 <code>ViewController</code> 子类中的 <code>IBAction</code> 中写了如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> customFrame1 = <span class="type">CGRect</span>(x: <span class="number">110</span>, y: <span class="number">210</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> customView1 = <span class="type">UIViewWithBackground</span>(frame: customFrame1)</span><br><span class="line">customView1.addBackgroundColor()</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(customView1)</span><br></pre></td></tr></table></figure><p>我不需要为这个 <code>UIView</code> 的子类去创建一个特殊的初始化方法。</p><h2 id="为-UIView-添加一个可配置的边框颜色"><a href="#为-UIView-添加一个可配置的边框颜色" class="headerlink" title="为 UIView 添加一个可配置的边框颜色"></a>为 UIView 添加一个可配置的边框颜色</h2><p>现在，我希望能够配置 <code>UIView</code> 边框的颜色和宽度。用下列实现代码，我可以随意创建不同边框颜色、宽度的视图。这样的一个例子是上图中，最下面的红色视图。向我的协议中去添加可配置的属性有一点代价，我需要能够初始化这些属性，因此，我为我的协议添加了一个 <code>init</code> 方法。这意味着，我也可以调用 <code>UIView</code> 的初始化方法。读完代码，你就会明白：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ViewWithBorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> borderColor: <span class="type">UIColor</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> borderThickness: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">init</span>(borderColor: <span class="type">UIColor</span>, borderThickness: <span class="type">CGFloat</span>, frame: <span class="type">CGRect</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewWithBorder</span> <span class="title">where</span> <span class="title">Self</span> : <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBorder</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        layer.borderColor = borderColor.cgColor</span><br><span class="line">        layer.borderWidth = borderThickness</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIViewWithBorder</span> : <span class="title">UIView</span>, <span class="title">ViewWithBorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> borderColor: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">let</span> borderThickness: <span class="type">CGFloat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// UIView 的必要初始化方法</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(borderColor: <span class="type">UIColor</span>, borderThickness: <span class="type">CGFloat</span>, frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.borderColor = borderColor</span><br><span class="line">        <span class="keyword">self</span>.borderThickness = borderThickness</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UIView 的必要初始化方法</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要创建、配置、显示一个 <code>UIViewWithBorder</code> 的实例，我在我的 <code>ViewController</code> 子类中的 <code>IBAction</code> 中写了如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> customFrame2 = <span class="type">CGRect</span>(x: <span class="number">110</span>, y: <span class="number">320</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> customView2 = <span class="type">UIViewWithBorder</span>(borderColor: .red, borderThickness: <span class="number">10.0</span>, frame: customFrame2)</span><br><span class="line">customView2.addBorder()</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(customView2)</span><br></pre></td></tr></table></figure><h2 id="我不想做的事"><a href="#我不想做的事" class="headerlink" title="我不想做的事"></a>我不想做的事</h2><p>我不想去创建像这样的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBorder</span><span class="params">()</span></span> &#123;  ...  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBackgroundColor</span><span class="params">()</span></span> &#123;  ...  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样也许在一些情况下是有效的，但我感觉这种实现太粗泛了，容易丧失很多细颗粒度的控制。这种实现也容易使得这种构造方法变成 <code>UIView</code> 相关扩展方法的垃圾场，换句话说，代码容易变得臃肿。随着方法越来越多，代码也变得越来越难以阅读和维护。</p><p>在上述所有基于 <code>UIKit</code> 的协议中，我都使用了 <code>UIView</code> 的子类——引用类型。子类化能够让我能直接访问父类 <code>UIView</code> 中的任何内容，让我的代码清晰、简短、易读。如果我使用的是 <code>struct</code>，我的代码会变得更加冗长，至于为什么，留给你们当做练习。</p><h2 id="我做的事情"><a href="#我做的事情" class="headerlink" title="我做的事情"></a>我做的事情</h2><p>时刻记住，所有这些默认协议 <code>extensions</code> 可以在类扩展中覆盖。用一个例子和图片来解释：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SimpleViewWithBorder</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SimpleViewWithBorder</span> <span class="title">where</span> <span class="title">Self</span> : <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBorder</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        layer.borderColor = <span class="type">UIColor</span>.green.cgColor</span><br><span class="line">        layer.borderWidth = <span class="number">10.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleUIViewWithBorder</span> : <span class="title">UIView</span>, <span class="title">SimpleViewWithBorder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 覆盖 extension 中的默认实现</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBorder</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        layer.borderColor = <span class="type">UIColor</span>.darkGray.cgColor</span><br><span class="line">        layer.borderWidth = <span class="number">20.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我在 <code>SimpleUIViewWithBorder</code> 中的注释。看下图中最上面的视图：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/03/Override-Extended-UIView.gif" alt=""></p><h2 id="真实的，基于协议的泛型数据结构"><a href="#真实的，基于协议的泛型数据结构" class="headerlink" title="真实的，基于协议的泛型数据结构"></a>真实的，基于协议的泛型数据结构</h2><p>我非常骄傲在我自己的应用中，我能够写尽量少的 POP 代码，来创建完整功能的泛型的栈和队列的数据结构。想了解有关 Swift 中的泛型，请阅读我 AppCoda 中的 <a href="https://appcoda.com/swift-generics/" target="_blank" rel="noopener">文章</a>。</p><p>请注意，我使用协议继承来帮助我利用抽象的 <code>List</code> 协议去创建更加具体的 <code>FIFO</code> 和 <code>LIFO</code> 协议。然后，我利用协议扩展来实现 <code>Queue</code> 和 <code>Stack</code> 值类型。你可以在下面的 Xcode 9 playground 中看到这些 <code>struct</code> 的实例。</p><p>我想向你展示的是如何像 Apple 建议的一样，通过其他协议来实现自己自定义的协议，因此，我创建了 <code>ListSubscript</code>，<code>ListPrintForwards</code>，<code>ListPrintBackwards</code>，<code>ListCount</code>协议。它们现在还很简单，但在一个实际的应用中将会展现出其作用。</p><p>这种继承多个其他协议的做法可以让开发者为现有代码增加新的功能，而且不会因为太多额外不相关的功能对代码造成”污染“或”臃肿“。这些协议中，每一个都是独立的。如果是作为类被添加到继承层级中叶级以上的话，根据它们所处的位置，这些功能将会至少自动被其他一些类继承。</p><p>关于 POP，我已经讲了足够多来帮助你阅读和理解代码。再给出一个我是如何让我的数据结构支持泛型的提示：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID189" target="_blank" rel="noopener">关联类型的定义</a>。</p><blockquote><p>当定义一个协议的时候，有时可以声明一个或多个关联类型，作为协议定义的一部分。一个关联类型提供了一个占位名，用来表示协议中的一种类型。这个关联类型真正的数据类型直到该协议被使用的时候才确定。使用 <code>associatedtype</code> 关键字来指明一个关联类型。</p></blockquote><p>代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ListSubscript</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">AnyType</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> elements : [<span class="type">AnyType</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ListSubscript</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Any</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ListPrintForwards</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">AnyType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> elements : [<span class="type">AnyType</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ListPrintForwards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showList</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> elements.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> line = <span class="string">""</span></span><br><span class="line">            <span class="keyword">var</span> index = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> element <span class="keyword">in</span> elements &#123;</span><br><span class="line">                line += <span class="string">"<span class="subst">\(element)</span> "</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(line)</span>\n"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"EMPTY\n"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ListPrintBackward</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">AnyType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> elements : [<span class="type">AnyType</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ListPrintBackwards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showList</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> elements.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> line = <span class="string">""</span></span><br><span class="line">            <span class="keyword">var</span> index = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> elements.reversed() &#123;</span><br><span class="line">                line += <span class="string">"<span class="subst">\(element)</span> "</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(line)</span>\n"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"EMPTY\n"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ListCount</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">AnyType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> elements : [<span class="type">AnyType</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ListCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elements.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">AnyType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> elements : [<span class="type">AnyType</span>] &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">()</span></span> -&gt; <span class="type">AnyType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> element: AnyType)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> element: AnyType)</span></span> &#123;</span><br><span class="line">        elements.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">FIFO</span> : <span class="title">List</span>, <span class="title">ListCount</span>, <span class="title">ListPrintForwards</span>, <span class="title">ListSubscript</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FIFO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">()</span></span> -&gt; <span class="type">AnyType</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> elements.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> elements.removeFirst()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"******EMPTY******"</span> <span class="keyword">as</span>! <span class="type">AnyType</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&lt;<span class="title">AnyType</span>&gt;: <span class="title">FIFO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elements: [<span class="type">AnyType</span>] = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> queue = <span class="type">Queue</span>&lt;<span class="type">Any</span>&gt;()</span><br><span class="line">queue.add(<span class="string">"Bob"</span>)</span><br><span class="line">queue.showList()</span><br><span class="line">queue.add(<span class="number">1</span>)</span><br><span class="line">queue.showList()</span><br><span class="line">queue.add(<span class="number">3.0</span>)</span><br><span class="line"><span class="number">_</span> = queue[<span class="number">0</span>] <span class="comment">// 该下标输出 "Bob"</span></span><br><span class="line"><span class="number">_</span> = queue.<span class="built_in">count</span>()</span><br><span class="line">queue.showList()</span><br><span class="line">queue.remove()</span><br><span class="line">queue.showList()</span><br><span class="line">queue.remove()</span><br><span class="line">queue.showList()</span><br><span class="line">queue.remove()</span><br><span class="line">queue.showList()</span><br><span class="line"><span class="number">_</span> = queue.<span class="built_in">count</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LIFO</span> : <span class="title">List</span>, <span class="title">ListCount</span>, <span class="title">ListPrintBackwards</span>, <span class="title">ListSubscript</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LIFO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">()</span></span> -&gt; <span class="type">AnyType</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> elements.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> elements.removeLast()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"******EMPTY******"</span> <span class="keyword">as</span>! <span class="type">AnyType</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">AnyType</span>&gt;: <span class="title">LIFO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elements: [<span class="type">AnyType</span>] = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stack = <span class="type">Stack</span>&lt;<span class="type">Any</span>&gt;()</span><br><span class="line">stack.add(<span class="string">"Bob"</span>)</span><br><span class="line">stack.showList()</span><br><span class="line">stack.add(<span class="number">1</span>)</span><br><span class="line">stack.showList()</span><br><span class="line">stack.add(<span class="number">3.0</span>)</span><br><span class="line"><span class="number">_</span> = stack[<span class="number">0</span>] <span class="comment">// 该下标输出 3</span></span><br><span class="line"><span class="number">_</span> = stack.<span class="built_in">count</span>()</span><br><span class="line">stack.showList()</span><br><span class="line">stack.remove()</span><br><span class="line">stack.showList()</span><br><span class="line">stack.remove()</span><br><span class="line">stack.showList()</span><br><span class="line">stack.remove()</span><br><span class="line">stack.showList()</span><br><span class="line"><span class="number">_</span> = stack.<span class="built_in">count</span>()</span><br></pre></td></tr></table></figure><p>这一段代码片段在控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bob</span><br><span class="line"></span><br><span class="line">Bob 1</span><br><span class="line"></span><br><span class="line">Bob 1 3.0</span><br><span class="line"></span><br><span class="line">1 3.0</span><br><span class="line"></span><br><span class="line">3.0</span><br><span class="line"></span><br><span class="line">EMPTY</span><br><span class="line"></span><br><span class="line">Bob</span><br><span class="line"></span><br><span class="line">1 Bob</span><br><span class="line"></span><br><span class="line">3.0 1 Bob</span><br><span class="line"></span><br><span class="line">1 Bob</span><br><span class="line"></span><br><span class="line">Bob</span><br><span class="line"></span><br><span class="line">EMPTY</span><br></pre></td></tr></table></figure><h2 id="我没有-100-使用-POP"><a href="#我没有-100-使用-POP" class="headerlink" title="我没有 100% 使用 POP"></a>我没有 100% 使用 POP</h2><p>在 WWDC 有关 POP 的视频之一中，一位工程师/讲师说 <a href="https://developer.apple.com/videos/play/wwdc2015-408/?time=882" target="_blank" rel="noopener">”在 Swift 中我们有一种说法，不要从一个类开始写代码，从一个协议开始“</a>。嘛~也许吧。这家伙开始了有关如何使用协议来写一个二分查找的冗长的讨论。我有点怀疑，这是不是我许多读者印象最深的部分。看完你失眠了吗？</p><p>这有点像是为了寻找一个 POP 解决方案而人为设计出的一个问题。也许问题是实际的，也许这种解决方案有优点，我也不知道。我的时间很宝贵，没有时间浪费在这种象牙塔理论上。如果读懂一段代码需要超过 5 分钟的时间，我就觉得这段代码违背了 Apple 的 ”local reasoning“ 原则。</p><p>如果你和我一样也是一个软件开发者，最好始终对新的方法论保持一个开放的心态，并且始终将控制复杂度作为你的主要工作重心。我绝不反对赚钱，但看得更高更远一点是有好处的。记住，Apple 是一家公司，一家大公司，主要使命是赚大钱，上周五的市值已经接近 8370 亿美元，拥有数千亿的现金和现金等价物。他们想让每个人都使用 Swift，而这些公司吸引人到自家生态系统的方法之一就是提供别人都提供不了的产品和服务。是的，<a href="https://developer.apple.com/swift/blog/?id=34" target="_blank" rel="noopener">Swift 是开源的</a>，但 Apple 从 App Store 赚了大钱，因此应用正是让所有 Apple 设备变得有用的关键，许许多多的开发者正在向 Swift 迁移。</p><p>我觉得没有任何理由只用 POP 进行编程。我认为 POP 和我使用的其他许多技术，甚至是 OOP 一样，都有一些问题。我们是在对现实建模，或者至少说，我们是在对现实进行拟合。没有完美的解决方案。所以，将 POP 作为你的开发工具箱中的一种吧，就像人们长年以来总结出的其他优秀的方案一样。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>30 年的开发经验，让我能够平心静气地说，<strong>你应该了解协议和 POP。</strong>开始设计并书写你自己的 POP 代码吧。</p><p>我已经花费了不少时间试用 POP，并且已经将这篇文章中的协议使用在了我自己的应用中，比如 <code>SimpleViewWithBorder</code>，<code>ViewWithBackground</code>，<code>ViewWithBorder</code>，<code>List</code>，<code>FIFO</code>，<code>LIFO</code>。POP 威力无穷。</p><p>正如我在前一篇文章中提到的，学习并接受一种新方法，比如 POP，并不是一个非对即错的事情。POP 和 OOP 不仅能并存，还能够互相补充。</p><p>所以，开始试验、练习、学习吧。最后，尽情享受生活和工作吧。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了面向协议编程的优缺点，以及与面向对象编程的对比。
    
    </summary>
    
      <category term="appcoda" scheme="https://swift.gg/categories/appcoda/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的设计模式 #3 外观模式与适配器模式</title>
    <link href="https://swift.gg/2018/11/29/design-pattern-structural/"/>
    <id>https://swift.gg/2018/11/29/design-pattern-structural/</id>
    <published>2018-11-29T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://www.appcoda.com/design-pattern-structural/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-09-04<br>译者：<a href="https://www.jianshu.com/u/076cc5e18bb8" target="_blank" rel="noopener">郑一一</a>；校对：<a href="https://bignerdcoding.com/" target="_blank" rel="noopener">BigNerdCoding</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>本文是我的设计模式系列教程的第三篇。在第一篇文章中，我介绍了 <a href="https://swift.gg/2018/09/10/design-pattern-creational/"><strong>创建型模式</strong>中的<em>工厂模式</em>和<em>单例模式</em></a>。在第二篇文章中，又讨论了一下 <a href="https://swift.gg/2018/11/26/design-pattern-behavorial/"><strong>行为型模式</strong>中的<em>观察者模式</em>和<em>备忘录模式</em></a>。</p><a id="more"></a><p>在本文中，我会就结构型模式中的<strong>外观模式</strong>和<strong>适配器模式</strong>分别举一个例子。首先，我建议你先去阅读前面提到的两篇文章，这会有助于你更熟悉软件设计模式的一些概念。除了简短地介绍一下设计模式的组成，我不会再重复介绍所有关于设计模式的概念了。如果需要了解，都可以在前面写的 <a href="https://swift.gg/2018/09/10/design-pattern-creational/"><strong>第一篇</strong></a>、 <a href="https://swift.gg/2018/11/26/design-pattern-behavorial/"><strong>第二篇</strong></a> 中找到。</p><p>接下来的几节，我们先来简单回顾一下设计模式的通用概念。“Gang of Four” (“GoF”) Erich Gamma，Richard Helm，Ralph Johonson，和 John Vlissides 在他们“<a href="https://smile.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8/" target="_blank" rel="noopener"><strong>设计模式：面向对象软件设计复用的基本原理</strong></a>”的重要著作里整理了 23 种经典的设计模式。今天我们重点关注的是两种结构型设计模式：<strong>外观模式</strong>和<strong>适配器模式</strong>。</p><h2 id="值语义的面向协议编程"><a href="#值语义的面向协议编程" class="headerlink" title="值语义的面向协议编程"></a>值语义的面向协议编程</h2><p>你可能会发现世面上非常多设计模式教程的示例代码，仍然是基于面向对象编程原则（OOP）、引用语义和 <a href="http://iosbrain.com/blog/2018/06/07/swift-4-memory-management-via-arc-for-reference-types-classes/" target="_blank" rel="noopener"><strong>引用类型</strong></a>（classes）编写的。所以，我决定编写一套基于 <a href="https://www.appcoda.com/pop-vs-oop/" target="_blank" rel="noopener"><strong>面向协议编程原则</strong></a>（POP）、值语义和 <a href="https://developer.apple.com/videos/play/wwdc2015/414/" target="_blank" rel="noopener"><strong>值类型</strong></a>（structs）的设计模式系列教程。如果你已经看过了我之前写的两篇文章，我希望你还能够熟悉一下 OOP 和 POP，引用语义和值语义这些概念。如果你还不是特别熟悉，我强烈建议赶紧去了解一下这些主题。本文所举的例子是全部基于 POP 和值语义的。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是开发者用于管理软件复杂性极其重要的工具。作为常见的模板技术，它很好地对软件中类似的、重复出现的、容易识别的问题进行了概念化抽象。我们可以将它视作最佳实践，从而应用到日常中会遇到的那些编程场景中。举一个具体的例子，回想一下你在平常写代码过程中有多少次会使用或写了遵守 <a href="https://www.appcoda.com/design-pattern-behavorial/" target="_blank" rel="noopener"><strong>观察者设计模式</strong></a> 的代码吧。</p><p>在观察者模式中，被观察者（一般来说是一个关键资源）会给所有依赖于自己的观察者，广播通知其内部状态的变化。观察者必须告知被观察者自己想接收通知，换句话说，观察者必须订阅通知。用户授权的 iOS 弹窗推送通知，就是一个典型的观察者模式的例子。</p><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p>GoF 将 23 种设计模式归纳为三种类型，分别是“<a href="https://www.appcoda.com/design-pattern-creational/" target="_blank" rel="noopener"><strong>创建型</strong></a>”、“<a href="https://www.appcoda.com/design-pattern-behavorial/" target="_blank" rel="noopener"><strong>行为型</strong></a>”、“结构型”。本文会介绍两种<strong>结构型</strong>设计模式。先看一下结构这个词的定义：</p><blockquote><p>“以一种确定方式构建的事物以及实体中各部分元素之间不同关系的汇总。”<br>- <a href="https://www.merriam-webster.com/dictionary/structure" target="_blank" rel="noopener">https://www.merriam-webster.com/dictionary/structure</a></p></blockquote><p>结构型设计模式的主要作用是明确一段代码的功能，并说明如何使用。大部分的结构型设计模式可以通过编写易读接口，来实现对一段代码的简化使用。因为一段代码势必要与其它代码联系，如果要为代码段编写出良好的接口，必须明确清晰地定义代码之间的各种关系。</p><h2 id="外观设计模式"><a href="#外观设计模式" class="headerlink" title="外观设计模式"></a><em>外观</em>设计模式</h2><blockquote><p>“外观可以定义为特殊结构化的建筑物表面或者错误的、表面上的、人为的外形或效果”。<br>- <a href="https://www.merriam-webster.com/dictionary/facade" target="_blank" rel="noopener">https://www.merriam-webster.com/dictionary/facade</a></p></blockquote><p>大部分情况下，可以使用外观模式，为一组复杂接口创建一个简单接口。或许你已经写过“封装”代码。“封装”的意思就是对一段复杂代码的简化使用。</p><h3 id="外观设计模式的示例-app"><a href="#外观设计模式的示例-app" class="headerlink" title="外观设计模式的示例 app"></a><em>外观</em>设计模式的示例 app</h3><p>外观设计模式示例的 playground 文件，可以在 <a href="https://github.com/appcoda/swift-design-patterns/tree/master/Facade" target="_blank" rel="noopener"><strong>GitHub</strong></a> 找到。在这个例子里展示了，如何通过外观设计模式，来为沙盒文件系统创建一个简单的接口，供所有的 iOS app 使用。iOS 文件系统是一个庞大的操作系统子系统，功能包括创建、读取、删除、移动、重命名、拷贝文件和目录。允许获取和设置文件和目录的元数据，比如列出在指定目录下的所有文件。允许查看文件和目录的状态，比如某个指定文件是否可写。提供苹果推荐、预定义的目录名。实际上其包含的功能远远不止上面提到的这些。</p><p>由于 iOS 文件系统是一个拥有如此多特性和功能的宏大主题，因此也是一个非常好的例子，用来讲解如何通过外观设计模式来简化代码的使用。外观接口会废弃掉无关功能和杂乱代码的部分。另一方面，外观接口只会定义在某个具体 app 需要使用到的功能。或者在我的例子中，我将功能缩减到只有经常使用的那部分。这样做的好处是保证代码在不同 app 中都是可复用、可扩展，可维护的。</p><p>基于面向协议编程和值语义，我将 iOS 文件系统的主要特性进行了划分，从而将其变成可复用、可扩展的单元：协议和协议扩展。</p><p>我<a href="http://iosbrain.com/blog/2018/04/22/ios-file-management-with-filemanager-in-protocol-oriented-swift-4/" target="_blank" rel="noopener"><strong>将四个协议组合成一个结构体，这个结构体代表了可以在所有 iOS 应用中使用的沙盒 iOS 目录</strong></a>（还可以看 <a href="http://iosbrain.com/blog/2018/05/29/the-ios-file-system-in-depth/" target="_blank" rel="noopener"><strong>这篇文章</strong></a>）。因为未来你肯定会更多接触到更多面向协议编程和值语义相关的主题，要注意术语 <strong>composed</strong> 和 <strong>composition</strong> 在这里属于同义词。</p><p>除此之外，为了让你更专注于理解外观设计模式的使用，在后面的代码中，我省略了 Swift 错误处理和通用错误检查的代码。</p><h3 id="外观设计模式的示例代码"><a href="#外观设计模式的示例代码" class="headerlink" title="外观设计模式的示例代码"></a>外观设计模式的示例代码</h3><p>接下来就看看我的代码吧。先确保已经下载了我在 <a href="https://github.com/appcoda/swift-design-patterns/tree/master/Facade" target="_blank" rel="noopener"><strong>GitHub</strong></a> 上的 playground 文件。下面是苹果官方推荐的用于文件系统操作的预定义目录。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AppDirectories</span> : <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Documents</span> = <span class="string">"Documents"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Inbox</span> = <span class="string">"Inbox"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Library</span> = <span class="string">"Library"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Temp</span> = <span class="string">"tmp"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将文件操作限定在上述目录中，避免了复杂性，并遵循了人机界面指南的原则。</p><p>在探究文件操作的核心代码之前，先来看看使用外观设计模式所设计出来的接口吧。我创建了 <code>iOSAppFileSystemDirectory</code> 结构体，作为文件系统常用功能的简单可读接口。这个接口适用于 <code>AppDirectories</code> 枚举下的所有目录。事实上，我原本还可以加入诸如 <a href="https://developer.apple.com/documentation/foundation/filemanager/1414652-createsymboliclink" target="_blank" rel="noopener"><strong>符号化链接的创建</strong></a>，或者使用 <code>FileHandle</code> 类实现对文件的精细控制。但是在实际情况中，我几乎不太使用到这些功能，更重要的一点是，我想要保持代码的简洁性。</p><p>我创建了由四个协议组成的外观。（我知道你看到下面的代码中只遵循了三个协议，这其实是因为其中有一个协议继承自另一个协议）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iOSAppFileSystemDirectory</span> : <span class="title">AppFileManipulation</span>, <span class="title">AppFileStatusChecking</span>, <span class="title">AppFileSystemMetaData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> workingDirectory: <span class="type">AppDirectories</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(using directory: <span class="type">AppDirectories</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.workingDirectory = directory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(containing text: String, withName name: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> writeFile(containing: text, to: workingDirectory, withName: name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(withName name: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> readFile(at: workingDirectory, withName: name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deleteFile</span><span class="params">(withName name: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deleteFile(at: workingDirectory, withName: name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showAttributes</span><span class="params">(forFile named: String)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fullPath = buildFullPath(forFileName: named, inDirectory: workingDirectory)</span><br><span class="line">        <span class="keyword">let</span> fileAttributes = attributes(ofFile: fullPath)</span><br><span class="line">        <span class="keyword">for</span> attribute <span class="keyword">in</span> fileAttributes &#123;</span><br><span class="line">            <span class="built_in">print</span>(attribute)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">list</span><span class="params">()</span></span> &#123;</span><br><span class="line">        list(directory: getURL(<span class="keyword">for</span>: workingDirectory))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 完成结构体 iOSAppFileSystemDirectory 的定义</span></span><br></pre></td></tr></table></figure><p>下面是一些用于测试 <code>iOSAppFileSystemDirectory</code> 结构体的代码： </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iOSDocumentsDirectory = iOSAppFileSystemDirectory(using: .<span class="type">Documents</span>)</span><br><span class="line"></span><br><span class="line">iOSDocumentsDirectory.writeFile(containing: <span class="string">"New file created."</span>, withName: <span class="string">"myFile3.txt"</span>)</span><br><span class="line">iOSDocumentsDirectory.list()</span><br><span class="line">iOSDocumentsDirectory.readFile(withName: <span class="string">"myFile3.txt"</span>)</span><br><span class="line">iOSDocumentsDirectory.showAttributes(forFile: <span class="string">"myFile3.txt"</span>)</span><br><span class="line">iOSDocumentsDirectory.deleteFile(withName: <span class="string">"myFile3.txt"</span>)</span><br></pre></td></tr></table></figure><p>接下来的代码是在运行了 playground 文件中代码之后的控制台输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------------</span><br><span class="line">LISTING: /var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Facade-Design-Pattern-1C4BD3E3-E23C-4991-A344-775D5585D1D7/Documents</span><br><span class="line"></span><br><span class="line">File: &quot;myFile3.txt&quot;</span><br><span class="line">File: &quot;Shared Playground Data&quot;</span><br><span class="line"></span><br><span class="line">----------------------------</span><br><span class="line"></span><br><span class="line">File created with contents: New file created.</span><br><span class="line"></span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileType), value: NSFileTypeRegular)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFilePosixPermissions), value: 420)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileSystemNumber), value: 16777223)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileExtendedAttributes), value: &#123;</span><br><span class="line">    &quot;com.apple.quarantine&quot; = &lt;30303836 3b356238 36656364 373b5377 69667420 46616361 64652044 65736967 6e205061 74746572 6e3b&gt;;</span><br><span class="line">&#125;)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileReferenceCount), value: 1)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileSystemFileNumber), value: 24946094)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileGroupOwnerAccountID), value: 20)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileModificationDate), value: 2018-08-29 18:58:31 +0000)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileCreationDate), value: 2018-08-29 18:58:31 +0000)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileSize), value: 17)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileExtensionHidden), value: 0)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileOwnerAccountID), value: 502)</span><br><span class="line"></span><br><span class="line">File deleted.</span><br></pre></td></tr></table></figure><p>我们来简单讨论下 <code>iOSAppFileSystemDirectory</code> 结构体所遵循的几个协议。<code>AppDirectoryNames</code> 协议和扩展定义和实现了以 <code>URL</code> 类型获取 <code>AppDirectories</code> 枚举中目录完整路径的方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentsDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inboxDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">libraryDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tempDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getURL</span><span class="params">(<span class="keyword">for</span> directory: AppDirectories)</span></span> -&gt; <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buildFullPath</span><span class="params">(forFileName name: String, inDirectory directory: AppDirectories)</span></span> -&gt; <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end protocol AppDirectoryNames</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentsDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask).first!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inboxDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask)[<span class="number">0</span>].appendingPathComponent(<span class="type">AppDirectories</span>.<span class="type">Inbox</span>.rawValue) <span class="comment">// "Inbox")</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">libraryDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: <span class="type">FileManager</span>.<span class="type">SearchPathDirectory</span>.libraryDirectory, <span class="keyword">in</span>: .userDomainMask).first!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tempDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.temporaryDirectory</span><br><span class="line">        <span class="comment">//urls(for: .documentDirectory, in: .userDomainMask)[0].appendingPathComponent(AppDirectories.Temp.rawValue) //"tmp")</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getURL</span><span class="params">(<span class="keyword">for</span> directory: AppDirectories)</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> directory &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Documents</span>:</span><br><span class="line">            <span class="keyword">return</span> documentsDirectoryURL()</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Inbox</span>:</span><br><span class="line">            <span class="keyword">return</span> inboxDirectoryURL()</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Library</span>:</span><br><span class="line">            <span class="keyword">return</span> libraryDirectoryURL()</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Temp</span>:</span><br><span class="line">            <span class="keyword">return</span> tempDirectoryURL()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buildFullPath</span><span class="params">(forFileName name: String, inDirectory directory: AppDirectories)</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getURL(<span class="keyword">for</span>: directory).appendingPathComponent(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end extension AppDirectoryNames</span></span><br></pre></td></tr></table></figure><p><code>AppFileStatusChecking</code> 协议和扩展封装了获取文件状态数据的方法。这些文件同样存储于 <code>AppDirectories</code> 枚举定义下的目录。通过“状态”，可以确定某个文件是否存在，是否可读等。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AppFileStatusChecking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isWritable</span><span class="params">(file at: URL)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isReadable</span><span class="params">(file at: URL)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">exists</span><span class="params">(file at: URL)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppFileStatusChecking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isWritable</span><span class="params">(file at: URL)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.isWritableFile(atPath: at.path) &#123;</span><br><span class="line">            <span class="built_in">print</span>(at.path)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(at.path)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isReadable</span><span class="params">(file at: URL)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.isReadableFile(atPath: at.path) &#123;</span><br><span class="line">            <span class="built_in">print</span>(at.path)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(at.path)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">exists</span><span class="params">(file at: URL)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.fileExists(atPath: at.path) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end extension AppFileStatusChecking</span></span><br></pre></td></tr></table></figure><p><code>AppFileSystemMetaData</code> 协议和扩展实现了列出目录内容和获取扩展文件的功能。 其目录也是定义在 <code>AppDirectories</code> 枚举下。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AppFileSystemMetaData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">list</span><span class="params">(directory at: URL)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">attributes</span><span class="params">(ofFile atFullPath: URL)</span></span> -&gt; [<span class="type">FileAttributeKey</span> : <span class="type">Any</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppFileSystemMetaData</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">list</span><span class="params">(directory at: URL)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> listing = <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.contentsOfDirectory(atPath: at.path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> listing.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\n----------------------------"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"LISTING: <span class="subst">\(at.path)</span>"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> listing &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"File: <span class="subst">\(file.debugDescription)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"----------------------------\n"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">attributes</span><span class="params">(ofFile atFullPath: URL)</span></span> -&gt; [<span class="type">FileAttributeKey</span> : <span class="type">Any</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.attributesOfItem(atPath: atFullPath.path)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//  end extension AppFileSystemMetaData</span></span><br></pre></td></tr></table></figure><p>最后是 <code>AppFileManipulation</code> 协议和扩展，封装了 <code>AppDirectories</code> 枚举目录下的所有文件操作方法，包括了读、写、删除、重命名、移动、拷贝修改文件扩展名等。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AppFileManipulation</span> : <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(containing: String, to path: AppDirectories, withName name: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(at path: AppDirectories, withName name: String)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deleteFile</span><span class="params">(at path: AppDirectories, withName name: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">renameFile</span><span class="params">(at path: AppDirectories, with oldName: String, to newName: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">moveFile</span><span class="params">(withName name: String, inDirectory: AppDirectories, toDirectory directory: AppDirectories)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copyFile</span><span class="params">(withName name: String, inDirectory: AppDirectories, toDirectory directory: AppDirectories)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">changeFileExtension</span><span class="params">(withName name: String, inDirectory: AppDirectories, toNewExtension newExtension: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppFileManipulation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(containing: String, to path: AppDirectories, withName name: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filePath = getURL(<span class="keyword">for</span>: path).path + <span class="string">"/"</span> + name</span><br><span class="line">        <span class="keyword">let</span> rawData: <span class="type">Data</span>? = containing.data(using: .utf8)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.createFile(atPath: filePath, contents: rawData, attributes: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(at path: AppDirectories, withName name: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filePath = getURL(<span class="keyword">for</span>: path).path + <span class="string">"/"</span> + name</span><br><span class="line">        <span class="keyword">let</span> fileContents = <span class="type">FileManager</span>.<span class="keyword">default</span>.contents(atPath: filePath)</span><br><span class="line">        <span class="keyword">let</span> fileContentsAsString = <span class="type">String</span>(bytes: fileContents!, encoding: .utf8)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"File created with contents: <span class="subst">\(fileContentsAsString!)</span>\n"</span>)</span><br><span class="line">        <span class="keyword">return</span> fileContentsAsString!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deleteFile</span><span class="params">(at path: AppDirectories, withName name: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filePath = buildFullPath(forFileName: name, inDirectory: path)</span><br><span class="line">        <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.removeItem(at: filePath)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\nFile deleted.\n"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">renameFile</span><span class="params">(at path: AppDirectories, with oldName: String, to newName: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> oldPath = getURL(<span class="keyword">for</span>: path).appendingPathComponent(oldName)</span><br><span class="line">        <span class="keyword">let</span> newPath = getURL(<span class="keyword">for</span>: path).appendingPathComponent(newName)</span><br><span class="line">        <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.moveItem(at: oldPath, to: newPath)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// highlights the limitations of using return values</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">moveFile</span><span class="params">(withName name: String, inDirectory: AppDirectories, toDirectory directory: AppDirectories)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> originURL = buildFullPath(forFileName: name, inDirectory: inDirectory)</span><br><span class="line">        <span class="keyword">let</span> destinationURL = buildFullPath(forFileName: name, inDirectory: directory)</span><br><span class="line">        <span class="comment">// warning: constant 'success' inferred to have type '()', which may be unexpected</span></span><br><span class="line">        <span class="comment">// *let success =*</span></span><br><span class="line">        <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.moveItem(at: originURL, to: destinationURL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copyFile</span><span class="params">(withName name: String, inDirectory: AppDirectories, toDirectory directory: AppDirectories)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> originURL = buildFullPath(forFileName: name, inDirectory: inDirectory)</span><br><span class="line">        <span class="keyword">let</span> destinationURL = buildFullPath(forFileName: name, inDirectory: directory)</span><br><span class="line">        <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.copyItem(at: originURL, to: destinationURL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">changeFileExtension</span><span class="params">(withName name: String, inDirectory: AppDirectories, toNewExtension newExtension: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> newFileName = <span class="type">NSString</span>(string:name)</span><br><span class="line">        newFileName = newFileName.deletingPathExtension <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">        newFileName = (newFileName.appendingPathExtension(newExtension) <span class="keyword">as</span> <span class="type">NSString</span>?)!</span><br><span class="line">        <span class="keyword">let</span> finalFileName:<span class="type">String</span> =  <span class="type">String</span>(newFileName)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> originURL = buildFullPath(forFileName: name, inDirectory: inDirectory)</span><br><span class="line">        <span class="keyword">let</span> destinationURL = buildFullPath(forFileName: finalFileName, inDirectory: inDirectory)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.moveItem(at: originURL, to: destinationURL)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end extension AppFileManipulation</span></span><br></pre></td></tr></table></figure><h2 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a><em>适配器</em>设计模式</h2><blockquote><p>“适配”的含义是“通过修改让一个事物更适合（用于新用途）。”<br>- <a href="https://www.merriam-webster.com/dictionary/adapts" target="_blank" rel="noopener">https://www.merriam-webster.com/dictionary/adapts</a></p></blockquote><blockquote><p>“适配器”的含义是“用于适配不在初始使用意图范围内设备的一种附加装置。”<br>- <a href="https://www.merriam-webster.com/dictionary/adapter" target="_blank" rel="noopener">https://www.merriam-webster.com/dictionary/adapter</a></p></blockquote><p>适配器设计模式的作用是在不修改已有代码库 “A” 的前提下，仍旧可以使用与代码库 “A” 不兼容的代码库 “B”，并保证 “A” 可以正常工作。我们可以创建适配器来保证 “A” 和 “B” 可以一起工作。其中一定要牢记的原则是代码库 “A” 是不能被修改的。（这是因为修改会破坏原有代码或者我们根本就没有这段源代码）</p><h3 id="适配器设计模式示例-app"><a href="#适配器设计模式示例-app" class="headerlink" title="适配器设计模式示例 app"></a><em>适配器</em>设计模式示例 app</h3><p>适配器的 playground 文件，可以在 <a href="https://github.com/appcoda/swift-design-patterns/tree/master/Adapter" target="_blank" rel="noopener"><strong>GitHub</strong></a> 上找到。在这部分代码中，我们基于 iOS 文件系统进行适配器模式的讨论，并基于 iOS 文件系统设计了一个适配器模式的例子。之前一章，我们已经实现了将 iOS 文件系统中所有目录和文件的路径表示为 <code>URL</code> 实例。想象一下下面的场景，在原有工程中已经存在了大量关于 iOS 文件系统的代码，但是所有目录和文件的路径都表示成了字符串形式。那我们就必须要让基于 URL 和基于 String 的代码可以协同工作。</p><h4 id="适配器设计模式的示例代码"><a href="#适配器设计模式的示例代码" class="headerlink" title="适配器设计模式的示例代码"></a><em>适配器</em>设计模式的示例代码</h4><p>接下来就看看代码吧。先确保已经下载了在 <a href="https://github.com/appcoda/swift-design-patterns/tree/master/Adapter" target="_blank" rel="noopener"><strong>GitHub</strong></a> 上的 playground 文件。为了在接下来的分析中更加专注于适配器模式的讨论，下面会使用简化版本的 <code>AppDirectories</code> 枚举和 <code>AppDirectoryNames</code> 协议和扩展。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AppDirectories</span> : <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Documents</span> = <span class="string">"Documents"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Temp</span> = <span class="string">"tmp"</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentsDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tempDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentsDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask).first!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tempDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.temporaryDirectory</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种方法是创建一个“专用”适配器。这个适配器会返回字符串路径，这些路径全部归属于在 <code>AppDirectories</code> 下的目录和文件。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 专用适配器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iOSFile</span> : <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fileName: <span class="type">URL</span></span><br><span class="line">    <span class="keyword">var</span> fullPathInDocuments: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> documentsDirectoryURL().appendingPathComponent(fileName.absoluteString).path</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fullPathInTemporary: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tempDirectoryURL().appendingPathComponent(fileName.absoluteString).path</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> documentsStringPath: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> documentsDirectoryURL().path</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> temporaryStringPath: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tempDirectoryURL().path</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">init</span>(fileName: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fileName = <span class="type">URL</span>(string: fileName)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一部分是用于测试 <code>iOSFile</code> “专用”适配器的代码，请注意代码中的注释。 </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iOSfile = iOSFile(fileName: <span class="string">"myFile.txt"</span>)</span><br><span class="line">iOSfile.fullPathInDocuments</span><br><span class="line">iOSfile.documentsStringPath</span><br><span class="line"> </span><br><span class="line">iOSfile.fullPathInTemporary</span><br><span class="line">iOSfile.temporaryStringPath</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过 `AppDirectoryNames` 协议，仍然能够访问到 URL</span></span><br><span class="line">iOSfile.documentsDirectoryURL()</span><br><span class="line">iOSfile.tempDirectoryURL()</span><br></pre></td></tr></table></figure><p>最后是 playground 文件中每一行代码对应的右侧输出，这些输出代表了运行时每一行代码的值。参照上一段代码，我们可以进行逐行对照。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iOSFile</span><br><span class="line">&quot;/var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Adapter-Design-Pattern-0A71F81A-9388-41F5-ACBE-52A1A61A9B99/Documents/myFile.txt&quot;</span><br><span class="line">&quot;/var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Adapter-Design-Pattern-0A71F81A-9388-41F5-ACBE-52A1A61A9B99/Documents&quot;</span><br><span class="line"> </span><br><span class="line">&quot;/Users/softwaretesting/Library/Developer/XCPGDevices/52E1A81A-98AF-42DE-ADCF-E69AC8FA2791/data/Containers/Data/Application/F08EFF4F-8C4F-4BB7-B220-980E16344F18/tmp/myFile.txt&quot;</span><br><span class="line">&quot;/Users/softwaretesting/Library/Developer/XCPGDevices/52E1A81A-98AF-42DE-ADCF-E69AC8FA2791/data/Containers/Data/Application/F08EFF4F-8C4F-4BB7-B220-980E16344F18/tmp&quot;</span><br><span class="line"> </span><br><span class="line">file:///var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Adapter-Design-Pattern-0A71F81A-9388-41F5-ACBE-52A1A61A9B99/Documents/</span><br><span class="line">file:///Users/softwaretesting/Library/Developer/XCPGDevices/52E1A81A-98AF-42DE-ADCF-E69AC8FA2791/data/Containers/Data/Application/F08EFF4F-8C4F-4BB7-B220-980E16344F18/tmp/</span><br></pre></td></tr></table></figure><p>另外，我还倾向为字符串类型的路径设计一个适配器协议。这样就可以很方便地使用<code>字符串</code>路径来替代 <code>URL</code> 路径。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Protocol-oriented approach</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AppDirectoryAndFileStringPathNamesAdpater</span> : <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> fileName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> workingDirectory: <span class="type">AppDirectories</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentsDirectoryStringPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tempDirectoryStringPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fullPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// end protocol AppDirectoryAndFileStringPathAdpaterNames</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDirectoryAndFileStringPathNamesAdpater</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentsDirectoryStringPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> documentsDirectoryURL().path</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tempDirectoryStringPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tempDirectoryURL().path</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fullPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> workingDirectory &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Documents</span>:</span><br><span class="line">            <span class="keyword">return</span> documentsDirectoryStringPath() + <span class="string">"/"</span> + fileName</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Temp</span>:</span><br><span class="line">            <span class="keyword">return</span> tempDirectoryStringPath() + <span class="string">"/"</span> + fileName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125; <span class="comment">// end extension AppDirectoryAndFileStringPathNamesAdpater</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AppDirectoryAndFileStringPathNames</span> : <span class="title">AppDirectoryAndFileStringPathNamesAdpater</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> fileName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> workingDirectory: <span class="type">AppDirectories</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(fileName: <span class="type">String</span>, workingDirectory: <span class="type">AppDirectories</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fileName = fileName</span><br><span class="line">        <span class="keyword">self</span>.workingDirectory = workingDirectory</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// end struct AppDirectoryAndFileStringPathNames</span></span><br></pre></td></tr></table></figure><p>接下来是用于测试 <code>AppDirectoryAndFileStringPathNames</code> 结构体的代码。这个结构体遵守了 <code>AppDirectoryAndFileStringPathNamesAdpater</code> 适配器协议。协议继承自 <code>AppDirectoryNames</code> 协议。注意在代码中的两段注释。 </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> appFileDocumentsDirectoryPaths = <span class="type">AppDirectoryAndFileStringPathNames</span>(fileName: <span class="string">"myFile.txt"</span>, workingDirectory: .<span class="type">Documents</span>)</span><br><span class="line">appFileDocumentsDirectoryPaths.fullPath()</span><br><span class="line">appFileDocumentsDirectoryPaths.documentsDirectoryStringPath()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过 `AppDirectoryNames` 协议仍然可以访问 URL</span></span><br><span class="line">appFileDocumentsDirectoryPaths.documentsDirectoryURL()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> appFileTemporaryDirectoryPaths = <span class="type">AppDirectoryAndFileStringPathNames</span>(fileName: <span class="string">"tempFile.txt"</span>, workingDirectory: .<span class="type">Temp</span>)</span><br><span class="line">appFileTemporaryDirectoryPaths.fullPath()</span><br><span class="line">appFileTemporaryDirectoryPaths.tempDirectoryStringPath()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过 `AppDirectoryNames` 协议仍然可以访问 URL</span></span><br><span class="line">appFileTemporaryDirectoryPaths.tempDirectoryURL()</span><br></pre></td></tr></table></figure><p>最后是在 playground 文件中右侧的输出。每一行代表了运行时的代码值，下面的输出同样和上一段代码是逐行对应的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppDirectoryAndFileStringPathNames</span><br><span class="line">&quot;/var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Adapter-Design-Pattern-A3DE7CC8-D60F-4448-869F-2A19556C62B2/Documents/myFile.txt&quot;</span><br><span class="line">&quot;/var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Adapter-Design-Pattern-A3DE7CC8-D60F-4448-869F-2A19556C62B2/Documents&quot;</span><br><span class="line"> </span><br><span class="line">file:///var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Adapter-Design-Pattern-A3DE7CC8-D60F-4448-869F-2A19556C62B2/Documents/</span><br><span class="line"> </span><br><span class="line">AppDirectoryAndFileStringPathNames</span><br><span class="line">&quot;/Users/softwaretesting/Library/Developer/XCPGDevices/52E1A81A-98AF-42DE-ADCF-E69AC8FA2791/data/Containers/Data/Application/CF3D4156-E773-4BC4-B117-E7BDEFA3F34C/tmp/tempFile.txt&quot;</span><br><span class="line">&quot;/Users/softwaretesting/Library/Developer/XCPGDevices/52E1A81A-98AF-42DE-ADCF-E69AC8FA2791/data/Containers/Data/Application/CF3D4156-E773-4BC4-B117-E7BDEFA3F34C/tmp&quot;</span><br><span class="line"> </span><br><span class="line">file:///Users/softwaretesting/Library/Developer/XCPGDevices/52E1A81A-98AF-42DE-ADCF-E69AC8FA2791/data/Containers/Data/Application/CF3D4156-E773-4BC4-B117-E7BDEFA3F34C/tmp/</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>设计模式不仅有利于代码复用，还能保证代码是不变、易读、松耦合的，从而提高了可维护性和拓展性。当重复出现并且能加以抽象的功能在你的 app 中出现的时候，我希望你能应用一下设计模式，并 <a href="http://iosbrain.com/blog/2018/01/13/building-swift-4-frameworks-and-including-them-in-your-apps-xcode-9/" target="_blank" rel="noopener"><strong>封装进框架</strong></a> 中。这样子你只需要写一次代码，就可以一直复用啦。</p><p>再次感谢大家来 AppCoda 给我捧场。享受工作，坚持学习，下次再见吧！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Andrew Jaffee，&lt;a href=&quot;https://www.appcoda.com/design-pattern-structural/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-09-04&lt;br&gt;译者：&lt;a href=&quot;https://www.jianshu.com/u/076cc5e18bb8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;郑一一&lt;/a&gt;；校对：&lt;a href=&quot;https://bignerdcoding.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigNerdCoding&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;，&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;本文是我的设计模式系列教程的第三篇。在第一篇文章中，我介绍了 &lt;a href=&quot;https://swift.gg/2018/09/10/design-pattern-creational/&quot;&gt;&lt;strong&gt;创建型模式&lt;/strong&gt;中的&lt;em&gt;工厂模式&lt;/em&gt;和&lt;em&gt;单例模式&lt;/em&gt;&lt;/a&gt;。在第二篇文章中，又讨论了一下 &lt;a href=&quot;https://swift.gg/2018/11/26/design-pattern-behavorial/&quot;&gt;&lt;strong&gt;行为型模式&lt;/strong&gt;中的&lt;em&gt;观察者模式&lt;/em&gt;和&lt;em&gt;备忘录模式&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
    
      <category term="Design Patterns" scheme="https://swift.gg/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的设计模式 #2 观察者模式与备忘录模式</title>
    <link href="https://swift.gg/2018/11/26/design-pattern-behavorial/"/>
    <id>https://swift.gg/2018/11/26/design-pattern-behavorial/</id>
    <published>2018-11-26T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://www.appcoda.com/design-pattern-behavorial/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-08-06<br>译者：<a href="https://dingtz.com/" target="_blank" rel="noopener">jojotov</a>；校对：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>本次教程是 AppCoda <a href="https://swift.gg/2018/09/10/design-pattern-creational/">上周开启</a> 的设计模式系列的第二期。在软件设计领域的四位大师级人物（GoF，又称“四人帮”或“Gang of Four”） —— Erich Gamma, Richard Helm, Ralph Johnson 和 John Vlissides 所著的 《设计模式：可复用面向对象软件的基础》一书中，首次对软件设计中总共 23 种设计模式进行了定义和归类，并对它们作了专业阐述。今天，我们将聚焦于其中两个行为型设计模式 —— “观察者模式” 和 “备忘录模式”。</p><a id="more"></a><p>软件开发领域致力于对真实世界的场景进行建模，并期望能创造出一系列工具来提高人类对这些场景的理解与体验。与 10 年前相比，一些类似银行应用和辅助购物应用（如亚马逊或 eBay 的 iOS 客户端应用）的财务类工具的出现，无疑让顾客们的生活变得更加简单。当我们回顾软件开发的发展历程，定会感叹我们在软件开发领域上走过了漫长而又成功的道路。如今，软件应用的功能普遍变得强大且易用，但对于开发者来说，开发这些软件却变得 <a href="http://iosbrain.com/blog/2018/04/29/controlling-chaos-why-you-should-care-about-adding-error-checking-to-your-ios-apps/#chaos" target="_blank" rel="noopener">越来越复杂</a>。</p><p>开发者们为了管理软件的复杂性，创造了一系列的最佳实践 —— 例如面向对象编程、面向协议编程、值语义、局部推理（Local Reasoning）、把大块的代码切分成一系列小块的代码并附上友好的接口（如 Swift 中的扩展）、语法糖等。但在众多的最佳实践之中，有一个非常重要且值得我们关注的最佳实践并没有在上文中提及 —— 那就是设计模式的使用。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>对于开发者来说，设计模式是管理代码复杂度问题的一个极其重要的工具。我们理解设计模式最好的办法，就是把设计模式概念化为 —— 有固定模版的通用技术，每个设计模式都旨在解决相应的一个反复出现且易于辨别的特定问题。你可以把设计模式看作是一系列最佳实践的集合，它们可以用于一些经常出现的编码场景：例如如何利用一系列有关联的对象创建出新的对象，并且不需要去理解原本那一系列对象中“又臭又长”的代码实现。设计模式最重要的意义是其可以应用于那些常见的场景。同时，由于设计模式都是已经创造出来的固定模式，拿来即用的特质令它具有很高的易用性。为了能更好的理解设计模式，我们来看一个例子：</p><p>设计模式并不能解决一些非常具体的问题。例如 “如何在 Swift 中遍历一个包含 11 个整型（<code>Int</code>）的 数组”之类的的问题。我们从一个例子来更好地理解为什么设计模式不能解决此类具体问题 —— GoF 定义了<em>迭代器</em>模式，为“便捷地遍历集合的所有元素，而不需要知道集合中元素的类型” 的问题提出通用的解决方案，。因此，我们不能单纯地把设计模式当作某种语言的代码，它只是用于解决通用软件开发场景的规则和指引。</p><p>我曾经在 AppCoda 中讨论过 <a href="https://www.appcoda.com/mvvm-vs-mvc/" target="_blank" rel="noopener">“Model-View-ViewModel” 或 “MVVM”</a>  设计模式 —— 当然也少不了那个 Apple 和 众多 iOS 开发者们长期喜爱着的经典设计模式 <a href="https://www.appcoda.com/mvvm-vs-mvc/" target="_blank" rel="noopener">“Model-View-Controller” 或 “MVC”</a> </p><p>这两种设计模式通常来说会应用于<em>整个应用层面</em>。MVVM 和 MVC 可以看作是<em>架构层面上</em>的设计模式，它们主要的作用可以简单分成四个方面：隔离用户界面（UI）与应用的数据；隔离用户界面（UI）与负责展示逻辑的代码；隔离应用的数据与核心数据处理逻辑；隔离应用的数据与业务逻辑。GoF 的设计模式都具有特殊性，它们都旨在解决一些在应用的<em>代码库中</em>较为特别的问题。你可能会在开发一个应用的时候用到好几个 GoF 的设计模式。同时你需要记得设计模式并不只是一些具体的代码实例，它们解决的是一些更抽象层面上的问题（希望你没忘记上面的<em>迭代器</em>例子）。除此之外我还想提及一个没有在 GoF 列出的 23 个设计模式之中，但却是设计模式的 <a href="https://www.appcoda.com/swift-delegate/" target="_blank" rel="noopener">典型例子</a> —— 代理模式。</p><p>虽然 GoF 关于设计模式的书已经被众多开发者视为圣经般的存在，但仍存在一些对其批判的声音。我们会在本文结尾的部分讨论这个问题。</p><h2 id="设计模式类别"><a href="#设计模式类别" class="headerlink" title="设计模式类别"></a>设计模式类别</h2><p>GoF 把他们提出的 23 种设计模式整理到了 3 种大的类别中：“创建型模式”、“结构型模式”以及“行为型模式”。本次的教程会讨论<em>行为型模式</em>类别中的两种设计模式。行为型模式的主要作用是对类和结构体（参与者）的行为赋予安全性、合理性，以及定义一些统一的规则、统一的的形式和最佳实践。对于整个应用中的参与者，我们都希望有一个良好的、统一的、并且可预测的行为。同时，我们不仅希望参与者本身拥有良好的行为，也希望不同的参与者之间的交互/通信可以拥有良好的行为。对于参与者的行为评估，其时机应该在编译之前以及编译时 —— 我通常把这段时间称之为“设计时间”，以及在运行时 —— 此时我们会有大量的类和结构体的实例在各司其职或与其他实例交互/通信。由于实例间的通信会导致软件复杂度的增加，因此制定一系列关于一致性、高效率和安全通信的规则是极为重要的，但与此同时，在构建每个单独的参与者时，这个概念不应以任何方式降低设计的质量。由于需要非常着重于行为，我们必须牢记一点 —— 在赋予参与者职责时必须使用一致的模式。</p><p>在高谈阔论太多理论之前，让我先说明一下本次教程中你会有哪些收获，同时所有的相关实践代码我都会用 Swift 来实现。在本次教程中，我们会了解到如何能够通过一致地赋予职责来维持参与者的状态。我们会了解到如何一致地赋予职责给一个参与者，让他能够发送通知给其他观察者。与之对应，我们也会了解到如何一致地赋予职责给观察者们注册通知。</p><p>当你讨论设计模式时，你应该把一致性当成最显而易见的基本概念。在 <a href="https://www.appcoda.com/design-pattern-creational/" target="_blank" rel="noopener">上周的推送</a> 中，我们着重讨论了一个概念：<a href="http://iosbrain.com/blog/2017/02/26/intro-to-object-oriented-principles-in-swift-3-via-a-message-box-class-hierarchy/#advantages" target="_blank" rel="noopener">高复杂度（封装）</a>。你必须把这个概念当作中心思想牢记于心，因为它会随着我们更深入地讨论设计模式而出现地越发频繁。举个例子，面向对象（OOP）中的众多类，可以在不需要开发者知道任何其内部实现的前提下，提供非常复杂、成熟且强大的功能。同样， Swift 的 <a href="https://www.appcoda.com/pop-vs-oop/" target="_blank" rel="noopener">面向协议编程</a> 也是一项对于控制复杂度来说极为重要的新技术。对开发者来说，想要管理好 <a href="http://iosbrain.com/blog/2018/01/02/understanding-swift-4-generics-and-applying-them-to-your-code/#complexity" target="_blank" rel="noopener">复杂度</a> 是一件异常困难的事情，但我们现在即将把这头野兽驯服！</p><h2 id="关于此教程的提醒"><a href="#关于此教程的提醒" class="headerlink" title="关于此教程的提醒"></a>关于此教程的提醒</h2><p>在这次的教程中，我决定把文字聚焦于对示例代码的解释。我将对今天所要介绍的设计模式概念进行一些简单明了的陈述，但同时为了能够让你更好地理解我所分享的技术，希望你可以认真看看代码和注释。毕竟作为一名程序员，如果你只能谈论代码而不能编写代码，那你可能会在很多面试中失利 —— 因为你还不够硬核。</p><p>你也许会留意到，我对与行为型设计模式的定义是遵循于苹果的 <a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html" target="_blank" rel="noopener">文档规范</a>:</p><blockquote><p>传统意义上来说，我们视一个类的实例为一个对象。虽然如此，但相对于其他语言而言，Swift 中的结构体和类在功能上非常相似，且本章节大部分内容描述了类或者结构体实例的功能。因此，我们使用更为通用的描述——实例。</p></blockquote><p>在设计时，我把对类和结构体的任何引用都描述为“参与者”。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>在使用苹果的移动设备时，观察者模式可能是贯穿整个应用使用过程的东西 —— 你应该在编写 iOS 应用时也发现了这一点。在我生活的地方，每当下雨天的时候，包括我在内的很大一部分人都会收到 iPhone 上的通知。不管是锁屏的状态还是解锁的状态，只要下起雨来，你都会收到一条类似下面这样的通知：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/08/PushNotification.png" alt="PushNotification demo"></p><p>作为所有通知的<em>源头</em>，苹果会代表国家气象局（National Weather Service）向<em>成千上万</em>的 iPhone 用户发送（广播）通知，提醒他们在其区域内是否有洪水灾害的风险。更具体一点地在 iOS 应用层级上说，当某一个实例（也就是被观察者）的状态发生改变时，它会通知其他（不止一个）的被称为<em>观察者</em>的实例，告诉他们自己的某个状态发生了变化。所有参与此次广播通信的实例都不需要知道除了自身以外的任何其他实例。这是一个关于 <a href="https://www.webopedia.com/TERM/L/loose_coupling.html" target="_blank" rel="noopener">松耦合</a> 的绝佳示例。</p><p>被观察的实例（通常是一个重要的资源）会广播关于自身状态改变的通知给其他众多观察者实例。对这些状态改变有兴趣的观察者必须通过订阅来获取关于状态改变通知。</p><p>这次我们不得不说苹果还是很靠谱的，iOS 已经内置了一个广为人知的用于观察者模式的特性：<a href="https://developer.apple.com/documentation/foundation/notificationcenter" target="_blank" rel="noopener">NotificationCenter</a>。在这里我不会对其作过多介绍，读者可自行在 <a href="http://iosbrain.com/blog/2018/02/09/nsnotificationcenter-in-swift-4-intra-app-communication-sending-receiving-listening-stop-listening-for-messages/" target="_blank" rel="noopener">这里</a> 学习相关内容。</p><h3 id="观察者模式用例"><a href="#观察者模式用例" class="headerlink" title="观察者模式用例"></a>观察者模式用例</h3><p>我的观察者模式示例项目展示了这种广播类型的通信是如何工作的，你可以在 <a href="https://github.com/appcoda/Observer-Pattern-Swift" target="_blank" rel="noopener">Github 上找到它</a>。</p><p>假设我们有一个工具来监视网络连接状况，并对已连接或未连接的状态作出响应。这个工具我们可以称之为广播者。为了实现此工具，你需要一个参与者遵循我提供的 <code>ObservedProtocol</code> 协议。虽然我知道这么做并不太符合苹果的 iOS Human Interface Guideline 的建议，但我为了更好地演示观察者模式，我需要以网络状况作为仅有的一个关键资源。</p><p>假设现在有许多个不同的观察者实例全都向被观察的对象订阅了关于网络连接状况的通知，例如一个图片下载类，一个通过 REST API 验证用户资格的登录业务实例，以及一个应用内浏览器。为了实现这些，你需要创建多个继承于我提供的 <code>Observer</code> 抽象类（此基类同时遵循 <code>ObserverProtocol</code> 协议）的自定义子类。（我稍后会解释为何我会把我关于观察者的示例代码放在一个类中）。</p><p>为了实现我示例应用中的观察者们，我创建了一个 <code>NetworkConnectionHandler</code> 类。当这个类的具体实例接收到 <code>NetworkConnectionStatus.connected</code> 通知时，这些实例会把几个视图变成绿色；当接收到 <code>NetworkConnectionStatus.disconnected</code> 通知时，会把视图变成红色。</p><p>下面是我的代码在 iPhone 8 Plus 设备上运行的效果：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/08/ObserverAppDemo.gif" alt="img"></p><p>上面的运行过程中，Xcode 控制台的输出如下：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/08/ObserverAppConsoleOutput.gif" alt="img"></p><h3 id="观察者模式应用的示例代码"><a href="#观察者模式应用的示例代码" class="headerlink" title="观察者模式应用的示例代码"></a>观察者模式应用的示例代码</h3><p>关于我上面所说的代码，你可以在项目中的 <code>Observable.swift</code> 文件找到。每段代码我都加上了详细的注释。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义通知名常量。</span></span><br><span class="line"><span class="comment">// 使用常量作为通知名，不要使用字符串或者数字。</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Notification</span>.<span class="title">Name</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> networkConnection = <span class="type">Notification</span>.<span class="type">Name</span>(<span class="string">"networkConnection"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> batteryStatus = <span class="type">Notification</span>.<span class="type">Name</span>(<span class="string">"batteryStatus"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> locationChange = <span class="type">Notification</span>.<span class="type">Name</span>(<span class="string">"locationChange"</span>)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义网络状态常量。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NetworkConnectionStatus</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> connected</span><br><span class="line">    <span class="keyword">case</span> disconnected</span><br><span class="line">    <span class="keyword">case</span> connecting</span><br><span class="line">    <span class="keyword">case</span> disconnecting</span><br><span class="line">    <span class="keyword">case</span> error</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义 userInfo 中的 key 值。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">StatusKey</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> networkStatusKey</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此协议定义了*观察者*的基本结构。</span></span><br><span class="line"><span class="comment">// 观察者即一些实体的集合，它们的操作严格依赖于其他实体的状态。</span></span><br><span class="line"><span class="comment">// 遵循此协议的实例会向某些重要的实体/资源*订阅*并*接收*通知。</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ObserverProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> statusValue: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> statusKey: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> notificationOfInterest: <span class="type">Notification</span>.<span class="type">Name</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">unsubscribe</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handleNotification</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此模版类抽象如何*订阅*和*接受*重要实体/资源的通知的所有必要细节。</span></span><br><span class="line"><span class="comment">// 此类提供了一个钩子方法（handleNotification()），</span></span><br><span class="line"><span class="comment">// 所有的子类可以通过此方法在接收到特定通知时进行各种需要的操作。</span></span><br><span class="line"><span class="comment">// 此类基为一个*抽象*类，并不会在编译时被检测，但这似乎是一个异常场景。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span>: <span class="title">ObserverProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此变量与 notificationOfInterest 通知关联。</span></span><br><span class="line">    <span class="comment">// 使用字符串以尽可能满足需要。</span></span><br><span class="line">    <span class="keyword">var</span> statusValue: <span class="type">String</span></span><br><span class="line">    <span class="comment">// 通知的 userInfo 中的 key 值，</span></span><br><span class="line">    <span class="comment">// 通过此 key 值读取到特定的状态值并存储到 statusValue 变量。</span></span><br><span class="line">    <span class="comment">// 使用字符串以尽可能满足需要。</span></span><br><span class="line">    <span class="keyword">let</span> statusKey: <span class="type">String</span></span><br><span class="line">    <span class="comment">// 此类所注册的通知名。</span></span><br><span class="line">    <span class="keyword">let</span> notificationOfInterest: <span class="type">Notification</span>.<span class="type">Name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过传入的通知名和需要观察的状态的 key 值进行初始化。</span></span><br><span class="line">    <span class="comment">// 初始化时会注册/订阅/监听特定的通知并观察特定的状态。</span></span><br><span class="line">    <span class="keyword">init</span>(statusKey: <span class="type">StatusKey</span>, notification: <span class="type">Notification</span>.<span class="type">Name</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.statusValue = <span class="string">"N/A"</span></span><br><span class="line">        <span class="keyword">self</span>.statusKey = statusKey.rawValue</span><br><span class="line">        <span class="keyword">self</span>.notificationOfInterest = notification</span><br><span class="line">        </span><br><span class="line">        subscribe()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向 NotificationCenter 注册 self(this) 来接收所有存储在 notificationOfInterest 中的通知。</span></span><br><span class="line">    <span class="comment">// 当接收到任意一个注册的通知时，会调用 receiveNotification(_:) 方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(receiveNotification(<span class="number">_</span>:)), name: notificationOfInterest, object: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在不需要监听时注销所有已注册的通知是一个不错的做法，</span></span><br><span class="line">    <span class="comment">// 但这主要是由于历史原因造成的，iOS 9.0 之后 OS 系统会自动做一些清理。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">unsubscribe</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>, name: notificationOfInterest, object: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在任意一个 notificationOfInterest 所定义的通知接收到时调用。</span></span><br><span class="line">    <span class="comment">// 在此方法中可以根据所观察的重要资源的改变进行任意操作。</span></span><br><span class="line">    <span class="comment">// 此方法**必须有且仅有一个参数（NSNotification 实例）。**</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">receiveNotification</span><span class="params">(<span class="number">_</span> notification: Notification)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> userInfo = notification.userInfo, <span class="keyword">let</span> status = userInfo[statusKey] <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">            </span><br><span class="line">            statusValue = status</span><br><span class="line">            handleNotification()</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Notification <span class="subst">\(notification.name)</span> received; status: <span class="subst">\(status)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// receiveNotification 方法结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// **必须重写此方法；且必须继承此类**</span></span><br><span class="line">    <span class="comment">// 我使用了些"技巧"来让此类达到抽象类的形式，因此你可以在子类中做其他任何事情而不需要关心关于 NotificationCenter 的细节。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handleNotification</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"ERROR: You must override the [handleNotification] method."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构时取消对 Notification 的关联，此时已经不需要进行观察了。</span></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Observer unsubscribing from notifications."</span>)</span><br><span class="line">        unsubscribe()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// Observer 类结束</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 一个具体观察者的例子。</span></span><br><span class="line"><span class="comment">// 通常来说，会有一系列（许多？）的观察者都会监听一些单独且重要的资源发出的通知。</span></span><br><span class="line"><span class="comment">// 需要注意此类已经简化了实现，并且可以作为所有通知的 handler 的模板。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkConnectionHandler</span>: <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> view: <span class="type">UIView</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 你可以创建任意类型的构造器，只需要调用 super.init 并传入合法且可以配合 NotificationCenter 使用的通知。</span></span><br><span class="line">    <span class="keyword">init</span>(view: <span class="type">UIView</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.view = view</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(statusKey: .networkStatusKey, notification: .networkConnection)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// **必须重写此方法**</span></span><br><span class="line">    <span class="comment">// 此方法中可以加入任何处理通知的逻辑。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">handleNotification</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> statusValue == <span class="type">NetworkConnectionStatus</span>.connected.rawValue &#123;</span><br><span class="line">            view.backgroundColor = <span class="type">UIColor</span>.green</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            view.backgroundColor = <span class="type">UIColor</span>.red</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// handleNotification() 结束</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// NetworkConnectionHandler 结束</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 一个被观察者的模板。</span></span><br><span class="line"><span class="comment">// 通常被观察者都是一些重要资源，在其自身某些状态发生改变时会广播通知给所有订阅者。</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ObservedProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> statusKey: <span class="type">StatusKey</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> notification: <span class="type">Notification</span>.<span class="type">Name</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">notifyObservers</span><span class="params">(about changeTo: String)</span></span> -&gt; <span class="type">Void</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在任意遵循 ObservedProtocol 示例的某些状态发生改变时，会通知*所有*已订阅的观察者。</span></span><br><span class="line"><span class="comment">// **向所有订阅者广播**</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObservedProtocol</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">notifyObservers</span><span class="params">(about changeTo: String)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">       <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: notification, object: <span class="keyword">self</span>, userInfo: [statusKey.rawValue : changeTo])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// ObservedProtocol 扩展结束</span></span><br></pre></td></tr></table></figure><p>我把大部分关于观察者的通知处理逻辑放在了 <code>ObserverProtocol</code> 的扩展当中，并且这段逻辑会在一个 <code>@objc</code> 修饰的方法中运行（此方法同时会设置为通知的 <code>#selector</code> 的方法）。作为抽象类中的方法，相较于使用基于 block 的 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver" target="_blank" rel="noopener"><code>addObserver(forName:object:queue:using:)</code></a> 并把处理通知的闭包传进去，使用 selector 可以让这段通知处理代码显得更加容易理解以及更加适合教学。</p><p>同时，我意识到 Swift 中并没有关于抽象类的官方概念。因此，为了完成我解释观察者模式的教学目的，我强制使用者重写 <code>Observer</code> 的 <code>handleNotification()</code> 方法，以此来达到 “抽象类” 的形态。如此以来，你可以注入任意的处理逻辑，让你的子类实例在接收到通知后有特定的行为。</p><p>下面我将展示示例项目中的 <code>ViewController.swift</code> 文件，在这里你可以看到刚刚讨论过的  <code>Obesever.swift</code> 中的核心代码是如何使用的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此 view controller 遵循 ObservedProtocol 协议，因此在*整个应用期间*</span></span><br><span class="line"><span class="comment">// 其可以通过 NotificationCenter 向*任意*有意接收的实体广播通知。</span></span><br><span class="line"><span class="comment">// 可以看到这个类仅仅需要很少量的代码便可以实现通知的功能。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">ObservedProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> topBox: <span class="type">UIView</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> middleBox: <span class="type">UIView</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> bottomBox: <span class="type">UIView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Mock 一些负责观察网络状况的实体对象。</span></span><br><span class="line">    <span class="keyword">var</span> networkConnectionHandler0: <span class="type">NetworkConnectionHandler</span>?</span><br><span class="line">    <span class="keyword">var</span> networkConnectionHandler1: <span class="type">NetworkConnectionHandler</span>?</span><br><span class="line">    <span class="keyword">var</span> networkConnectionHandler2: <span class="type">NetworkConnectionHandler</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遵循 ObservedProtocol 的两个属性。</span></span><br><span class="line">    <span class="keyword">let</span> statusKey: <span class="type">StatusKey</span> = <span class="type">StatusKey</span>.networkStatusKey</span><br><span class="line">    <span class="keyword">let</span> notification: <span class="type">Notification</span>.<span class="type">Name</span> = .networkConnection</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// 初始化负责监听的实体对象。</span></span><br><span class="line">        networkConnectionHandler0 = <span class="type">NetworkConnectionHandler</span>(view: topBox)</span><br><span class="line">        networkConnectionHandler1 = <span class="type">NetworkConnectionHandler</span>(view: middleBox)</span><br><span class="line">        networkConnectionHandler2 = <span class="type">NetworkConnectionHandler</span>(view: bottomBox)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Mock 一个可以改变状态的重要资源。</span></span><br><span class="line">    <span class="comment">// 此处模拟此 ViewController 可以检测网络连接状况，</span></span><br><span class="line">    <span class="comment">// 当网络可以连接或者网络连接丢失时，通知所有有兴趣的监听者。</span></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">switchChanged</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> swtich:<span class="type">UISwitch</span> = sender <span class="keyword">as</span>! <span class="type">UISwitch</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> swtich.isOn &#123;</span><br><span class="line">            notifyObservers(about: <span class="type">NetworkConnectionStatus</span>.connected.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            notifyObservers(about: <span class="type">NetworkConnectionStatus</span>.disconnected.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// switchChanged 函数结束</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// ViewController 类结束</span></span><br></pre></td></tr></table></figure><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>大部分 iOS 开发者对备忘录模式都很熟悉。回忆一下 iOS 中十分便利的 <a href="https://developer.apple.com/documentation/foundation/archives_and_serialization" target="_blank" rel="noopener">归档和序列化功能</a>，让你能够 “在对象和基本数据类型在 plist、JSON 和其他二进制形式之间自由转换”。再回忆一下 iOS 中的 <a href="https://developer.apple.com/documentation/uikit/view_controllers/preserving_your_app_s_ui_across_launches" target="_blank" rel="noopener">状态保存和恢复功能</a>，它能够记住你的应用被系统强制杀死时的状态，并在之后恢复此状态。</p><p>备忘录模式可以理解为在某个时刻捕捉、展示以及储存任意实例的内部状态，同时允许你可以在随后的时间内查找这些保存下来的状态并恢复它。当你恢复一个实例的某个状态时，它应当完全反映出这个实例在被捕捉时的状态。显然，要达到此效果，你必须保证所有实例属性的访问权限在捕捉和恢复时都是一样的 —— 例如，<code>public</code> 的数据应恢复为 <code>public</code> 的属性，<code>private</code>  的数据应恢复为 <code>private</code> 的属性。</p><p>为了简单起见，我使用 iOS 系统提供的 <code>UserDefaults</code> 作为我存储和恢复实例状态的核心工具。</p><h3 id="备忘录模式用例"><a href="#备忘录模式用例" class="headerlink" title="备忘录模式用例"></a>备忘录模式用例</h3><p>在我知道了 iOS 本身已提供了便捷的归档和序列化的功能后，我随即编写了一些可以保存和恢复类的状态的示例代码。我的代码很出色地抽象出了归档和解档的功能，因此你可以利用这些抽象方法存储和恢复许多不同的实例和实例的属性。不过我的示例代码并非用于生产环境下的，它们只是为了解释备忘录模式而编写的教学性代码。</p><p>你可以在 Github 上找到我的 <a href="https://github.com/appcoda/Memento-Pattern-Swift" target="_blank" rel="noopener">示例项目</a>。这个项目展示了一个包含<code>firstName</code>、<code>lastName</code>  和 <code>age</code> 属性的 <code>User</code> 类实例保存在 <code>UserDefaults</code> 中，并随后从 <code>UserDefaults</code> 恢复的过程。如同下面的效果一样，一开始，并没有任何 <code>User</code> 实例提供给我进行恢复，随后我输入了一个并把它归档，然后再恢复它：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/08/MementoDemoApp.gif" alt="MementoDemoApp"></p><p>上面过程中控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Empty entity.</span><br><span class="line"> </span><br><span class="line">lastName: Adams</span><br><span class="line">age: 87</span><br><span class="line">firstName: John</span><br><span class="line"> </span><br><span class="line">lastName: Adams</span><br><span class="line">age: 87</span><br><span class="line">firstName: John</span><br></pre></td></tr></table></figure><h3 id="备忘录模式示例代码"><a href="#备忘录模式示例代码" class="headerlink" title="备忘录模式示例代码"></a>备忘录模式示例代码</h3><p>我所实现的备忘录模式非常直白。代码中包含了一个 <code>Memento</code> 协议，以及 <code>Memento</code> 协议的扩展，用于在成员属性中存在遵循 <code>Memento</code> 协议的属性时，处理和抽象关于归档与解档的逻辑。与此同时，这个协议扩展允许在任何时候打印实例的所有状态。我使用了一个 <code>Dictionary&lt;String, String&gt;</code> 来存储那些遵循协议的类中的属性 —— 属性名作为字典的 Key，属性值作为字典的 Value。我把属性的值以字符串的类型存储，以此达到代码较简洁且容易理解的目的，但我必须承认实际情况中有许多用例会要求你去操作非常复杂的属性类型。归根到底，这是一个关于设计模式的教程，因此没有任何代码是基于生产环境来编写的。</p><p>需要注意我为 <code>Memento</code> 协议加了一个 <code>persist()</code> 方法和一个 <code>recover()</code> 方法，任何遵循此协议的类都必须实现它们。这两个方法让开发者可以根据实际需要，通过名字来归档和解档某个遵循 <code>Memento</code> 协议的类中的特定属性。换句话说，<code>Memento</code> 中类型为 <code>Dictionary&lt;String, String&gt;</code> 的 <code>state</code> 属性可以一对一地对应到某个遵循此协议的类中的属性，这些属性的名称对应字典中元素的 key，属性的值对应字典中元素的 value。相信你在看完具体的代码后肯定能完全理解。</p><p>由于遵循 <code>Memento</code> 协议的类必须实现  <code>persist()</code> 和 <code>recover()</code> 方法，因此这两个方法必须可以访问所有可见的属性，无论它具有什么样的访问权限 ——  <code>public</code> 、<code>private</code>  还是  <code>fileprivate</code>。</p><p>你或许也想知道我为什么把 <code>Memento</code> 协议设置为类协议（class-only）。原因仅仅是因为 Swift 编译器那诡异的报错：”Cannot use mutating member on immutable value: ‘self’ is immutable”。我们暂且不讨论这个问题，因为它远远超出了本次教程的范围。如果你对这个问题感兴趣，你可以看一下这个 <a href="https://www.bignerdranch.com/blog/protocol-oriented-problems-and-the-immutable-self-error/" target="_blank" rel="noopener">不错的解释</a>。</p><p>接下来就到了代码的部分。首先，你可以在我示例项目中的 <code>Memento.swift</code> 文件找到关于备忘录模式的核心实现：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 由于"Cannot use mutating member on immutable value: ‘self’ is immutable"报错问题，</span></span><br><span class="line"><span class="comment">// 此协议定义为类协议，仅适用于引用类型。</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Memento</span> : <span class="title">class</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问 UserDefaults 中 state 属性的 key 值。</span></span><br><span class="line">    <span class="keyword">var</span> stateName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储遵循此协议的类当前状态下的所有属性名（key）和属性值。</span></span><br><span class="line">    <span class="keyword">var</span> state: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以特定的 stateName 为 key 将 state 属性存入 UserDefaults 中。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以特定的 stateName 为 key 从 UserDefaults 中读取 state。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可自定义，以特定方式把遵循此协议的类的属性存储到 state 字典。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">persist</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 可自定义，以特定方式从 state 字典读取属性。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 state 字典并打印所有成员属性，格式如下：</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 属性 1 名字（key）：属性 1 的值</span></span><br><span class="line">    <span class="comment">// 属性 2 名字（key）：属性 2 的值</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// Memento 协议结束</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存 state 到磁盘中。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(state, forKey: stateName)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从磁盘中读取 state。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> dictionary = <span class="type">UserDefaults</span>.standard.object(forKey: stateName) <span class="keyword">as</span>! <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;? &#123;</span><br><span class="line">            state = dictionary</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            state.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// restore() 函数结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以字典的形式保存当前状态可以很方便地进行可视化输出。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> line = <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> state.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (key, value) <span class="keyword">in</span> state &#123;</span><br><span class="line">                line += key + <span class="string">": "</span> + value + <span class="string">"\n"</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(line)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Empty entity.\n"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125; <span class="comment">// show() 函数结束</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// Memento 扩展结束</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过遵循 Memento 协议，任何类都可以方便地在整个应有运行期间</span></span><br><span class="line"><span class="comment">// 保存其完整状态，并能随后任意时间进行读取。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>: <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Memento 必须遵循的属性。</span></span><br><span class="line">    <span class="keyword">let</span> stateName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> state: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此类独有的几个属性，用于保存系统用户账号。</span></span><br><span class="line">    <span class="keyword">var</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> lastName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此构造器可用于保存新用户到磁盘，或者更新一个现有的用户。</span></span><br><span class="line">    <span class="comment">// 持久化储存所用的 key 值为 stateName 属性。</span></span><br><span class="line">    <span class="keyword">init</span>(firstName: <span class="type">String</span>, lastName: <span class="type">String</span>, age: <span class="type">String</span>, stateName: <span class="type">String</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.firstName = firstName</span><br><span class="line">        <span class="keyword">self</span>.lastName = lastName</span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.stateName = stateName</span><br><span class="line">        <span class="keyword">self</span>.state = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        persist()</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// 构造器定义结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此构造器可以从磁盘中读取出一个已存在的用户信息。</span></span><br><span class="line">    <span class="comment">// 读取所使用的 key 值为 stateName 属性。</span></span><br><span class="line">    <span class="keyword">init</span>(stateName: <span class="type">String</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.stateName = stateName</span><br><span class="line">        <span class="keyword">self</span>.state = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.firstName = <span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.lastName = <span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.age = <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        recover()</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// 构造器定义结束</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 持久化存储用户属性。</span></span><br><span class="line">    <span class="comment">// 此处很直观地将每个属性一对一地以"属性名-属性值"的形式存入字典中。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">persist</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        state[<span class="string">"firstName"</span>] = firstName</span><br><span class="line">        state[<span class="string">"lastName"</span>] = lastName</span><br><span class="line">        state[<span class="string">"age"</span>] = age</span><br><span class="line">        </span><br><span class="line">        save() <span class="comment">// leverage protocol extension</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// persist() 函数结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取已存储的用户属性。</span></span><br><span class="line">    <span class="comment">// 从 UserDefaults 中读取了 state 字典后</span></span><br><span class="line">    <span class="comment">// 会简单地以属性名为 key 从字典中读取出属性值。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        restore() <span class="comment">// leverage protocol extension</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> state.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            firstName = state[<span class="string">"firstName"</span>]!</span><br><span class="line">            lastName = state[<span class="string">"lastName"</span>]!</span><br><span class="line">            age = state[<span class="string">"age"</span>]!</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.firstName = <span class="string">""</span></span><br><span class="line">            <span class="keyword">self</span>.lastName = <span class="string">""</span></span><br><span class="line">            <span class="keyword">self</span>.age = <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// recover() 函数结束</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// user 类结束</span></span><br></pre></td></tr></table></figure><p>接下来，你可以在示例项目中的 <code>ViewController.swift</code>  文件中找到我上问所说的关于备忘录模式的使用用例（对 <code>User</code> 类的归档和解档）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> firstNameTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> lastNameTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> ageTextField: <span class="type">UITextField</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// "保存用户" 按钮按下时调用此方法。</span></span><br><span class="line">    <span class="comment">// 以 "userKey" 作为 stateName 的值将 User 类实例的属性</span></span><br><span class="line">    <span class="comment">// 保存到 UserDefaults 中。</span></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">saveUserTapped</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> firstNameTextField.text != <span class="string">""</span> &amp;&amp;</span><br><span class="line">            lastNameTextField.text != <span class="string">""</span> &amp;&amp;</span><br><span class="line">            ageTextField.text != <span class="string">""</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> user = <span class="type">User</span>(firstName: firstNameTextField.text!,</span><br><span class="line">                            lastName: lastNameTextField.text!,</span><br><span class="line">                            age: ageTextField.text!,</span><br><span class="line">                            stateName: <span class="string">"userKey"</span>)</span><br><span class="line">            user.show()</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// saveUserTapped 函数结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在"恢复用户"按钮按下时调用此方法。</span></span><br><span class="line">    <span class="comment">// 以 "userKey" 作为 stateName 的值将 User 类实例的属性</span></span><br><span class="line">    <span class="comment">// 从 UserDefaults 中读取出来。</span></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">restoreUserTapped</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> user = <span class="type">User</span>(stateName: <span class="string">"userKey"</span>)</span><br><span class="line">        firstNameTextField.text = user.firstName</span><br><span class="line">        lastNameTextField.text = user.lastName</span><br><span class="line">        ageTextField.text = user.age</span><br><span class="line">        user.show()</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// ViewController 类结束</span></span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>即便 GoF 的设计模式已经在多数开发者心中被视为圣经般的存在（我在文章开头提到的），但仍有某些对设计模式持有批评意见的人认为，设计模式的使用恰恰是我们对编程语言不够了解或使用不够巧妙的证明，而且在代码中频繁使用设计模式并不是一件好事。我个人并不认同此看法。对于一些拥有几乎所有能想象得到的特性的语言，例如 C++ 这种非常庞大的编程语言来说，这种意见或许会适用，但诸如此类的语言通常极其复杂以致于我们很难去学习、使用并掌握它。能够识别出并解决一些重复出现的问题是我们作为人类的优点之一，我们并不应该抗拒它。而设计模式恰巧是人类从历史错误中吸取教训，并加以改进的绝佳例子。同时，设计模式对一些通用的问题给出了抽象化且标准化的解决方案，提高了解决这些问题的可能性和可部署性。</p><p>把一门简洁的编程语言和一系列最佳实践结合起来是一件美妙的事情，例如 Swift 和设计模式的结合。高一致性的代码通常也有高可读性和高可维护性。同时你要记得一件事，设计模式是通过成千上万的开发者们不断地讨论和交流想法而持续完善的。通过万维网带来的便捷性，开发者们在虚拟世界相互连接，他们的讨论不断碰撞出天才的火花。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Andrew Jaffee，&lt;a href=&quot;https://www.appcoda.com/design-pattern-behavorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-08-06&lt;br&gt;译者：&lt;a href=&quot;https://dingtz.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jojotov&lt;/a&gt;；校对：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;本次教程是 AppCoda &lt;a href=&quot;https://swift.gg/2018/09/10/design-pattern-creational/&quot;&gt;上周开启&lt;/a&gt; 的设计模式系列的第二期。在软件设计领域的四位大师级人物（GoF，又称“四人帮”或“Gang of Four”） —— Erich Gamma, Richard Helm, Ralph Johnson 和 John Vlissides 所著的 《设计模式：可复用面向对象软件的基础》一书中，首次对软件设计中总共 23 种设计模式进行了定义和归类，并对它们作了专业阐述。今天，我们将聚焦于其中两个行为型设计模式 —— “观察者模式” 和 “备忘录模式”。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
    
      <category term="Design Patterns" scheme="https://swift.gg/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>实用的可选项（Optional）扩展</title>
    <link href="https://swift.gg/2018/11/19/useful-optional-extensions/"/>
    <id>https://swift.gg/2018/11/19/useful-optional-extensions/</id>
    <published>2018-11-19T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：terhechte，<a href="https://appventure.me/2018/01/10/optional-extensions/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-01-10<br>译者：<a href="https://github.com/rsenjoyer" target="_blank" rel="noopener">rsenjoyer</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>可选值（Optional）是 Swift 语言最基础的内容。我想每个人都同意它带来了巨大的福音，因为它迫使开发者妥善处理边缘情况。可选值的语言特性能让发者在开发阶段发现并处理整个类别的 bug。</p><p>然而，Swift 标准库中可选值的 API 相当的有限。如果忽略 <code>customMirror</code> 和 <code>debugDescription</code> 属性，<a href="https://developer.apple.com/documentation/swift/optional#topics" target="_blank" rel="noopener">Swift 文档</a> 仅仅列出了几个方法/属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unsafelyUnwrapped: <span class="type">Wrapped</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>? </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>?) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>?</span><br></pre></td></tr></table></figure><a id="more"></a><p>即使方法如此少，可选值仍然非常有用，这是因为 Swift 在语法上通过 <a href="https://appventure.me/2014/06/13/swift-optionals-made-simple/" target="_blank" rel="noopener">可选链</a>、<a href="https://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="noopener">模式匹配</a>、<code>if let</code> 或 <code>guard let</code> 等功能来弥补它。但在某些情况下，可选值容易造成多分支条件。有时，一个非常简洁的方法通常允许你用一行代码表达某个概念，而不是用多行组合的 <code>if let</code> 语句。</p><p>我筛选了 Github 上的 Swift 项目以及 Rust、Scala 或 C＃ 等其他语言的可选实现，目的是为 Optional 找一些有用的补充。以下 14 个可选扩展，我将分类逐一解释，同时给每个类别举几个例子。最后，我将编写一个更复杂的示例，它同时使用多个可选扩展。</p><h2 id="判空（Emptiness）"><a href="#判空（Emptiness）" class="headerlink" title="判空（Emptiness）"></a>判空（Emptiness）</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 可选值为空的时候返回 true</span></span><br><span class="line">    <span class="keyword">var</span> isNone: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> .some:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 可选值非空返回 true</span></span><br><span class="line">    <span class="keyword">var</span> isSome: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !isNone</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是对可选类型最基础的补充。我很喜欢这些补充，因为它们将可选项为空的概念从代码中移除了。在使用的细节上， 使用 <code>optional.isSome</code> 比 <code>if optional == nil</code> 更简洁明了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用前</span></span><br><span class="line"><span class="keyword">guard</span> leftButton != <span class="literal">nil</span>, rightButton != <span class="literal">nil</span> <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"Missing Interface Builder connections"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用后</span></span><br><span class="line"><span class="keyword">guard</span> leftButton.isSome, rightButton.isSome <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"Missing Interface Builder connections"</span>) &#125;</span><br></pre></td></tr></table></figure><h2 id="或（Or）"><a href="#或（Or）" class="headerlink" title="或（Or）"></a>或（Or）</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 返回可选值或默认值</span></span><br><span class="line">    <span class="comment">/// - 参数: 如果可选值为空，将会默认值</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(<span class="number">_</span> <span class="keyword">default</span>: Wrapped)</span></span> -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> ?? `<span class="keyword">default</span>`</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 返回可选值或 `else` 表达式返回的值</span></span><br><span class="line">    <span class="comment">/// 例如. optional.or(else: print("Arrr"))</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(<span class="keyword">else</span>: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Wrapped</span>) -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> ?? `<span class="keyword">else</span>`()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 返回可选值或者 `else` 闭包返回的值</span></span><br><span class="line">    <span class="comment">// 例如. optional.or(else: &#123; </span></span><br><span class="line">    <span class="comment">/// ... do a lot of stuff</span></span><br><span class="line">    <span class="comment">/// &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(<span class="keyword">else</span>: <span class="params">()</span></span></span> -&gt; <span class="type">Wrapped</span>) -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> ?? `<span class="keyword">else</span>`()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 当可选值不为空时，返回可选值</span></span><br><span class="line">    <span class="comment">/// 如果为空，抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(<span class="keyword">throw</span> exception: Error)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> unwrapped = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">throw</span> exception &#125;</span><br><span class="line">        <span class="keyword">return</span> unwrapped</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> <span class="title">where</span> <span class="title">Wrapped</span> == <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 当可选值不为空时，执行 `else`</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(<span class="number">_</span> <span class="keyword">else</span>: <span class="params">(Error)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> error = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">`<span class="keyword">else</span>`(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isNone / isSome</code> 的另一个抽象概念是能够指定当变量不成立的时需要执行的指令。这能让我们避免编写 <code>if</code> 或 <code>guard</code> 分支，而是将逻辑封装为一个易于理解的方法。</p><p>这个概念非常的有用，它可在四个不同功能中被定义。</p><h2 id="默认值（Default-Value）"><a href="#默认值（Default-Value）" class="headerlink" title="默认值（Default Value）"></a>默认值（Default Value）</h2><p>第一个扩展方法是返回可选值或者默认值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">optional</span>: <span class="type">Int</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">optional</span>.or(<span class="number">10</span>)) <span class="comment">// 打印 10</span></span><br></pre></td></tr></table></figure><h2 id="默认闭包（Default-Closure）"><a href="#默认闭包（Default-Closure）" class="headerlink" title="默认闭包（Default Closure）"></a>默认闭包（Default Closure）</h2><p>默认闭包和默认值非常的相似，但它允许从闭包中返回默认值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">optional</span>: <span class="type">Int</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">optional</span>.or(<span class="keyword">else</span>: secretValue * <span class="number">32</span>)</span><br></pre></td></tr></table></figure><p>由于使用了 <code>@autoclosure</code> 参数, 我们实际上使用的是默认闭包。使用默认值将会自动转换为返回值的闭包。然而，我倾向于将两个实现单独分开，因为它可以让用户用更加复杂的逻辑编写闭包。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cachedUserCount: <span class="type">Int</span>? = <span class="literal">nil</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> cachedUserCount.or(<span class="keyword">else</span>: &#123;</span><br><span class="line">   <span class="keyword">let</span> db = database()</span><br><span class="line">   db.prefetch()</span><br><span class="line">   <span class="keyword">guard</span> db.failures.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">   <span class="keyword">return</span> db.amountOfUsers</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当你对一个为空的可选值赋值的时候，使用 <code>or</code> 就是一个不错的选择。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> databaseController == <span class="literal">nil</span> &#123;</span><br><span class="line">  databaseController = <span class="type">DatabaseController</span>(config: config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以写的更加优雅: </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">databaseController = databaseController.or(<span class="type">DatabaseController</span>(config: config)</span><br></pre></td></tr></table></figure><h2 id="抛出异常（Throw-an-error）"><a href="#抛出异常（Throw-an-error）" class="headerlink" title="抛出异常（Throw an error）"></a>抛出异常（Throw an error）</h2><p>这也是一个非常有用的补充，因为它将 Swift 中可选值与错误处理连接起来。根据项目中的代码，方法或函数通过返回一个为空的可选值（例如访问字典中不存在的键）时，抛出错误来表述这一无效的行为。将两者连接起来能够使代码更加清晰：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildCar</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Car</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tires = <span class="keyword">try</span> machine1.createTires()</span><br><span class="line">  <span class="keyword">let</span> windows = <span class="keyword">try</span> machine2.createWindows()</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> motor = externalMachine.deliverMotor() <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">MachineError</span>.motor</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> trunk = <span class="keyword">try</span> machine3.createTrunk()</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> car = manufacturer.buildCar(tires, windows,  motor, trunk) &#123;</span><br><span class="line">    <span class="keyword">return</span> car</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">MachineError</span>.manufacturer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过调用内部及外部代码共同构建汽车对象，外部代码（<code>external_machine</code> 和 <code>manufacturer</code>）选择使用可选值而不是错误处理。这使得代码变得很复杂，我们可使用 <code>or(throw:)</code> 使函数可读性更高。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build_car</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Car</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tires = <span class="keyword">try</span> machine1.createTires()</span><br><span class="line">  <span class="keyword">let</span> windows = <span class="keyword">try</span> machine2.createWindows()</span><br><span class="line">  <span class="keyword">let</span> motor = <span class="keyword">try</span> externalMachine.deliverMotor().or(<span class="keyword">throw</span>: <span class="type">MachineError</span>.motor)</span><br><span class="line">  <span class="keyword">let</span> trunk = <span class="keyword">try</span> machine3.createTrunk()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">try</span> manufacturer.buildCar(tires, windows,  motor, trunk).or(<span class="keyword">throw</span>: <span class="type">MachineError</span>.manufacturer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误处理（Handling-Errors）"><a href="#错误处理（Handling-Errors）" class="headerlink" title="错误处理（Handling Errors）"></a>错误处理（Handling Errors）</h2><p>当代码中包含 <a href="https://github.com/doozMen" target="_blank" rel="noopener">Stijn Willems 在 Github</a> 自由函数，上面抛出异常部分的代码变更加有用。感谢 Stijn Willems 的建议。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">should</span><span class="params">(<span class="number">_</span> <span class="keyword">do</span>: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Error</span>? &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">try</span> `<span class="keyword">do</span>`()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line"><span class="keyword">return</span> error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个自由函数（可选的，可将它当做一个可选项的类方法）使用 <code>do {} catch {}</code> 块并返回一个错误。当且仅当 <code>do</code> 代码块捕捉到异常。以下面 Swift 代码为例：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> throwingFunction()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">  <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 Swift 中错误处理的基本原则之一，但它不够简单明了。使用上面的提供的函数，你可以使代码变得足够简单。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">should &#123; <span class="keyword">try</span> throwingFunction) &#125;.or(<span class="built_in">print</span>($<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>我觉得在很多情况下，这样进行错误处理效果更好。</p><h2 id="变换（Map）"><a href="#变换（Map）" class="headerlink" title="变换（Map）"></a>变换（Map）</h2><p>正如上面所见，<code>map</code> 和 <code>flatMap</code> 是 Swift 标准库在可选项上面提供的的全部方法。然而，在多数情况下，也可以对它们稍微改进使得更加通用。这有两个扩展 <code>map</code> 允许定义一个默认值，类似于上面 <code>or</code> 的实现方式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 可选值变换返回，如果可选值为空，则返回默认值</span></span><br><span class="line">    <span class="comment">/// - 参数 fn: 映射值的闭包</span></span><br><span class="line">    <span class="comment">/// - 参数 default: 可选值为空时，将作为返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> fn: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>, <span class="keyword">default</span>: <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="built_in">map</span>(fn) ?? `<span class="keyword">default</span>`</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 可选值变换返回，如果可选值为空，则调用 `else` 闭包</span></span><br><span class="line">    <span class="comment">/// - 参数 fn: 映射值的闭包</span></span><br><span class="line">    <span class="comment">/// - 参数 else: The function to call if the optional is empty</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> fn: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>, <span class="keyword">else</span>: () <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="built_in">map</span>(fn) ?? `<span class="keyword">else</span>`()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个方法允许你将可选值 <code>map</code> 成一个新的类型 <code>T</code>. 如果可选值为空，你可以提供一个 <code>T</code> 类型的默认值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> optional1: <span class="type">String</span>? = <span class="string">"appventure"</span></span><br><span class="line"><span class="keyword">let</span> optional2: <span class="type">String</span>? = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前</span></span><br><span class="line"><span class="built_in">print</span>(optional1.<span class="built_in">map</span>(&#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;) ?? <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(optional2.<span class="built_in">map</span>(&#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;) ?? <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用后 </span></span><br><span class="line"><span class="built_in">print</span>(optional1.<span class="built_in">map</span>(&#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;, <span class="keyword">default</span>: <span class="number">0</span>)) <span class="comment">// prints 10</span></span><br><span class="line"><span class="built_in">print</span>(optional2.<span class="built_in">map</span>(&#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;, <span class="keyword">default</span>: <span class="number">0</span>)) <span class="comment">// prints 0</span></span><br></pre></td></tr></table></figure><p>这里改动很小，我们再也不需要使用 <code>??</code> 操作符，取而代之的是更能表达意图的 <code>default</code> 值。</p><p>第二个方法也与第一个很相似，主要区别在于它接受（再次）返回 <code>T</code> 类型的闭包，而不是使用一个默认值。这里有个简单的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">optional</span>: <span class="type">String</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">optional</span>.<span class="built_in">map</span>(&#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;, <span class="keyword">else</span>: &#123; <span class="string">"default"</span>.<span class="built_in">count</span> &#125;)</span><br></pre></td></tr></table></figure><h2 id="组合可选项（Combining-Optionals）"><a href="#组合可选项（Combining-Optionals）" class="headerlink" title="组合可选项（Combining Optionals）"></a>组合可选项（Combining Optionals）</h2><p>这个类别包含了四个函数，允许你定义多个可选项之间的关系。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="comment">///  当可选值不为空时，解包并返回参数 `optional`</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">and</span>&lt;B&gt;<span class="params">(<span class="number">_</span> <span class="keyword">optional</span>: B?)</span></span> -&gt; <span class="type">B</span>? &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">self</span> != <span class="literal">nil</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">optional</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 解包可选值，当可选值不为空时，执行 `then` 闭包，并返回执行结果</span></span><br><span class="line">    <span class="comment">/// 允许你将多个可选项连接在一起</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">and</span>&lt;T&gt;<span class="params">(then: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>?) <span class="keyword">rethrows</span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> unwrapped = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> then(unwrapped)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 将当前可选值与其他可选值组合在一起</span></span><br><span class="line">    <span class="comment">/// 当且仅当两个可选值都不为空时组合成功，否则返回空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">zip2</span>&lt;A&gt;<span class="params">(with other: Optional&lt;A&gt;)</span></span> -&gt; (<span class="type">Wrapped</span>, <span class="type">A</span>)? &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> first = <span class="keyword">self</span>, <span class="keyword">let</span> second = other <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> (first, second)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 将当前可选值与其他可选值组合在一起</span></span><br><span class="line">    <span class="comment">/// 当且仅当三个可选值都不为空时组合成功，否则返回空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">zip3</span>&lt;A, B&gt;<span class="params">(with other: Optional&lt;A&gt;, another: Optional&lt;B&gt;)</span></span> -&gt; (<span class="type">Wrapped</span>, <span class="type">A</span>, <span class="type">B</span>)? &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> first = <span class="keyword">self</span>,</span><br><span class="line">      <span class="keyword">let</span> second = other,</span><br><span class="line">      <span class="keyword">let</span> third = another <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"><span class="keyword">return</span> (first, second, third)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的四个函数都以传入可选值当做参数，最终都返回一个可选值，然而，他们的实现方式完全不同。</p><h2 id="依赖（Dependencies）"><a href="#依赖（Dependencies）" class="headerlink" title="依赖（Dependencies）"></a>依赖（Dependencies）</h2><p>若一个可选值的解包仅作为另一可选值解包的前提，<code>and&lt;B&gt;(_ optional)</code> 就显得非常使用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用前</span></span><br><span class="line"><span class="keyword">if</span> user != <span class="literal">nil</span>, <span class="keyword">let</span> account = userAccount() ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用后</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> account = user.and(userAccount()) ...</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们对 <code>user</code> 的具体内容不感兴趣，但是要求在调用 <code>userAccount</code> 函数前保证它非空。虽然这种关系也可以使用 <code>user != nil</code>，但我觉得 <code>and</code> 使它们的意图更加清晰。</p><h2 id="链式调用（Chaining）"><a href="#链式调用（Chaining）" class="headerlink" title="链式调用（Chaining）"></a>链式调用（Chaining）</h2><p><code>and&lt;T&gt;(then:)</code> 是另一个非常有用的函数, 它将多个可选项链接起来，以便将可选项 <code>A</code> 的解包值当做可选项 <code>B</code> 的输入。我们从一个简单的例子开始：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UserDatabase</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">current</span><span class="params">()</span></span> -&gt; <span class="type">User</span>?</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">spouse</span><span class="params">(of user: User)</span></span> -&gt; <span class="type">User</span>?</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">father</span><span class="params">(of user: User)</span></span> -&gt; <span class="type">User</span>?</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">childrenCount</span><span class="params">(of user: User)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> database: <span class="type">UserDatabase</span> = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 思考如下关系该如何表达：</span></span><br><span class="line"><span class="comment">// Man -&gt; Spouse -&gt; Father -&gt; Father -&gt; Spouse -&gt; children</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前</span></span><br><span class="line"><span class="keyword">let</span> childrenCount: <span class="type">Int</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> user = database.current(), </span><br><span class="line">   <span class="keyword">let</span> father1 = database.father(user),</span><br><span class="line">   <span class="keyword">let</span> father2 = database.father(father1),</span><br><span class="line">   <span class="keyword">let</span> spouse = database.spouse(father2),</span><br><span class="line">   <span class="keyword">let</span> children = database.childrenCount(father2) &#123;</span><br><span class="line">  childrenCount = children</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  childrenCount = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用后</span></span><br><span class="line"><span class="keyword">let</span> children = database.current().and(then: &#123; database.spouse($<span class="number">0</span>) &#125;)</span><br><span class="line">     .and(then: &#123; database.father($<span class="number">0</span>) &#125;)</span><br><span class="line">     .and(then: &#123; database.spouse($<span class="number">0</span>) &#125;)</span><br><span class="line">     .and(then: &#123; database.childrenCount($<span class="number">0</span>) &#125;)</span><br><span class="line">     .or(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>使用 <code>and(then)</code> 函数对代码有很大的提升。首先，你没必要声明临时变量名（user, father1, father2, spouse, children），其次，代码更加的简洁。而且，使用 <code>or(0)</code> 比 <code>let childrenCount</code> 可读性更好。</p><p>最后，原来的 Swift 代码很容易导致逻辑错误。也许你还没有注意到，但示例中存在一个 bug。在写那样的代码时，就很容易地引入复制粘贴错误。你观察到了么？</p><p>是的，<code>children</code> 属性应该由调用 <code>database.childrenCount(spouse)</code> 创建，但我写成了 <code>database.childrenCount(father2)</code>。很难发现这样的错误。使用 <code>and(then:)</code> 就容易发现这个错误，因为它使用的是变量 <code>$0</code>。</p><h2 id="组合（Zipping）"><a href="#组合（Zipping）" class="headerlink" title="组合（Zipping）"></a>组合（Zipping）</h2><p>这是现有 Swift 概念的另一个扩展，<code>zip</code> 可以组合多个可选值，它们一起解包成功或解包失败。在上面的代码片段中，我提供了 <code>zip2</code> 与 <code>zip3</code> 函数，但你也可以命名为 <code>zip22</code>（好吧，也许对合理性和编译速度有一点点影响）。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildProduct</span><span class="params">()</span></span> -&gt; <span class="type">Product</span>? &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> var1 = machine1.makeSomething(),</span><br><span class="line">    <span class="keyword">let</span> var2 = machine2.makeAnotherThing(),</span><br><span class="line">    <span class="keyword">let</span> var3 = machine3.createThing() &#123;</span><br><span class="line">    <span class="keyword">return</span> finalMachine.produce(var1, var2, var3)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扩展</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildProduct</span><span class="params">()</span></span> -&gt; <span class="type">Product</span>? &#123;</span><br><span class="line">  <span class="keyword">return</span> machine1.makeSomething()</span><br><span class="line">     .zip3(machine2.makeAnotherThing(), machine3.createThing())</span><br><span class="line">     .<span class="built_in">map</span> &#123; finalMachine.produce($<span class="number">0.1</span>, $<span class="number">0.2</span>, $<span class="number">0.3</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码量更少，代码更清晰，更优雅。然而，也存一个缺点，就是更复杂了。读者必须了解并理解 <code>zip</code> 才能完全掌握它。</p><h2 id="On"><a href="#On" class="headerlink" title="On"></a>On</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 当可选值不为空时，执行 `some` 闭包</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(some: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) <span class="keyword">rethrows</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span> != <span class="literal">nil</span> &#123; <span class="keyword">try</span> some() &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 当可选值为空时，执行 `none` 闭包</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="keyword">none</span>: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) <span class="keyword">rethrows</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span> == <span class="literal">nil</span> &#123; <span class="keyword">try</span> <span class="keyword">none</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论可选值是否为空，上面两个扩展都允许你执行一些额外的操作。与上面讨论过的方法相反，这两个方法忽略可选值。<code>on(some:)</code> 会在可选值不为空的时候执行闭包 <code>some</code>，但是闭包 <code>some</code> 不会获取可选项的值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 如果用户不存在将登出</span></span><br><span class="line"><span class="keyword">self</span>.user.on(<span class="keyword">none</span>: &#123; <span class="type">AppCoordinator</span>.shared.logout() &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 当用户不为空时，连接网络</span></span><br><span class="line"><span class="keyword">self</span>.user.on(some: &#123; <span class="type">AppCoordinator</span>.shared.unlock() &#125;)</span><br></pre></td></tr></table></figure><h2 id="Various"><a href="#Various" class="headerlink" title="Various"></a>Various</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 可选值不为空且可选值满足 `predicate` 条件才返回，否则返回 `nil`</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(<span class="number">_</span> predicate: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Wrapped</span>? &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> unwrapped = <span class="keyword">self</span>,</span><br><span class="line">    predicate(unwrapped) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 可选值不为空时返回，否则 crash</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">expect</span><span class="params">(<span class="number">_</span> message: String)</span></span> -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> value = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(message) &#125;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤（Filter）"><a href="#过滤（Filter）" class="headerlink" title="过滤（Filter）"></a>过滤（Filter）</h3><p>这个方法类似于一个守护者一样，只有可选值满足 <code>predicate</code> 条件时才进行解包。比如说，我们希望所有的老用户都升级为高级账户，以便与我们保持更长久的联系。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅会影响 id &lt; 1000 的用户</span></span><br><span class="line"><span class="comment">// 正常写法</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> aUser = user, user.id &lt; <span class="number">1000</span> &#123; aUser.upgradeToPremium() &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `filter`</span></span><br><span class="line">user.<span class="built_in">filter</span>(&#123; $<span class="number">0</span>.id &lt; <span class="number">1000</span> &#125;)?.upgradeToPremium()</span><br></pre></td></tr></table></figure><p>在这里，<code>user.filter</code> 使用起来更加自然。此外，它的实现类似于 Swift 集合中的功能。</p><h3 id="期望（Expect）"><a href="#期望（Expect）" class="headerlink" title="期望（Expect）"></a>期望（Expect）</h3><p>这是我最喜欢的功能之一。这是我从 <code>Rush</code> 语言中借鉴而来的。我试图避免强行解包代码库中的任何东西。类似于隐式解包可选项。</p><p>然而，当在项目中使用可视化界面构建 UI 时，下面的这种方式很常见：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateLabel</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> label = valueLabel <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"valueLabel not connected in IB"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  label.text = state.title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，另一种方式是强制解包 <code>label</code>, 这么做可能会造成应用程序崩溃类似于 <code>fatalError</code>。 然而，我必须插入 <code>!</code>, 当造成程序崩溃后，<code>!</code> 并不能给明确的错误信息。在这里，使用上面实现的 <code>expect</code> 函数就是一个更好的选择：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateLabel</span><span class="params">()</span></span> &#123;</span><br><span class="line">  valueLabel.expect(<span class="string">"valueLabel not connected in IB"</span>).text = state.title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例（Example）"><a href="#示例（Example）" class="headerlink" title="示例（Example）"></a>示例（Example）</h2><p>至此我们已经实现了一系列非常有用的可选项扩展。我将会给出个综合示例，以便更好的了解如何组合使用这些扩展。首先，我们需要先说明一下这个示例，原谅我使用这个不太恰当的例子：</p><p>假如你是为 80 年代的软件商工作。每个月都有很多的人为你编写应用软件和游戏。你需要追踪销售量，你从会计那里收到一个 XML 文件，你需要进行解析并将结果存入到数据库中（如果在 80 年代就有 Swift 语言 以及 XML，这将是多么奇妙）。你的软件系统有一个XML解析器和一个数据库（当然都是用6502 ASM编写的），它们实现了以下协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">XMLImportNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">firstChild</span><span class="params">(with tag: String)</span></span> -&gt; <span class="type">XMLImportNode</span>?</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">children</span><span class="params">(with tag: String)</span></span> -&gt; [<span class="type">XMLImportNode</span>]</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">attribute</span><span class="params">(with name: String)</span></span> -&gt; <span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">DatabaseUser</span> = <span class="type">String</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">DatabaseSoftware</span> = <span class="type">String</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">user</span><span class="params">(<span class="keyword">for</span> id: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">DatabaseUser</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">software</span><span class="params">(<span class="keyword">for</span> id: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">DatabaseSoftware</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">insertSoftware</span><span class="params">(user: DatabaseUser, name: String, id: String, type: String, amount: Int)</span></span> <span class="keyword">throws</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateSoftware</span><span class="params">(software: DatabaseSoftware, amount: Int)</span></span> <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 文件可能看起来像这样：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"158"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">software</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">type</span>=<span class="string">"game"</span> <span class="attr">name</span>=<span class="string">"Maniac Mansion"</span> <span class="attr">id</span>=<span class="string">"4332"</span> <span class="attr">amount</span>=<span class="string">"30"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">type</span>=<span class="string">"game"</span> <span class="attr">name</span>=<span class="string">"Doom"</span> <span class="attr">id</span>=<span class="string">"1337"</span> <span class="attr">amount</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">type</span>=<span class="string">"game"</span> <span class="attr">name</span>=<span class="string">"Warcraft 2"</span> <span class="attr">id</span>=<span class="string">"1000"</span> <span class="attr">amount</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">software</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解析 XML 的代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ParseError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> msg(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseGamesFromXML</span><span class="params">(from root: XMLImportNode, into database: Database)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> users = root.firstChild(with: <span class="string">"users"</span>)?.children(with: <span class="string">"user"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">ParseError</span>.msg(<span class="string">"No Users"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> software = user.firstChild(with: <span class="string">"software"</span>)?</span><br><span class="line">.children(with: <span class="string">"package"</span>),</span><br><span class="line">    <span class="keyword">let</span> userId = user.attribute(with: <span class="string">"id"</span>),</span><br><span class="line">    <span class="keyword">let</span> dbUser = <span class="keyword">try</span>? database.user(<span class="keyword">for</span>: userId)</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">ParseError</span>.msg(<span class="string">"Invalid User"</span>) &#125;</span><br><span class="line"><span class="keyword">for</span> package <span class="keyword">in</span> software &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> type = package.attribute(with: <span class="string">"type"</span>),</span><br><span class="line">    type == <span class="string">"game"</span>,</span><br><span class="line">    <span class="keyword">let</span> name = package.attribute(with: <span class="string">"name"</span>),</span><br><span class="line">    <span class="keyword">let</span> softwareId = package.attribute(with: <span class="string">"id"</span>),</span><br><span class="line">    <span class="keyword">let</span> amountString = package.attribute(with: <span class="string">"amount"</span>)</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">ParseError</span>.msg(<span class="string">"Invalid Package"</span>) &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> existing = <span class="keyword">try</span>? database.software(<span class="keyword">for</span>: softwareId) &#123;</span><br><span class="line"><span class="keyword">try</span> database.updateSoftware(software: existing, </span><br><span class="line">      amount: <span class="type">Int</span>(amountString) ?? <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> database.insertSoftware(user: dbUser, name: name, </span><br><span class="line">      id: softwareId, </span><br><span class="line">    type: type, </span><br><span class="line">  amount: <span class="type">Int</span>(amountString) ?? <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们运用下上面学到的内容：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseGamesFromXML</span><span class="params">(from root: XMLImportNode, into database: Database)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> <span class="keyword">try</span> root.firstChild(with: <span class="string">"users"</span>)</span><br><span class="line">    .or(<span class="keyword">throw</span>: <span class="type">ParseError</span>.msg(<span class="string">"No Users"</span>)).children(with: <span class="string">"user"</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> dbUser = <span class="keyword">try</span> user.attribute(with: <span class="string">"id"</span>)</span><br><span class="line">    .and(then: &#123; <span class="keyword">try</span>? database.user(<span class="keyword">for</span>: $<span class="number">0</span>) &#125;)</span><br><span class="line">    .or(<span class="keyword">throw</span>: <span class="type">ParseError</span>.msg(<span class="string">"Invalid User"</span>))</span><br><span class="line"><span class="keyword">for</span> package <span class="keyword">in</span> (user.firstChild(with: <span class="string">"software"</span>)?</span><br><span class="line">    .children(with: <span class="string">"package"</span>)).or([]) &#123;</span><br><span class="line">    <span class="keyword">guard</span> (package.attribute(with: <span class="string">"type"</span>)).<span class="built_in">filter</span>(&#123; $<span class="number">0</span> == <span class="string">"game"</span> &#125;).isSome</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">    <span class="keyword">try</span> package.attribute(with: <span class="string">"name"</span>)</span><br><span class="line">.zip3(with: package.attribute(with: <span class="string">"id"</span>), </span><br><span class="line">   another: package.attribute(with: <span class="string">"amount"</span>))</span><br><span class="line">.<span class="built_in">map</span>(&#123; (tuple) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">try</span>? database.software(<span class="keyword">for</span>: tuple.<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> e?: <span class="keyword">try</span> database.updateSoftware(software: e, </span><br><span class="line">       amount: <span class="type">Int</span>(tuple.<span class="number">2</span>).or(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">try</span> database.insertSoftware(user: dbUser, name: tuple.<span class="number">0</span>, </span><br><span class="line">   id: tuple.<span class="number">1</span>, type: <span class="string">"game"</span>, </span><br><span class="line">       amount: <span class="type">Int</span>(tuple.<span class="number">2</span>).or(<span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, or: &#123; <span class="keyword">throw</span> <span class="type">ParseError</span>.msg(<span class="string">"Invalid Package"</span>) &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们对比下，至少会有两点映入眼帘：</p><ol><li>代码量更少</li><li>代码看起来更复杂了</li></ol><p>在组合使用可选扩展时，我故意造成一种过载状态。其中的一部分使用很恰当，但是另一部分却不那么合适。然而，使用扩展的关键不在于过度依赖（正如我上面做的那样），而在于这些扩展是否使语义更加清晰明了。比较上面的两个实现方式，<br>在第二个实现中，考虑下是使用 Swift 本身提供的功能好还是使用可选扩展更佳。</p><p>这就是本文的全部内容，感谢阅读！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      关于 Swift 可选项（Optional）扩展
    
    </summary>
    
      <category term="APPVENTURE" scheme="https://swift.gg/categories/APPVENTURE/"/>
    
    
      <category term="Swift，iOS开发，Swift进阶" scheme="https://swift.gg/tags/Swift%EF%BC%8CiOS%E5%BC%80%E5%8F%91%EF%BC%8CSwift%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>Mirror 的工作原理</title>
    <link href="https://swift.gg/2018/11/15/how-mirror-works/"/>
    <id>https://swift.gg/2018/11/15/how-mirror-works/</id>
    <published>2018-11-15T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://swift.org/blog/how-mirror-works/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-09-26<br>译者：<a href="https://nemocdz.github.io/" target="_blank" rel="noopener">Nemocdz</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://linusling.com" target="_blank" rel="noopener">小铁匠Linus</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>尽管 Swift 重心在强调静态类型上，但它同时支持丰富的元数据类型。元数据类型允许代码在运行时检查和操作任意值。这个功能通过 <code>Mirror</code> API 暴露给 Swift 开发者。大家可能会感到困惑，在 Swift 这种如此强调静态类型的语言里，<code>Mirror</code> 这样的特性是怎么工作的？让我们一起来通过这篇文章了解一下。</p><a id="more"></a><h2 id="事先声明"><a href="#事先声明" class="headerlink" title="事先声明"></a>事先声明</h2><p>这里介绍的东西都是内部实现的细节。这些代码的版本是写下文章时的版本，代码可能会随着版本改变。元数据会随着 ABI 稳定的到来而变得稳定和可靠，但在到来那时也会容易发生变化。大家在写日常的 Swift 代码时，不要依赖这里讲的一切。如果你想做比 <code>Mirror</code> 所提供的方式更复杂的反射，这里会给你一些思路。但在 ABI 的稳定前，还需要保持相关变化的关注。如果你想使用 <code>Mirror</code> 本身，这篇文章会提供一些好的思路去做接入和适配。不过再次提醒，这些东西可能会随着版本而改变。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><code>Mirror(reflecting:)</code> 初始化方法可以接受任意值，返回结果是一个提供该值子元素集合 <code>Children</code> 的相关信息的实例。一个 <code>Child</code> 由可选的标签和值构成。可以在编译期且不用知道任何类型信息情况下，在 <code>Child</code> 的值上用 <code>Mirror</code> 去遍历整个对象的层级视图。</p><p><code>Mirror</code> 允许类型用遵循 <code>CustomReflectable</code> 协议的方式提供一个自定义的表示方式。这给那些想表示得比内建形式更友好的类型提供一种有效的方法。 比如 <code>Array</code> 类型遵守 <code>CustomReflectable</code> 协议并且暴露其中的元素为无标签的 <code>Children</code>。<code>Dictionary</code> 使用这种方法暴露其中的键值对为带标签的 <code>Children</code>。</p><p>对于其他类型，<code>Mirror</code> 用魔法去返回一个基于其中的实际子元素的 <code>Children</code> 集合。对于结构体和类，<code>Children</code> 为其中储存的属性值。对于元组，<code>Children</code> 为元组的子元素。枚举则是枚举的 case 和其关联的值（如果有的话）。</p><p>这些神奇的魔法是怎么工作的呢？让我们一起来了解一下。</p><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>反射的 API 有一部分是用 Swift 实现的，另一部分是用 C++ 实现的。Swift 更适合用在实现更 Swift 的接口，并让很多任务变得更简单。Swift 的运行时的底层是使用 C++ 实现的，但是在 Swift 中不能直接访问 C++ 的类，所以有一个 C 的连接层。反射的 Swift 实现在 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/ReflectionMirror.swift" target="_blank" rel="noopener">ReflectionMirror.swift</a>，C++ 实现在 <a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/ReflectionMirror.mm" target="_blank" rel="noopener">ReflectionMirror.mm</a>。</p><p>这两者通过一小组暴露给 Swift 的 C++ 函数进行通信的。与其使用 Swift 生成的 C 桥接层，不如将这些函数在 Swift 中直接声明成指定的自定义符号，而这些名字的 C++ 函数则专门实现为可以被 Swift 直接调用的方式。这两部分的代码可以在不关心桥接机制会在幕后如何处理传递值的情况下交互，但仍需要准确的知道 Swift 应该如何传递参数和返回值。除非你在使用需要它的运行时代码，否则别轻易尝试这些。</p><p>举个例子，让我们看下在 <code>ReflectionMirror.swift</code> 中的 <code>_getChildCount</code> 函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_count"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getChildCount</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T, type: Any.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><p><code>@_silgen_name</code> 修饰符会通知 Swift 编译器将这个函数映射成 <code>swift_reflectionMirror_count</code> 符号，而不是 Swift 通常对应到的 <code>_getChildCount</code> 方法名修饰。需要注意的是，最前面的下划线表示这个修饰符是被保留在标准库中的。在 C++ 这边，这个函数是这样的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SWIFT_CC(swift) SWIFT_RUNTIME_STDLIB_INTERFACE</span><br><span class="line"><span class="keyword">intptr_t</span> swift_reflectionMirror_count(OpaqueValue *value,</span><br><span class="line">                                      <span class="keyword">const</span> Metadata *type,</span><br><span class="line">                                      <span class="keyword">const</span> Metadata *T) &#123;</span><br></pre></td></tr></table></figure><p><code>SWIFT_CC(swift)</code> 会告诉编译器这个函数使用的是 Swift 的调用约定，而不是 C/C++ 的。<code>SWIFT_RUNTIME_STDLIB_INTERFACE</code> 标记这是个函数，在 Swift 侧的一部分接口中，而且它还有标记为 <code>extern &quot;C&quot;</code> 的作用从而避免 C++ 的方法名修饰，并确保它在 Swift 侧会有预期的符号。同时，C++ 的参数会去特意匹配在 Swift 中声明的函数调用。当 Swift 调用 <code>_getChildCount</code> 时，C++ 会用包含的 Swift 值指针的 <code>value</code>，包含类型参数的 <code>type</code>，包含类型相应的范型 <code>&lt;T&gt;</code> 的 <code>T</code> 的函数参数来调用此函数。</p><p><code>Mirror</code> 的在 Swift 和 C++ 之间的全部接口由以下函数组成：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_normalizedType"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getNormalizedType</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T, type: Any.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Any</span>.<span class="type">Type</span></span><br><span class="line"></span><br><span class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_count"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getChildCount</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T, type: Any.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">typealias</span> <span class="type">NameFreeFunc</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">CChar</span>&gt;?) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_subscript"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getChild</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  of: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  type: Any.<span class="keyword">Type</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  index: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">  outName: UnsafeMutablePointer&lt;UnsafePointer&lt;CChar&gt;?&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  outFreeFunc: UnsafeMutablePointer&lt;NameFreeFunc?&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns 'c' (class), 'e' (enum), 's' (struct), 't' (tuple), or '\0' (none)</span></span><br><span class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_displayStyle"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getDisplayStyle</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T)</span></span> -&gt; <span class="type">CChar</span></span><br><span class="line"></span><br><span class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_quickLookObject"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getQuickLookObject</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T)</span></span> -&gt; <span class="type">AnyObject</span>?</span><br><span class="line"></span><br><span class="line">@_silgen_name(<span class="string">"_swift_stdlib_NSObject_isKindOfClass"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_isImpl</span><span class="params">(<span class="number">_</span> object: AnyObject, kindOf: AnyObject)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><h2 id="神奇的动态派发"><a href="#神奇的动态派发" class="headerlink" title="神奇的动态派发"></a>神奇的动态派发</h2><p>没有一种单一、通用的方式去获取任意类型中我们想要的信息。元组、结构、类和枚举都需要不同的代码去完成这些繁多的任务，比如说查找子元素的数量。其中还有一些更深、微妙的不同之处，比如对 Swift 和 Objective-C 的类的不同处理。</p><p>所有的这些函数因为需要不同类型的检查而需要派发不同的实现代码。这听起来有点像动态方法派发，除了选择哪种实现去调用比检查对象类型所使用的方法更复杂之外。这些反射代码尝试去简化使用包含 C++ 版本信息的接口的抽象基类，还有一大堆包含各种各样情况的子类进行 C++ 的动态派发。一个单独的函数会将一个 Swift 类型映射成一个其中的 C++ 类的实例。在一个实例上调用一个方法然后派发合适的实现。</p><p>映射的函数叫做 <code>call</code>，声明是这样的：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">call</span><span class="params">(OpaqueValue *passedValue, <span class="keyword">const</span> Metadata *T, <span class="keyword">const</span> Metadata *passedType,</span></span></span><br><span class="line">          const F &amp;f) -&gt; decltype(f(nullptr))</span><br></pre></td></tr></table></figure><p><code>passedValue</code> 是实际需要传入的Swift的值的指针。<code>T</code> 是该值得静态类型，对应 Swift 中的范型参数 <code>&lt;T&gt;</code>。<code>passedType</code> 是被显式传递进 Swift 侧并且会实际应用在反射过程中的类型（这个类型和在使用 <code>Mirror</code> 作为父类的实例在实际运行时的对象类型不一样）。最后，<code>f</code> 参数会传递这个函数查找到的会被调用的实现的对象引用。然后这个函数会返回当这个 <code>f</code> 参数调用时的返回值，可以让使用者更方便的获得返回值。</p><p><code>call</code> 的实现并没有想象中那么令人激动。主要是一个大型的 <code>switch</code> 声明和一些额外的代码去处理特殊的情况。重要的是它会用一个 <code>ReflectionMirrorImpl</code> 的子类实例去结束调用 <code>f</code>，然后会调用这个实例上的方法去让真正的工作完成。</p><p>这是 <code>ReflectionMirrorImpl</code>，接口的所有东西都要传入：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReflectionMirrorImpl</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> Metadata *type;</span><br><span class="line">  OpaqueValue *value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">displayStyle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> intptr_t <span class="title">count</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> AnyReturn <span class="title">subscript</span><span class="params">(<span class="keyword">intptr_t</span> index, <span class="keyword">const</span> <span class="keyword">char</span> **outName,</span></span></span><br><span class="line">                              void (**outFreeFunc)(const char *)) = 0;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">enumCaseName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SWIFT_OBJC_INTEROP</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> id <span class="title">quickLookObject</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nil; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~ReflectionMirrorImpl() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作用在 Swift 和 C++ 组件之间的接口函数就会用 <code>call</code> 去调用相应的方法。比如，<code>swift_reflectionMirror_count</code> 是这样的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SWIFT_CC(swift) SWIFT_RUNTIME_STDLIB_INTERFACE</span><br><span class="line"><span class="keyword">intptr_t</span> swift_reflectionMirror_count(OpaqueValue *value,</span><br><span class="line">                                      <span class="keyword">const</span> Metadata *type,</span><br><span class="line">                                      <span class="keyword">const</span> Metadata *T) &#123;</span><br><span class="line">  <span class="keyword">return</span> call(value, T, type, [](ReflectionMirrorImpl *impl) &#123;</span><br><span class="line">    <span class="keyword">return</span> impl-&gt;count();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元组的反射"><a href="#元组的反射" class="headerlink" title="元组的反射"></a>元组的反射</h2><p>先看看元组的反射，应该是最简单的一种了，但还是做了不少工作。它一开始会返回 <code>&#39;t&#39;</code> 的显示样式来表明这是一个元组：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TupleImpl</span> :</span> ReflectionMirrorImpl &#123;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">displayStyle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'t'</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>虽然用硬编码的常量看起来不是很常见，不过这样做可以完全在同一个地方给 C++ 和 Swift 这个值的引用，并且他们不需要使用桥接层进行交互，这还算是一个合理的选择。</p><p>接下来是 <code>count</code> 方法。此时我们知道 <code>type</code> 实际上是一个 <code>TupleTypeMetadata</code> 类型的指针而不仅仅是一个 <code>Metadata</code> 类型的指针。<code>TupleTypeMetadata</code> 有一个记录元组的元素数量的 <code>NumElements</code> 字段，然后这个方法就完成了：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> count() &#123;</span><br><span class="line">    <span class="keyword">auto</span> *Tuple = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TupleTypeMetadata *&gt;(type);</span><br><span class="line">    <span class="keyword">return</span> Tuple-&gt;NumElements;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>subscript</code> 方法会做更多一点的工作。它也从一样的的 <code>static_cast</code> 函数开始：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AnyReturn <span class="title">subscript</span><span class="params">(<span class="keyword">intptr_t</span> i, <span class="keyword">const</span> <span class="keyword">char</span> **outName,</span></span></span><br><span class="line">                      void (**outFreeFunc)(const char *)) &#123;</span><br><span class="line">    <span class="keyword">auto</span> *Tuple = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TupleTypeMetadata *&gt;(type);</span><br></pre></td></tr></table></figure><p>接下来，会有一个边界检查避免调用者请求了这个元组不存在的索引：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || (<span class="keyword">size_t</span>)i &gt; Tuple-&gt;NumElements)</span><br><span class="line">      swift::crash(<span class="string">"Swift mirror subscript bounds check failure"</span>);</span><br></pre></td></tr></table></figure><p>下标有两个作用：可以检索元素和对应的名字。对于一个结构体或者类来说，这个名字就是所储存的属性名。而对于元组来说，这个名字要么是该元素的元组标签，要么在没有标签的情况下就是一个类似 <code>.0</code> 的数值指示器。</p><p>标签以一个用空格做间隔的列表存储，放在元数据的 <code>Labels</code> 字段中。这段代码查找列表中的第 i 个字符串：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确定是否有一个标签</span></span><br><span class="line"><span class="keyword">bool</span> hasLabel = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">const</span> <span class="keyword">char</span> *labels = Tuple-&gt;Labels) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *space = <span class="built_in">strchr</span>(labels, <span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">intptr_t</span> j = <span class="number">0</span>; j != i &amp;&amp; space; ++j) &#123;</span><br><span class="line">    labels = space + <span class="number">1</span>;</span><br><span class="line">    space = <span class="built_in">strchr</span>(labels, <span class="string">' '</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we have a label, create it.</span></span><br><span class="line">  <span class="keyword">if</span> (labels &amp;&amp; space &amp;&amp; labels != space) &#123;</span><br><span class="line">    *outName = strndup(labels, space - labels);</span><br><span class="line">    hasLabel = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在没有标签的情况下，创建一个合适的数值指示器作为名字：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!hasLabel) &#123;</span><br><span class="line">  <span class="comment">// The name is the stringized element number '.0'.</span></span><br><span class="line">  <span class="keyword">char</span> *str;</span><br><span class="line">  asprintf(&amp;str, <span class="string">".%"</span> PRIdPTR, i);</span><br><span class="line">  *outName = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为要将 Swift 和 C++ 交叉使用，所以不能享受一些方便的特性比如自动内存管理。Swift 有 ARC，C++ 有 RALL， 但是这两种技术没办法兼容。<code>outFreeFunc</code> 允许 C++ 的代码提供一个函数给调用者用来释放返回的名字。标签需要使用 <code>free</code> 进行释放，所以设置给 <code>*outFreeFunc</code> 相应的值如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*outFreeFunc = [](<span class="keyword">const</span> <span class="keyword">char</span> *str) &#123; <span class="built_in">free</span>(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(str)); &#125;;</span><br></pre></td></tr></table></figure><p>值得注意的是名字，但令人惊讶的是，这个值检索起来很简单。<code>Tuple</code> 元数据包含了一个可以用索引去获取元素的相关信息的返回的函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;elt = Tuple-&gt;getElement(i);</span><br></pre></td></tr></table></figure><p><code>elt</code> 包含了一个偏移值，可以应用在元组值上，去获得元素的值指针：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> *bytes = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(value);</span><br><span class="line"><span class="keyword">auto</span> *eltData = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> OpaqueValue *&gt;(bytes + elt.Offset);</span><br></pre></td></tr></table></figure><p><code>elt</code> 还包含了元素的类型。可以通过类型和值的指针，去构造一个包括这个值新的 <code>Any</code> 对象。这个类型有可以分配内存并初始化包含给定类型的值的储存字段的函数指针。用这些函数拷贝值为 <code>Any</code> 类型的对象，然后返回 <code>Any</code> 给调用者。代码是这样的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    Any result;</span><br><span class="line"></span><br><span class="line">    result.Type = elt.Type;</span><br><span class="line">    <span class="keyword">auto</span> *opaqueValueAddr = result.Type-&gt;allocateBoxForExistentialIn(&amp;result.Buffer);</span><br><span class="line">    result.Type-&gt;vw_initializeWithCopy(opaqueValueAddr,</span><br><span class="line">                                       <span class="keyword">const_cast</span>&lt;OpaqueValue *&gt;(eltData));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> AnyReturn(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就是元组的做法。</p><h2 id="swift-getFieldAt"><a href="#swift-getFieldAt" class="headerlink" title="swift_getFieldAt"></a>swift_getFieldAt</h2><p>在结构、类和枚举中查找元素目前来说相当复杂。造成这么复杂的主要原因是，这些类型和包含这些类型相关信息的字段的字段描述符之间缺少直接的引用关系。有一个叫 <code>swift_getField</code> 的帮助函数可以查找给定类型相应的字段描述符。一但我们添加了那个直接的引用，这整个函数应该就没啥作用了，但在同一时刻，它提供了运行时代码怎么能做到用语言的元数据去查找类型信息的一个有趣思路。</p><p>这个函数原型是这样的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> swift::_swift_getFieldAt(</span><br><span class="line">    <span class="keyword">const</span> Metadata *base, <span class="keyword">unsigned</span> index,</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(llvm::StringRef name, FieldType fieldInfo)&gt;</span><br><span class="line">        callback) &#123;</span><br></pre></td></tr></table></figure><p>它会用类型去检查，用字段的索引去查找，还有一个会被在信息找到时回调。</p><p>首先就是获取类型的类型上下文描述，包含着更进一步将会被使用的类型的信息：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> *baseDesc = base-&gt;getTypeContextDescriptor();</span><br><span class="line"><span class="keyword">if</span> (!baseDesc)</span><br><span class="line">  <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>这个工作会分为两个部分。第一步查找类型的字段描述符。字段描述符包括所有有关这个类型的字段信息。一旦字段描述符可用，这个函数可以从描述符中查找所需要的信息。</p><p>从描述符中查找信息被封装成一个叫 <code>getFieldAt</code> 的帮助方法， 可以让各种各样地方的其它代码查找到合适的字段描述符。让我们看下这个查询过程。它从获取一个用来将符号还原器开始，将符号修饰过的类名还原为实际的类型引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> dem = getDemanglerForRuntimeTypeResolution();</span><br></pre></td></tr></table></figure><p>会用缓存来加快多次的查找：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;cache = FieldCache.get();</span><br></pre></td></tr></table></figure><p>如果缓存中已经有字段描述符，调用 <code>getFieldAt</code> 来获得：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> Value = cache.FieldCache.find(base)) &#123;</span><br><span class="line">  getFieldAt(*Value-&gt;getDescription());</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让查找的代码更简单，有一个可以检查 <code>FieldDescriptor</code> 是否是被查找的那一个的帮助方法。如果描述符匹配，那么描述符放入缓存中，调用 <code>getFieldAt</code> ，然后返回成功给调用者。匹配的过程是复杂的，不过本质上归纳起来就是去匹配符号修饰的名字：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> isRequestedDescriptor = [&amp;](<span class="keyword">const</span> FieldDescriptor &amp;descriptor) &#123;</span><br><span class="line">  assert(descriptor.hasMangledTypeName());</span><br><span class="line">  <span class="keyword">auto</span> mangledName = descriptor.getMangledTypeName(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!_contextDescriptorMatchesMangling(baseDesc,</span><br><span class="line">                                         dem.demangleType(mangledName)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  cache.FieldCache.getOrInsert(base, &amp;descriptor);</span><br><span class="line">  getFieldAt(descriptor);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字段描述符可用在运行时注册或在编译时放进二进制。这两个循环查找在匹配中所有已知的的字段描述符：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;section : cache.DynamicSections.snapshot()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> *descriptor : section) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isRequestedDescriptor(*descriptor))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;section : cache.StaticSections.snapshot()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;descriptor : section) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isRequestedDescriptor(descriptor))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发现没有匹配时，记录一个警告信息并且在回调返回一个空元组（仅仅为了给一个回调）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">auto</span> typeName = swift_getTypeName(base, <span class="comment">/*qualified*/</span> <span class="literal">true</span>);</span><br><span class="line">  warning(<span class="number">0</span>, <span class="string">"SWIFT RUNTIME BUG: unable to find field metadata for type '%*s'\n"</span>,</span><br><span class="line">             (<span class="keyword">int</span>)typeName.length, typeName.data);</span><br><span class="line">  callback(<span class="string">"unknown"</span>,</span><br><span class="line">           FieldType()</span><br><span class="line">             .withType(TypeInfo(&amp;METADATA_SYM(EMPTY_TUPLE_MANGLING), &#123;&#125;))</span><br><span class="line">             .withIndirect(<span class="literal">false</span>)</span><br><span class="line">             .withWeak(<span class="literal">false</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是字段描述符的查找过程。<code>getFieldAt</code> 帮助方法将字段描述符转化为名字和回调中返回的字段类型。开始它会从字段描述符中请求字段的引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> getFieldAt = [&amp;](<span class="keyword">const</span> FieldDescriptor &amp;descriptor) &#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;field = descriptor.getFields()[index];</span><br></pre></td></tr></table></figure><p>名字可以直接获得在这个引用中访问到：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> name = field.getFieldName(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果这个字段实际上是一个枚举，那么就可能没有类型。先做这种检查，并执行回调：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!field.hasMangledTypeName()) &#123;</span><br><span class="line">  callback(name, FieldType().withIndirect(field.isIndirectCase()));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段的引用将字段类型储存为一个符号修饰的名字。因为回调预期的是元数据的指针，所以符号修饰的名字必须被转化为一个真实的类型。<code>_getTypeByMangledName</code> 函数处理了大部分工作，不过需要调用者解决这个类型用的所有范型参数。这个工作需要将这个类型的所有范型的上下文抽离出来：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> ContextDescriptor *&gt; descriptorPath;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> *parent = <span class="keyword">reinterpret_cast</span>&lt;</span><br><span class="line">                          <span class="keyword">const</span> ContextDescriptor *&gt;(baseDesc);</span><br><span class="line">  <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;isGeneric())</span><br><span class="line">      descriptorPath.push_back(parent);</span><br><span class="line"></span><br><span class="line">    parent = parent-&gt;Parent.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在获得了符号修饰的名字和类型，将它们传入一个 Lambda 表达式来解决范型参数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> typeName = field.getMangledTypeName(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> typeInfo = _getTypeByMangledName(</span><br><span class="line">    typeName,</span><br><span class="line">    [&amp;](<span class="keyword">unsigned</span> depth, <span class="keyword">unsigned</span> index) -&gt; <span class="keyword">const</span> Metadata * &#123;</span><br></pre></td></tr></table></figure><p>如果请求的深度比描述符的路径大小还大，那么就会失败：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (depth &gt;= descriptorPath.size())</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>除此之外，还有从字段的类型中获取范型参数。这需要将索引和深度转化为单独的扁平化的索引，通过遍历描述符的路径，在每个阶段添加范型参数的数量直到达到深度为止：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> currentDepth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> flatIndex = index;</span><br><span class="line"><span class="keyword">const</span> ContextDescriptor *currentContext = descriptorPath.back();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> *context : llvm::reverse(descriptorPath)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (currentDepth &gt;= depth)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  flatIndex += context-&gt;getNumGenericParams();</span><br><span class="line">  currentContext = context;</span><br><span class="line">  ++currentDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果索引比范型参数可达到的深度大，那么失败：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (index &gt;= currentContext-&gt;getNumGenericParams())</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>除此之外，从基本类型中获得合适的范型参数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> base-&gt;getGenericArgs()[flatIndex];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>像之前那样，如果不能找到类型，就用空元组：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeInfo == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  typeInfo = TypeInfo(&amp;METADATA_SYM(EMPTY_TUPLE_MANGLING), &#123;&#125;);</span><br><span class="line">  warning(<span class="number">0</span>, <span class="string">"SWIFT RUNTIME BUG: unable to demangle type of field '%*s'. "</span></span><br><span class="line">             <span class="string">"mangled type name is '%*s'\n"</span>,</span><br><span class="line">             (<span class="keyword">int</span>)name.size(), name.data(),</span><br><span class="line">             (<span class="keyword">int</span>)typeName.size(), typeName.data());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行回调，无论找到了什么：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  callback(name, FieldType()</span><br><span class="line">                     .withType(typeInfo)</span><br><span class="line">                     .withIndirect(field.isIndirectCase())</span><br><span class="line">                     .withWeak(typeInfo.isWeak()));</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就是 <code>swift_getFieldAt</code>。我们带着这个帮助方法看看其他反射的实现。</p><h2 id="结构体的反射"><a href="#结构体的反射" class="headerlink" title="结构体的反射"></a>结构体的反射</h2><p>结构体的实现也是类似的，但稍微有点复杂。这是因为有些结构体类型不完全支持反射，查找名字和偏移值要花费更多力气，而且结构体可能包含需要反射代码去提取的弱引用。</p><p>首先是一个帮助方法去检查结构体是否完全支持反射。结构体元数据里储存这样一个可被访问的标志位。跟上面元组的代码类似，可以知道 <code>type</code> 实际上是一个 <code>StructMetadata</code> 指针，所以我们可以自由的传入：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StructImpl</span> :</span> ReflectionMirrorImpl &#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isReflectable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> *Struct = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> StructMetadata *&gt;(type);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;Description = Struct-&gt;getDescription();</span><br><span class="line">    <span class="keyword">return</span> Description-&gt;getTypeContextDescriptorFlags().isReflectable();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>结构体的显示样式是 s :</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">displayStyle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'s'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子元素的数量是元数据给出的字段的数量，也可能是 0（如果这个类型实际上不能支持反射的话）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> count() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isReflectable()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> *Struct = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> StructMetadata *&gt;(type);</span><br><span class="line">  <span class="keyword">return</span> Struct-&gt;getDescription()-&gt;NumFields;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像之前那样，<code>subscript</code> 方法是比较复杂的部分。它开始也是类似的，做边界检查和查找偏移值：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AnyReturn <span class="title">subscript</span><span class="params">(<span class="keyword">intptr_t</span> i, <span class="keyword">const</span> <span class="keyword">char</span> **outName,</span></span></span><br><span class="line">                    void (**outFreeFunc)(const char *)) &#123;</span><br><span class="line">  <span class="keyword">auto</span> *Struct = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> StructMetadata *&gt;(type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">0</span> || (<span class="keyword">size_t</span>)i &gt; Struct-&gt;getDescription()-&gt;NumFields)</span><br><span class="line">    swift::crash(<span class="string">"Swift mirror subscript bounds check failure"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the offset from its respective vector.</span></span><br><span class="line">  <span class="keyword">auto</span> fieldOffset = Struct-&gt;getFieldOffsets()[i];</span><br></pre></td></tr></table></figure><p>从结构体字段中获取类型信息会更复杂一点。这项工作通过 <code>_swift_getFieldAt</code> 帮助方法进行：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Any result;</span><br><span class="line"></span><br><span class="line">_swift_getFieldAt(type, i, [&amp;](llvm::StringRef name, FieldType fieldInfo) &#123;</span><br></pre></td></tr></table></figure><p>一但它有字段信息，一切就会进行得和元组对应部分的代码类似。填写名字和计算字段储存的指针：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*outName = name.data();</span><br><span class="line">*outFreeFunc = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> *bytes = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(value);</span><br><span class="line"><span class="keyword">auto</span> *fieldData = <span class="keyword">reinterpret_cast</span>&lt;OpaqueValue *&gt;(bytes + fieldOffset);</span><br></pre></td></tr></table></figure><p>这里有一个额外的步骤去拷贝字段的值到 <code>Any</code> 类型的返回值来处理弱引用。<code>loadSpecialReferenceStorage</code> 方法处理这种情况。如果值没有被载入的话那么那个值用普通的储存，并且以普通的方式拷贝到返回值：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">bool</span> didLoad = loadSpecialReferenceStorage(fieldData, fieldInfo, &amp;result);</span><br><span class="line">      <span class="keyword">if</span> (!didLoad) &#123;</span><br><span class="line">        result.Type = fieldInfo.getType();</span><br><span class="line">        <span class="keyword">auto</span> *opaqueValueAddr = result.Type-&gt;allocateBoxForExistentialIn(&amp;result.Buffer);</span><br><span class="line">        result.Type-&gt;vw_initializeWithCopy(opaqueValueAddr,</span><br><span class="line">                                           <span class="keyword">const_cast</span>&lt;OpaqueValue *&gt;(fieldData));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> AnyReturn(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些就是结构体值得注意的了。</p><h2 id="类的反射"><a href="#类的反射" class="headerlink" title="类的反射"></a>类的反射</h2><p>类和结构体很类似，在 <code>ClassImpl</code> 里的代码几乎是相同的。在操作 Objective-C 上有两点值得注意的不同之处。一个是 <code>quickLookObject</code> 的实现，会调起 Objective-C 的  <code>debugQuickLookObject</code>  方法的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SWIFT_OBJC_INTEROP</span></span><br><span class="line"><span class="function">id <span class="title">quickLookObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  id object = [*<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> id *&gt;(value) retain];</span><br><span class="line">  <span class="keyword">if</span> ([object respondsToSelector:@selector(debugQuickLookObject)]) &#123;</span><br><span class="line">    id quickLookObject = [object debugQuickLookObject];</span><br><span class="line">    [quickLookObject retain];</span><br><span class="line">    [object release];</span><br><span class="line">    <span class="keyword">return</span> quickLookObject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>另一个是如果该类的父类是 Objective-C 的类，字段的偏移值需要在 Objective-C 运行时获得：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">uintptr_t</span> fieldOffset;</span><br><span class="line">  <span class="keyword">if</span> (usesNativeSwiftReferenceCounting(Clas)) &#123;</span><br><span class="line">    fieldOffset = Clas-&gt;getFieldOffsets()[i];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#<span class="keyword">if</span> SWIFT_OBJC_INTEROP</span><br><span class="line">    Ivar *ivars = class_copyIvarList((Class)Clas, <span class="literal">nullptr</span>);</span><br><span class="line">    fieldOffset = ivar_getOffset(ivars[i]);</span><br><span class="line">    <span class="built_in">free</span>(ivars);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    swift::crash(<span class="string">"Object appears to be Objective-C, but no runtime."</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="枚举的反射"><a href="#枚举的反射" class="headerlink" title="枚举的反射"></a>枚举的反射</h2><p>枚举有一些不同之处。<code>Mirror</code> 会考虑一个枚举实例最多只包含一个元素，枚举 case 名字作为标签，它的关联值作为值。没有关联值的 case 没有包含的元素。 举个例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> bar</span><br><span class="line">  <span class="keyword">case</span> baz(<span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> quux(<span class="type">String</span>, <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>Foo</code> 类型的值使用 mirror 时，mirror 会显示 <code>Foo.bar</code> 没有子元素，<code>Foo.baz</code> 有一个 <code>Int</code> 类型的元素，<code>Foo.quux</code> 有一个 <code>(String, String)</code> 类型的元素。相同的子标签和类型的类和结构体的值有着相同字段，但同一个类型的不同的枚举 case 不是这样的。关联的值也可能是间接的，所以需要一些特殊处理。</p><p><code>enum</code> 的反射需要四部分核心的信息：case 的名字，tag（表示该值储存的枚举 case 的数字），payload 的类型，是否是间接的 payload。<code>getInfo</code> 方法获取这些值：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getInfo</span><span class="params">(<span class="keyword">unsigned</span> *tagPtr = <span class="literal">nullptr</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> Metadata **payloadTypePtr = <span class="literal">nullptr</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">bool</span> *indirectPtr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>tag 从请求元数据直接检索而来：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> tag = type-&gt;vw_getEnumTag(value);</span><br></pre></td></tr></table></figure><p>其它信息用 <code>_swift_getFieldAt</code> 检索而来。将 tag 作为字段索引来调用，就会提供合适的信息：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Metadata *payloadType = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">bool</span> indirect = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *caseName = <span class="literal">nullptr</span>;</span><br><span class="line">_swift_getFieldAt(type, tag, [&amp;](llvm::StringRef name, FieldType info) &#123;</span><br><span class="line">  caseName = name.data();</span><br><span class="line">  payloadType = info.getType();</span><br><span class="line">  indirect = info.isIndirect();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所有的值会返回给调用者：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (tagPtr)</span><br><span class="line">    *tagPtr = tag;</span><br><span class="line">  <span class="keyword">if</span> (payloadTypePtr)</span><br><span class="line">    *payloadTypePtr = payloadType;</span><br><span class="line">  <span class="keyword">if</span> (indirectPtr)</span><br><span class="line">    *indirectPtr = indirect;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> caseName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（你可能会好奇：为什么只有 case 的名字是直接返回的，而其它的三个信息用指针返回？为什么不返回 tag 或者 payload 的类型？答案是：我真的不知道，可能在那个时机看起来是个好主意）</p><p><code>count</code> 方法可以用 <code>getInfo</code> 方法去检索 payload 的类型，并返回 0 或 1 表示 payload 类型是否为 null：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> count() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isReflectable()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Metadata *payloadType;</span><br><span class="line">  getInfo(<span class="literal">nullptr</span>, &amp;payloadType, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">return</span> (payloadType != <span class="literal">nullptr</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>subscript</code>方法开始会获取所有有关这个值的信息：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AnyReturn <span class="title">subscript</span><span class="params">(<span class="keyword">intptr_t</span> i, <span class="keyword">const</span> <span class="keyword">char</span> **outName,</span></span></span><br><span class="line">                    void (**outFreeFunc)(const char *)) &#123;</span><br><span class="line">  <span class="keyword">unsigned</span> tag;</span><br><span class="line">  <span class="keyword">const</span> Metadata *payloadType;</span><br><span class="line">  <span class="keyword">bool</span> indirect;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> *caseName = getInfo(&amp;tag, &amp;payloadType, &amp;indirect);</span><br></pre></td></tr></table></figure><p>实际的复制值需要更多的工作。为了处理间接的值，整个过程在一个额外的 box 中进行：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Metadata *boxType = (indirect ? &amp;METADATA_SYM(Bo).base : payloadType);</span><br><span class="line">BoxPair pair = swift_allocBox(boxType);</span><br></pre></td></tr></table></figure><p>间接的情况下，真实值要在 box 中取出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (indirect) &#123;</span><br><span class="line">  <span class="keyword">const</span> HeapObject *owner = *<span class="keyword">reinterpret_cast</span>&lt;HeapObject * <span class="keyword">const</span> *&gt;(value);</span><br><span class="line">  value = swift_projectBox(<span class="keyword">const_cast</span>&lt;HeapObject *&gt;(owner));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在一切都准备好了。给 case 名字设置子标签：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*outName = caseName;</span><br><span class="line">*outFreeFunc = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>似曾相识的方式被用在将 payload 返回为 <code>Any</code> 类型的对象：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  Any result;</span><br><span class="line"></span><br><span class="line">  result.Type = payloadType;</span><br><span class="line">  <span class="keyword">auto</span> *opaqueValueAddr = result.Type-&gt;allocateBoxForExistentialIn(&amp;result.Buffer);</span><br><span class="line">  result.Type-&gt;vw_initializeWithCopy(opaqueValueAddr,</span><br><span class="line">                                     <span class="keyword">const_cast</span>&lt;OpaqueValue *&gt;(value));</span><br><span class="line"></span><br><span class="line">  swift_release(pair.object);</span><br><span class="line">  <span class="keyword">return</span> AnyReturn(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其余种类"><a href="#其余种类" class="headerlink" title="其余种类"></a>其余种类</h2><p>文件中还有三种其他的实现，每种几乎都没做什么事情。<code>ObjCClassImpl</code> 处理 Objective-C 的类。它甚至不去尝试返回任何子元素，因为 Objective-C 在 ivars 的内容上允许太多种补救方案了。Objective-C 的类允许保持野指针一直存在，并需要单独的逻辑让实现不要去碰那个值。因为这样的值尝试作为 <code>Mirror</code> 子元素返回，会违反 Swift 的安全性保证。因为没有办法可靠地去告知应该如何处理如果值出了问题，所以代码避开处理整个这种情况。</p><p><code>MetatypeImpl</code> 处理元类型。如果将 <code>Mirror</code> 用在实际的类型，比如这样用 <code>Mirror(reflecting:String.self)</code>，这时就会用到它。第一反应是，它会在这时提供一些有用的信息。但实际上它仅仅返回空，甚至没有去尝试获取任何东西。同样的，<code>OpaqueImpl</code> 处理不透明的类型并返回空。</p><h2 id="Swift-侧接口"><a href="#Swift-侧接口" class="headerlink" title="Swift 侧接口"></a>Swift 侧接口</h2><p>在 Swift 侧，<code>Mirror</code> 调用在 C++ 侧实现的接口函数，去检索需要的信息，然后以更友好的方式去展现。这些会在 <code>Mirror</code> 的初始化器中完成：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">init</span>(internalReflecting subject: <span class="type">Any</span>,</span><br><span class="line">            subjectType: <span class="type">Any</span>.<span class="type">Type</span>? = <span class="literal">nil</span>,</span><br><span class="line">            customAncestor: <span class="type">Mirror</span>? = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p><code>subjectType</code> 是将要被反射 <code>subject</code> 的值的类型。这通常是值的运行时类型，但如果调用者用 <code>superclassMirror</code> 去找到上面的类的层级，它可以是父类。如果调用者不传 入<code>subjectType</code>，代码会问 C++ 侧的代码要 <code>subject</code> 的类型：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> subjectType = subjectType ?? _getNormalizedType(subject, type: type(of: subject))</span><br></pre></td></tr></table></figure><p>然后它就会获取子元素的数量，创建一个稍后获取每个子元素个体的集合来构建构建 <code>children</code> 对象：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> childCount = _getChildCount(subject, type: subjectType)</span><br><span class="line"><span class="keyword">let</span> children = (<span class="number">0</span> ..&lt; childCount).<span class="built_in">lazy</span>.<span class="built_in">map</span>(&#123;</span><br><span class="line">  getChild(of: subject, type: subjectType, index: $<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">self</span>.children = <span class="type">Children</span>(children)</span><br></pre></td></tr></table></figure><p><code>getChild</code> 函数是 C++ 的 <code>_getChild</code> 函数的简单封装，将标签名字中包含的 C 字符串转换成 Swift 字符串。</p><p><code>Mirror</code> 有一个 <code>superclassMirror</code> 属性，会返回检查过类的层级结构里上一层的类的属性的 <code>Mirror</code> 对象。在内部，它有一个 <code>_makeSuperclassMirror</code> 属性保存着一个按需求构建父类的 <code>Mirror</code> 的闭包。闭包一开始会获取 <code>subjectType</code> 的父类。非类的类型和没有父类的类没有父类的 Mirror，所以他们会获取到 <code>nil</code>:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>._makeSuperclassMirror = &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> subjectClass = subjectType <span class="keyword">as</span>? <span class="type">AnyClass</span>,</span><br><span class="line">        <span class="keyword">let</span> superclass = _getSuperclass(subjectClass) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调用者可以用一个可作为父类 Mirror 直接返回的 <code>Mirror</code> 实例来指定自定义的祖先的表现：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> customAncestor = customAncestor &#123;</span><br><span class="line">  <span class="keyword">if</span> superclass == customAncestor.subjectType &#123;</span><br><span class="line">    <span class="keyword">return</span> customAncestor</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> customAncestor._defaultDescendantRepresentation == .suppressed &#123;</span><br><span class="line">    <span class="keyword">return</span> customAncestor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，给相同值返回一个将 <code>superclass</code> 作为 <code>subjectType</code> 的新 <code>Mirror</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="type">Mirror</span>(internalReflecting: subject,</span><br><span class="line">                subjectType: superclass,</span><br><span class="line">                customAncestor: customAncestor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，它获取并解析显示的样式，并设置 <code>Mirror</code> 的剩下的属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> rawDisplayStyle = _getDisplayStyle(subject)</span><br><span class="line">  <span class="keyword">switch</span> <span class="type">UnicodeScalar</span>(<span class="type">Int</span>(rawDisplayStyle)) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"c"</span>: <span class="keyword">self</span>.displayStyle = .<span class="keyword">class</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"e"</span>: <span class="keyword">self</span>.displayStyle = .<span class="keyword">enum</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"s"</span>: <span class="keyword">self</span>.displayStyle = .<span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"t"</span>: <span class="keyword">self</span>.displayStyle = .tuple</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"\0"</span>: <span class="keyword">self</span>.displayStyle = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">default</span>: <span class="built_in">preconditionFailure</span>(<span class="string">"Unknown raw display style '<span class="subst">\(rawDisplayStyle)</span>'"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.subjectType = subjectType</span><br><span class="line">  <span class="keyword">self</span>._defaultDescendantRepresentation = .generated</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Swift 丰富的元数据类型大多数在幕后存在，为像协议一致性检查和泛型类型解决这样的事提供支持。其中某些通过 <code>Mirror</code> 类 型暴露给用户，从而允许在运行时检查任意值。对于静态类型的 Swift 生态来说，这种方式一开始看起来有点奇怪和神秘，但根据已经存在的信息来看，它其实是个简单直接的应用。这个实现的探索旅程应该会帮助大家了解神秘之处，并在使用 <code>Mirror</code> 时可以意识到背后正在进行着什么。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://swift.org/blog/how-mirror-works/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-09-26&lt;br&gt;译者：&lt;a href=&quot;https://nemocdz.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nemocdz&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://linusling.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小铁匠Linus&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;尽管 Swift 重心在强调静态类型上，但它同时支持丰富的元数据类型。元数据类型允许代码在运行时检查和操作任意值。这个功能通过 &lt;code&gt;Mirror&lt;/code&gt; API 暴露给 Swift 开发者。大家可能会感到困惑，在 Swift 这种如此强调静态类型的语言里，&lt;code&gt;Mirror&lt;/code&gt; 这样的特性是怎么工作的？让我们一起来通过这篇文章了解一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
      <category term="Swift" scheme="https://swift.gg/categories/Mike-Ash/Swift/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>NSDataAsset</title>
    <link href="https://swift.gg/2018/11/12/nshipster-nsdataasset/"/>
    <id>https://swift.gg/2018/11/12/nshipster-nsdataasset/</id>
    <published>2018-11-12T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/nsdataasset/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-08-26<br>译者：<a href="https://github.com/mobilefellow" target="_blank" rel="noopener">雨谨</a>；校对：<a href="https://github.com/wongzigii" target="_blank" rel="noopener">wongzigii</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>在 Web 的世界里，速度不是一种奢求；它事关生死。</p><p>近年来的用户研究表明，页面加载中 _任何_ 可以察觉到的延迟 —— 即大于 400 毫秒（字面意义上的“一眨眼的功夫”） —— 都会对转化率和参与率产生负面影响。网页加载时每多花一秒，就会多 10% 的用户返回或者关闭这个页面。</p><p>对于谷歌、亚马逊和 Netflix 这样的大型的互联网公司而言，这里和那里额外的一秒钟可能意味着年收入里的 <em>数十亿</em> 美金。所以那些公司投入如此多的工程努力来让网页更快，也没有什么奇怪的了。</p><p>有很多加速网络请求的技术：压缩和流技术、缓存和预加载、连接池和多路复用、延迟和后台运行。然而，还有一种比它们优先级更高，效果更好的优化策略：<em>不要在刚开始的地方发送请求</em>。</p><p>在这个方面，App 凭借先下载后使用的特点，拥有传统网页所不具备的独特优势。在这一周的 NSHipster 里，我们将展示如何以一种非传统的方式使用 Asset Catalog 来改善你的 App 的首次启动体验。</p><a id="more"></a><p>Asset Catalog 允许你根据当前设备的特点来组织资源文件。对于一个给定的图片，你可以根据设备（iPhone、iPad、Apple Watch、Apple TV、Mac）、屏幕分辨率（<code>@2x</code> / <code>@3x</code>）或者色域（sRGB / P3），提供不同的文件。对于其他类型的 asset，你可能根据可用内存或者 Metal 版本的不同而提供不同的文件。请求 asset 时仅需提供名字，最合适的那个资源就会自动返回。</p><p>除了提供更简便的 API，Asset Catalog 还允许 App 使用 <a href="https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f" target="_blank" rel="noopener">App 瘦身</a> 为每个用户设备提供一个经过优化的更小的安装包。</p><p>图片是最常见的 Asset 类型，但是从 iOS 9 和 macOS El Capitan 开始，JSON、XML 和其他数据文件之类的资源也可以通过 <a href="https://developer.apple.com/documentation/uikit/nsdataasset" target="_blank" rel="noopener"><code>NSDataAsset</code></a> 加入到这种乐趣中。</p><h2 id="如何使用-Asset-Catalog-存储和获取数据"><a href="#如何使用-Asset-Catalog-存储和获取数据" class="headerlink" title="如何使用 Asset Catalog 存储和获取数据"></a>如何使用 Asset Catalog 存储和获取数据</h2><p>举个例子，让我们想象一个用于创建数字调色板的 iOS App。</p><p>为了区分不同深浅的灰色，我们可能会加载一个颜色和对应名字的列表。通常情况下，我们可能会在第一次启动时从服务器下载这个列表，但是如果恶劣的网络环境限制了 App 的功能，就会导致很差的用户体验。既然它是一个相对静态的数据集，为什么不以一种 Asset Catalog 形式将它添加到 app bundle 中？</p><h3 id="步骤-1：向-Asset-Catalog-中添加-New-Data-Set"><a href="#步骤-1：向-Asset-Catalog-中添加-New-Data-Set" class="headerlink" title="步骤 1：向 Asset Catalog 中添加 New Data Set"></a>步骤 1：向 Asset Catalog 中添加 New Data Set</h3><p>当你在 Xcode 中新建一个 app 项目时，它会自动生成一个 Asset Catalog。在项目导航（Project navigator）中选中 <code>Assets.xcassets</code>，打开 Asset Catalog 编辑器。点击左下方的 <kbd>+</kbd> 图标，然后选择 “New Data Set”。</p><p><img src="/img/articles/nshipster-nsdataasset/add-new-data-set-b6d8b1604dd12f49f1e034c0a36a42aa9fc6efc3f42d7320d9b489b6cec5fde0.png1542253210.0550492" alt=""></p><p>这样会在 <code>Assets.xcassets</code> 下新建一个后缀名为 <code>.dataset</code> 的子目录。</p><blockquote><p>默认情况下，Finder （访达）把这两种 bundle 都当做目录，以便在需要时查看和修改它们的内容。</p></blockquote><h3 id="步骤2：添加数据文件"><a href="#步骤2：添加数据文件" class="headerlink" title="步骤2：添加数据文件"></a>步骤2：添加数据文件</h3><p>打开 Finder，找到数据文件，把它拖拽到 Xcode 中 data set asset 的空白处。</p><p><img src="/img/articles/nshipster-nsdataasset/asset-catalog-any-any-universal-f634190ce57540a9fa1406ded75e13936c390fb0552b374d584510896db186bc.png1542253210.4507105" alt=""></p><p>当你这么做时，Xcode 会把那个文件复制到 <code>.dataset</code> 子目录，并将它的文件名和 <a href="https://en.wikipedia.org/wiki/Uniform_Type_Identifier" target="_blank" rel="noopener">通用类型标识符（Universal Type Identifier）</a> 更新到 <code>contents.json</code> 元数据文件。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"info"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"author"</span>: <span class="string">"xcode"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"idiom"</span>: <span class="string">"universal"</span>,</span><br><span class="line">      <span class="attr">"filename"</span>: <span class="string">"colors.json"</span>,</span><br><span class="line">      <span class="attr">"universal-type-identifier"</span>: <span class="string">"public.json"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤3：使用-NSDataAsset-访问数据"><a href="#步骤3：使用-NSDataAsset-访问数据" class="headerlink" title="步骤3：使用 NSDataAsset 访问数据"></a>步骤3：使用 NSDataAsset 访问数据</h3><p>现在你可以使用如下代码访问文件的数据：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> asset = <span class="type">NSDataAsset</span>(name: <span class="string">"NamedColors"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Missing data asset: NamedColors"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = asset.data</span><br></pre></td></tr></table></figure><p>对于我们颜色 App，我们可能在一个 view controller 的 <code>viewDidLoad()</code> 方法中调用上面的代码，然后解码返回的数据，获取 model 对象的数组，并展示在一个 table view 上。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">self</span>.colors = <span class="keyword">try</span>! decoder.decode([<span class="type">NamedColor</span>].<span class="keyword">self</span>, from: asset.data)</span><br></pre></td></tr></table></figure><h2 id="混合一下"><a href="#混合一下" class="headerlink" title="混合一下"></a>混合一下</h2><p>Data set 通常无法从 Asset Catalog 的 App 瘦身特性中获益（例如，大部分的 JSON 文件都不太关心设备所支持的 Metal 版本）。</p><p>但是对于我们的调色板 App，我们可能为支持广色域显示的设备提供不同的颜色列表。</p><p>为了做到这一点，在 Asset Catalog 编辑器的侧边栏选中刚才的 asset，然后点击 Attributes Inspector 下名为 Gamut 的下拉控件。</p><p><img src="/img/articles/nshipster-nsdataasset/select-color-gamut-02114afe2b744c228c2b29b7277abb9ec7e2bcb9afa683cc80115792849988c4.png1542253210.733386" alt=""></p><p>为每个色域提供定制的数据文件后，<code>contents.json</code> 元数据文件应该看起来像这样：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"info"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"author"</span>: <span class="string">"xcode"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"idiom"</span>: <span class="string">"universal"</span>,</span><br><span class="line">      <span class="attr">"filename"</span>: <span class="string">"colors-srgb.json"</span>,</span><br><span class="line">      <span class="attr">"universal-type-identifier"</span>: <span class="string">"public.json"</span>,</span><br><span class="line">      <span class="attr">"display-gamut"</span>: <span class="string">"sRGB"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"idiom"</span>: <span class="string">"universal"</span>,</span><br><span class="line">      <span class="attr">"filename"</span>: <span class="string">"colors-p3.json"</span>,</span><br><span class="line">      <span class="attr">"universal-type-identifier"</span>: <span class="string">"public.json"</span>,</span><br><span class="line">      <span class="attr">"display-gamut"</span>: <span class="string">"display-P3"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保鲜一下"><a href="#保鲜一下" class="headerlink" title="保鲜一下"></a>保鲜一下</h2><p>使用 Asset Catalog 存储和获取数据是非常简单的。真正困难 —— 并最终更重要 —— 的是保持数据的更新。</p><p>使用 <code>curl</code>、<code>rsync</code>、<code>sftp</code>、Dropbox、BitTorrent 或 Filecoin 刷新数据。从一个 shell 脚本开始（如果你喜欢，可以在 Xcode Build Phase 中调用它）。将它添加到你的 <code>Makefile</code>、<code>Rakefile</code>、<code>Fastfile</code>，或者你的编译系统所要求的任何地方。将这个任务分配给 Jenkins、Travis 或者某个烦人的实习生。使用定制的 Slack integration 或者 Siri Shortcuts 触发它，这样你就可以用随意的一句 <em>“Hey Siri，在数据变得太旧之前更新一下”</em>，让你的同事大吃一惊。</p><p><strong>注意，当你决定同步你的数据时，一定要确保它是自动化的，而且是你发布过程的一部分。</strong></p><p>下面是一个 shell 脚本示例，你可以运行它来使用 <code>curl</code> 下载最新的数据文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">CURL='/usr/bin/curl'</span><br><span class="line">URL='https://example.com/path/to/data.json'</span><br><span class="line">OUTPUT='./Assets.xcassets/Colors.dataset/data.json'</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">CURL -fsSL -o <span class="variable">$OUTPUT</span> <span class="variable">$URL</span></span></span><br></pre></td></tr></table></figure><h2 id="封装一下"><a href="#封装一下" class="headerlink" title="封装一下"></a>封装一下</h2><p>虽然 Assets Catalog 会对 image asset 执行的无损压缩，但没有任何文档、Xcode 帮助或 WWDC 会议指出 data asset 上也存在这种优化（至少目前没有）。</p><p>当 data asset 的文件大小大于，比如说几百 KB 时，你就要考虑使用压缩了。JSON、CSV 和 XML 之类的文本文件尤其如此，它们通常可以被压缩到原始大小的 60% - 80%。</p><p>我们可以将 <code>curl</code> 的输出发送给 <code>gzip</code>，然后再写到我们的文件，从而为我们之前的 shell 脚本添加压缩功能。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">CURL='/usr/bin/curl'</span><br><span class="line">GZIP='/usr/bin/gzip'</span><br><span class="line">URL='https://example.com/path/to/data.json'</span><br><span class="line">OUTPUT='./Assets.xcassets/Colors.dataset/data.json.gz'</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">CURL -fsSL <span class="variable">$URL</span> | <span class="variable">$GZIP</span> -c &gt; <span class="variable">$OUTPUT</span></span></span><br></pre></td></tr></table></figure><p>如果你使用了压缩，请确保 <code>&quot;universal-type-identifier&quot;</code> 字段体现了这一点：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"info"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"author"</span>: <span class="string">"xcode"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"idiom"</span>: <span class="string">"universal"</span>,</span><br><span class="line">      <span class="attr">"filename"</span>: <span class="string">"colors.json.gz"</span>,</span><br><span class="line">      <span class="attr">"universal-type-identifier"</span>: <span class="string">"org.gnu.gnu-zip-archive"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端上，你使用 asset catalog 之前需要先解压数据。如果有 <code>Gzip</code> 模块，你可能会做以下事情：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">Gzip</span>.decompress(data: asset.data)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，如果你会在 App 中反复地这么做，那么可以在 <code>NSDataAsset</code> 的扩展中创建一个便利方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSDataAsset</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">decompressedData</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">Gzip</span>.decompress(data: <span class="keyword">self</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>你还可以考虑使用 <a href="https://git-lfs.github.com" target="_blank" rel="noopener">Git Large File Storage (LFS)</a> 实现大型 data asset 文件的版本控制。</p></blockquote><p>尽管你倾向于认为你的所有用户都享受着快速的、无处不在的 WiFi 和 LTE 网络，但这并不适用于所有人，也不适用于所有时段。</p><p>花点时间看看你的 App 在启动时发出的网络请求，然后考虑哪些可能从预加载中受益。给人留下好的第一印象可能意味着你的 App 是被长期地积极地使用着，而不是几秒钟之后就被删除。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mattt，&lt;a href=&quot;https://nshipster.com/nsdataasset/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-08-26&lt;br&gt;译者：&lt;a href=&quot;https://github.com/mobilefellow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;雨谨&lt;/a&gt;；校对：&lt;a href=&quot;https://github.com/wongzigii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wongzigii&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在 Web 的世界里，速度不是一种奢求；它事关生死。&lt;/p&gt;
&lt;p&gt;近年来的用户研究表明，页面加载中 _任何_ 可以察觉到的延迟 —— 即大于 400 毫秒（字面意义上的“一眨眼的功夫”） —— 都会对转化率和参与率产生负面影响。网页加载时每多花一秒，就会多 10% 的用户返回或者关闭这个页面。&lt;/p&gt;
&lt;p&gt;对于谷歌、亚马逊和 Netflix 这样的大型的互联网公司而言，这里和那里额外的一秒钟可能意味着年收入里的 &lt;em&gt;数十亿&lt;/em&gt; 美金。所以那些公司投入如此多的工程努力来让网页更快，也没有什么奇怪的了。&lt;/p&gt;
&lt;p&gt;有很多加速网络请求的技术：压缩和流技术、缓存和预加载、连接池和多路复用、延迟和后台运行。然而，还有一种比它们优先级更高，效果更好的优化策略：&lt;em&gt;不要在刚开始的地方发送请求&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;在这个方面，App 凭借先下载后使用的特点，拥有传统网页所不具备的独特优势。在这一周的 NSHipster 里，我们将展示如何以一种非传统的方式使用 Asset Catalog 来改善你的 App 的首次启动体验。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>使用 YOLO 进行实时目标检测</title>
    <link href="https://swift.gg/2018/10/29/object-detection-with-yolo/"/>
    <id>https://swift.gg/2018/10/29/object-detection-with-yolo/</id>
    <published>2018-10-29T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Matthijs Hollemans，<a href="http://machinethink.net/blog/object-detection-with-yolo/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018/03/28<br>译者：<a href="https://github.com/YangGao1991" target="_blank" rel="noopener">阳仔</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://linusling.com" target="_blank" rel="noopener">小铁匠Linus</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote> <!--此处开始正文--><p>目标检测是计算机视觉中的经典问题之一：</p><p>识别一幅图像中有哪些目标，以及它们在图像中的位置。</p><p>检测是一个比分类更复杂的问题，因为分类也可以识别目标，但不能准确判断目标在图像中的位置——并且分类不能适用于包含多个目标的图像。</p><p><img src="http://machinethink.net/images/yolo/ClassificationVsDetection.png" alt=""></p><p><a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">YOLO</a> 是一个实时有效的目标检测神经网络。</p><p>在这篇文章中，我将阐述如何使用 Metal Performance Shaders 来将“简化版” YOLOv2 运行在 iOS 设备上。</p><a id="more"></a><p>在继续阅读之前，请先 <a href="https://www.youtube.com/watch?v=VOC3huqHrss" target="_blank" rel="noopener">观看这个令人惊叹的 YOLOv2 介绍视频</a>。</p><h2 id="YOLO-的工作原理"><a href="#YOLO-的工作原理" class="headerlink" title="YOLO 的工作原理"></a>YOLO 的工作原理</h2><p>你可以使用 <a href="http://machinethink.net/blog/convolutional-neural-networks-on-the-iphone-with-vggnet/" target="_blank" rel="noopener">VGGNet</a> 或 <a href="https://github.com/hollance/Forge/tree/master/Examples/Inception" target="_blank" rel="noopener">Inception</a> 这样的分类器，通过一个小的滑动窗口对图像进行遍历，从而形成一个目标检测器。每一步遍历运行一次分类器，来对当前窗口中的目标进行分类。使用这样的滑动窗口，会对一幅图像输出成百上千的检测结果，但你只需要保留分类器最确定的那些结果。</p><p>这种方法是可行的，但很显然会很慢，因为需要运行很多遍分类器。一种效率稍微高一点的方法是，首先判断图像的哪一部分包含了有效的信息——也就是候选区域 (region proposals)——然后仅仅在这些区域中运行分类器。这种方法比滑动窗口的方法能减少分类器的运行次数，但仍然很多。</p><p>YOLO 采用了一种完全不同的方法。它并不是将传统的分类器改造成检测器。YOLO 实际上只对图像进行一次操作（也就是它名字的由来：You Only Look Once），但是是以一种聪明的方式。</p><p>YOLO 将图像分成 13×13 的网格单元：</p><p><img src="http://machinethink.net/images/yolo/Grid.png" alt=""></p><p>每一个网格单元负责预测 5 个检测框。一个检测框是包含一个目标的矩形区域。</p><p>YOLO 同时会给出一个置信度，描述了某个检测框确实包含了某目标的确定程度。这个值和检测框中是什么目标毫无关系，只和检测框的形状大小匹配程度有关。</p><p>预测出的检测框看起来和下图类似（置信度越高，框越粗）：</p><p><img src="http://machinethink.net/images/yolo/Boxes.png" alt=""></p><p>对每个检测框，对应的网格单元还给出了一个分类的预测。这和分类器的工作相似：它给出一个全部可能的类别的概率分布。我们使用的这个版本的 YOLO 是用 <a href="http://host.robots.ox.ac.uk/pascal/VOC/" target="_blank" rel="noopener">PASCAL VOC dataset</a> 训练的，可以检测 20 种不同的类别，比如：</p><ul><li>自行车</li><li>船</li><li>汽车</li><li>猫</li><li>狗</li><li>人</li><li>等等</li></ul><p>检测框的置信度和分类预测最终被整合成一个最终得分，来告诉我们该检测框内包含一个特定类型的目标的概率。例如，左边这个又大又粗的黄色框告诉我们，85% 的概率这里面包含一只狗：</p><p><img src="http://machinethink.net/images/yolo/Scores.png" alt=""></p><p>因为整幅图像包含 13×13 = 169 个网格单元，且每个网格单元预测 5 个检测框，我们最后总计能得到 845 个检测框。实际上，这其中大多数的检测框的置信度都很低，所以，我们只需要保留最终得分大于等于 30% 的检测框就行了（你也可以根据需要的检测准确度改变这个阈值）。</p><p>最终的检测结果：</p><p><img src="http://machinethink.net/images/yolo/Prediction.png" alt=""></p><p>从 845 个检测框中，我们只保留了这三个，因为它们给出的结果最好。尽管我们有 845 个检测框，但它们都是同时得到的——神经网络只需要运行一次。这也是 YOLO 强大而快速的原因。</p><p>（以上图片来自 <a href="https://pjreddie.com/" target="_blank" rel="noopener">pjreddie.com</a>）</p><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>YOLO 的结构只是一个简单的卷积神经网络：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Layer         kernel  stride  output shape</span><br><span class="line">---------------------------------------------</span><br><span class="line">Input                          (416, 416, 3)</span><br><span class="line">Convolution    3×3      1      (416, 416, 16)</span><br><span class="line">MaxPooling     2×2      2      (208, 208, 16)</span><br><span class="line">Convolution    3×3      1      (208, 208, 32)</span><br><span class="line">MaxPooling     2×2      2      (104, 104, 32)</span><br><span class="line">Convolution    3×3      1      (104, 104, 64)</span><br><span class="line">MaxPooling     2×2      2      (52, 52, 64)</span><br><span class="line">Convolution    3×3      1      (52, 52, 128)</span><br><span class="line">MaxPooling     2×2      2      (26, 26, 128)</span><br><span class="line">Convolution    3×3      1      (26, 26, 256)</span><br><span class="line">MaxPooling     2×2      2      (13, 13, 256)</span><br><span class="line">Convolution    3×3      1      (13, 13, 512)</span><br><span class="line">MaxPooling     2×2      1      (13, 13, 512)</span><br><span class="line">Convolution    3×3      1      (13, 13, 1024)</span><br><span class="line">Convolution    3×3      1      (13, 13, 1024)</span><br><span class="line">Convolution    1×1      1      (13, 13, 125)</span><br><span class="line">---------------------------------------------</span><br></pre></td></tr></table></figure><p>该神经网络具有典型的结构：一个 3×3 卷积核的卷积层，采样窗口 2×2 的池化层。没有花哨的东西。YOLO 中没有全连接层。</p><blockquote><p>注意：我们使用的“简化版” YOLO 只有 9 个卷积层和 6 个池化层。完全版 YOLOv2 模型分层数是这个的三倍，并且会更复杂一些，但仍然是一个常规的卷积神经网络。</p></blockquote><p>最后一个卷积层的卷积核为 1×1，是为了将参数降维至 13×13×125。其中的 13×13 看起来很熟悉：这就是图像被划分成的网格单元的数量。</p><p>因此，每个网格单元有 125 个通道。这 125 个通道包含了检测框的数据，以及分类预测的数据。为什么是 125 呢？因为每个网格单元预测 5 个检测框的结果，每个检测框由 25 个数据元素来描述：</p><ul><li>检测框矩形的 x，y，宽，高</li><li>置信度</li><li>在 20 个分类上的概率分布</li></ul><p>YOLO 的使用很简单：输入一幅图像（大小为 416×416 像素），它运行一次卷积网络，输出一个 13×13×125 的张量，描述网格单元以及检测框。你需要做的只是计算每个检测框的最终得分，并抛弃低于 30% 的那些。</p><blockquote><p>小提示：要了解更多有关 YOLO 的工作原理，以及 YOLO 是如何训练的，请 <a href="https://www.youtube.com/watch?v=NM6lrxy0bxs" target="_blank" rel="noopener">观看对它的发明者之一的访谈</a>。这个视频介绍的是 YOLOv1，由于是老版本，结构稍有不同，但主体思想是相同的。很值得观看！</p></blockquote><h2 id="转换成-Metal"><a href="#转换成-Metal" class="headerlink" title="转换成 Metal"></a>转换成 Metal</h2><p>上文描述的是简化版的 YOLO，也是我们将在 iOS 应用中使用的版本。完全版 YOLOv2 的神经网络有三倍的分层数，因为太大，所以在当前的 iPhone 设备上不能快速运行。简化版的 YOLO 使用更少的分层数，因此运行会更快，但准确度也稍差。</p><p><img src="http://machinethink.net/images/yolo/CatOrDog.png" alt=""></p><p>YOLO 使用 Darknet 编写，这是 YOLO 作者自己编写的深度学习框架。能下载到的都是 Darknet 格式。尽管 <a href="https://github.com/pjreddie/darknet" target="_blank" rel="noopener">Darknet 是开源的</a>，我也不想花很多时间去弄清它的工作原理。</p><p>幸运的是，<a href="https://github.com/allanzelener/YAD2K/" target="_blank" rel="noopener">有人</a> 已经做了这件事，将 Darknet 模型转换成了我所使用的深度学习工具 Keras。我所要做的，就是运行这个“YAD2K”脚本，将 Darknet 转换成 Keras 格式，然后用我自己写的脚本将 Keras 转换成 Metal。</p><p>但是，有一点小麻烦。YOLO 在它的卷积层后，使用了一种叫做”批标准化“的规整化方法。</p><p>“批标准化”的思想是，当数据是干净的时候，神经网络能够达到最好的工作效果。理想情况下，一个层级的输入数据的平均值为 0，且方差较小。每个做过机器学习的人都应比较熟悉这一思想，因为我们经常使用一种称为“特征缩放”或“白化”的技术来处理我们的输入数据，以达到这一目的。</p><p>批标准化对层间数据做了类似特征缩放的处理。这种处理能防止数据在神经网络中传递时退化，从而有效提升神经网络的性能。</p><p>为了让你直观感受到批标准化的作用，以下是第一个卷积层分别在应用和未应用批标准化的情况下的输出直方图：</p><p><img src="http://machinethink.net/images/yolo/BatchNorm.png" alt=""></p><p>批标准化在训练一个深度网络时很重要，但事实上，我们在进行推断的时候可以不需要这一处理。不需要进行批标准化的计算，有助于使我们的应用运行更快。在任何时候，Metal 都没有一个 <code>MPSCNNBatchNormalization</code> 层。</p><p>批标准化通常发生在卷积层之后，激活函数（YOLO 中的 ReLU 函数）之前。卷积操作和批标准化操作都是对数据进行线性变换，所以我们可以将批标准化层的参数和卷积权重相结合。这称为将批标准化层“折叠”到卷积层。</p><p>长话短说，使用一些数学方法，我们可以省略批标准化层，但需要改变前序卷积层的权重。</p><p>快速阐述一下卷积层的计算过程：设 <code>x</code> 是输入图像中的像素，<code>w</code> 是卷积层权重，那么，经过卷积层计算，输出的每个像素的值为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">out[j] = x[i]*w[0] + x[i+1]*w[1] + x[i+2]*w[2] + ... + x[i+k]*w[k] + b</span><br></pre></td></tr></table></figure><p>即输入像素矩阵和卷积核权重的点积，再加上偏差项 <code>b</code>。</p><p>以下是对卷积层输出进行批标准化处理的计算过程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        gamma * (out[j] - mean)</span><br><span class="line">bn[j] = ---------------------- + beta</span><br><span class="line">            sqrt(variance)</span><br></pre></td></tr></table></figure><p>批标准化首先对每个像素的输出值减去平均值 <code>mean</code>，再除以标准差，乘以一个缩放系数 <code>gamma</code>，再加上一个偏移值 <code>beta</code>。这四个参数 —— <code>mean</code>，<code>variance</code>，<code>gamma</code>，<code>beta</code> —— 是在网络训练过程中，批标准化层学习得到的。</p><p>为了省略批标准化，我们可以将这两个公式进行稍微的整合，来为卷积层计算新的权重和偏差项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">           gamma * w</span><br><span class="line">w_new = --------------</span><br><span class="line">        sqrt(variance)</span><br><span class="line"></span><br><span class="line">        gamma*(b - mean)</span><br><span class="line">b_new = ---------------- + beta</span><br><span class="line">         sqrt(variance)</span><br></pre></td></tr></table></figure><p>利用这些新的权重和偏差项对输入 <code>x</code> 进行卷积操作，能够得到与原来卷积层加上批标准化处理后同样的结果。</p><p>现在，我们可以去掉批标准化层，只使用卷积层，但参数是经过调节的权重和偏差项 <code>w_new</code> 和 <code>b_new</code>。我们对网络中所有的卷积层都重复这一过程。</p><blockquote><p>注意：事实上，YOLO 中的卷积层没有使用偏差项，因此上述公式中 b 为 0。但请注意，经过整合批标准化的参数后，卷积层就有了偏差项。</p></blockquote><p>一旦我们将所有的批标准化层整合到了它们的前序卷积层，我们就可以将权重转换到 Metal 了。简单地将该数组（Keras 中存储的顺序和 Metal 不同）进行转置，再将其写进 32 位浮点数的二进制文件。</p><p>如果你对这些操作感到好奇，你可以查看转换脚本 <a href="https://github.com/hollance/Forge/blob/master/Examples/YOLO/yolo2metal.py" target="_blank" rel="noopener">yolo2metal.py</a> 来获得详细信息。为了验证整合批标准化的效果，脚本创建了一个不包含批标准化层，但使用了调节后的权重的模型，并将其与原始模型的预测结果进行比对。</p><h2 id="iOS-应用"><a href="#iOS-应用" class="headerlink" title="iOS 应用"></a>iOS 应用</h2><p>我理所当然地使用 <a href="https://github.com/hollance/Forge" target="_blank" rel="noopener">Forge</a> 来编写我的 iOS 应用。😂你可以在 <a href="https://github.com/hollance/Forge/tree/master/Examples/YOLO" target="_blank" rel="noopener">YOLO</a> 文件夹中找到源代码。如果想尝试一下的话，可以下载或者 clone Forge，在 Xcode 8.3 以上版本中打开 <strong>Forge.xcworkspace</strong>，在 iPhone 6 以上设备上运行 <strong>YOLO</strong>。</p><p>最简单的测试方法是将你的 iPhone 对准某个 <a href="https://www.youtube.com/watch?v=e_WBuBqS9h8" target="_blank" rel="noopener">YouTube 视频</a>：</p><p><img src="http://machinethink.net/images/yolo/App.png" alt=""></p><p><strong>YOLO.swift</strong> 中有一些有趣的代码。首先，这里创建了卷积网络：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let leaky = MPSCNNNeuronReLU(device: device, a: 0.1)</span><br><span class="line"></span><br><span class="line">let input = Input()</span><br><span class="line"></span><br><span class="line">let output = input</span><br><span class="line">         --&gt; Resize(width: 416, height: 416)</span><br><span class="line">         --&gt; Convolution(kernel: (3, 3), channels: 16, padding: true, activation: leaky, name: &quot;conv1&quot;)</span><br><span class="line">         --&gt; MaxPooling(kernel: (2, 2), stride: (2, 2))</span><br><span class="line">         --&gt; Convolution(kernel: (3, 3), channels: 32, padding: true, activation: leaky, name: &quot;conv2&quot;)</span><br><span class="line">         --&gt; MaxPooling(kernel: (2, 2), stride: (2, 2))</span><br><span class="line">         --&gt; ...and so on...</span><br></pre></td></tr></table></figure><p>摄像头的输入图像被调整为 416×416 像素大小，接着被输入到卷积层和池化层。这和其他卷积神经网络的操作是非常类似的。</p><p>真正有意思的是对输出的操作。回想一下，我们的输出是一个 13×13×125 的张量：图像中每个网格单元有 125 个通道。这 125 个数字包含了检测框的数据，以及分类预测的数据。我们需要将这些数据通过某些方法进行整理。这些是通过 <code>fetchResult()</code> 实现的。</p><blockquote><p>注意：fetchResult() 函数在 CPU 中运行，而非 GPU。这种实现方式比较简单。有人说 GPU 的并行性会对嵌套循环的运行比较有利。也许我在将来会重新写一个 GPU 的版本。</p></blockquote><p>以下是 <code>fetchResult()</code> 的工作原理：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func fetchResult(inflightIndex: Int) -&gt; NeuralNetworkResult&lt;Prediction&gt; &#123;</span><br><span class="line">  let featuresImage = model.outputImage(inflightIndex: inflightIndex)</span><br><span class="line">  let features = featuresImage.toFloatArray()</span><br></pre></td></tr></table></figure><p>卷积网络的输出是一个 <code>MPSImage</code> 格式的数据。我们首先将其转换成一个 <code>Float</code> 的数组，即 <code>features</code>，以便处理。</p><p><code>fetchResult()</code> 的主体部分是一个大的嵌套循环。它对所有的网格单元以及每个网格单元的 5 个预测结果进行遍历：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for cy in 0..&lt;13 &#123;</span><br><span class="line">  for cx in 0..&lt;13 &#123;</span><br><span class="line">    for b in 0..&lt;5 &#123;</span><br><span class="line">       . . .</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每个循环中我们对网格单元 <code>(cy, cx)</code> 计算出其检测框 <code>b</code>。</p><p>首先，我们从 <code>features</code> 数组中读取出检测框的 x，y，宽，高，以及置信度：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let channel = b*(numClasses + 5)</span><br><span class="line">let tx = features[offset(channel, cx, cy)]</span><br><span class="line">let ty = features[offset(channel + 1, cx, cy)]</span><br><span class="line">let tw = features[offset(channel + 2, cx, cy)]</span><br><span class="line">let th = features[offset(channel + 3, cx, cy)]</span><br><span class="line">let tc = features[offset(channel + 4, cx, cy)]</span><br></pre></td></tr></table></figure><p><code>offset()</code> 函数的作用是帮助在数组中寻找读取数据的合适位置。Metal 将其数据以每 4 个通道为一组进行存储，这意味着这 125 个通道的数据并不是连续存储的，而是分散的。（请查阅代码以获得更详尽的解释）</p><p>我们仍然需要对这 5 个数据 <code>tx</code>，<code>ty</code>，<code>tw</code>，<code>th</code>，<code>tc</code> 进行处理，因为它们的格式有一点奇怪。如果你好奇这些公式是从哪里来的，它们是在 <a href="https://arxiv.org/abs/1612.08242" target="_blank" rel="noopener">这篇文章</a> 中提出的（这是网络训练的副产物）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let x = (Float(cx) + Math.sigmoid(tx)) * 32</span><br><span class="line">let y = (Float(cy) + Math.sigmoid(ty)) * 32</span><br><span class="line"></span><br><span class="line">let w = exp(tw) * anchors[2*b    ] * 32</span><br><span class="line">let h = exp(th) * anchors[2*b + 1] * 32</span><br><span class="line"></span><br><span class="line">let confidence = Math.sigmoid(tc)</span><br></pre></td></tr></table></figure><p>现在，<code>x</code> 和 <code>y</code> 代表在 416×416 大小的输入图像中，检测框的中心点的坐标。<code>w</code> 和 <code>h</code> 是检测框的宽和高。<code>tc</code> 是检测框的置信度，我们用 logistic sigmoid 函数将其转换成百分制的形式。</p><p>我们现在有了检测框，并且我们知道 YOLO 有多确信其中包含了某个目标。下一步，让我们看一下分类预测的结果，看看 YOLO 认为检测框中的目标是什么物体：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var classes = [Float](repeating: 0, count: numClasses)</span><br><span class="line">for c in 0..&lt;numClasses &#123;</span><br><span class="line">  classes[c] = features[offset(channel + 5 + c, cx, cy)]</span><br><span class="line">&#125;</span><br><span class="line">classes = Math.softmax(classes)</span><br><span class="line"></span><br><span class="line">let (detectedClass, bestClassScore) = classes.argmax()</span><br></pre></td></tr></table></figure><p>回想一下，<code>features</code> 数组中的 20 个通道的数据包含了该检测框的分类检测结果。我们将这些读取到一个新的 <code>classes</code> 数组中。像分类器的一般做法一样，我们采用 softmax 函数来将数组转换成一个概率分布。然后，我们挑选分数最高的分类作为结果。</p><p>现在，我们可以对检测框计算最终得分了 —— 例如，“我有 85% 的确信度相信这个检测框包含了一只狗”。一共会有 845 个检测框，而我们只想保留最终得分超过某一阈值的那些。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let confidenceInClass = bestClassScore * confidence</span><br><span class="line">if confidenceInClass &gt; 0.3 &#123;</span><br><span class="line">  let rect = CGRect(x: CGFloat(x - w/2), y: CGFloat(y - h/2),</span><br><span class="line">                    width: CGFloat(w), height: CGFloat(h))</span><br><span class="line"></span><br><span class="line">  let prediction = Prediction(classIndex: detectedClass,</span><br><span class="line">                              score: confidenceInClass,</span><br><span class="line">                              rect: rect)</span><br><span class="line">  predictions.append(prediction)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对所有网格单元重复上述代码。当循环结束后，我们就有了一个 <code>predictions</code> 数组，一般来说，其中会包含 10 到 20 个预测结果。</p><p>我们已经过滤掉了那些最终得分非常低的检测框，但剩下的检测框中，仍然可能会存在相互重叠特别严重的情况。因此，我们在 <code>fetchResult()</code> 中做的最后一件事就是用一种称为<em>非极大值抑制</em>的方法来减少这种重复的检测框。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  var result = NeuralNetworkResult&lt;Prediction&gt;()</span><br><span class="line">  result.predictions = nonMaxSuppression(boxes: predictions,</span><br><span class="line">                                         limit: 10, threshold: 0.5)</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nonMaxSuppression()</code> 函数所使用的算法很简单：</p><ol><li>从最终得分最高的那个检测框开始。</li><li>将其他与该检测框重叠率超过一定阈值（比如超过 50%）的检测框移除。</li><li>返回第一步，重复直到遍历完所有的检测框。</li></ol><p>该算法移除了与更高得分的检测框有太多重叠的其他检测框，只保留了最好的那些。</p><p>以上就是所有的过程了：一个常规的卷积网络，以及后续对结果的一些处理。</p><h2 id="运行效果如何？"><a href="#运行效果如何？" class="headerlink" title="运行效果如何？"></a>运行效果如何？</h2><p><a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">YOLO 官方网站</a> 宣称精简版 YOLO 最快每秒可处理 200 帧图像。但那是在性能优秀的笔记本上的运行结果，而不是在移动设备上。那么，它在 iPhone 上能够运行多快呢？</p><p>在我的 iPhone 6s 上，它处理一幅图像大约需要 0.15 秒。那也只有 6 FPS，几乎不能称之为实时。如果你将手机对准一辆开过的汽车，你会看到一个检测框拖在汽车后面一些。尽管如此，它能够生效已经使我印象深刻了。😁</p><blockquote><p>注意：正如上文解释，检测框的处理是在 CPU 上进行，而不是 GPU。如果 YOLO 完全运行在 GPU 上，会变得更快吗？也许会，但 CPU 代码运行时间只有 0.03 秒，占 20% 的运行时间。将其中一部分工作交给 GPU 做当然是可行的，但考虑到卷积层的计算仍然占据了 80% 的时间，我不确定是否值得这样做。</p></blockquote><p>我认为导致变慢的主要原因在于输出通道为 512 和 1024 卷积层。经过实验，<code>MPSCNNConvolution</code> 在通道较多的小图片上的表现比在通道较少的大图片上会更差。</p><p>另一件我比较感兴趣的事情是采用另一种不同的网络结构，例如 SqueezeNet，对其重新进行训练，以在最后一层进行检测框的预测。换句话说，采用 YOLO 的思想，并将其应用在一个更小更快的网络上。这样以精确度的损失换来速度上的提升是否值得呢？</p><blockquote><p>注意：顺便说一句，最近的 <a href="http://caffe2.ai/" target="_blank" rel="noopener">Caffe2</a> 框架也是通过 Metal 的支持，运行在 iOS 设备上。<a href="https://github.com/KleinYuan/Caffe2-iOS" target="_blank" rel="noopener">Caffe2-iOS project</a> 是一个针对 YOLO 的精简版本。看起来它运行得会比纯 Metal 版稍慢，大约 0.17 秒/帧。</p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>想要了解更多 YOLO 相关的知识，可以查看 YOLO 作者的以下论文：</p><ul><li><a href="https://arxiv.org/abs/1506.02640" target="_blank" rel="noopener">You Only Look Once: Unified, Real-Time Object Detection</a> by Joseph Redmon, Santosh Divvala, Ross Girshick, Ali Farhadi (2015)</li><li><a href="https://arxiv.org/abs/1612.08242" target="_blank" rel="noopener">YOLO9000: Better, Faster, Stronger</a> by Joseph Redmon and Ali Farhadi (2016)</li></ul><p>我的实现一部分基于 TensorFlow Android demo <a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/android" target="_blank" rel="noopener">TF Detect</a>，Allan Zelener 的 <a href="https://github.com/allanzelener/YAD2K/" target="_blank" rel="noopener">YAD2K</a>，以及 <a href="https://github.com/pjreddie/darknet" target="_blank" rel="noopener">Darknet 源代码</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文详细介绍了使用 YOLO 进行实时目标检测的原理，以及在 iOS 上的应用。
    
    </summary>
    
      <category term="machinethink" scheme="https://swift.gg/categories/machinethink/"/>
    
    
      <category term="机器学习" scheme="https://swift.gg/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>macOS Dynamic Desktop</title>
    <link href="https://swift.gg/2018/10/25/macos-dynamic-desktop/"/>
    <id>https://swift.gg/2018/10/25/macos-dynamic-desktop/</id>
    <published>2018-10-25T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/macos-dynamic-desktop/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-10-01<br>译者：<a href="http://www.saitjr.com" target="_blank" rel="noopener">saitjr</a>；校对：<a href="http://www.desgard.com/" target="_blank" rel="noopener">冬瓜</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>Dark Mode（深色模式）可谓是 macOS 最受欢迎的特性之一了 —— 尤其是对于你我这样的开发者来说。我们不仅喜欢文本编辑器是暗色的主题，还很看中整个系统色调的一致性。</p><p>过去几年，和这个特性旗鼓相当的要数 Night Shift（夜览），它主要是在日夜更替的时候减少对眼睛的劳损。</p><p>纵观这两个功能，Dynamic Desktop（动态桌面）也就呼之欲出了，当然这也是 Mojave 的新特性之一。进入“系统偏好设置 &gt; 桌面与屏幕保护程序” 并且选择“动态”，就能得到一个基于地理位置且全天候动态变化的壁纸。</p><a id="more"></a><p><img src="/img/articles/macos-dynamic-desktop/desktop-and-screen-saver-preference-pane-b457c3a4bc26017c8d555506333d5b73244adaf8b7060f0cadd450f39b279c88.png1540446627.765852" alt=""></p><p>效果不仅微妙，而且让人愉悦。桌面仿佛被赋予了生命，能随着时间的推移而变化；符合自然规律。（不出意外的话，结合 dark mode 的切换，还会有讨喜的特效）</p><p><em>这到底是如何实现的呢？</em><br><br>这便是本周 NSHipster 讨论的问题。</p><p>答案会深入探究图片格式，同时涉及一些逆向工程以及球面三角学相关的内容。</p><p><br></p><hr><p><br></p><p>理解 Dynamic Desktop 第一步，就是要找到这些动态图片。</p><p>在 macOS Mojave 系统下，打开访达，选择“前往 &gt; 前往文件夹…” （⇧⌘G），输入“/Library/Desktop Pictures/”。</p><p><img src="/img/articles/macos-dynamic-desktop/go-to-library-desktop-pictures-3992f8efa1d14dd3bf092ec7eb298c6c1855dcc8e0cf57c0e494a840a8cb4713.png1540446628.0454302" alt=""></p><p>在这个目录下，可以找到名为“Mojave.heic”的文件。双击通过预览打开。</p><p><img src="/img/articles/macos-dynamic-desktop/mojave-heic-abd6b67d8941ad50a9bcd7dd6657994174d4be713bb3c2cfbc9e24ffff7ad129.png1540446628.1945882" alt=""></p><p>在预览中，左边栏会显示从 1~16 的缩略图，每张都是不同状态的沙漠图。</p><p><img src="/img/articles/macos-dynamic-desktop/mojave-dynamic-desktop-images-c8bc3aab78c049d74abd46240445f82c3d0cf0ad043bcc9da6f3fda066776034.png1540446628.454165" alt=""></p><p>如果选择“工具 &gt; 显示检查器”（⌘I），可以看到更为详细的信息，如下图所示：</p><p><img src="/img/articles/macos-dynamic-desktop/mojave-heic-preview-info-b71c5e4084bd43f1e6b34852c4c757493627eb8b66ee44b282e2f53d274dda02.png1540446628.7528405" alt=""></p><p>不幸的是，这些就是预览所展示的全部信息了（截至发稿前）。即使点击旁边的“更多信息检查器”，我们也只是能得到下面这个表格，其余的无从得知：</p><table><thead><tr><th>Color Model</th><th>RGB</th></tr></thead><tbody><tr><td>Depth:</td><td>8</td></tr><tr><td>Pixel Height</td><td>2,880</td></tr><tr><td>Pixel Width</td><td>5,120</td></tr><tr><td>Profile Name</td><td>Display P3</td></tr></tbody></table><blockquote><p>后缀 <code>.heic</code> 表示图片容器采用 HFIF（High-Efficiency Image File Format）编码，即高效率图档格式（这种格式基于 <strong>HEVC</strong>（High-Efficiency Video Compression），即高效率视频压缩，也就是 H.265）。更多信息，可以参考 <a href="https://developer.apple.com/videos/play/wwdc2017/503/" target="_blank" rel="noopener">WWDC 2017 Session 503 “Introducing HEIF and HEVC”</a></p></blockquote><p>想要获得更多的数据，我们还需要脚踏实地，真真切切的深入底层 API。</p><h2 id="利用-CoreGraphics-一探究竟"><a href="#利用-CoreGraphics-一探究竟" class="headerlink" title="利用 CoreGraphics 一探究竟"></a>利用 CoreGraphics 一探究竟</h2><p>第一步先创建 Xcode Playground。简单起见，我们将“Mojave.heic”文件路径硬编码到代码中。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CoreGraphics</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统版本要求 macOS 10.14 Mojave</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(fileURLWithPath: <span class="string">"/Library/Desktop Pictures/Mojave.heic"</span>)</span><br></pre></td></tr></table></figure><p>然后，创建 <code>CGImageSource</code>，拷贝元数据并遍历全部标签：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> source = <span class="type">CGImageSourceCreateWithURL</span>(url <span class="keyword">as</span> <span class="type">CFURL</span>, <span class="literal">nil</span>)!</span><br><span class="line"><span class="keyword">let</span> metadata = <span class="type">CGImageSourceCopyMetadataAtIndex</span>(source, <span class="number">0</span>, <span class="literal">nil</span>)!</span><br><span class="line"><span class="keyword">let</span> tags = <span class="type">CGImageMetadataCopyTags</span>(metadata) <span class="keyword">as</span>! [<span class="type">CGImageMetadataTag</span>]</span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> tags &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name = <span class="type">CGImageMetadataTagCopyName</span>(tag),</span><br><span class="line">        <span class="keyword">let</span> value = <span class="type">CGImageMetadataTagCopyValue</span>(tag)</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(name, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码，会得到两个值：一个是 <code>hasXMP</code>，值为 <code>&quot;True&quot;</code>，另一个是 <code>solar</code>，它的值是一串看不大懂的数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YnBsaXN0MDDRAQJSc2mvEBADDBAUGBwgJCgsMDQ4PEFF1AQFBgcICQoLUWlRelFh</span><br><span class="line">UW8QACNAcO7vOubr3yO/1e+pmkOtXBAB1AQFBgcNDg8LEAEjQFRxqCKOFiAjwCR6</span><br><span class="line">waUkDgHUBAUGBxESEwsQAiNAVZV4BI4c+CPAEP2uFrMcrdQEBQYHFRYXCxADI0BW</span><br><span class="line">tALKmrjwIz/2ObLnx6l21AQFBgcZGhsLEAQjQFfTrJlEjnwjQByrLle1Q0rUBAUG</span><br><span class="line">Bx0eHwsQBSNAWPrrmI0ISCNAKiwhpSRpc9QEBQYHISIjCxAGI0BgJff9KDpyI0BE</span><br><span class="line">NTOsilht1AQFBgclJicLEAcjQGbHdYIVQKojQEq3fAg86lXUBAUGBykqKwsQCCNA</span><br><span class="line">bTGmpC2YRiNAQ2WFOZGjntQEBQYHLS4vCxAJI0BwXfII2B+SI0AmLcjfuC7g1AQF</span><br><span class="line">BgcxMjMLEAojQHCnF6YrsxcjQBS9AVBLTq3UBAUGBzU2NwsQCyNAcTcSnimmjCPA</span><br><span class="line">GP5E0ASXJtQEBQYHOTo7CxAMI0BxgSADjxK2I8AoalieOTyE1AQFBgc9Pj9AEA0j</span><br><span class="line">QHNWsnnMcWIjwEO+oq1pXr8QANQEBQYHQkNEQBAOI0ABZpkFpAcAI8BKYGg/VvMf</span><br><span class="line">1AQFBgdGR0hAEA8jQErBKblRzPgjwEMGElBIUO0ACAALAA4AIQAqACwALgAwADIA</span><br><span class="line">NAA9AEYASABRAFMAXABlAG4AcAB5AIIAiwCNAJYAnwCoAKoAswC8AMUAxwDQANkA</span><br><span class="line">4gDkAO0A9gD/AQEBCgETARwBHgEnATABOQE7AUQBTQFWAVgBYQFqAXMBdQF+AYcB</span><br><span class="line">kAGSAZsBpAGtAa8BuAHBAcMBzAHOAdcB4AHpAesB9AAAAAAAAAIBAAAAAAAAAEkA</span><br><span class="line">AAAAAAAAAAAAAAAAAAH9</span><br></pre></td></tr></table></figure><h3 id="太阳之光"><a href="#太阳之光" class="headerlink" title="太阳之光"></a>太阳之光</h3><p>大多数人看到这串文字，就会默默合上 MacBook Pro，大呼告辞。但一定有人发现，这串文字非常像 <a href="https://en.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">Base64 编码</a> 的杰作。</p><p>让我们来验证一下这个假设：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">"solar"</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="type">Data</span>(base64Encoded: value)!</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">String</span>(data: data, encoding: .ascii))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><samp>              bplist00Ò\u{01}\u{02}\u{03}…</samp><br><br><br>这又是什么？<code>bplist</code> 后面接了一串乱码？</p><p>天哪，原来这是 <a href="https://en.wikipedia.org/wiki/Property_list" target="_blank" rel="noopener">二进制属性列表</a> 的 <a href="https://en.wikipedia.org/wiki/File_format#Magic_number" target="_blank" rel="noopener">文件签名</a>。</p><p>利用 <code>PropertyListSerialization</code> 来看看呢…</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">"solar"</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="type">Data</span>(base64Encoded: value)!</span><br><span class="line">    <span class="keyword">let</span> propertyList = <span class="keyword">try</span> <span class="type">PropertyListSerialization</span></span><br><span class="line">                            .propertyList(from: data,</span><br><span class="line">                                          options: [],</span><br><span class="line">                                          format: <span class="literal">nil</span>)</span><br><span class="line">    <span class="built_in">print</span>(propertyList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(</span><br><span class="line">    ap = &#123;</span><br><span class="line">        d = <span class="number">15</span>;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    si = (</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="string">"-0.3427528387535028"</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            z = <span class="string">"270.9334057827345"</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="string">"-38.04743388682423"</span>;</span><br><span class="line">            i = <span class="number">15</span>;</span><br><span class="line">            z = <span class="string">"53.50908581251309"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><em>清晰多了！</em></p><p>首先有两个一级键：</p><p><code>ap</code> 键对应的值是包含 <code>d</code> 和 <code>l</code> 两个键的字典，它们的值都是整型。</p><p><code>si</code> 键对应的值是包含多个字典的数组，字典中有整型，也有浮点型的值。在嵌套的字典中，<code>i</code> 最容易理解：它从 0 一直递增到 15，这表示的是图片序列的下标。在没有更多信息的情况下，很难猜测 <code>a</code> 与 <code>z</code> 的含义，其实它们表示相应图片中太阳的高度（<code>a</code>）和方位角（<code>z</code>）。</p><h3 id="计算太阳的位置"><a href="#计算太阳的位置" class="headerlink" title="计算太阳的位置"></a>计算太阳的位置</h3><p>就在我落笔之时，身处北半球的人正在进入秋季，白昼变短，气温变低，而南半球的人却经历着白昼变长，气温变高。季节的变化告诉我们，日照的时长取决于你在星球上的位置，以及星球绕太阳的轨道。</p><p>可喜的是，天文学家能告诉你 —— 而且相当准确 —— 太阳在天空中的位置或时间。不可贺的是，这其中的计算十分 <a href="https://en.wikipedia.org/wiki/Position_of_the_Sun" target="_blank" rel="noopener">复杂</a>。</p><p>但老实讲，我们并不用过分深究它，在网上能找到相关的代码。经过不断的试错，<a href="https://github.com/NSHipster/DynamicDesktop/blob/master/SolarPosition.playground" target="_blank" rel="noopener">它们就能为我所用</a>（欢迎 PR！）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CoreLocation</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于加州库比蒂诺的 Apple Park</span></span><br><span class="line"><span class="keyword">let</span> location = <span class="type">CLLocation</span>(latitude: <span class="number">37.3327</span>, longitude: -<span class="number">122.0053</span>)</span><br><span class="line"><span class="keyword">let</span> time = <span class="type">Date</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> position = solarPosition(<span class="keyword">for</span>: location, at: time)</span><br><span class="line"><span class="keyword">let</span> formattedDate = <span class="type">DateFormatter</span>.localizedString(from: time,</span><br><span class="line">                                                    dateStyle: .medium,</span><br><span class="line">                                                    timeStyle: .short)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Solar Position on <span class="subst">\(formattedDate)</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(position.azimuth)</span>° Az / <span class="subst">\(position.elevation)</span>° El"</span>)</span><br></pre></td></tr></table></figure><p><samp>Solar Position on Oct 1, 2018 at 12:00 180.73470025840783° Az / 49.27482549913847° El</samp></p><p>2018 年 10 月 1 日中午，太阳从南面照射在 Apple Park，大约处于地平线中间，直射头顶。</p><p>如果绘制出太阳一天的位置，我们可以得到一个正弦曲线，这不禁让人联想到 Apple Watch 的“太阳表盘”。</p><p><img src="/img/articles/macos-dynamic-desktop/solar-position-watch-faces-1815d6d3c84f42ff4588fa47cd59841f4de15be2b219f6f4ec9a83e13ea0f08b.jpg1540446628.9008124" alt=""></p><h3 id="扩展对-XMP-的理解"><a href="#扩展对-XMP-的理解" class="headerlink" title="扩展对 XMP 的理解"></a>扩展对 XMP 的理解</h3><p>好吧，天文学到此结束。接下来是一个乏味的过程：<em>摆在眼前</em>的 XML 元数据。</p><p>还记得之前的元数据键 <code>hasXMP</code> 吗？对，就是它没错。</p><p>XMP（Extensible Metadata Platform），即可扩展元数据平台，是一种使用元数据标记文件的标准格式。XMP 长什么样呢？请打起精神来：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xmpData = <span class="type">CGImageMetadataCreateXMPData</span>(metadata, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> xmp = <span class="type">String</span>(data: xmpData <span class="keyword">as</span>! <span class="type">Data</span>, encoding: .utf8)!</span><br><span class="line"><span class="built_in">print</span>(xmp)</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x:xmpmeta</span> <span class="attr">xmlns:x</span>=<span class="string">"adobe:ns:meta/"</span> <span class="attr">x:xmptk</span>=<span class="string">"XMP Core 5.4.0"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rdf:RDF</span> <span class="attr">xmlns:rdf</span>=<span class="string">"http://www.w3.org/1999/02/22-rdf-syntax-ns#"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rdf:Description</span> <span class="attr">rdf:about</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:apple_desktop</span>=<span class="string">"http://ns.apple.com/namespace/1.0/"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">apple_desktop:solar</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- (Base64-Encoded Metadata) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">apple_desktop:solar</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">rdf:Description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">rdf:RDF</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x:xmpmeta</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>呕。</em></p><p>不过也幸好我们检查了一下。之后想要成功自定义 Dynamic Desktop，还得仰仗 <code>apple_desktop</code> 命名空间。</p><p>既然如此，就开始吧。</p><h2 id="创建自定义-Dynamic-Desktop"><a href="#创建自定义-Dynamic-Desktop" class="headerlink" title="创建自定义 Dynamic Desktop"></a>创建自定义 Dynamic Desktop</h2><p>首先，创建一个数据模型来表示 Dynamic Desktop：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DynamicDesktop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> images: [<span class="type">Image</span>]</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cgImage: <span class="type">CGImage</span></span><br><span class="line">        <span class="keyword">let</span> metadata: <span class="type">Metadata</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Metadata</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> index: <span class="type">Int</span></span><br><span class="line">            <span class="keyword">let</span> altitude: <span class="type">Double</span></span><br><span class="line">            <span class="keyword">let</span> azimuth: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">                <span class="keyword">case</span> index = <span class="string">"i"</span></span><br><span class="line">                <span class="keyword">case</span> altitude = <span class="string">"a"</span></span><br><span class="line">                <span class="keyword">case</span> azimuth = <span class="string">"z"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如前文所述，每个 Dynamic Desktop 都由一个有序的图片序列构成，每个图片又包含存储在 <code>CGImage</code> 对象中的图片数据和元数据。<code>Metadata</code> 采用 <code>Codable</code> 类型，是为了编译器自动合成相关函数。我们能在生成 Base64 编码的二进制属性列表时感受到它的优势。</p><h3 id="写入图片目标"><a href="#写入图片目标" class="headerlink" title="写入图片目标"></a>写入图片目标</h3><p>首先，创建一个指定输出 URL 的 <code>CGImageDestination</code>。文件类型为 <code>heic</code>，资源数量即需要包含的图片张数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> imageDestination = <span class="type">CGImageDestinationCreateWithURL</span>(</span><br><span class="line">                                outputURL <span class="keyword">as</span> <span class="type">CFURL</span>,</span><br><span class="line">                                <span class="type">AVFileType</span>.heic <span class="keyword">as</span> <span class="type">CFString</span>,</span><br><span class="line">                                dynamicDesktop.images.<span class="built_in">count</span>,</span><br><span class="line">                                <span class="literal">nil</span></span><br><span class="line">                             )</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Error creating image destination"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，遍历动态桌面对象中的全部图片。通过 <code>enumerated()</code> 方法，我们还能获取到当前 <code>index</code>，这样就可以在第一张图片上设置图片元数据：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, image) <span class="keyword">in</span> dynamicDesktop.images.enumerated() &#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> imageMetadata = <span class="type">CGImageMetadataCreateMutable</span>()</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> tag = <span class="type">CGImageMetadataTagCreate</span>(</span><br><span class="line">                            <span class="string">"http://ns.apple.com/namespace/1.0/"</span> <span class="keyword">as</span> <span class="type">CFString</span>,</span><br><span class="line">                            <span class="string">"apple_desktop"</span> <span class="keyword">as</span> <span class="type">CFString</span>,</span><br><span class="line">                            <span class="string">"solar"</span> <span class="keyword">as</span> <span class="type">CFString</span>,</span><br><span class="line">                            .string,</span><br><span class="line">                            <span class="keyword">try</span>! dynamicDesktop.base64EncodedMetadata() <span class="keyword">as</span> <span class="type">CFString</span></span><br><span class="line">                        ),</span><br><span class="line">            <span class="type">CGImageMetadataSetTagWithPath</span>(</span><br><span class="line">                imageMetadata, <span class="literal">nil</span>, <span class="string">"xmp:solar"</span> <span class="keyword">as</span> <span class="type">CFString</span>, tag</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Error creating image metadata"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">CGImageDestinationAddImageAndMetadata</span>(imageDestination,</span><br><span class="line">                                              image.cgImage,</span><br><span class="line">                                              imageMetadata,</span><br><span class="line">                                              <span class="literal">nil</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">CGImageDestinationAddImage</span>(imageDestination,</span><br><span class="line">                                   image.cgImage,</span><br><span class="line">                                   <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了较为繁杂的 Core Graphics API 以外，代码可以说非常直观了。唯一需要进一步解释的只有 <code>CGImageMetadataTagCreate(_:_:_:_:_:)</code>。</p><p>由于图片与元数据容器的结构、代码的表现形式均不同，所以我们不得不为 <code>DynamicDesktop</code> 实现 <code>Encodable</code> 协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DynamicDesktop</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> ap, si</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">NestedCodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> d, l</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> keyedContainer =</span><br><span class="line">            encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> nestedKeyedContainer =</span><br><span class="line">            keyedContainer.nestedContainer(keyedBy: <span class="type">NestedCodingKeys</span>.<span class="keyword">self</span>,</span><br><span class="line">                                           forKey: .ap)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// FIXME：不确定此处 `l` 与 `d` 的含义</span></span><br><span class="line">        <span class="keyword">try</span> nestedKeyedContainer.encode(<span class="number">0</span>, forKey: .l)</span><br><span class="line">        <span class="keyword">try</span> nestedKeyedContainer.encode(<span class="keyword">self</span>.images.<span class="built_in">count</span>, forKey: .d)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> unkeyedContainer =</span><br><span class="line">            keyedContainer.nestedUnkeyedContainer(forKey: .si)</span><br><span class="line">        <span class="keyword">for</span> image <span class="keyword">in</span> <span class="keyword">self</span>.images &#123;</span><br><span class="line">            <span class="keyword">try</span> unkeyedContainer.encode(image.metadata)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个，就可以实现之前代码中提到的 <code>base64EncodedMetadata()</code> 方法了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DynamicDesktop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">base64EncodedMetadata</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> encoder = <span class="type">PropertyListEncoder</span>()</span><br><span class="line">        encoder.outputFormat = .binary</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> binaryPropertyListData = <span class="keyword">try</span> encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">return</span> binaryPropertyListData.base64EncodedString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 for-in 循环执行完，也就表明所有图片和元数据均被写入，我们可以调用 <code>CGImageDestinationFinalize(_:)</code> 方法终止图片源，并将图片写入磁盘。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="type">CGImageDestinationFinalize</span>(imageDestination) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Error finalizing image"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一切顺利，就可以为重新定义 Dynamic Desktop 的自己而感到骄傲了。棒！</p><p><br></p><hr><p><br></p><p>我们非常喜欢 Mojave 的 Dynamic Desktop 特性，并且也很欣慰看到它仿佛重现了 Windows 95 壁纸进入主流市场时的辉煌。</p><p>如果你也这样想，下面还有些想法可供参考：</p><h3 id="照片自动生成-Dynamic-Desktop"><a href="#照片自动生成-Dynamic-Desktop" class="headerlink" title="照片自动生成 Dynamic Desktop"></a>照片自动生成 Dynamic Desktop</h3><p>让人振奋的是，天体运动这样高不可攀的研究，竟然可以简化用二元方程来表达：时间与位置。</p><p>在之前的例子中，这部分信息都是硬编码的，但其实它们可以通过读取图片数据来自动获取。</p><p>默认情况下，绝大部分手机的相机都会捕获拍摄时的 <a href="https://en.wikipedia.org/wiki/Exif" target="_blank" rel="noopener">Exif 元数据</a>。元数据包含了照片拍摄的时间，以及当时设备的 GPS 坐标。</p><p>通过读取元数据中的时间与位置信息，能自动获取太阳的位置，那么从一系列图片中生成 Dynamic Desktop 也就顺理成章了。</p><h3 id="iPhone-上的延时摄影"><a href="#iPhone-上的延时摄影" class="headerlink" title="iPhone 上的延时摄影"></a>iPhone 上的延时摄影</h3><p>想要好好利用手上全新的 iPhone Xs 吗？（更确切的说，“在纠结卖不卖旧 iPhone 的时候，可以先用它来做些有创意的事？”）</p><p>将手机充上电，摆在窗前，打开相机的延时摄影模式，点击“拍摄”按钮。从最后的视频中选出一些关键帧，就可以制作专属 Dynamic Desktop 了。</p><p>当然，你可以看看 <a href="https://itunes.apple.com/us/app/skyflow-time-lapse-shooting/id937208291?mt=8" target="_blank" rel="noopener">Skyflow</a> 这类应用，它能设置时间间隔来拍摄静态图片。</p><h3 id="通过-GIS-数据打造风景"><a href="#通过-GIS-数据打造风景" class="headerlink" title="通过 GIS 数据打造风景"></a>通过 GIS 数据打造风景</h3><p>如果你无法忍受手机一整天不在身边（伤心），又或者没什么标志性景象值得拍摄（依然伤心），你还可以创造一个属于自己的世界（这比现实本身还要令人伤心）。</p><p>可以选择用 <a href="https://planetside.co.uk/" target="_blank" rel="noopener">Terragen</a> 这类应用，它打造了一个逼真的 3D 世界，还能对太阳、地球、天空进行微调。</p><p>想要更加简化，还可以从美国地质调查局的 <a href="https://viewer.nationalmap.gov/basic/" target="_blank" rel="noopener">国家地图网站</a> 上下载高程地图，以用于 3D 渲染的模板。</p><h3 id="下载预制的-Dynamic-Desktops"><a href="#下载预制的-Dynamic-Desktops" class="headerlink" title="下载预制的 Dynamic Desktops"></a>下载预制的 Dynamic Desktops</h3><p>再或者，你每天都非常多的工作要做，抽不出时间捣腾好看的图片，也可以选择付费从别人那里购买。</p><p>我个人是 <a href="https://www.jetsoncreative.com/24hourwallpaper" target="_blank" rel="noopener">24 Hour Wallpaper</a> 这款应用的粉丝。如果你有别的推荐，欢迎 <a href="https://twitter.com/NSHipster/" target="_blank" rel="noopener">联系我们</a>。</p><p><br></p><hr><h3 id="NSMUTABLEHIPSTER"><a href="#NSMUTABLEHIPSTER" class="headerlink" title="NSMUTABLEHIPSTER"></a>NSMUTABLEHIPSTER</h3><p>疑问？纠错？欢迎提 <a href="https://github.com/NSHipster/articles/issues" target="_blank" rel="noopener">issues</a> 和 <a href="https://github.com/NSHipster/articles/blob/master/2018-10-01-macos-dynamic-desktop.md" target="_blank" rel="noopener">pull requests</a> —— NSHipster 因你而变得更好。</p><p><em>本文用的是 Swift 4.2</em>。关于站内文章的状态信息，可以查看 <a href="https://nshipster.com/status/" target="_blank" rel="noopener">状态汇总页面</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Mojave 中 Dynamic Desktop 的奥义
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>编译开源 Swift Foundation 库</title>
    <link href="https://swift.gg/2018/10/22/compiling-open-source-swift-foundation/"/>
    <id>https://swift.gg/2018/10/22/compiling-open-source-swift-foundation/</id>
    <published>2018-10-22T00:00:00.000Z</published>
    <updated>2019-02-21T03:45:01.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：iAchieved.it，<a href="http://dev.iachieved.it/iachievedit/compiling-open-source-swift-foundation/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016-06-30<br>译者：<a href="https://github.com/rsenjoyer" target="_blank" rel="noopener">rsenjoyer</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://hulizhen.me" target="_blank" rel="noopener">智多芯</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p><img src="/img/articles/compiling-open-source-swift-foundation/006tNbRwgy1fuksdkfewij306o06omx6.jpg1540189674.5814507" alt=""></p><p>我最近在开源的 <a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="noopener">Swift Foundation</a> 中遇到了 <code>NSThread</code> 实现的问题。如果不是尝试在树莓派 3 上运行代码，我也许就发现不了这个问题：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> Glibc</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">  sleep(<span class="number">2</span>)</span><br><span class="line">  counter = counter + <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> t = <span class="type">Thread</span>()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"STARTED:<span class="subst">\(counter)</span>"</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"EXIT:<span class="subst">\(counter)</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"START:<span class="subst">\(counter)</span>"</span>)</span><br><span class="line">  t.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我所期望的是每 2 秒都会创建并销毁一个线程。不幸的是在大约启动 230 个线程之后，系统资源已经耗尽，不再有新的线程被创建。解决的方式正如 <a href="https://bugs.swift.org/browse/SR-1908" target="_blank" rel="noopener">SR-1908</a> 所提到的，初始化具有系统范围的分离状态的线程</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> main: (<span class="type">Void</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  _main = main</span><br><span class="line">  <span class="keyword">let</span> <span class="number">_</span> = <span class="built_in">withUnsafeMutablePointer</span>(&amp;_attr) &#123; attr <span class="keyword">in</span></span><br><span class="line">    pthread_attr_init(attr)</span><br><span class="line">    pthread_attr_setscope(attr，<span class="type">Int32</span>(<span class="type">PTHREAD_SCOPE_SYSTEM</span>))</span><br><span class="line">    pthread_attr_setdetachstate(attr，<span class="type">Int32</span>(<span class="type">PTHREAD_CREATE_DETACHED</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/phausler" target="_blank" rel="noopener">Philippe Hausler</a> 在 SR-1908 中提出了解决方案。正巧我有个树莓派 3 可以实现和测试该方案。</p><h2 id="针对-Foundation-的构建"><a href="#针对-Foundation-的构建" class="headerlink" title="针对 Foundation 的构建"></a>针对 Foundation 的构建</h2><p>如果你阅读了 <a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="noopener">开源库 Foundation</a> 的 <a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Docs/GettingStarted.md" target="_blank" rel="noopener">新手入门文档</a>，你就会知道，它建议在构建 Foundation 之前，首先需要构建 Swift，clang 和 llvm。如果可以在一个有大量的 CPU 和快速磁盘的服务器上工作，我丝毫不介意按照文档一步步构建。然而树莓派 3 与其他老式的设备一样，性能提升有点慢。我也可以考虑交叉编译 Swift，但我还没有足够时间来解决交叉编译带来的问题（如果你曾经使用过交叉编译环境，你一定知道它需要很长时间来做相关的配置）。</p><p>我们所需要的是充分利用已有的构建环境并自行编译 Foundation。事实证明是可以做到的，不然的话，我们也不会有这篇博客了。</p><p>下面是你所需要的准备操作（无论你是在 x86 服务器上还是在像 BeagleBone 或树莓派的 ARM 的计算机上）：</p><ul><li>全量构建 <code>swiftc</code>，通常位于 <code>build/buildbot_linux/swift-linux-armv7/bin</code> 目录</li><li>全量构建 <code>swift</code>，同样位于 <code>build/buildbot_linux/swift-linux-armv7/bin</code> 目录</li><li>全量构建 <code>clang</code>(从开源库中构建)，位于 <code>build/buildbot_linux/llvm-linux-armv7/bin</code> 目录中</li></ul><p>我希望提供各种已经编译过的“工具链”，但是现在你必须首先构建自己的工具链。然后你就可以自己构建 Foundation 了。</p><p>现在，让我们来看看如何使用它来测试 Foundation 上的内容。请注意，我们克隆的是我们自己 fork 的 swift-corelibs-foundation 的分支。如果你打算给上游开源库（即 Apple 开源库）提交 PR，这一点非常的重要。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/iachievedit/swift-corelibs-foundation</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> PREBUILT_ROOT=/root/workspace/Swift-3.0-Pi3-ARM-Incremental/build/buildbot_linux/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SWIFTC=<span class="variable">$PREBUILT_ROOT</span>/swift-linux-armv7/bin/swiftc \</span></span><br><span class="line">CLANG=$PREBUILT_ROOT/llvm-linux-armv7/bin/clang      \</span><br><span class="line">SWIFT=$PREBUILT_ROOT/swift-linux-armv7/bin/swift     \</span><br><span class="line">SDKROOT=$PREBUILT_ROOT/swift-linux-armv7             \</span><br><span class="line">BUILD_DIR=build ./configure Debug</span><br><span class="line"><span class="meta">#</span><span class="bash"> /usr/bin/ninja</span></span><br><span class="line">...</span><br><span class="line">[290/290] Link: build/Foundation/libFoundation.so</span><br></pre></td></tr></table></figure><p>首先，我们将环境变量 <code>PREBUILT_ROOT</code> 设置到预构建 Swift 及相关工具所在的位置，还可以在下一步操作前配置 <code>./configure</code> 为 <code>Debug</code> 模式（你也可以配置为 <code>Release</code>）。我们还需要将环境变量 <code>SWIFTC</code>，<code>CLANG</code>，<code>SWIFT</code> 和 <code>SDKROOT</code> 配置脚本指向我们的“工具链”。最后，环境变量 <code>BUILD_DIR</code> 设置为所有中间件和最终输出（libFoundation.so）的放置位置。</p><p>注意：也许有时你会惊讶于评论中的某些内容。你的 <code>PREBUILT_ROOT</code> 是你工具链的位置。不要期望在 <code>/root/workspace/Swift-3.0-Pi3-ARM-Incremental</code> 上找到你系统上的任何内容！</p><p>最后，执行 <code>/usr/bin/ninja</code> 来运行我们的构建。一旦构建结束后，在 <code>build/Foundation/</code> 目录中会有一个 <code>libFoundation.so</code> 共享库。<br>要使用已安装的 Swift 来测试它，只需将 <code>libFoundation.so</code> 复制到 <code>$YOUR_SWIFT_ROOT/usr/lib/swift/linux/ libFoundation.so</code>。</p><h2 id="运行测试用例"><a href="#运行测试用例" class="headerlink" title="运行测试用例"></a>运行测试用例</h2><p>你可以通过向 <code>./configure</code> 添加 <code>-DXCTEST_BUILD_DIR</code> 参数来运行 Foundation 测试套件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> PREBUILT_ROOT=/root/workspace/Swift-3.0-Pi3-ARM-Incremental/build/buildbot_linux/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SWIFTC=<span class="variable">$PREBUILT_ROOT</span>/swift-linux-armv7/bin/swiftc \</span></span><br><span class="line">CLANG=$PREBUILT_ROOT/llvm-linux-armv7/bin/clang      \</span><br><span class="line">SWIFT=$PREBUILT_ROOT/swift-linux-armv7/bin/swift     \</span><br><span class="line">SDKROOT=$PREBUILT_ROOT/swift-linux-armv7             \</span><br><span class="line">BUILD_DIR=build ./configure Debug                    \</span><br><span class="line">-DXCTEST_BUILD_DIR=$PREBUILT_ROOT/xctest-linux-armv7</span><br><span class="line"><span class="meta">#</span><span class="bash"> /usr/bin/ninja <span class="built_in">test</span></span></span><br><span class="line">[4/4] Building Tests</span><br><span class="line">**** RUNNING TESTS ****</span><br><span class="line">execute:</span><br><span class="line">LD_LIBRARY_PATH= build/TestFoundation/TestFoundation</span><br><span class="line">**** DEBUGGING TESTS ****</span><br><span class="line">execute:</span><br><span class="line">LD_LIBRARY_PATH= lldb build/TestFoundation/TestFoundation</span><br></pre></td></tr></table></figure><p>运行测试需要为 <code>LD_LIBRARY_PATH</code> 提供两个路径：<code>libXCTest.so</code> 共享库和“library under test”的路径。<br>如果我们按照上述步骤操作，<code>libFoundation.so</code> 就一定位于 <code>./build/Foundation</code> 目录中。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> LD_LIBRARY_PATH=./build/Foundation:<span class="variable">$PREBUILT_ROOT</span>/xctest-linux-armv7 ./build/TestFoundation/TestFoundation</span></span><br><span class="line">...</span><br><span class="line">Test Suite 'All tests' passed at 03:16:45.315</span><br><span class="line">     Executed 483 tests, with 0 failures (0 unexpected) in 37.621 (37.621) seconds</span><br></pre></td></tr></table></figure><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>需要强调的是使用这种技术，你需要一个“构建工具链”，它包含 Swift，clang 和 llvm。此外，您的工具链最后一次构建到您尝试自行构建 Foundation 的时间间隔越长，Foundation 所依赖的语言特性在构建工具链时不存在的风险就越高。但如果您决定开始使用 Foundation，请首先构建完整的 Swift 工具链并保存构建目录以使用上述技术。</p><p>祝你好运！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      这是一篇关于编译 Swift 开源的 Foundation 库的文章
    
    </summary>
    
      <category term="iAchieved.it" scheme="https://swift.gg/categories/iAchieved-it/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="iOS" scheme="https://swift.gg/tags/iOS/"/>
    
  </entry>
  
</feed>
