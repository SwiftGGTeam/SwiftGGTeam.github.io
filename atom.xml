<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftGG</title>
  
  <subtitle>走心的 Swift 翻译组</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swift.gg/"/>
  <updated>2019-09-27T14:20:11.504Z</updated>
  <id>https://swift.gg/</id>
  
  <author>
    <name>SwiftGG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>宏定义与可选括号</title>
    <link href="https://swift.gg/2019/09/27/preprocessor-abuse-and-optional-parentheses/"/>
    <id>https://swift.gg/2019/09/27/preprocessor-abuse-and-optional-parentheses/</id>
    <published>2019-09-27T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-03-20-preprocessor-abuse-and-optional-parentheses.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-03-20<br>译者：俊东；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://nemocdz.github.io/" target="_blank" rel="noopener">Nemocdz</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>前几天我遇到了一个有趣的问题：如何编写一个 C 语言预处理器的宏，删除包围实参的括号？</p><p>今天的文章，将为大家分享我的解决方案。<br><a id="more"></a></p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>C 语言预处理器是一个相当盲目的文本替换引擎，它并不理解 C 代码，更不用说 Objective-C 了。它的工作原理还算不错，可以应付大部分情况，但偶尔也会出现判断失误。</p><p>这里举个典型的例子：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">XCTAssertEqualObjects</span>(someArray, @[ <span class="string">@"one"</span>, <span class="string">@"two"</span> ], <span class="string">@"Array is not as expected"</span>);</span><br></pre></td></tr></table></figure><p>这会无法编译，并且会出现非常古怪的错误提示。预处理器查找分隔宏参数的逗号时，没能将数组结构 <code>@ [...]</code> 中的东西理解为一个单一的元素。结果代码尝试比较 <code>someArray</code> 和 <code>@[@&quot;one&quot;</code>。断言失败消息 <code>@&quot;two&quot;]</code> 和 <code>@&quot;Array is not as expected&quot;</code> 是另外的实参。这些半成品部分用于 <code>XCTAssertEqualObjects</code> 的宏扩展中，生成的代码当然错得离谱。</p><p>要解决这个问题也很容易：添加括号就行。预编译器不能识别 <code>[]</code>，但它<em>确实</em>知道 <code>()</code> 并且能够理解应该忽略里面的逗号。下面的代码就能正常运行：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">XCTAssertEqualObjects</span>(someArray, (@[ <span class="string">@"one"</span>, <span class="string">@"two"</span> ]), <span class="string">@"Array is not as expected"</span>);</span><br></pre></td></tr></table></figure><p>在 C 语言的许多场景下，你添加多余的括号也不会有任何区别。宏扩展开之后，生成的代码虽然在数组文字周围有括号，但没有异常。你可以写搞笑的多层括号表达式，编译器会愉快地帮你解析到最里面一层：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,((((((((((<span class="number">42</span>)))))))))));</span><br></pre></td></tr></table></figure><p>甚至将 <code>NSLog</code> 这样处理也行：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">((((((((((<span class="built_in">NSLog</span>))))))))))(<span class="string">@"%d"</span>,<span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>在 C 中有一个地方你不能随意添加括号：类型（types）。例如：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f(<span class="keyword">void</span>); <span class="comment">// 合法</span></span><br><span class="line">(<span class="keyword">int</span>) f(<span class="keyword">void</span>); <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure><p>什么时候会发生这种情况呢？这种情况并不常见，但如果你有一个使用类型的宏，并且类型包含的逗号不在括号内，则会出现这种情况。宏可以做很多事情，当一个类型遵循多个协议时，在 Objective-C 中可能出现一些类型带有未加括号的逗号;当使用带有多个模板参数的模板化类型时，在 C++ 中也可能出现。举个例子，这有一个简单的宏，创建从字典中提供静态类型值的 <code>getter</code>：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define GETTER(type,name) \</span></span><br><span class="line">- (type)name &#123; \</span><br><span class="line"><span class="keyword">return</span> [_dictionary objectForKey: @<span class="meta">#name]; \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你能这样使用它：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line"><span class="built_in">NSDictionary</span> *_dictionary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GETTER(<span class="built_in">NSView</span> *,view)</span><br><span class="line">GETTER(<span class="built_in">NSString</span> *,name)</span><br><span class="line">GETTER(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;,someCopyableThing)</span><br></pre></td></tr></table></figure><p>到目前为止没问题。现在假设我们想要创建一个遵循<em>两个</em>协议的类型：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">GETTER(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>,<span class="built_in">NSCoding</span>&gt;,someCopyableAndCodeableThing)</span><br></pre></td></tr></table></figure><p>哎呀！宏不起作用了。而且添加括号也无济于事：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">GETTER((<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>,<span class="built_in">NSCoding</span>&gt;),someCopyableAndCodeableThing)</span><br></pre></td></tr></table></figure><p>这会产生非法代码。这时我们需要一个删除可选括号的 UNPAREN 宏。将 <code>GETTER</code> 宏重写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define GETTER(type,name) \</span><br><span class="line">- (UNPAREN(type))name &#123; \</span><br><span class="line">return [_dictionary objectForKey: @#name]; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们该怎么做呢？</p><h2 id="必须的括号"><a href="#必须的括号" class="headerlink" title="必须的括号"></a>必须的括号</h2><p>删除括号很容易：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define UNPAREN(...) __VA_ARGS__</span></span><br><span class="line"><span class="meta">#define GETTER(type,name) \</span></span><br><span class="line">- (UNPAREN type)name &#123; \</span><br><span class="line"><span class="keyword">return</span> [_dictionary objectForKey: @<span class="meta">#name]; \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然看上去很扯，但这的确能运行。预编译器将 <code>type</code> 扩展为 <code>(id &lt;NSCopying，NSCoding&gt;)</code>，生成 <code>UNPAREN (id&lt;NSCopying, NSCoding&gt;)</code>。然后它会将 <code>UNPAREN</code> 宏扩展为 <code>id &lt;NSCopying，NSCoding&gt;</code>。括号，消失！</p><p>但是，之前使用的 <code>GETTER</code> 失败了。例如，<code>GETTER(NSView *，view)</code> 在宏扩展中生成 <code>UNPAREN NSView *</code>。不会进一步扩展就直接提供给编译器。结果自然会报编译器错误，因为 <code>UNPAREN NSView *</code> 是无法编译的。这虽然可以通过编写 <code>GETTER((NSView *)，view)</code> 来解决，但是被迫添加这些括号很烦人。这样的结果可不是我们想要的。</p><h2 id="宏不能被重载"><a href="#宏不能被重载" class="headerlink" title="宏不能被重载"></a>宏不能被重载</h2><p>我立刻想到了如何摆脱剩余的 <code>UNPAREN</code>。当你想要一个标识符消失时，你可以使用一个空的 <code>#define</code>，如下所示：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define UNPAREN</span></span><br></pre></td></tr></table></figure><p>有了这个，<code>a UNPAREN b</code> 的序列变为 <code>a b</code>。完美解决问题！但是，如果已经存在带参数的另一个定义，则预处理器会拒绝此操作。即使预处理器可能选择其中一个，它也不会同时存在两种形式。如果可行的话，这能有效解决我们的问题，但可惜的是并不允许：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define UNPAREN(...) __VA_ARGS__</span></span><br><span class="line"><span class="meta">#define UNPAREN</span></span><br><span class="line"><span class="meta">#define GETTER(type,name) \</span></span><br><span class="line">- (UNPAREN type)name &#123; \</span><br><span class="line"><span class="keyword">return</span> [_dictionary objectForKey: @<span class="meta">#name]; \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这无法通过预处理器，它会由于 <code>UNPAREN</code> 的重复 <code>#define</code> 而报错。不过，它引导我们走上了成功的道路。现在的瓶颈是怎么找出一种方法来实现相同的效果，而不会使两个宏具有相同的名称。</p><h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><p>最终目标是让 <code>UNPAREN(x)</code> 和 <code>UNPAREN((x))</code> 结果都是 <code>x</code>。朝着这个目标迈出的第一步是制作一些宏，其中传递 <code>x</code> 和 <code>(x)</code> 产生相同的输出，即使它并不确定 <code>x</code> 是什么。这可以通过将宏名称放在宏扩展中来实现，如下所示：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define EXTRACT(...) EXTRACT __VA_ARGS__</span></span><br></pre></td></tr></table></figure><p>现在如果你写 <code>EXTRACT(x)</code>，结果是 <code>EXTRACT x</code>。当然，如果你写 <code>EXTRACT x</code>，结果也是 <code>EXTRACT x</code>，就像没有宏扩展的情况。这仍然给我们留下一个 <code>EXTRACT</code>。虽然不能用 <code>#define</code> 直接解决，但这已经进步了。</p><h2 id="标识符粘合"><a href="#标识符粘合" class="headerlink" title="标识符粘合"></a>标识符粘合</h2><p>预处理器有一个操作符 <code>##</code>，它将两个标识符粘合在一起。例如，<code>a ## b</code> 变为 <code>ab</code>。这可以用于从片段构造标识符，但也可以用于调用宏。例如：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define AA 1</span></span><br><span class="line"><span class="meta">#define AB 2</span></span><br><span class="line"><span class="meta">#define A(x) A ## x</span></span><br></pre></td></tr></table></figure><p>从这里可以看到，<code>A(A)</code> 产生 <code>1</code>，<code>A(B)</code> 产生 <code>2</code>。</p><p>让我们将这个运算符与上面的 <code>EXTRACT</code> 宏结合起来，尝试生成一个 <code>UNPAREN</code> 宏。由于 <code>EXTRACT(...)</code> 使用前缀 <code>EXTRACT</code> 生成实参，因此我们可以使用标识符粘合来生成以 <code>EXTRACT</code> 结尾的其他标记。如果我们 <code>#define</code> 那个新标记为空，那就搞定了。</p><p>这是一个以 <code>EXTRACT</code> 结尾的宏，它不会产生任何结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define NOTHING_EXTRACT</span></span><br></pre></td></tr></table></figure><p>这是对 <code>UNPAREN</code> 宏的尝试，它将所有内容放在一起：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define UNPAREN(x) NOTHING_ ## EXTRACT x</span></span><br></pre></td></tr></table></figure><p>不幸的是，这并不能实现我们的目标。问题在操作顺序上。如果我们写 <code>UNPAREN((int))</code>，我们将会得到：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">UNPAREN((<span class="keyword">int</span>))</span><br><span class="line">NOTHING_ <span class="meta">## EXTRACT (int)</span></span><br><span class="line">NOTHING_EXTRACT (<span class="keyword">int</span>)</span><br><span class="line">(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>标示符粘合太早起作用，<code>EXTRACT</code> 宏永远不会有机会扩展开。</p><p>可以使用间接的方式强制预处理器用不同的顺序判断事件。我们可以制作一个 <code>PASTE</code> 宏，而不是直接使用 <code>##</code>：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define PASTE(x,...) x ## __VA_ARGS__</span></span><br></pre></td></tr></table></figure><p>然后我们将根据它编写 <code>UNPAREN</code>：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define UNPAREN(x)  PASTE(NOTHING_,EXTRACT x)</span></span><br></pre></td></tr></table></figure><p>这<em>仍然</em>不起作用。情况如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">UNPAREN((<span class="keyword">int</span>))</span><br><span class="line">PASTE(NOTHING_,EXTRACT (<span class="keyword">int</span>))</span><br><span class="line">NOTHING_ <span class="meta">## EXTRACT (int)</span></span><br><span class="line">NOTHING_EXTRACT (<span class="keyword">int</span>)</span><br><span class="line">(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>但更接近我们的目标了。序列 <code>EXTRACT(int)</code> 显然没有触发标示符粘合操作符。我们必须让预处理器在它看到 <code>##</code> 之前解析它。可以通过另一种方式间接强制解析它。让我们定义一个只包装 <code>PASTE</code> 的 <code>EVALUATING_PASTE</code> 宏：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define EVALUATING_PASTE(x,...) PASTE(x,__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><p>现在让我们用<em>它</em>写 <code>UNPAREN</code>：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define UNPAREN(x) EVALUATING_PASTE(NOTHING_,EXTRACT x)</span></span><br></pre></td></tr></table></figure><p>这是展开之后：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">UNPAREN((<span class="keyword">int</span>))</span><br><span class="line">EVALUATING_PASTE(NOTHING_,EXTRACT (<span class="keyword">int</span>))</span><br><span class="line">PASTE(NOTHING_,EXTRACT <span class="keyword">int</span>)</span><br><span class="line">NOTHING_ <span class="meta">## EXTRACT int</span></span><br><span class="line">NOTHING_EXTRACT <span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>即使没有额外加括号也能正常运行，因为额外的赋值并没有影响：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">UNPAREN(<span class="keyword">int</span>)</span><br><span class="line">EVALUATING_PASTE(NOTHING_,EXTRACT <span class="keyword">int</span>)</span><br><span class="line">PASTE(NOTHING_,EXTRACT <span class="keyword">int</span>)</span><br><span class="line">NOTHING_ <span class="meta">## EXTRACT int</span></span><br><span class="line">NOTHING_EXTRACT <span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>成功了！我们现在编写 <code>GETTER</code> 时可以不需要围绕类型的括号了：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define GETTER(type,name) \</span></span><br><span class="line">- (UNPAREN(type))name &#123; \</span><br><span class="line"><span class="keyword">return</span> [_dictionary objectForKey: @<span class="meta">#name]; \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="奖励宏"><a href="#奖励宏" class="headerlink" title="奖励宏"></a>奖励宏</h2><p>在选择一些宏来证明这个结构时，我构建了一个很好的 <code>dispatch_once</code> 宏来制作延迟初始化的常量。实现如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define ONCE(type,name,...) \</span></span><br><span class="line">UNPAREN(type) name() &#123; \</span><br><span class="line"><span class="keyword">static</span> UNPAREN(type) static_ <span class="meta">## name; \</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate; \</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;predicate,^&#123; \</span><br><span class="line">static_ <span class="meta">## name = (&#123; __VA_ARGS__; &#125;); \</span></span><br><span class="line">&#125;); \</span><br><span class="line"><span class="keyword">return</span> static_ <span class="meta">## name; \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用案例：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ONCE(<span class="built_in">NSSet</span> *,AllowedFileTypes,[<span class="built_in">NSSet</span> setWithArray:@[ <span class="string">@"mp3"</span>,<span class="string">@"m4a"</span>,<span class="string">@"aiff"</span> ]])</span><br></pre></td></tr></table></figure><p>然后，你可以调用 <code>AllowedFileTypes()</code> 来获取集合，并根据需要高效创建集合。如果类型不巧包括括号，添加括号就能运行。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>仅仅写这个宏，我就发现了很多艰涩的知识。我希望接触这些知识也不会影响你的思维。请谨慎使用这些知识。</p><p>今天就这样。以后还会有更多令人兴奋的探索，可能比这还要再不可思议。在此之前，如果你对此主题有任何建议，请发送给 <a href="mike@mikeash.com">我们</a>！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Objective-C 中 C 语言宏定义扩展
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS" scheme="https://swift.gg/tags/iOS/"/>
    
      <category term="macro" scheme="https://swift.gg/tags/macro/"/>
    
  </entry>
  
  <entry>
    <title>Swift Import 声明</title>
    <link href="https://swift.gg/2019/09/23/swift-import/"/>
    <id>https://swift.gg/2019/09/23/swift-import/</id>
    <published>2019-09-23T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/import/" target="_blank" rel="noopener">原文链接</a>，原文日期：2019-01-07<br>译者：<a href="https://github.com/mobilefellow" target="_blank" rel="noopener">雨谨</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>作为软件开发人员，我们学到的第一课是如何将概念和功能组织成独立的单元。在最小的层级上，这意味着思考类型、方法和属性。这些东西构成了模块（module）的基础，而模块又可以被打包成为 library 或者 framework。</p><p>在这种方式中，import 声明是将所有内容组合在一起的粘合剂。</p><a id="more"></a><p>尽管 import 声明非常重要，但大部分 Swift 开发者都只熟悉它的最基本用法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;#module#&gt;</span><br></pre></td></tr></table></figure><p>本周的 NSHipster 中，我们将探索 Swift 这个最重要的功能的其他用法。</p><hr><p>import 声明允许你的代码访问其他文件中声明的符号。但是，如果多个模块都声明了一个同名的函数或类型，那么编译器将无法判断你的代码到底想调用哪个。</p><p>为了演示这个问题，考虑 <a href="https://zh.wikipedia.org/wiki/三项全能" target="_blank" rel="noopener">铁人三项（Triathlon）</a> 和 <a href="https://zh.wikipedia.org/wiki/现代五项" target="_blank" rel="noopener">铁人五项（Pentathlon）</a> 这两个代表多运动比赛的模块:</p><p><dfn>铁人三项</dfn> 包括三个项目：游泳、自行车和跑步。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 铁人三项模块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swim</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🏊‍ Swim 1.5 km"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bike</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🚴 Cycle 40 km"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🏃‍ Run 10 km"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><dfn>铁人五项</dfn> 模块由五个项目组成：击剑、游泳、马术、射击和跑步。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 铁人五项模块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fence</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🤺 Bout with épées"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swim</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🏊‍ Swim 200 m"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ride</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🏇 Complete a show jumping course"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shoot</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🎯 Shoot 5 targets"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🏃‍ Run 3 km cross-country"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们单独 import 其中一个模块，我们可以通过它们的 <dfn>非限定（unqualified）</dfn>名称引用它们的每个函数，而不会出现问题。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Triathlon</span><br><span class="line"></span><br><span class="line">swim() <span class="comment">// 正确，调用 Triathlon.swim</span></span><br><span class="line">bike() <span class="comment">// 正确，调用 Triathlon.bike</span></span><br><span class="line">run() <span class="comment">// 正确，调用 Triathlon.run</span></span><br></pre></td></tr></table></figure><p>但是如果同时 import 两个模块，我们不能全部使用非限定函数名。铁人三项和五项都包括游泳和跑步，所以对 <code>swim()</code> 的引用是模糊的。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Triathlon</span><br><span class="line"><span class="keyword">import</span> Pentathlon</span><br><span class="line"></span><br><span class="line">bike() <span class="comment">// 正确，调用 Triathlon.bike</span></span><br><span class="line">fence() <span class="comment">// 正确，调用 Pentathlon.fence</span></span><br><span class="line">swim() <span class="comment">// 错误，模糊不清</span></span><br></pre></td></tr></table></figure><p>如何解决这个问题？一种策略是使用 <dfn>全限定名称（fully-qualified name）</dfn> 来处理任何不明确的引用。通过包含模块名称，程序是要在游泳池中游几圈，还是在开放水域中游一英里，就不存在混淆了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Triathlon</span><br><span class="line"><span class="keyword">import</span> Pentathlon</span><br><span class="line"></span><br><span class="line"><span class="type">Triathlon</span>.swim() <span class="comment">// 正确，指向 Triathlon.swim 的全限定引用</span></span><br><span class="line"><span class="type">Pentathlon</span>.swim() <span class="comment">// 正确，指向 Pentathlon.swim 的全限定引用</span></span><br></pre></td></tr></table></figure><p>解决 API 名称冲突的另一种方法是更改 import 声明，使其更加严格地挑选需要包含每个模块哪些的内容。</p><h2 id="import-单个声明"><a href="#import-单个声明" class="headerlink" title="import 单个声明"></a>import 单个声明</h2><p>import 声明提供了一种样式，可以指定引入定义在顶层（top-level）的单个结构体、类、枚举、协议和类型别名，以及函数、常量和变量。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;#kind#&gt; &lt;#module.symbol#&gt;</span><br></pre></td></tr></table></figure><p>这里，<code>&lt;#kind#&gt;</code> 可以为如下的任何关键字：</p><table><thead><tr><th>Kind</th><th>Description</th></tr></thead><tbody><tr><td><code>struct</code></td><td>结构体</td></tr><tr><td><code>class</code></td><td>类</td></tr><tr><td><code>enum</code></td><td>枚举</td></tr><tr><td><code>protocol</code></td><td>协议</td></tr><tr><td><code>typealias</code></td><td>类型别名</td></tr><tr><td><code>func</code></td><td>函数</td></tr><tr><td><code>let</code></td><td>常量</td></tr><tr><td><code>var</code></td><td>变量</td></tr></tbody></table><p>例如，下面的 import 声明只添加了 <code>Pentathlon</code> 模块的 <code>swim()</code> 函数:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> func Pentathlon.swim</span><br><span class="line"></span><br><span class="line">swim() <span class="comment">// 正确，调用 Pentathlon.swim</span></span><br><span class="line">fence() <span class="comment">// 错误，无法解析的标识</span></span><br></pre></td></tr></table></figure><h3 id="解决符号名称冲突"><a href="#解决符号名称冲突" class="headerlink" title="解决符号名称冲突"></a>解决符号名称冲突</h3><p>当代码中多个符号被同一个名字被引用时，Swift 编译器参考以下信息，按优先级顺序解析该引用:</p><ol><li>本地的声明</li><li>单个导入（import）的声明</li><li>整体导入的模块</li></ol><p>如果任何一个优先级有多个候选项，Swift 将无法解决歧义，进而引发编译错误。</p><p>例如，整体导入的 <code>Triathlon</code> 模块会提供 <code>swim()</code>、<code>bike()</code> 和 <code>run()</code> 方法，但从 <code>Pentathlon</code> 中单个导入的 <code>swim()</code> 函数声明会覆盖 <code>Triathlon</code> 模块中的对应函数。同样，本地声明的 <code>run()</code> 函数会覆盖 <code>Triathlon</code> 中的同名符号，也会覆盖任何单个导入的函数声明。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Triathlon</span><br><span class="line"><span class="keyword">import</span> func Pentathlon.swim</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地的函数会遮住整体导入的 Triathlon 模块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"🏃‍ Run 42.195 km"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swim() <span class="comment">// 正确，调用 Pentathlon.swim</span></span><br><span class="line">bike() <span class="comment">// 正确，调用 Triathlon.bike</span></span><br><span class="line">run() <span class="comment">//  正确，调用本地的 run</span></span><br></pre></td></tr></table></figure><p>那这个代码的运行结果是？一个古怪的多运动比赛，包括在一个泳池里游几圈的游泳，一个适度的自行车骑行，和一个马拉松跑。<em>(@ 我们, 钢铁侠)</em></p><blockquote><p>如果本地或者导入的声明，与模块的名字发生冲突，编译器首先查找声明，然后在模块中进行限定查找。</p></blockquote><blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">import</span> Triathlon</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">enum</span> <span class="title">Triathlon</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">case</span> sprint, olympic, ironman</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="type">Triathlon</span>.olympic <span class="comment">// 引用本地的枚举 case</span></span><br><span class="line">&gt; <span class="type">Triathlon</span>.swim() <span class="comment">// 引用模块的函数</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Swift编译器不会通知开发者，也无法协调模块和本地声明之间的命名冲突，因此使用依赖项时，你应该了解这种可能性。</p></blockquote><h3 id="澄清和缩小范围"><a href="#澄清和缩小范围" class="headerlink" title="澄清和缩小范围"></a>澄清和缩小范围</h3><p>除了解决命名冲突之外，import 声明还可以作为澄清程序员意图的一种方法。</p><p>例如，如果只使用 AppKit 这样大型框架中的一个函数，那么你可以在 import 声明中单独指定这个函数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> func AppKit.NSUserName</span><br><span class="line"></span><br><span class="line"><span class="type">NSUserName</span>() <span class="comment">// "jappleseed"</span></span><br></pre></td></tr></table></figure><p>顶层常量和变量的来源通常比其他的导入符号更难识别，在导入它们时，这个技术尤其有用。</p><p>例如，Darwin framework 提供的众多功能中，包含一个顶层的 <code>stderr</code> 变量。这里的一个显式 import 声明可以在代码评审时，提前避免该变量来源的任何疑问。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> func Darwin.fputs</span><br><span class="line"><span class="keyword">import</span> var Darwin.stderr</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StderrOutputStream</span>: <span class="title">TextOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(<span class="number">_</span> string: String)</span></span> &#123;</span><br><span class="line">        fputs(string, stderr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> standardError = <span class="type">StderrOutputStream</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Error!"</span>, to: &amp;standardError)</span><br></pre></td></tr></table></figure><h2 id="import-子模块"><a href="#import-子模块" class="headerlink" title="import 子模块"></a>import 子模块</h2><p>最后一种 import 声明样式，提供了另一种限制 API 暴露的方式。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;#module.submodule#&gt;</span><br></pre></td></tr></table></figure><p>你很可能在 AppKit 和 Accelerate 等大型的系统 framework 中遇到子模块。虽然这种 <dfn><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-97623-BAJJHAJC" target="_blank" rel="noopener">伞架构（umbrella framework）</a></dfn> 不再是一种最佳实践，但它们在 20 世纪初苹果向 Cocoa 过渡的过程中发挥了重要作用。</p><p>例如，你可以仅 import <a href="developer.apple.com/documentation/coreservices">Core Services framework</a> 的 <a href="/dictionary-services/">DictionaryServices</a> 子模块，从而将你的代码与无数已废弃的 API（如 Carbon Core）隔离开来。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CoreServices.DictionaryServices</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">define</span><span class="params">(<span class="number">_</span> word: String)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> nsstring = word <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">    <span class="keyword">let</span> cfrange = <span class="type">CFRange</span>(location: <span class="number">0</span>, length: nsstring.length)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> definition = <span class="type">DCSCopyTextDefinition</span>(<span class="literal">nil</span>, nsstring, cfrange) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(definition.takeUnretainedValue())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define(<span class="string">"apple"</span>) <span class="comment">// "apple | ˈapəl | noun 1 the round fruit of a tree..."</span></span><br></pre></td></tr></table></figure><p>事实上，单独导入的声明和子模块，除了澄清程序员的意图，并不能带来任何真正的好处。这种方式并不会让你的代码编译地更快。由于大部分的子模块似乎都会重新导入它们的伞头文件（umbrella header），因此这种方式也没法减少自动补全列表上的噪音。</p><hr><p>与许多晦涩难懂的高级主题一样，你之所以没有听说过这些 import 声明样式，很可能的是因为你不需要了解它们。如果你已经在没有它们的情况下开发了很多 APP，那么你完全有理由可以相信，你不需要开始使用它们。</p><p>相反，这里比较有价值的收获是理解 Swift 编译器如何解决命名冲突。为此，理解 import 声明是非常重要的。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      作为软件开发人员，我们学到的第一课是如何将概念和功能组织成独立的单元。但是，当命名空间冲突和声明隐藏在阴影时，会发生什么呢？
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>用结构体和元组构建更整洁的类</title>
    <link href="https://swift.gg/2019/09/20/2019-02-24-anonymous-tuple-structs/"/>
    <id>https://swift.gg/2019/09/20/2019-02-24-anonymous-tuple-structs/</id>
    <published>2019-09-20T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Benedikt Terhechte，<a href="https://appventure.me/posts/2019-02-24-anonymous-tuple-structs.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2019-02-24<br>译者：<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://bignerdcoding.com/" target="_blank" rel="noopener">BigNerdCoding</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>假设你正在开发一款社交网络应用，其中包含了一个带有关注按钮和点赞按钮的用户图片展示组件。同时，为了满足单一功能原则（single responsibility principle）和视图控制器的构成，<strong>点赞</strong>和<strong>关注</strong>的实现应该另有它处。社交网络不仅有高级账户，也有企业账户，因此 <code>InteractiveUserImageController</code>（命名从来不是我的强项） 要能满足一系列的配置选项。以下是这个类一个可能的实现（为作展示，示例代码保留了不少可改进的地方）：<br><a id="more"></a><br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InteractiveUserImageController</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 是否需要展示高级布局</span></span><br><span class="line">    <span class="keyword">var</span> isPremium: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 账户类型</span></span><br><span class="line">    <span class="keyword">var</span> accountType: <span class="type">AccountType</span></span><br><span class="line">    <span class="comment">/// 点击视图是否高亮</span></span><br><span class="line">    <span class="keyword">var</span> isHighlighted: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 用户名</span></span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line">    <span class="comment">/// 用户头像</span></span><br><span class="line">    <span class="keyword">var</span> profileImage: <span class="type">UIImage</span></span><br><span class="line">    <span class="comment">/// 当前用户是否能点赞该用户</span></span><br><span class="line">    <span class="keyword">var</span> canLike: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 当前用户是否能关注该用户</span></span><br><span class="line">    <span class="keyword">var</span> canFollow: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 大赞按钮是否能使用</span></span><br><span class="line">    <span class="keyword">var</span> bigLikeButton: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 针对一些内容使用特殊的背景色</span></span><br><span class="line">    <span class="keyword">var</span> alternativeBackgroundColor: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(...) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，我们就有了不少参数。随着应用体量的增长，会有更多的参数被加进类里。将这些参数通过职能进行划分和重构固然可行，但有时保持了单一功能后仍会有大量的参数存在。要如何才能更好的组织代码呢？</p><h2 id="Swift-结构体结构"><a href="#Swift-结构体结构" class="headerlink" title="Swift 结构体结构"></a>Swift 结构体结构</h2><p>Swift 的 <code>struct</code> 类型在这种情况能发挥巨大的作用。依据参数的类型将它们装进<strong>一次性</strong>结构体：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InteractiveUserImageController</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DisplayOptions</span> </span>&#123;</span><br><span class="line">        <span class="comment">/// 大赞按钮是否能使用</span></span><br><span class="line">        <span class="keyword">var</span> bigLikeButton: <span class="type">Bool</span></span><br><span class="line">        <span class="comment">/// 针对一些内容使用特殊的背景色</span></span><br><span class="line">        <span class="keyword">var</span> alternativeBackgroundColor: <span class="type">Bool</span></span><br><span class="line">        <span class="comment">/// 是否需要展示高级布局</span></span><br><span class="line">        <span class="keyword">var</span> isPremium: <span class="type">Bool</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UserOptions</span> </span>&#123;</span><br><span class="line">        <span class="comment">/// 账户类型</span></span><br><span class="line">        <span class="keyword">var</span> accountType: <span class="type">AccountType</span></span><br><span class="line">        <span class="comment">/// 用户名</span></span><br><span class="line">        <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line">        <span class="comment">/// 用户头像</span></span><br><span class="line">        <span class="keyword">var</span> profileImage: <span class="type">UIImage</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        <span class="comment">/// 点击视图是否高亮</span></span><br><span class="line">        <span class="keyword">var</span> isHighlighted: <span class="type">Bool</span></span><br><span class="line">        <span class="comment">/// 当前用户是否能点赞该用户</span></span><br><span class="line">        <span class="keyword">var</span> canLike: <span class="type">Bool</span></span><br><span class="line">        <span class="comment">/// 当前用户是否能关注该用户</span></span><br><span class="line">        <span class="keyword">var</span> canFollow: <span class="type">Bool</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> displayOptions = <span class="type">DisplayOptions</span>(...)</span><br><span class="line">    <span class="keyword">var</span> userOptions = <span class="type">UserOptions</span>(...)</span><br><span class="line">    <span class="keyword">var</span> state = <span class="type">State</span>(...)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(...) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所见，我们把这些状态放入了独立的 <code>struct</code> 类型中。不仅让类更整洁，也便于新上手的开发者找到相关联的选项。</p><p>已经是一个不错的改进了，但我们能做得更好！</p><p>我们面临的问题是查找一个参数需要额外的操作。</p><p>由于使用了一次性结构体类型，我们需要在某处定义它们（例如：<code>struct DisplayOptions</code>），也需要将它们实例化（例如：<code>let displayOptions = DisplayOptions(...)</code>）。大体上来说<strong>没什么问题</strong>，但在更大的类中，为确定 <code>displayOptions</code> 的类型仍旧需要一次额外的查询。然而，与 C 语言不同，像下面这样的匿名 <code>struct</code> 在 Swift 里并不存在：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> displayOptions = <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 大赞按钮是否能使用</span></span><br><span class="line">    <span class="keyword">var</span> bigLikeButton: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 针对一些内容使用特殊的背景色</span></span><br><span class="line">    <span class="keyword">var</span> alternativeBackgroundColor: <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// 是否需要展示高级布局</span></span><br><span class="line">    <span class="keyword">var</span> isPremium: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元组-–-匿名结构体在-Swift-中的实现"><a href="#元组-–-匿名结构体在-Swift-中的实现" class="headerlink" title="元组 – 匿名结构体在 Swift 中的实现"></a>元组 – 匿名结构体在 Swift 中的实现</h2><p>实际上，Swift 中还真有这么一个类型。它就是我们的老朋友，<code>tuple</code>。自己看吧：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> displayOptions: (</span><br><span class="line">  bigLikeButton: <span class="type">Bool</span>,</span><br><span class="line">  alternativeBackgroundColor: <span class="type">Bool</span>,</span><br><span class="line">  isPremium: <span class="type">Bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里定义了一个新的类型 <code>displayOptions</code>，带有三个参数（<code>bigLikeButton</code>，<code>alternativeBackgroundColor</code>，<code>isPremium</code>），它能像前面的 <code>struct</code> 一样被访问：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">user.displayOptions.alternativeBackgroundColor = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>更好的是，参数定义不需要做额外的初始化，一切都井然有序。</p><h2 id="强制不可变性"><a href="#强制不可变性" class="headerlink" title="强制不可变性"></a>强制不可变性</h2><p>最后，<code>tuple</code> 既可以是 <code>可变的</code> 也可以是 <code>不可变的</code>。正如你在第一行所看到的那样：我们定义的是 <code>var displayOptions</code> 而不是 <code>var</code> 或 <code>let</code> <code>bigLikeButton</code>。<code>bigLikeButton</code> 和 <code>displayOptions</code> 一样也是 <code>var</code>。这样做的好处在于强制把静态常量（例如行高，头部高度）放入一个不同的（<code>let</code>）组。</p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>当需要用一些值初始化参数时，你也能很好的利用这个特性，这是一个加分项：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> displayOptions = (</span><br><span class="line">  bigLikeButton: <span class="literal">true</span>,</span><br><span class="line">  alternativeBackgroundColor: <span class="literal">false</span>,</span><br><span class="line">  isPremium: <span class="literal">false</span>,</span><br><span class="line">  defaultUsername: <span class="string">"Anonymous"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>与之前的代码类似，这里定义了一个元组的选项集，同时将它们正确进行了初始化。</p><h2 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h2><p>相比于使用结构体而言，使用了元组的选项集能更轻易的简化代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserFollowComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> displayOptions = (</span><br><span class="line">        likeButton: (</span><br><span class="line">            bigButton: <span class="literal">true</span>,</span><br><span class="line">            alternativeBackgroundColor: <span class="literal">true</span></span><br><span class="line">            ),</span><br><span class="line">        imageView: (</span><br><span class="line">            highlightLineWidth: <span class="number">2.0</span>,</span><br><span class="line">            defaultColor: <span class="string">"#33854"</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我希望这篇文章会对你有帮助。我大量应用这些简单的模式来让代码更具结构化。即便是只对 2 - 3 个参数做这样的处理，也能从中获益。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文描述了如何巧妙利用结构体与元组来结构化类。
    
    </summary>
    
      <category term="APPVENTURE" scheme="https://swift.gg/categories/APPVENTURE/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>千呼万唤始出来☑️：SwiftWebUI</title>
    <link href="https://swift.gg/2019/09/12/swiftwebui/"/>
    <id>https://swift.gg/2019/09/12/swiftwebui/</id>
    <published>2019-09-12T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：The Always Right Institute，<a href="http://www.alwaysrightinstitute.com/swiftwebui/" target="_blank" rel="noopener">原文链接</a>，原文日期：2019-06-30<br>译者：<a href="https://github.com/Ji4n1ng" target="_blank" rel="noopener">Ji4n1ng</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><hr><!--此处开始正文--><p>六月初，Apple 在 <a href="https://developer.apple.com/wwdc19/" target="_blank" rel="noopener">WWDC 2019</a> 上发布了 <a href="https://developer.apple.com/xcode/swiftui/" target="_blank" rel="noopener">SwiftUI</a>。SwiftUI 是一个“跨平台的”、“声明式”框架，用于构建 tvOS、macOS、watchOS 和 iOS 上的用户界面。<a href="https://github.com/SwiftWebUI/SwiftWebUI" target="_blank" rel="noopener">SwiftWebUI</a> 则将它带到了 Web 平台上✔️。</p><a id="more"></a><p><strong>免责声明</strong>：这是一个玩具项目！不要用于生产。使用 SwiftWebUI 是为了了解更多关于 SwiftUI 本身及其内部工作原理的信息。</p><h2 id="SwiftWebUI"><a href="#SwiftWebUI" class="headerlink" title="SwiftWebUI"></a>SwiftWebUI</h2><p>那么究竟什么是 <a href="https://github.com/SwiftWebUI/SwiftWebUI" target="_blank" rel="noopener">SwiftWebUI</a>？它允许你编写可以在 Web 浏览器中显示的 SwiftUI 的 <a href="https://developer.apple.com/documentation/swiftui/view" target="_blank" rel="noopener">视图</a>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftWebUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MainPage</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  @<span class="type">State</span> <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">countUp</span><span class="params">()</span></span> &#123; counter += <span class="number">1</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">      <span class="type">Text</span>(<span class="string">"🥑🍞 #\(counter)"</span>)</span><br><span class="line">        .padding(.all)</span><br><span class="line">        .background(.green, cornerRadius: <span class="number">12</span>)</span><br><span class="line">        .foregroundColor(.white)</span><br><span class="line">        .tapAction(<span class="keyword">self</span>.countUp)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/AvocadoCounter/AvocadoCounter.gif" alt></p><p>与其他一些工作不同，SwiftWebUI 不仅仅是将 SwiftUI 视图渲染为 HTML，而且还在浏览器和 Swift 服务器中托管的代码之间建立了一个连接，这样就可以实现各种交互功能——按钮、选择器、步进器、列表、导航等，这些都可以做到！</p><p>换句话说：<a href="https://github.com/SwiftWebUI/SwiftWebUI" target="_blank" rel="noopener">SwiftWebUI</a> 是针对浏览器的 SwiftUI API（很多部分但不是所有）的一种实现。</p><p>再次进行<strong>免责声明</strong>：这是一个玩具项目！不要用于生产。使用 SwiftWebUI 是为了了解更多关于 SwiftUI 本身及其内部工作原理的信息。</p><h2 id="学习一次，随处使用"><a href="#学习一次，随处使用" class="headerlink" title="学习一次，随处使用"></a>学习一次，随处使用</h2><p>SwiftUI 的既定目标不是“<a href="https://en.wikipedia.org/wiki/Write_once,_run_anywhere" target="_blank" rel="noopener">编写一次，随处运行</a>”，而是“<a href="https://developer.apple.com/videos/play/wwdc2019/216" target="_blank" rel="noopener">学习一次，随处使用</a>”。不要期望在 iOS 上开发了一个漂亮的 SwiftUI 应用程序，然后将它的代码放入 SwiftWebUI 项目中，并让它在浏览器中呈现完全相同的内容。这不是我们的重点。</p><p>关键是能够重用 SwiftUI 的原理并使其在不同平台之间共享。在这种情况下，SwiftWebUI 就达到目的了✔️。</p><p>但是先让我们深入了解一下细节，并编写一个简单的 SwiftWebUI 应用程序。本着“学习一次，随处使用”的精神，首先观看这两个 WWDC 演讲：<a href="https://developer.apple.com/videos/play/wwdc2019/204/" target="_blank" rel="noopener">介绍 SwiftUI</a> 和 <a href="https://developer.apple.com/videos/play/wwdc2019/216" target="_blank" rel="noopener">SwiftUI 要点</a>。本文不会过多的深入数据流有关的内容，但这篇演讲同样推荐观看（这些概念在 SwiftWebUI 中被广泛支持）：<a href="https://developer.apple.com/videos/play/wwdc2019/226" target="_blank" rel="noopener">SwiftUI 中的数据流</a>。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>到目前为止，SwiftWebUI 需要安装 <a href="https://www.apple.com/macos/catalina-preview/" target="_blank" rel="noopener">macOS Catalina</a> 来运行（“Swift ABI”🤦‍♀️）。幸运的是，将 <a href="https://support.apple.com/en-us/HT208891" target="_blank" rel="noopener">Catalina 安装在单独的 APFS 卷</a> 上非常容易。并且需要安装 <a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener">Xcode 11</a> 才能获得在 SwiftUI 中大量使用的 Swift 5.1 新功能。明白了吗？很好！</p><blockquote><p>Linux 呢？这个项目确实准备在 Linux 上运行，但尚未完成。唯一还没完成的事情是对 <a href="https://developer.apple.com/documentation/combine/passthroughsubject" target="_blank" rel="noopener">Combine PassthroughSubject</a> 的简单实现以及围绕它的一些基础设施。准备：<a href="https://github.com/SwiftWebUI/SwiftWebUI/blob/master/Sources/SwiftWebUI/Misc/NoCombine.swift" target="_blank" rel="noopener">NoCombine</a>。欢迎来提 PR！</p></blockquote><blockquote><p>Mojave 呢？有一个可以在 Mojave 和 Xcode 11 上运行的办法。你需要创建一个 iOS 13 模拟器项目并在其中运行整个项目。</p></blockquote><h2 id="开始第一个应用程序"><a href="#开始第一个应用程序" class="headerlink" title="开始第一个应用程序"></a>开始第一个应用程序</h2><h3 id="创建-SwiftWebUI-项目"><a href="#创建-SwiftWebUI-项目" class="headerlink" title="创建 SwiftWebUI 项目"></a>创建 SwiftWebUI 项目</h3><p>启动 Xcode 11，选择“File &gt; New &gt; Project…”或按 Cmd-Shift-N：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/1-new-project.png" alt></p><p>选择“macOS / Command Line Tool”项目模板:</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/2-new-cmdline-tool.png" alt></p><p>给它取个好听的名字，用“AvocadoToast”吧：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/3-swift-project-name.png" alt></p><p>然后，添加 <a href="https://github.com/SwiftWebUI/SwiftWebUI" target="_blank" rel="noopener">SwiftWebUI</a> 作为 Swift Package Manager 的依赖项。该选项隐藏在“File / Swift Packages”菜单中：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/4-add-pkg-dep.png" alt></p><p>输入 <code>https://github.com/SwiftWebUI/SwiftWebUI.git</code> 作为包的 URL：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/5-add-swui-dep-large.png" alt></p><p>使用“Branch” <code>master</code> 选项，以便于总能获得最新和最好的版本（也可以使用修订版或 <code>develop</code> 分支）:</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/6-branch-select-large.png" alt></p><p>最后，将 SwiftWebUI 库添加到你的工具的 <code>target</code> 中:</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/ProjectSetup/7-target-select-large.png" alt></p><p>这就完成了创建。你现在有了一个可以导入 SwiftWebUI 的工具项目。（Xcode 可能需要一些时间来获取和构建依赖。）</p><h3 id="SwiftWebUI-Hello-World"><a href="#SwiftWebUI-Hello-World" class="headerlink" title="SwiftWebUI Hello World"></a>SwiftWebUI Hello World</h3><p>让我们开始使用 SwiftWebUI。打开 <code>main.swift</code> 文件，将其内容替换为：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftWebUI</span><br><span class="line"></span><br><span class="line"><span class="type">SwiftWebUI</span>.serve(<span class="type">Text</span>(<span class="string">"Holy Cow!"</span>))</span><br></pre></td></tr></table></figure><p>在 Xcode 中编译并运行该应用程序，打开 Safari，然后访问 <a href="http://localhost:1337/" target="_blank" rel="noopener"><code>http://localhost:1337/</code></a>：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/HolyCow/holycow.png" alt></p><p>这里发生了什么：首先导入 SwiftWebUI 模块（不要意外导入 macOS SwiftUI 😀）。</p><p>然后我们调用了 <code>SwiftWebUI.serve</code>，它要么接受一个返回视图的闭包，要么就直接是一个视图——如下所示：一个 <a href="https://developer.apple.com/documentation/swiftui/text" target="_blank" rel="noopener"><code>Text</code></a> 视图（也称为“UILabel”，它可以显示纯文本或格式化的文本）。</p><h4 id="幕后发生的事情"><a href="#幕后发生的事情" class="headerlink" title="幕后发生的事情"></a>幕后发生的事情</h4><p>在内部，<a href="https://github.com/SwiftWebUI/SwiftWebUI/blob/master/Sources/SwiftWebUI/ViewHosting/Serve.swift#L66" target="_blank" rel="noopener"><code>serve</code></a> 函数创建一个非常简单的 <a href="https://github.com/apple/swift-nio" target="_blank" rel="noopener">SwiftNIO</a> HTTP 服务器，它将会监听 1337 端口。当浏览器访问该服务器时，它会创建一个 <a href="https://github.com/SwiftWebUI/SwiftWebUI/blob/master/Sources/SwiftWebUI/ViewHosting/NIOHostingSession.swift" target="_blank" rel="noopener">session</a>（会话）并将（Text）视图传递给该会话。</p><p>最后，SwiftWebUI 在服务器上根据这个视图来创建一个“Shadow DOM”，将其渲染为 HTML 并将结果发送到浏览器。“Shadow DOM”（和状态对象保持在一起）存储在会话中。</p><blockquote><p>这是 SwiftWebUI 应用程序与 watchOS 或 iOS SwiftUI 应用程序之间的区别。单个 SwiftWebUI 应用程序为一组用户提供服务，而不仅仅是一个用户。</p></blockquote><h3 id="添加一些交互"><a href="#添加一些交互" class="headerlink" title="添加一些交互"></a>添加一些交互</h3><p>第一步，更好地组织代码。在项目中创建一个新的 Swift 文件，并将其命名为 <code>MainPage.swift</code>。然后向其中添加一个简单的 SwiftUI 视图的定义：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftWebUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MainPage</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Holy Cow!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>main.swift</code> 来让 SwiftWebUI 作用于我们的定制视图:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SwiftWebUI</span>.serve(<span class="type">MainPage</span>())</span><br></pre></td></tr></table></figure><p>现在，可以把 <code>main.swift</code> 放到一边，在自定义视图中完成所有工作。添加一些交互：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MainPage</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  @<span class="type">State</span> <span class="keyword">var</span> counter = <span class="number">3</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">countUp</span><span class="params">()</span></span> &#123; counter += <span class="number">1</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Count is: \(counter)"</span>)</span><br><span class="line">      .tapAction(<span class="keyword">self</span>.countUp)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/swiftui/view" target="_blank" rel="noopener"><code>视图</code></a> 有了一个名为 counter 的持久 <a href="https://developer.apple.com/documentation/swiftui/state" target="_blank" rel="noopener">状态</a> 变量（不知道这是什么？再看一下 SwiftUI 的介绍）。还有一个可以使计数器加一的小函数。</p><p>然后，使用 SwiftUI <a href="https://developer.apple.com/documentation/swiftui/text/3086357-tapaction" target="_blank" rel="noopener"><code>tapAction</code></a> 修饰符将事件处理程序附加到 <code>Text</code>。最后，在标签中显示当前值：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/HolyCow/ClickCounter.gif" alt></p><p>🧙<em>魔法</em>🧙</p><h4 id="幕后发生的事情-1"><a href="#幕后发生的事情-1" class="headerlink" title="幕后发生的事情"></a>幕后发生的事情</h4><p>这是如何运作的？当浏览器访问端点时，SwiftWebUI 在其中创建了会话和“Shadow DOM”。然后将描述视图的 HTML 发送到浏览器。<code>tapAction</code> 通过向 HTML 添加 <code>onclick</code> 处理程序来工作。SwiftWebUI 还向浏览器发送 JavaScript（少量，没有大的 JavaScript 框架！），处理点击并将其转发到 Swift 服务器。</p><p>然后 SwiftUI 的魔法开始生效。SwiftWebUI 将 click 事件与“Shadow DOM”中的事件处理程序相关联，并调用 <code>countUp</code> 函数。该函数通过修改 <code>counter</code> <a href="https://developer.apple.com/documentation/swiftui/state" target="_blank" rel="noopener"><code>状态</code></a> 变量，使视图的渲染无效。SwiftWebUI 开始工作，并对“Shadow DOM”中的变更进行差异比较。然后将这些变更发送回浏览器。</p><blockquote><p>“变更”作为 JSON 数组发送，页面中的小型 JavaScript 可以处理这些数组。如果整个子树发生了变化（例如，如果用户导航到一个全新的视图），则变更可以是应用于 <code>innerHTML</code> 或 <code>outerHTML</code> 的更大的 HTML 片段。</p><p>但通常情况下，这些变更都很小，例如 <code>添加类</code>，<code>设置 HTML 属性</code> 等（即浏览器 DOM 修改）。</p></blockquote><h2 id="🥑🍞-Avocado-Toast"><a href="#🥑🍞-Avocado-Toast" class="headerlink" title="🥑🍞 Avocado Toast"></a>🥑🍞 Avocado Toast</h2><p>太好了，基础的部分可以正常工作了。让我们引入更多的交互。以下是基于 <a href="https://developer.apple.com/videos/play/wwdc2019/216" target="_blank" rel="noopener">SwiftUI 要点</a> 演讲中演示 SwiftUI 的“Avocado Toast App”。没看过吗？你应该看看，讲的是美味的吐司。</p><blockquote><p>HTML / CSS 样式不漂亮也不完美。你知道，我们不是网页设计师，而且需要帮助。欢迎来提交 PR！</p></blockquote><p>想要跳过细节，观看应用程序的 GIF 并在 GitHub 上下载：<a href="http://www.alwaysrightinstitute.com/swiftwebui/#the--finished-app" target="_blank" rel="noopener">🥑🍞</a>。</p><h3 id="🥑🍞订单"><a href="#🥑🍞订单" class="headerlink" title="🥑🍞订单"></a>🥑🍞订单</h3><p>谈话从这（~6:00）开始，可以将这些代码添加到新的 <code>OrderForm.swift</code> 文件中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> includeSalt            = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> includeRedPepperFlakes = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> quantity               = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OrderForm</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> order = <span class="type">Order</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">submitOrder</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">      <span class="type">Text</span>(<span class="string">"Avocado Toast"</span>).font(.title)</span><br><span class="line">      </span><br><span class="line">      <span class="type">Toggle</span>(isOn: $order.includeSalt) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Include Salt"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Toggle</span>(isOn: $order.includeRedPepperFlakes) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Include Red Pepper Flakes"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Stepper</span>(value: $order.quantity, <span class="keyword">in</span>: <span class="number">1</span>...<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Quantity: \(order.quantity)"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="type">Button</span>(action: submitOrder) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Order"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>main.swift</code> 中直接用 <code>SwiftWebUI.serve()</code> 测试新的 <code>OrderForm</code> 视图。</p><p>这就是浏览器中的样子：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/AvocadoOrder/orderit.gif" alt></p><blockquote><p><a href="https://semantic-ui.com/" target="_blank" rel="noopener">SemanticUI</a> 用于在 SwiftWebUI 中设置一些样式。SemanticUI 并不是必须的，这里只是用它的控件来美化界面。</p><p>注意：仅使用 CSS 和字体，而不是 JavaScript 组件。</p></blockquote><h3 id="幕间休息：一些-SwiftUI-布局"><a href="#幕间休息：一些-SwiftUI-布局" class="headerlink" title="幕间休息：一些 SwiftUI 布局"></a>幕间休息：一些 SwiftUI 布局</h3><p>在 <a href="https://developer.apple.com/videos/play/wwdc2019/216" target="_blank" rel="noopener">SwiftUI 要点</a> 演讲的 16:00 左右，他们将介绍 SwiftUI 布局和视图修改器排序：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">  <span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"🥑🍞"</span>)</span><br><span class="line">      .background(.green, cornerRadius: <span class="number">12</span>)</span><br><span class="line">      .padding(.all)</span><br><span class="line">    </span><br><span class="line">    <span class="type">Text</span>(<span class="string">" =&gt; "</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="type">Text</span>(<span class="string">"🥑🍞"</span>)</span><br><span class="line">      .padding(.all)</span><br><span class="line">      .background(.green, cornerRadius: <span class="number">12</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下，请注意修饰符的排序是如何相关的：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/AvocadoLayout.png" alt></p><blockquote><p>SwiftWebUI 尝试复制常见的 SwiftUI 布局，但还没有完全成功。毕竟它必须处理浏览器提供的布局系统。需要帮助，欢迎弹性盒布局相关的专家！</p></blockquote><h3 id="🥑🍞订单历史"><a href="#🥑🍞订单历史" class="headerlink" title="🥑🍞订单历史"></a>🥑🍞订单历史</h3><p>回到应用程序，演讲（~19:50）介绍了 <a href="https://developer.apple.com/documentation/swiftui/list" target="_blank" rel="noopener">列表</a> 视图，用于显示 Avocado toast 订单历史记录。这就是它在 Web 上的外观：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/OrderHistory/OrderHistory1.png" alt></p><p><code>列表</code> 视图遍历已完成订单的数组，并为每个订单创建一个子视图（<code>OrderCell</code>），并传入列表中的当前项。</p><p>这是我们使用的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OrderHistory</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> previousOrders : [ <span class="type">CompletedOrder</span> ]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">List</span>(previousOrders) &#123; order <span class="keyword">in</span></span><br><span class="line">      <span class="type">OrderCell</span>(order: order)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OrderCell</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> order : <span class="type">CompletedOrder</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">HStack</span> &#123;</span><br><span class="line">      <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">        <span class="type">Text</span>(order.summary)</span><br><span class="line">        <span class="type">Text</span>(order.purchaseDate)</span><br><span class="line">          .font(.subheadline)</span><br><span class="line">          .foregroundColor(.secondary)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Spacer</span>()</span><br><span class="line">      <span class="keyword">if</span> order.includeSalt &#123;</span><br><span class="line">        <span class="type">SaltIcon</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">      <span class="keyword">if</span> order.includeRedPepperFlakes &#123;</span><br><span class="line">        <span class="type">RedPepperFlakesIcon</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SaltIcon</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> body = <span class="type">Text</span>(<span class="string">"🧂"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedPepperFlakesIcon</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> body = <span class="type">Text</span>(<span class="string">"🌶"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Model</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CompletedOrder</span>: <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id           : <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> summary      : <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> purchaseDate : <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> includeSalt            = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> includeRedPepperFlakes = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SwiftWebUI 列表视图效率很低，它总是呈现整个子集合。没有单元格重用，什么都没有😎。在一个网络应用程序中有各种各样的方法来处理这个问题，例如使用分页或更多客户端逻辑。</p></blockquote><p>你不必手动输入演讲中的样本数据，我们为你提供了这些数据：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> previousOrders : [ <span class="type">CompletedOrder</span> ] = [</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">1</span>, summary: <span class="string">"Rye with Almond Butter"</span>,  purchaseDate: <span class="string">"2019-05-30"</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">2</span>, summary: <span class="string">"Multi-Grain with Hummus"</span>, purchaseDate: <span class="string">"2019-06-02"</span>,</span><br><span class="line">        includeRedPepperFlakes: <span class="literal">true</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">3</span>, summary: <span class="string">"Sourdough with Chutney"</span>,  purchaseDate: <span class="string">"2019-06-08"</span>,</span><br><span class="line">        includeSalt: <span class="literal">true</span>, includeRedPepperFlakes: <span class="literal">true</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">4</span>, summary: <span class="string">"Rye with Peanut Butter"</span>,  purchaseDate: <span class="string">"2019-06-09"</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">5</span>, summary: <span class="string">"Wheat with Tapenade"</span>,     purchaseDate: <span class="string">"2019-06-12"</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">6</span>, summary: <span class="string">"Sourdough with Vegemite"</span>, purchaseDate: <span class="string">"2019-06-14"</span>,</span><br><span class="line">        includeSalt: <span class="literal">true</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">7</span>, summary: <span class="string">"Wheat with Féroce"</span>,       purchaseDate: <span class="string">"2019-06-31"</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">8</span>, summary: <span class="string">"Rhy with Honey"</span>,          purchaseDate: <span class="string">"2019-07-03"</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id:  <span class="number">9</span>, summary: <span class="string">"Multigrain Toast"</span>,        purchaseDate: <span class="string">"2019-07-04"</span>,</span><br><span class="line">        includeSalt: <span class="literal">true</span>),</span><br><span class="line">  .<span class="keyword">init</span>(id: <span class="number">10</span>, summary: <span class="string">"Sourdough with Chutney"</span>,  purchaseDate: <span class="string">"2019-07-06"</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="🥑🍞涂抹酱选择器"><a href="#🥑🍞涂抹酱选择器" class="headerlink" title="🥑🍞涂抹酱选择器"></a>🥑🍞涂抹酱选择器</h3><p>选择器控件以及如何将它与枚举一起使用将在（~43:00）进行演示。首先是各种吐司选项的枚举：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AvocadoStyle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> sliced, mashed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BreadType</span>: <span class="title">CaseIterable</span>, <span class="title">Hashable</span>, <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> wheat, white, rhy</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"\(self)"</span>.capitalized &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Spread</span>: <span class="title">CaseIterable</span>, <span class="title">Hashable</span>, <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">none</span>, almondButter, peanutButter, honey</span><br><span class="line">  <span class="keyword">case</span> almou, tapenade, hummus, mayonnaise</span><br><span class="line">  <span class="keyword">case</span> kyopolou, adjvar, pindjur</span><br><span class="line">  <span class="keyword">case</span> vegemite, chutney, cannedCheese, feroce</span><br><span class="line">  <span class="keyword">case</span> kartoffelkase, tartarSauce</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"\(self)"</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span>.isUppercase ? <span class="string">" \($0)"</span> : <span class="string">"\($0)"</span> &#125;</span><br><span class="line">           .joined().capitalized</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将这些代码添加到 <code>Order</code> 结构体中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> includeSalt            = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> includeRedPepperFlakes = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> quantity               = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> avocadoStyle           = <span class="type">AvocadoStyle</span>.sliced</span><br><span class="line">  <span class="keyword">var</span> spread                 = <span class="type">Spread</span>.<span class="keyword">none</span></span><br><span class="line">  <span class="keyword">var</span> breadType              = <span class="type">BreadType</span>.wheat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用不同的选择器类型来显示它们。如何循环枚举值非常简单：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Form</span> &#123;</span><br><span class="line">  <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"Avocado Toast"</span>).font(.title)) &#123;</span><br><span class="line">    <span class="type">Picker</span>(selection: $order.breadType, label: <span class="type">Text</span>(<span class="string">"Bread"</span>)) &#123;</span><br><span class="line">      <span class="type">ForEach</span>(<span class="type">BreadType</span>.allCases) &#123; breadType <span class="keyword">in</span></span><br><span class="line">        <span class="type">Text</span>(breadType.name).tag(breadType)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .pickerStyle(.radioGroup)</span><br><span class="line">    </span><br><span class="line">    <span class="type">Picker</span>(selection: $order.avocadoStyle, label: <span class="type">Text</span>(<span class="string">"Avocado"</span>)) &#123;</span><br><span class="line">      <span class="type">Text</span>(<span class="string">"Sliced"</span>).tag(<span class="type">AvocadoStyle</span>.sliced)</span><br><span class="line">      <span class="type">Text</span>(<span class="string">"Mashed"</span>).tag(<span class="type">AvocadoStyle</span>.mashed)</span><br><span class="line">    &#125;</span><br><span class="line">    .pickerStyle(.radioGroup)</span><br><span class="line">    </span><br><span class="line">    <span class="type">Picker</span>(selection: $order.spread, label: <span class="type">Text</span>(<span class="string">"Spread"</span>)) &#123;</span><br><span class="line">      <span class="type">ForEach</span>(<span class="type">Spread</span>.allCases) &#123; spread <span class="keyword">in</span></span><br><span class="line">        <span class="type">Text</span>(spread.name).tag(spread) <span class="comment">// there is no .name?!</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/AvocadoOrder/picker.png" alt></p><blockquote><p>同样，这需要一些对 CSS 的热爱来让它看起来更好看…</p></blockquote><h3 id="完成后的🥑🍞应用"><a href="#完成后的🥑🍞应用" class="headerlink" title="完成后的🥑🍞应用"></a>完成后的🥑🍞应用</h3><p>不，我们与原版略有不同，也没有真正完成应用。它看起来并不那么棒，但毕竟只是一个演示示例😎。</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/AvocadoOrder/AvocadoToast.gif" alt></p><p>完成后的应用程序可在GitHub：<a href="https://github.com/SwiftWebUI/AvocadoToast" target="_blank" rel="noopener">AvocadoToast</a> 上获取。</p><h2 id="HTML-和-SemanticUI"><a href="#HTML-和-SemanticUI" class="headerlink" title="HTML 和 SemanticUI"></a>HTML 和 SemanticUI</h2><p><a href="https://developer.apple.com/documentation/swiftui/uiviewrepresentable" target="_blank" rel="noopener"><code>UIViewRepresentable</code></a> 在 SwiftWebUI 中对应的实现，是直接使用原始 HTML。</p><p>它提供了两种变体，一种是 HTML 按原样输出字符串，另一种是通过 HTML 转义内容：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyHTMLView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">      <span class="type">HTML</span>(<span class="string">"&lt;blink&gt;Blinken Lights&lt;/blink&gt;"</span>)</span><br><span class="line">      <span class="type">HTML</span>(<span class="string">"42 &gt; 1337"</span>, escape: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个原语，基本上可以构建所需的任何 HTML。</p><p>还有一种更高级的用法是 HTMLContainer，SwiftWebUI 内部也用到了它。例如，这是步进器控件的实现：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">  <span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">HTMLContainer</span>(classes: [ <span class="string">"ui"</span>, <span class="string">"icon"</span>, <span class="string">"buttons"</span>, <span class="string">"small"</span> ]) &#123;</span><br><span class="line">      <span class="type">Button</span>(<span class="keyword">self</span>.decrement) &#123;</span><br><span class="line">        <span class="type">HTMLContainer</span>(<span class="string">"i"</span>, classes: [ <span class="string">"minus"</span>, <span class="string">"icon"</span> ], body: &#123;<span class="type">EmptyView</span>()&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Button</span>(<span class="keyword">self</span>.increment) &#123;</span><br><span class="line">        <span class="type">HTMLContainer</span>(<span class="string">"i"</span>, classes: [ <span class="string">"plus"</span>, <span class="string">"icon"</span> ], body: &#123;<span class="type">EmptyView</span>()&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    label</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTMLContainer 是“响应式的”，即如果类、样式或属性发生变化，它将触发（emit）常规 DOM 变更（而不是重新渲染整个内容）。</p><h3 id="SemanticUI"><a href="#SemanticUI" class="headerlink" title="SemanticUI"></a>SemanticUI</h3><p>SwiftWebUI 还附带了一些预先设置的 <a href="https://semantic-ui.com/" target="_blank" rel="noopener">SemanticUI</a> 控件：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">  <span class="type">SUILabel</span>(<span class="type">Image</span>(systemName: <span class="string">"mail"</span>)) &#123; <span class="type">Text</span>(<span class="string">"42"</span>) &#125;</span><br><span class="line">  <span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">SUILabel</span>(<span class="type">Image</span>(...)) &#123; <span class="type">Text</span>(<span class="string">"Joe"</span>) &#125; ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">SUILabel</span>(<span class="type">Image</span>(...)) &#123; <span class="type">Text</span>(<span class="string">"Joe"</span>) &#125; ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">SUILabel</span>(<span class="type">Image</span>(...), <span class="type">Color</span>(<span class="string">"blue"</span>), </span><br><span class="line">             detail: <span class="type">Text</span>(<span class="string">"Friend"</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">Text</span>(<span class="string">"Veronika"</span>)</span><br><span class="line">    &#125; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>……渲染为如下内容：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/SemanticUI/labels.png" alt></p><blockquote><p>请注意，SwiftWebUI 还支持一些 SFSymbols 图像名称（通过 <code>Image(systemName:)</code> 来使用）。这些都得到了 SemanticUI <a href="https://semantic-ui.com/elements/icon.html" target="_blank" rel="noopener">对 Font Awesome 的支持</a>。</p></blockquote><p>还有 <code>SUISegment</code>，<code>SUIFlag</code> 和 <code>SUICARD</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SUICards</span> &#123;</span><br><span class="line">  <span class="type">SUICard</span>(<span class="type">Image</span>.unsplash(size: <span class="type">UXSize</span>(width: <span class="number">200</span>, height: <span class="number">200</span>),</span><br><span class="line">                         <span class="string">"Zebra"</span>, <span class="string">"Animal"</span>),</span><br><span class="line">          <span class="type">Text</span>(<span class="string">"Some Zebra"</span>),</span><br><span class="line">          meta: <span class="type">Text</span>(<span class="string">"Roaming the world since 1976"</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"A striped animal."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">SUICard</span>(<span class="type">Image</span>.unsplash(size: <span class="type">UXSize</span>(width: <span class="number">200</span>, height: <span class="number">200</span>),</span><br><span class="line">                         <span class="string">"Cow"</span>, <span class="string">"Animal"</span>),</span><br><span class="line">          <span class="type">Text</span>(<span class="string">"Some Cow"</span>),</span><br><span class="line">          meta: <span class="type">Text</span>(<span class="string">"Milk it"</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Holy cow!."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>……渲染为这些内容：</p><p><img src="http://www.alwaysrightinstitute.com/images/swiftwebui/SemanticUI/cards.png" alt></p><p>添加此类视图非常简单，也非常有趣。可以使用 <del>WOComponent</del> 的 SwiftUI 视图来快速构建相当复杂和美观的布局。</p><blockquote><p><code>Image.unsplash</code> 根据 <code>http://source.unsplash.com</code> 上运行的 Unsplash API 来构建图像的查询。只需给它一些查询词、大小和可选范围。</p><p>注意：有时，特定的 Unsplash 服务似乎有点慢且不可靠。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这就是我们的演示示例。我们希望你能喜欢！但要再次进行<strong>免责声明</strong>：这是一个玩具项目！不要用于生产。使用 SwiftWebUI 是为了了解更多关于 SwiftUI 本身及其内部工作原理的信息。</p><p>我们认为它是一个很好的玩具，可能也是一个有价值的工具，以便于更多地了解 SwiftUI 的内部工作原理。</p><h2 id="技术随记"><a href="#技术随记" class="headerlink" title="技术随记"></a>技术随记</h2><p>这些只是关于该技术的各个方面的一些笔记。可以跳过，这个不是那么的有趣😎。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>SwiftWebUI 有很多问题，有些是在 GitHub 上提出的：<a href="https://github.com/SwiftWebUI/SwiftWebUI/issues" target="_blank" rel="noopener">Issues</a>。欢迎来提更多问题。</p><p>相当多的 HTML 布局的东西有问题（例如 <code>ScrollView</code> 并不总是滚动的），还有一些像 Shapes 这样的正在讨论方案的功能也有问题（可能通过 SVG 和 CSS 很容易做到）。</p><p>哦，还有一个例子是 If-ViewBuilder 不能正常工作。不明白为什么：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">  <span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">      <span class="type">SomeView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// currently need an empty else: `else &#123;&#125;` to make it compile.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要帮忙！欢迎来提交 PR！</p><h3 id="与原来的-SwiftUI-相比"><a href="#与原来的-SwiftUI-相比" class="headerlink" title="与原来的 SwiftUI 相比"></a>与原来的 SwiftUI 相比</h3><p>本文的实现非常简单且效率低下。在现实情况下，必须以更高的速率来处理状态修改事件，以 60Hz 的帧速率做所有的动画等等。</p><p>我们侧重于使基本操作正确，例如状态和绑定如何工作，视图如何以及何时更新等等。很可能本文的实现在某些方面并不正确，可能是因为 Apple 忘了将原始资源作为 Xcode 11 的一部分发送给我们。</p><h3 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h3><p>我们目前使用 AJAX 将浏览器连接到服务器。使用 WebSockets 有多种优势：</p><ul><li>保证了事件的顺序（AJAX 请求可能不同步到达）</li><li>非用户发起的服务器端 DOM 更新（定时器、推送）</li><li>会话超时指示器</li></ul><p>这会让实现一个聊天客户端的演示示例变得非常容易。</p><p>添加 WebSockets 实际上非常简单，因为事件已经作为 JSON 发送了。我们只需要客户端和服务器端的垫片（shims）。所有这些都已经在 <a href="https://github.com/NozeIO/swift-nio-irc-webclient" target="_blank" rel="noopener">swift-nio-irc-webclient</a> 中试用过了，只需要移植一下。</p><h3 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h3><p>SwiftWebUI 的当前版本是一个连接到有状态后端服务器的 SPA（单页面应用程序）。</p><p>还有其他方法可以做到这一点，例如，当用户通过正常的链接遍历应用程序时，保持树的状态。又名 WebObjects。;-)</p><p>一般来说，最好能更好地控制 DOM ID 生成、链接生成以及路由等等。这和 <a href="http://swiftobjects.org/" target="_blank" rel="noopener">SwiftObjects</a> 所提供的方式类似。</p><p>但是最终用户将不得不放弃很多本可以“学习一次，随处使用”的功能，因为 SwiftUI 操作处理程序通常是围绕着捕捉任意状态的事实来构建的。</p><p>我们将会期待基于 Swift 的服务器端框架提出什么更好的东西来👽。</p><h3 id="WASM"><a href="#WASM" class="headerlink" title="WASM"></a>WASM</h3><p>一旦我们找到合适的 Swift WASM（WebAssembly），SwiftWebUI 就会更有用处。期待 WASM！</p><h3 id="WebIDs"><a href="#WebIDs" class="headerlink" title="WebIDs"></a>WebIDs</h3><p>有些像 <code>ForEach</code> 这样的 SwiftUI 视图需要 <code>Identifiable</code> 对象，其中的 <code>id</code> 可以是任何 <code>Hashable</code>。这在 DOM 中不太好，因为我们需要基于字符串的 ID 来识别节点。</p><p>这是通过将 ID 映射到全局映射中的字符串来解决的。这在技术上是无界的（一个类引用的特定问题）。</p><p>总结：对于 web 代码，最好使用字符串或整型来标识个体。</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>表单需要做得更好：<a href="https://github.com/SwiftWebUI/SwiftWebUI/issues/10" target="_blank" rel="noopener">Issue</a>。</p><p>SemanticUI 有一些很好的表单布局，我们可能参照这些布局重写子树。有待商榷。</p><h2 id="面向-Swift-的-WebObjects-6"><a href="#面向-Swift-的-WebObjects-6" class="headerlink" title="面向 Swift 的 WebObjects 6"></a>面向 Swift 的 WebObjects 6</h2><p>花了点时间在文章中嵌入了下面这个可点击的 Twitter 控件。（译者注：由于某些原因，这里没办法像原文一样嵌入 Twitter 控件，只能放链接。）</p><p><a href="https://twitter.com/helje5/status/1137092138104233987/photo/1?ref_src=twsrc^tfw|twcamp^tweetembed|twterm^1137092138104233987&amp;ref_url=http%3A%2F%2Fwww.alwaysrightinstitute.com%2Fswiftwebui%2F" target="_blank" rel="noopener">https://twitter.com/helje5/status/1137092138104233987/photo/1?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1137092138104233987&amp;ref_url=http%3A%2F%2Fwww.alwaysrightinstitute.com%2Fswiftwebui%2F</a></p><p>苹果确实给了我们一个“Swift 风格”的 WebObjects 6！</p><p>下一篇：直面 Web 和一些 Swift 化的 EOF（又名 CoreData 又名 ZeeQL）。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>GitHub：<a href="https://github.com/SwiftWebUI/SwiftWebUI" target="_blank" rel="noopener">SwiftWebUI</a></li><li>SwiftUI<ul><li><a href="https://developer.apple.com/videos/play/wwdc2019/204/" target="_blank" rel="noopener">介绍 SwiftUI</a>（204）</li><li><a href="https://developer.apple.com/videos/play/wwdc2019/216" target="_blank" rel="noopener">SwiftUI 要点</a> （216）</li><li><a href="https://developer.apple.com/videos/play/wwdc2019/226" target="_blank" rel="noopener">SwiftUI 中的数据流</a>（226）</li><li><a href="https://developer.apple.com/documentation/swiftui" target="_blank" rel="noopener">SwiftUI 框架 API</a></li></ul></li><li><a href="http://swiftobjects.org/" target="_blank" rel="noopener">SwiftObjects</a></li><li>SemanticUI<ul><li><a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome</a></li><li><a href="https://github.com/SwiftWebResources/SemanticUI-Swift" target="_blank" rel="noopener">SemanticUI Swift</a></li></ul></li><li><a href="https://github.com/apple/swift-nio" target="_blank" rel="noopener">SwiftNIO</a></li></ul><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p>嘿，我们希望你能喜欢这篇文章，并且也希望得到你的反馈！</p><p>Twitter（任何一个都可以）：<a href="https://twitter.com/helje5" target="_blank" rel="noopener">@helje5</a>，<a href="https://twitter.com/ar_institute" target="_blank" rel="noopener">@ar_institute</a>。</p><p>电子邮件：<a href="mailto:wrong@alwaysrightinstitute.com" target="_blank" rel="noopener">wrong@alwaysrightinstitute.com</a></p><p>Slack：在 SwiftDE、swift-server、noze、ios-developers 上找到我们。</p><p><em>写于 2019 年 6 月 30 日</em></p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文是关于 SwiftWebUI 的介绍。SwiftWebUI 将 SwiftUI 带到了 Web 平台上。
    
    </summary>
    
      <category term="The Always Right Institute" scheme="https://swift.gg/categories/The-Always-Right-Institute/"/>
    
    
      <category term="Swift 跨平台" scheme="https://swift.gg/tags/Swift-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的面向协议编程：引言</title>
    <link href="https://swift.gg/2019/09/05/protocol-oriented-programming/"/>
    <id>https://swift.gg/2019/09/05/protocol-oriented-programming/</id>
    <published>2019-09-05T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://www.appcoda.com/protocol-oriented-programming/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-03-20<br>译者：<a href="https://github.com/dzyding" target="_blank" rel="noopener">灰s</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>对于开发者来说，复杂性是最大的敌人，因此我会去了解那些可以帮助我管理混乱的新技术。Swift 中的“面向协议编程”（POP）是最近（至少自2015年以来）引起广泛关注的“热门”方法之一。在这里我们将使用 Swift 4。在我自己编写代码时，发现 POP 很有前途。更吸引人的是，Apple 宣称 <a href="https://developer.apple.com/videos/play/wwdc2015/408/?time=868" target="_blank" rel="noopener"><strong>“Swift 的核心是面对协议的”</strong></a>。我想在一个正式的报告中分享关于 POP 的经验，一篇关于这个新兴技术清晰而简洁的教程。  </p><p>我将解释关键概念，提供大量代码示例，无法避免的将 POP 和 OOP （面向对象编程）进行比较，并对面向流行编程（FOP?）的人群所声称的 POP 是解决所有问题的灵丹妙药这一说法进行泼冷水。  </p><p>面向协议编程是一个很棒的新工具，值得<em>添加到你现有的编程工具库中</em>，但是<strong>没有什么</strong>可以代替那些经久不衰的基本功，就像将大的函数拆分成若干个小函数，将大的代码文件拆分成若干个小的文件，使用有意义的变量名，在敲代码之前花时间设计架构，合理而一致的使用间距和缩进，将相关的属性和行为分配到类和结构体中 - 遵循这些常识可以让世界变得不同。如果你编写的代码无法被同事理解，那它就是无用的代码。  </p><p>学习和采用像 POP 这样的新技术并不需要绝对的唯一。POP 和 OOP 不仅可以共存，还可以互相协助。对于大多数开发者包括我自己，掌握 POP 需要时间和耐心。因为 POP 真的很重要，所以我将教程分成两篇文章。本文将主要介绍和解释 Swift 的协议和 POP。第二篇文章将深入研究 POP 的高级应用方式（比如从协议开始构建应用程序的功能），范型协议，从引用类型到值类型转变背后的动机，列举 POP 的利弊，列举 OOP 的利弊，比较 OOP 和 POP，阐述为什么“Swift 是面向协议的”，并且深入研究一个被称为 <a href="https://developer.apple.com/videos/play/wwdc2016/419/?time=41" target="_blank" rel="noopener"><strong>“局部推理”</strong></a> 的概念，它被认为是通过使用 POP 增强的。这次我们只会粗略涉及一些高级主题。<br><a id="more"></a> </p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>作为软件开发者，<strong>管理复杂性</strong>本质上是我们最应该关注的问题。当我们尝试学习 POP 这项新技术时，你可能无法从时间的投资中看到即时回报。但是，就像你对我的认识有个过程一样，你将会了解 <a href="https://developer.apple.com/videos/play/wwdc2015/408/" target="_blank" rel="noopener"><strong>POP 处理复杂性的方法</strong></a>，同时为你提供另一种工具来控制软件系统中固有的混乱。  </p><p>我听到越来越多关于 POP 的<em>讨论</em>，但是却很少看到使用这种方式编写的产品代码，换句话说，我还没有看到有很多人从协议而不是类开始创建应用程序的功能。这不仅仅是因为人类有抗拒改变的倾向。学习一种全新的范式并将其付诸实践，说起来容易做起来难。在我编写新应用程序时，逐渐发现自己开始使用 POP 来设计和实现功能 — 有组织的且自然而然的。  </p><p>伴随着新潮流带来的刺激，很多人都在谈论用 POP <em>取代</em> OOP。我认为除非像 Swift 这样的 POP 语言被广泛改进，否则这是不可能发生的 — 也或许根本就不会发生。我是个实用主义者，而不是追求时髦的人。在开发新的 Swift 项目时，我发现自己的行为是一种折衷的方法。我在合理的地方利用 OOP，而用 POP 更合适的地方也不会死脑筋的一定要使用 OOP，这样反而了解到这两种模式<strong>并不</strong>相互排斥。我把这两种技术结合在一起。在本期由两部分组成的 POP 教程中，你将了解我在说什么。  </p><p>我投入到 OOP 中已经有很久了。1990 年，我买了一个零售版本的 Turbo Pascal。在使用了 OOP 大约一年后，我开始设计、开发和发布面向对象的应用程序产品。我成了一个忠粉。当我发现可以<strong>扩展</strong>和<strong>增强</strong>自己的类，简直兴奋的飞起。随着时间的推移，Microsoft 和 Apple 等公司开始开发基于 OOP 的大型代码库，如 Microsoft Foundation Classes（MFC）和 .NET，以及 iOS 和 OS X SDK。现在，开发人员在开发新应用程序时很少需要重新造轮子。没有完美的方法，OOP 也有一些缺点，但是优点仍然大于缺点。我们将花一些时间来比较 OOP 和 POP。  </p><h2 id="理解协议"><a href="#理解协议" class="headerlink" title="理解协议"></a>理解协议</h2><p>当开发人员设计一个新的 iOS 应用程序的基本结构时，他们几乎总是从 <code>Foundation</code> 和 <code>UIKit</code> 等框架中的现有 <code>类</code> 开始。我能想到的几乎所有应用程序都需要某种用户界面导航系统。用户需要一些进入应用程序的入口点和引导他们使用应用程序功能的路标。可以浏览一下你的 iPhone 或 iPad 上的应用程序。  </p><p>当这些应用程序打开时，你看到了什么？我打赌你看到的是 <code>UITableViewController</code>，<code>UICollectionViewController</code> 和 <code>UIPageViewController</code> 的子类。  </p><p>当你第一次创建新的 iOS 项目时，所有人都必须认识下面的代码片段，例如，一个新的 iOS 项目基于 Xcode 中的 <code>Single View App（单视图应用）</code> 模板：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>部分开发人员将在这里停下来，创建完全定制的接口，但大多数人将采取另一个步骤。  </p><p>当 iOS 开发者开发新的应用程序时，最常见的特征就是 OOP，那么 POP 在这里扮演什么角色呢？  </p><p>你知道我将怎样继续么？想象大多数开发人员的下一个主要步骤是什么。那就是<strong>遵循协议</strong>（并实现 <a href="https://appcoda.com/swift-delegate/" target="_blank" rel="noopener"><strong>委托，但我们已经讨论过了</strong></a>）。  </p><p>让我给你们看一个例子使其便于理解。我相信你们很多人都用过 <code>UITableView</code>。虽然这不是一个关于 <code>UITableView</code> 的教程，但是你应该知道在 <code>UIViewController</code> 中将其实现时，协议扮演着重要的角色。在向 <code>UIViewController</code> 中添加 <code>UITableView</code>时，<code>UIViewController</code> 必须<strong>遵循</strong> <code>UITableViewDataSource</code> 和 <code>UITableViewDelegate</code> 协议，就像这样：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span></span></span><br></pre></td></tr></table></figure><p>简而言之，遵循 <code>UITableViewDataSource</code> 允许你用数据填充所有的 <code>UITableViewCell</code>，比如给用户提供导航的菜单项名称。采用 <code>UITableViewDelegate</code>，你可以对用户与 <code>UITableView</code> 的交互进行更细粒度的控制，比如在用户点击特定的 <code>UITableViewCell</code> 时执行适当的操作。  </p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>我发现，在进行技术性定义和讨论之前，理解常用的术语定义可以帮助读者更好地理解某个主题。首先，让我们 考虑 <a href="https://en.oxforddictionaries.com/definition/protocol" target="_blank" rel="noopener"><strong>“协议”一词的通俗定义</strong></a>：  </p><blockquote><p>……管理国家事务或外交领域的正式程序或规则体系。……<br>在任何团体、组织或形势下，公认或已制定的程序或行为准则。……<br>进行科学实验时的程序……</p></blockquote><p>Apple 的“Swift 编程语言（Swift 4.0.3）” <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" target="_blank" rel="noopener">文档中的声明</a>：  </p><blockquote><p>协议定义了适合特定任务或功能的方法、属性和其他需求的蓝图。然后，类、结构体或枚举可以遵循该协议来提供这些需求的实际实现。任何满足协议要求的类型都被称为遵循该协议。</p></blockquote><p>协议是最重要的工具之一，我们必须给软件固有的混乱带来一些秩序。协议使我们能够要求一个或多个类和结构体包含特定的最小且必需的属性，和/或提供特定的最小且必需的实现/方法。通过 <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID521" target="_blank" rel="noopener"><strong>协议扩展</strong></a>，我们可以为一些或所有协议的方法提供默认实现。  </p><h3 id="遵循协议"><a href="#遵循协议" class="headerlink" title="遵循协议"></a>遵循协议</h3><p>下面，我们将使自定义的 <code>Person</code> 类<strong>遵循</strong>（<strong>采用</strong>）Apple 自带 <a href="https://developer.apple.com/documentation/swift/equatable" target="_blank" rel="noopener"><code>Equatable</code></a> 协议。  </p><blockquote><p>遵循 Equatable 协议以后可以使用等于运算符（==）来判断是否相等，使用不等于运算符（!=）来判断是否不等。Swift 标准库中的大部分基础类型都遵循了 Equatable 协议……  </p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Equatable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> weight:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> sex:<span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(weight:<span class="type">Int</span>, name:<span class="type">String</span>, sex:<span class="type">String</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.weight = weight</span><br><span class="line">        <span class="keyword">self</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Person, rhs: Person)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> lhs.weight == rhs.weight &amp;&amp;</span><br><span class="line">            lhs.name == rhs.name &amp;&amp;</span><br><span class="line">            lhs.sex == rhs.sex</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Apple <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" target="_blank" rel="noopener">规定</a>，“自定义类型声明它们采用特定的协议，需要将协议的名称放在类型名称之后，以冒号分隔，作为其定义的一部分。”这也正是我所做的：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Equatable</span></span></span><br></pre></td></tr></table></figure><p>你可以将协议理解为专门针对 <code>class</code>、<code>struct</code> 或 <code>enum</code> 的<strong>约定</strong>或<strong>承诺</strong>。我通过 <code>Equatable</code> 协议使自定义的 <code>Person</code> 类遵守了一个约定，<code>Person</code> 类<strong><em>承诺</em></strong>通过现实 <code>Equatable</code> 协议需要的方法或成员变量来履行该约定，即将其实现。  </p><p><code>Equatable</code> 协议<strong><em>并没有实现任何东西</em></strong>。它只是指明了<strong><em>采用（遵循）</em></strong> <code>Equatable</code> 协议的 <code>class</code>，<code>struct</code>，或者 <code>enum</code> <strong><em>必须实现</em></strong>的方法和/或成员变量。有一些协议通过 <code>extensions</code> 实现了功能，稍后我们会进行讨论。我不会花太多时间来讲述关于 <code>enum</code> 的 POP 用法。我将它作为练习留给你。  </p><h3 id="定义协议"><a href="#定义协议" class="headerlink" title="定义协议"></a>定义协议</h3><p>理解协议最好的方式是通过例子。我将自己构建一个 <code>Equatable</code> 来向你展示协议的用法：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">IsEqual</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> != <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请记住，我的“IsEqual”协议并没有对 <code>==</code> 和 <code>!=</code> 运算符进行实现。“IsEqual”需要协议的遵循者<strong><em>实现他们自己的</em></strong> <code>==</code> 和 <code>!=</code> 运算符。  </p><p>所有定义协议属性和方法的规则都在 <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" target="_blank" rel="noopener"><strong>Apple 的 Swift 文档</strong></a> 中进行了总结。比如，在协议中定义属性永远不要用 <code>let</code> 关键字。只读属性规定使用 <code>var</code> 关键字，并在后面单独跟上 <code>{ get }</code>。如果有一个方法改变了一个或多个属性，你需要标记它为 <code>mutating</code>。你需要知道为什么我重写的 <code>==</code> 和 <code>!=</code> 操作符被定义为 <code>static</code>。如果你不知道，找出原因将会是一个很好的练习。  </p><p>为了向你展示我的 <code>IsEqual</code>（或者 <code>Equatable</code>）这样的协议具有广泛的适用性，我们将使用它在下面构建一个类。但是在我们开始之前，让我们先讨论一下“引用类型”与“值类型”。  </p><h2 id="引用类型与值类型"><a href="#引用类型与值类型" class="headerlink" title="引用类型与值类型"></a>引用类型与值类型</h2><p>在继续之前，您应该阅读 Apple 关于 <a href="https://developer.apple.com/swift/blog/?id=10" target="_blank" rel="noopener"><strong>“值和引用类型”</strong></a> 的文章。它将让你思考引用<em>类型</em>和值<em>类型</em>。我<strong>故意</strong>不在这里讲太多细节，因为我想让你们思考并理解这个非常重要的概念。它太过重要，以至于针对 POP <strong>和</strong> 引用/值类型的讨论<strong>同时</strong>出现在这些地方：  </p><ol><li>WWDC 2015 展示的 <a href="https://developer.apple.com/videos/play/wwdc2015/408/?time=2558" target="_blank" rel="noopener"><strong>“Protocol-Oriented Programming in Swift”</strong></a>  </li><li>WWDC 2015 展示的 <a href="https://developer.apple.com/videos/play/wwdc2015-414/?time=48" target="_blank" rel="noopener"><strong>“Building Better Apps with Value Types in Swift”</strong></a>  </li><li>WWDC 2016 展示的 <a href="https://developer.apple.com/videos/play/wwdc2016-419/?time=340" target="_blank" rel="noopener"><strong>“Protocol and Value Oriented Programming in UIKit Apps”</strong></a>  </li></ol><p>我会给你一个提示和作业……假设你有多个指向同一个类实例的引用，用于修改或“改变”属性。这些引用指向相同的数据块，因此将其称为“共享”数据并不夸张。在某些情况下，共享数据可能会导致问题，如下面的示例所示。这是否表示我们要将所有的代码改成值类型？<strong>并不是！</strong>就像 Apple 的一个工程师指出：<a href="https://developer.apple.com/videos/play/wwdc2015-408/?time=2566" target="_blank" rel="noopener"><strong>“例如，以 Window 为例。复制一个 Window 是什么意思？”</strong></a> 查看下面的代码，并思考这个问题。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>下面的代码片段来自 Xcode playground，在创建对象副本然后更改属性时，会遇到一个有趣的难题。你能找到问题么？我们将在下一篇文章中讨论这个问题。  </p><p>这段代码同时也演示了协议的定义和 <code>extension</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用类型：每个人都使用类很长时间了 </span></span><br><span class="line"><span class="comment">// -- 想想 COCOA 中进行的所有隐式复制。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flightTerminology: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> <span class="comment">// 不需要提供实现，除非我想</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> -&gt; <span class="type">Void</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> myType = <span class="type">String</span>(describing: type(of: <span class="keyword">self</span>))</span><br><span class="line">        <span class="keyword">let</span> flightTerminologyForType = myType + <span class="string">" "</span> + flightTerminology + <span class="string">"\n"</span></span><br><span class="line">        <span class="built_in">print</span>(flightTerminologyForType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> : <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flightTerminology: <span class="type">String</span> = <span class="string">"flies WITH feathers, and flaps wings differently than bats"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bat</span> : <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flightTerminology: <span class="type">String</span> = <span class="string">"flies WITHOUT feathers, and flaps wings differently than birds"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bat = <span class="type">Bat</span>()</span><br><span class="line">bat.fly()</span><br><span class="line"><span class="comment">// "Bat flies WITHOUT feathers, and flaps wings differently than birds"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bird = <span class="type">Bird</span>()</span><br><span class="line">bird.fly()</span><br><span class="line"><span class="comment">// "Bird flies WITH feathers, and flaps wings differently than bats"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> batCopy = bat</span><br><span class="line">batCopy.fly()</span><br><span class="line"><span class="comment">// "Bird flies WITH feathers, and flaps wings differently than bats"</span></span><br><span class="line"></span><br><span class="line">batCopy.flightTerminology = <span class="string">""</span></span><br><span class="line">batCopy.fly()</span><br><span class="line"><span class="comment">// 控制台输出 "Bat"</span></span><br><span class="line"></span><br><span class="line">bat.fly()</span><br><span class="line"><span class="comment">// 控制台输出 "Bat"</span></span><br></pre></td></tr></table></figure><p><strong><em>来自前面代码片段的控制台输出</em></strong>  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bat flies WITHOUT feathers, and flaps wings differently than birds</span><br><span class="line"></span><br><span class="line">Bird flies WITH feathers, and flaps wings differently than bats</span><br><span class="line"></span><br><span class="line">Bird flies WITH feathers, and flaps wings differently than bats</span><br><span class="line"></span><br><span class="line">Bat</span><br><span class="line"></span><br><span class="line">Bat</span><br></pre></td></tr></table></figure><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>在接下来的 Swift 代码片段中，我们使用 <code>struct</code> 替代 <code>class</code>。在这里，代码看起来更安全，而 Apple 似乎在推广值类型和 POP。注意，<a href="https://developer.apple.com/videos/play/wwdc2015/408/?time=2677" target="_blank" rel="noopener"><strong>他们目前还没有放弃 <code>class</code></strong></a>。  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是范式转变的起点，不仅仅是协议，还有值类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flightTerminology: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> <span class="comment">// 不需要提供实现，除非我想</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> -&gt; <span class="type">Void</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> myType = <span class="type">String</span>(describing: type(of: <span class="keyword">self</span>))</span><br><span class="line">        <span class="keyword">let</span> flightTerminologyForType = myType + <span class="string">" "</span> + flightTerminology + <span class="string">"\n"</span></span><br><span class="line">        <span class="built_in">print</span>(flightTerminologyForType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bird</span> : <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flightTerminology: <span class="type">String</span> = <span class="string">"flies WITH feathers, and flaps wings differently than bats"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bat</span> : <span class="title">ObjectThatFlies</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flightTerminology: <span class="type">String</span> = <span class="string">"flies WITHOUT feathers, and flaps wings differently than birds"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bat = <span class="type">Bat</span>()</span><br><span class="line">bat.fly()</span><br><span class="line"><span class="comment">// "Bat flies WITHOUT feathers, and flaps wings differently than birds"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bird = <span class="type">Bird</span>()</span><br><span class="line">bird.fly()</span><br><span class="line"><span class="comment">// "Bird flies WITH feathers, and flaps wings differently than bats"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> batCopy = bat</span><br><span class="line">batCopy.fly()</span><br><span class="line"><span class="comment">// "Bird flies WITH feathers, and flaps wings differently than bats"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我在这里对 Bat 实例所做的事情是显而易见的</span></span><br><span class="line">batCopy.flightTerminology = <span class="string">""</span></span><br><span class="line">batCopy.fly()</span><br><span class="line"><span class="comment">// 控制台输出 "Bat"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，因为我们使用的是值类型，所以 Bat 实例的原始数据并没有因为之前的操作而被篡改。</span></span><br><span class="line">bat.fly()</span><br><span class="line"><span class="comment">// "Bat flies WITHOUT feathers, and flaps wings differently than birds"</span></span><br></pre></td></tr></table></figure><p><strong><em>来自前面代码片段的控制台输出</em></strong>  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bat flies WITHOUT feathers, and flaps wings differently than birds</span><br><span class="line"></span><br><span class="line">Bird flies WITH feathers, and flaps wings differently than bats</span><br><span class="line"></span><br><span class="line">Bat flies WITHOUT feathers, and flaps wings differently than birds</span><br><span class="line"></span><br><span class="line">Bat </span><br><span class="line"></span><br><span class="line">Bat flies WITHOUT feathers, and flaps wings differently than birds</span><br></pre></td></tr></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>我写了一些面向协议的代码。请通读代码，阅读内联注释，阅读附带的文章，跟随我的超链接，并充分理解我在做什么。你将在下一篇关于 POP 的文章中用到它。  </p><h3 id="采用多种协议"><a href="#采用多种协议" class="headerlink" title="采用多种协议"></a>采用多种协议</h3><p>刚开始写这篇文章的时候，我很贪心，想要自定义一个协议，使它能<strong><em>同时</em></strong>体现 Apple 的内置协议 <code>Equatable</code> 和 <code>Comparable</code>：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">IsEqualAndComparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> != <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &gt; <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt; (lhs: Self, rhs: Self) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">static</span> <span class="title">func</span> &gt;= <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;= (lhs: Self, rhs: Self) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>我意识到应该将它们分开，使我的代码尽可能灵活。为什么不呢？Apple 声明同一个类，结构体，枚举可以遵循多个协议，就像接下来我们将看到的一样。下面是我提出的两个协议：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">IsEqual</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> != <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &gt; <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt; (lhs: Self, rhs: Self) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">static</span> <span class="title">func</span> &gt;= <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;= (lhs: Self, rhs: Self) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="记住你的算法"><a href="#记住你的算法" class="headerlink" title="记住你的算法"></a>记住你的算法</h3><p>你需要磨练的一项重要技能是编程的算法，并将它们转换为代码。我保证在将来的某一天，会有人给你一个复杂过程的口头描述并要求你对它进行编码。用人类语言描述某些步骤，之后用软件将其实现，它们之间一般都会有很大的差距。当我想要将 <code>IsEqual</code> 和 <code>Comparable</code> 应用于表示直线（向量）的类时，我意识到了这一点。我记得计算一个直线的长度是基于勾股定理的（参考 <a href="https://orion.math.iastate.edu/dept/links/formulas/form2.pdf" target="_blank" rel="noopener"><strong>这里</strong></a>和 <a href="https://www.mathwarehouse.com/algebra/distance_formula/index.php" target="_blank" rel="noopener"><strong>这里</strong></a>），并且对向量使用 <code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，和 <code>&gt;=</code> 这些运算符进行比较时，直线的长度是必须的。我的 <code>Line</code> 类迟早会派上用场，例如，在一个绘图应用程序或游戏中，用户点击屏幕上的两个位置，在两点之间创建一条线。</p><h3 id="自定义类采用多个协议"><a href="#自定义类采用多个协议" class="headerlink" title="自定义类采用多个协议"></a>自定义类采用多个协议</h3><p>这是我的 <code>Line</code> 类，它采用了两个协议，<code>IsEqual</code> 和 <code>Comparable</code>（如下）。这是多继承的一种形式！  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> : <span class="title">IsEqual</span>, <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> beginPoint:<span class="type">CGPoint</span></span><br><span class="line">    <span class="keyword">var</span> endPoint:<span class="type">CGPoint</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        beginPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>);</span><br><span class="line">        endPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(beginPoint:<span class="type">CGPoint</span>, endPoint:<span class="type">CGPoint</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.beginPoint = <span class="type">CGPoint</span>( x: beginPoint.x, y: beginPoint.y )</span><br><span class="line">        <span class="keyword">self</span>.endPoint = <span class="type">CGPoint</span>( x: endPoint.x, y: endPoint.y )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线长的计算基于勾股定理。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">length</span> <span class="params">()</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> length = sqrt( pow(endPoint.x - beginPoint.x, <span class="number">2</span>) + pow(endPoint.y - beginPoint.y, <span class="number">2</span>) )</span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(leftHandSideLine: Line, rightHandSideLine: Line)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (leftHandSideLine.length() == rightHandSideLine.length())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> != <span class="params">(leftHandSideLine: Line, rightHandSideLine: Line)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (leftHandSideLine.length() != rightHandSideLine.length())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &gt; <span class="params">(leftHandSideLine: Line, rightHandSideLine: Line)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (leftHandSideLine.length() &gt; rightHandSideLine.length())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt; (leftHandSideLine: Line, rightHandSideLine: Line) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (leftHandSideLine.length() &lt; rightHandSideLine.length())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &gt;= <span class="params">(leftHandSideLine: Line, rightHandSideLine: Line)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (leftHandSideLine.length() &gt;= rightHandSideLine.length())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;= (leftHandSideLine: Line, rightHandSideLine: Line) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (leftHandSideLine.length() &lt;= rightHandSideLine.length())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 类的结束行：IsEqual, Comparable</span></span><br></pre></td></tr></table></figure><h3 id="验证你的算法"><a href="#验证你的算法" class="headerlink" title="验证你的算法"></a>验证你的算法</h3><p>我使用电子制表软件 Apple Numbers，并准备了两个向量的可视化表示，对 <code>Line</code> 类的 <code>length()</code> 方法做了一些基本测试：  </p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/03/swift-pop-1.png" alt>  </p><p>这里是我根据上面图表中的点，写的测试代码：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x1 = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> y1 = <span class="type">CGPoint</span>(x: <span class="number">2</span>, y: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> line1 = <span class="type">Line</span>(beginPoint: x1, endPoint: y1)</span><br><span class="line">line1.length()</span><br><span class="line"><span class="comment">// returns 2.82842712474619</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x2 = <span class="type">CGPoint</span>(x: <span class="number">3</span>, y: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> y2 = <span class="type">CGPoint</span>(x: <span class="number">5</span>, y: <span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> line2 = <span class="type">Line</span>(beginPoint: x2, endPoint: y2)</span><br><span class="line">line2.length()</span><br><span class="line"><span class="comment">// returns 2.82842712474619</span></span><br><span class="line"></span><br><span class="line">line1 == line2</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line">line1 != line2</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line">line1 &gt; line2</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line">line1 &lt;= line2</span><br><span class="line"><span class="comment">// returns true</span></span><br></pre></td></tr></table></figure><h3 id="使用-Xcode-“Single-View”-playground-模版测试-原型化-UI"><a href="#使用-Xcode-“Single-View”-playground-模版测试-原型化-UI" class="headerlink" title="使用 Xcode “Single View” playground 模版测试/原型化 UI"></a>使用 Xcode “Single View” playground 模版测试/原型化 UI</h3><p>你是否知道可以使用 Xcode 9 <code>Single View</code> playground 模板来原型化和测试用户界面（UI）？它非常棒 - 可以节省大量时间并快速原型化的工具。为了更好的测试我的 <code>Line</code> 类，我创建了这样一个 playground。<strong>作业：在我解释之前，我想让你自己试一下。</strong>我<strong>将</strong>向你展示我的 playground 代码、模拟器输出和我的 Swift 测试语句。  </p><p>这里是我的 playground 代码：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> PlaygroundSupport</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineDrawingView</span>: <span class="title">UIView</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> currGraphicsContext = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">        currGraphicsContext?.setLineWidth(<span class="number">2.0</span>)</span><br><span class="line">        currGraphicsContext?.setStrokeColor(<span class="type">UIColor</span>.blue.cgColor)</span><br><span class="line">        currGraphicsContext?.move(to: <span class="type">CGPoint</span>(x: <span class="number">40</span>, y: <span class="number">400</span>))</span><br><span class="line">        currGraphicsContext?.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">320</span>, y: <span class="number">40</span>))</span><br><span class="line">        currGraphicsContext?.strokePath()</span><br><span class="line">        </span><br><span class="line">        currGraphicsContext?.setLineWidth(<span class="number">4.0</span>)</span><br><span class="line">        currGraphicsContext?.setStrokeColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line">        currGraphicsContext?.move(to: <span class="type">CGPoint</span>(x: <span class="number">40</span>, y: <span class="number">400</span>))</span><br><span class="line">        currGraphicsContext?.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">320</span>, y: <span class="number">60</span>))</span><br><span class="line">        currGraphicsContext?.strokePath()</span><br><span class="line">        </span><br><span class="line">        currGraphicsContext?.setLineWidth(<span class="number">6.0</span>)</span><br><span class="line">        currGraphicsContext?.setStrokeColor(<span class="type">UIColor</span>.green.cgColor)</span><br><span class="line">        currGraphicsContext?.move(to: <span class="type">CGPoint</span>(x: <span class="number">40</span>, y: <span class="number">400</span>))</span><br><span class="line">        currGraphicsContext?.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">250</span>, y: <span class="number">80</span>))</span><br><span class="line">        currGraphicsContext?.strokePath()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="type">LineDrawingView</span>()</span><br><span class="line">        view.backgroundColor = .white</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.view = view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实时视图窗口中显示视图控制器</span></span><br><span class="line"><span class="type">PlaygroundPage</span>.current.liveView = <span class="type">MyViewController</span>()</span><br></pre></td></tr></table></figure><p>这是我在 playground 模拟器上的视图输出：  </p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/03/swift-pop-2.png" alt>  </p><p>下面是测试我的 <code>Line</code> 类型实例与我在 playground 上所画向量匹配的 Swift 代码：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xxBlue = <span class="type">CGPoint</span>(x: <span class="number">40</span>, y: <span class="number">400</span>)</span><br><span class="line"><span class="keyword">let</span> yyBlue = <span class="type">CGPoint</span>(x: <span class="number">320</span>, y: <span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> lineBlue = <span class="type">Line</span>(beginPoint: xxBlue, endPoint: yyBlue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xxRed = <span class="type">CGPoint</span>(x: <span class="number">40</span>, y: <span class="number">400</span>)</span><br><span class="line"><span class="keyword">let</span> yyRed = <span class="type">CGPoint</span>(x: <span class="number">320</span>, y: <span class="number">60</span>)</span><br><span class="line"><span class="keyword">let</span> lineRed = <span class="type">Line</span>(beginPoint: xxRed, endPoint: yyRed)</span><br><span class="line">lineRed.length()</span><br><span class="line"><span class="comment">// returns 440.454310910905</span></span><br><span class="line"></span><br><span class="line">lineBlue != lineRed</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line">lineBlue &gt; lineRed</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line">lineBlue &gt;= lineRed</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xxGreen = <span class="type">CGPoint</span>(x: <span class="number">40</span>, y: <span class="number">400</span>)</span><br><span class="line"><span class="keyword">let</span> yyGreen = <span class="type">CGPoint</span>(x: <span class="number">250</span>, y: <span class="number">80</span>)</span><br><span class="line"><span class="keyword">let</span> lineGreen = <span class="type">Line</span>(beginPoint: xxGreen, endPoint: yyGreen)</span><br><span class="line">lineGreen.length()</span><br><span class="line"><span class="comment">// returns 382.753184180093</span></span><br><span class="line">lineGreen &lt; lineBlue</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line">lineGreen &lt;= lineRed</span><br><span class="line"><span class="comment">// returns true</span></span><br><span class="line">lineGreen &gt; lineBlue</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line">lineGreen &gt;= lineBlue</span><br><span class="line"><span class="comment">// returns false</span></span><br><span class="line">lineGreen == lineGreen</span><br><span class="line"><span class="comment">// returns true</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我希望你喜欢今天的文章，并且非常期待阅读本文的“第二部分”。记住，我们将深入研究使用 POP 的先进应用程序，范型协议，从引用类型到值类型背后的动机，列举 POP 的优缺点，列举 OOP 的优缺点，比较 OOP 和 POP，确定为什么“Swift 是面向协议的”，并深入研究称为“局部推理”的概念。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      对面向协议编程，做了一个简单的引言，为第二篇文章做准备工作。
    
    </summary>
    
      <category term="POP" scheme="https://swift.gg/categories/POP/"/>
    
      <category term="SWIFT" scheme="https://swift.gg/categories/POP/SWIFT/"/>
    
    
      <category term="教程" scheme="https://swift.gg/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Swift 关键字</title>
    <link href="https://swift.gg/2019/08/22/Swift-Keywords/"/>
    <id>https://swift.gg/2019/08/22/Swift-Keywords/</id>
    <published>2019-08-22T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jordan Morgan，<a href="https://www.swiftjectivec.com/swift-keywords-v-3-0-1/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-02-11<br>译者：<a href="https://www.jianshu.com/u/076cc5e18bb8" target="_blank" rel="noopener">郑一一</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><p>有句话之前我提过，今天还想再说一次。那就是打铁还需自身硬。对于自身能力的严格要求，可以帮助实现我们所有梦寐以求的东西。</p><p>说起来可能有些消极，知识毕竟是永远学不完的。不论如何，今天 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html" target="_blank" rel="noopener">我们先来学习一下 Swift 中的每一个关键字</a>（V3.0.1），在介绍每个关键字的时候，同时会附带一段代码加以说明。</p><p>在这些关键字之中，会有你熟悉或者不熟悉的部分。但为了最好的阅读和学习体验，我把它们全部列出来了。文章篇幅有些长，你准备好了么？</p><p>让我们现在就开始吧。</p><a id="more"></a><h2 id="声明式关键字"><a href="#声明式关键字" class="headerlink" title="声明式关键字"></a>声明式关键字</h2><p><strong>associatedtype</strong>：在协议中，定义一个类型的占位符名称。直到协议被实现，该占位符才会被指定具体的类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Entertainment</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">MediaType</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> : <span class="title">Entertainment</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">MediaType</span> = <span class="type">String</span> <span class="comment">//可以指定任意类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>class</strong>：通用、灵活的结构体，是程序的基础组成部分。与 struct 类似，不同之处在于：</p><ul><li>允许一个类继承另一个类的特性。</li><li>类型转换，允许在运行时检查和指定一个类的实际类型。</li><li>析构方法允许类的实例释放所有资源。</li><li>引用计数允许多个引用指向一个实例。</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>  </span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span>  </span><br><span class="line">    <span class="keyword">var</span> gender:<span class="type">String</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>deinit</strong>：当一个类的实例即将被销毁时，会调用这个方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>  </span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span>  </span><br><span class="line">    <span class="keyword">var</span> gender:<span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//从堆中释放，并释放的资源</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>enum</strong>：定义了包含一组有关联的值的类型，并可以以一种类型安全的方式使用这些值。在 Swift 中，枚举是一等类型，拥有在其它语言中只有 class 才会支持的特性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Gender</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> male  </span><br><span class="line">    <span class="keyword">case</span> female  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>extension</strong>：允许给已有的类、结构体、枚举、协议类型，添加新功能。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span> = <span class="string">""</span>  </span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span> = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">var</span> gender:<span class="type">String</span> = <span class="string">""</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"My name is \(name), I'm \(age) years old and I'm a \(gender)."</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fileprivate</strong>：访问控制权限，只允许在定义源文件中访问。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> jobTitle:<span class="type">String</span> = <span class="string">""</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//当 extension 和 class 在同一个文件中时，允许访问</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printJobTitle</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"My job is (jobTitle)"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>func</strong>：包含用于执行特定任务的代码块。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNumbers</span><span class="params">(num1:Int, num2:Int)</span></span> -&gt; <span class="type">Int</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> num1+num2  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>import</strong>：引入一个以独立单元构建的框架或者应用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用 UIKit 框架下的所有代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>init</strong>：类、结构体、枚举的实例的初始化准备过程。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">init</span>()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//设置默认值，实例准备被使用</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>inout</strong>：将一个值传入函数，并可以被函数修改，然后将值传回到调用处，来替换初始值。适用于引用类型和值类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dangerousOp</span><span class="params">(<span class="number">_</span> error:<span class="keyword">inout</span> NSError?)</span></span>  </span><br><span class="line">&#123;  </span><br><span class="line">    error = <span class="type">NSError</span>(domain: <span class="string">""</span>, code: <span class="number">0</span>, userInfo: [<span class="string">""</span>:<span class="string">""</span>])  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> potentialError:<span class="type">NSError?</span></span><br><span class="line">dangerousOp(&amp;potentialError)</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码运行到这里，potentialError 不再是 nil，而是已经被初始化</span></span><br></pre></td></tr></table></figure><p><strong>internal</strong>：访问控制权限，允许同一个模块下的所有源文件访问，如果在不同模块下则不允许访问。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> jobTitle:<span class="type">String</span> = <span class="string">""</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.jobTitle = <span class="string">"This can set anywhere in the application"</span></span><br></pre></td></tr></table></figure><p><strong>let</strong>：定义一个不可变的变量。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> constantString = <span class="string">"This cannot be mutated going forward"</span></span><br></pre></td></tr></table></figure><p><strong>open</strong>：访问控制权限，允许在定义的模块外也可以访问源文件里的所有类，并进行子类化。对于类成员，允许在定义的模块之外访问和重写。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> foo:<span class="type">String?</span> <span class="comment">//这个属性允许在 app 内或 app 外重写和访问。在开发框架的时候，会应用到这个访问修饰符。</span></span><br></pre></td></tr></table></figure><p><strong>operator</strong>：特殊符号，用于检查、修改、组合值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一元运算符 "-"，改变值的符号</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">5</span>  </span><br><span class="line"><span class="keyword">let</span> anotherFoo = -foo <span class="comment">//anotherFoo 等于 -5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二元运算符 "+" 将两个值相加</span></span><br><span class="line"><span class="keyword">let</span> box = <span class="number">5</span> + <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑运算符 "&amp;&amp;" 将两个布尔值进行组合运算</span></span><br><span class="line"><span class="keyword">if</span> didPassCheckOne &amp;&amp; didPassCheckTwo</span><br><span class="line"></span><br><span class="line"><span class="comment">//三元运算符需要使用三个值</span></span><br><span class="line"><span class="keyword">let</span> isLegalDrinkingAgeInUS:<span class="type">Bool</span> = age &gt;= <span class="number">21</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>private</strong>：访问控制权限，只允许实体在定义的类以及相同源文件内的 extension 中访问。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> jobTitle:<span class="type">String</span> = <span class="string">""</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 extension 和 class 不在同一个源文件时</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 无法编译通过，只有在同一个源文件下才可以访问</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printJobTitle</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"My job is (jobTitle)"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>protocol</strong>：定义了一组方法、属性或其它要求，用于满足特定任务和一系列功能。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Blog</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> wordCount:<span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printReaderStats</span><span class="params">()</span></span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TTIDGPost</span> : <span class="title">Blog</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> wordCount:<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(wordCount:<span class="type">Int</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">self</span>.wordCount = wordCount  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printReaderStats</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//打印 post 的数据  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>public</strong>：访问控制权限，允许在定义的模块外也可以访问源文件里的所有类，但只有在同一个模块内可以进行子类化。对于类成员，允许在同个模块下访问和重写。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> foo:<span class="type">String?</span> <span class="comment">//只允许在 app 内重写和访问。</span></span><br></pre></td></tr></table></figure><p><strong>static</strong>：用于定义类方法，在类型本身进行调用。此外还可以定义静态成员。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> jobTitle:<span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">assignRandomName</span><span class="params">(<span class="number">_</span> aPerson:Person)</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        aPerson.jobTitle = <span class="string">"Some random job"</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> somePerson = <span class="type">Person</span>()  </span><br><span class="line"><span class="type">Person</span>.assignRandomName(somePerson)  </span><br><span class="line"><span class="comment">//somePerson.jobTitle 的值是 "Some random job"</span></span><br></pre></td></tr></table></figure><p><strong>struct</strong>：通用、灵活的结构体，是程序的基础组成部分，并提供了默认初始化方法。与 class 不同，当 struct 在代码中被传递时，是被拷贝的，并不使用引用计数。除此之外，struct 没有下面的这些功能：</p><ul><li>使用继承。</li><li>运行时的类型转换。</li><li>使用析构方法。</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>  </span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span>  </span><br><span class="line">    <span class="keyword">var</span> gender:<span class="type">String</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>subscript</strong>：访问集合、列表、序列中成员元素的快捷方式。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postMetrics = [<span class="string">"Likes"</span>:<span class="number">422</span>, <span class="string">"ReadPercentage"</span>:<span class="number">0.58</span>, <span class="string">"Views"</span>:<span class="number">3409</span>]  </span><br><span class="line"><span class="keyword">let</span> postLikes = postMetrics[<span class="string">"Likes"</span>]</span><br></pre></td></tr></table></figure><p><strong>typealias</strong>：给代码中已经存在的类，取别名。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">JSONDictionary</span> = [<span class="type">String</span>: <span class="type">AnyObject</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseJSON</span><span class="params">(<span class="number">_</span> deserializedData:JSONDictionary)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>var</strong>：定义可变变量。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutableString = <span class="string">""</span>  </span><br><span class="line">mutableString = <span class="string">"Mutated"</span></span><br></pre></td></tr></table></figure><h2 id="语句中的关键词"><a href="#语句中的关键词" class="headerlink" title="语句中的关键词"></a>语句中的关键词</h2><p><strong>break</strong>：终止程序中循环的执行，比如 if 语句、switch 语句。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>...<span class="number">3</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> idx % <span class="number">2</span> == <span class="number">0</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//当 idx 等于偶数时，退出 for 循环  </span></span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>case</strong>：该语句在 switch 语句中列出，在每个分支可以进行模式匹配。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> box = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> box  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 0"</span>)  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 1"</span>)  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box doesn't equal 0 or 1"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>continue</strong>：用于终止循环的当前迭代，并进入下一次迭代，而不会停止整个循环的执行。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>...<span class="number">3</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> idx % <span class="number">2</span> == <span class="number">0</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//直接开始循环的下一次迭代</span></span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This code never fires on even numbers"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>default</strong>：用于涵盖在 switch 语句中，所有未明确列出的枚举成员。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> box = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> box  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 0"</span>)  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 1"</span>)  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Covers any scenario that doesn't get addressed above."</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>defer</strong>：用于在程序离开当前作用域之前，执行一段代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cleanUpIO</span><span class="params">()</span></span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">defer</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This is called right before exiting scope"</span>)  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件流等。  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>do</strong>：用于表示处理错误代码段的开始。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">try</span> expression  </span><br><span class="line">    <span class="comment">//语句</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span> someError ex  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>else</strong>：与 if 语句结合使用。当条件为 true，执行一段代码。当条件为 false，执行另一段代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> val &gt; <span class="number">1</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"val is greater than 1"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"val is not greater than 1"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fallthrough</strong>：显式地允许从当前 case 跳转到下一个相邻 case 继续执行代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> box = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> box  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 0"</span>)  </span><br><span class="line">    <span class="keyword">fallthrough</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 0 or 1"</span>)  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box doesn't equal 0 or 1"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>for</strong>：在序列上迭代，比如一组特定范围内的数字，数组中的元素，字符串中的字符。*与关键字 in 成对使用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">3</span> &#123; <span class="built_in">print</span> (<span class="string">"This prints 3 times"</span>) &#125;</span><br></pre></td></tr></table></figure><p><strong>guard</strong>：当有一个以上的条件不满足要求时，将离开当前作用域。同时还提供解包可选类型的功能。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">printRecordFromLastName</span><span class="params">(userLastName: String?)</span></span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name = userLastName, name != <span class="string">"Null"</span> <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//userLastName = "Null"，需要提前退出</span></span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续执行代码</span></span><br><span class="line">    <span class="built_in">print</span>(dataStore.findByLastName(name))  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>if</strong>：当条件满足时，执行代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1</span> &gt; <span class="number">2</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This will never execute"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>in</strong>：在序列上迭代，比如一组特定范围内的数字，数组中的元素，字符串中的字符。*与关键字 key 搭配使用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">3</span> &#123; <span class="built_in">print</span> (<span class="string">"This prints 3 times"</span>) &#125;</span><br></pre></td></tr></table></figure><p><strong>repeat</strong>：在使用循环的判断条件之前，先执行一次循环中的代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repeat</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Always executes at least once before the condition is considered"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span> &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>return</strong>：立刻终止当前上下文，离开当前作用域，此外在返回时可以额外携带一个值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doNothing</span><span class="params">()</span></span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="comment">//直接离开当前上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> anInt = <span class="number">0</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This never prints (anInt)"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnName</span><span class="params">()</span></span> -&gt; <span class="type">String?</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.userName <span class="comment">//离开，并返回 userName 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>switch</strong>：将给定的值与分支进行比较。执行第一个模式匹配成功的分支代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> box = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> box  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 0"</span>)  </span><br><span class="line">    <span class="keyword">fallthrough</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box equals 0 or 1"</span>)  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Box doesn't equal 0 or 1"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>where</strong>：要求关联类型必须遵守特定协议，或者类型参数和关联类型必须保持一致。也可以用于在 case 中提供额外条件，用于满足控制表达式。</p><blockquote><p>where 从句可以应用于多种场景。以下例子指明了 where 的主要应用场景，泛型中的模式匹配。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Nameable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createdFormattedName</span><span class="params">(<span class="number">_</span> namedEntity:T)</span></span> -&gt; <span class="type">String</span> <span class="keyword">where</span> <span class="type">T</span>:<span class="type">Equatable</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//只有当实体同时遵守 Nameable 和 Equatable 协议的时候，才允许调用这个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This things name is "</span> + namedEntity.name  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>…<span class="number">3</span> <span class="keyword">where</span> i % <span class="number">2</span> == <span class="number">0</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">//打印 0 和 2  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>while</strong>：循环执行特定的一段语句，直到条件不满足时，停止循环。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> foo != bar  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Keeps going until the foo == bar"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式和类型中的关键字"><a href="#表达式和类型中的关键字" class="headerlink" title="表达式和类型中的关键字"></a>表达式和类型中的关键字</h2><p><strong>Any</strong>：用于表示任意类型的实例，包括函数类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anything = [<span class="type">Any</span>]()</span><br><span class="line"></span><br><span class="line">anything.append(<span class="string">"Any Swift type can be added"</span>)  </span><br><span class="line">anything.append(<span class="number">0</span>)  </span><br><span class="line">anything.append(&#123;(foo: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="string">"Passed in (foo)"</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>as</strong>：类型转换运算符，用于尝试将值转成其它类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anything = [<span class="type">Any</span>]()</span><br><span class="line"></span><br><span class="line">anything.append(<span class="string">"Any Swift type can be added"</span>)  </span><br><span class="line">anything.append(<span class="number">0</span>)  </span><br><span class="line">anything.append(&#123;(foo: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="string">"Passed in (foo)"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> intInstance = anything[<span class="number">1</span>] <span class="keyword">as</span>? <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anything = [<span class="type">Any</span>]()</span><br><span class="line"></span><br><span class="line">anything.append(<span class="string">"Any Swift type can be added"</span>)  </span><br><span class="line">anything.append(<span class="number">0</span>)  </span><br><span class="line">anything.append(&#123;(foo: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="string">"Passed in (foo)"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> anything  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">switch</span> thing  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Int</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"It's zero and an Int type"</span>)  </span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> someInt <span class="keyword">as</span> <span class="type">Int</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"It's an Int that's not zero but (someInt)"</span>)  </span><br><span class="line">        <span class="keyword">default</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Who knows what it is"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>catch</strong>：如果在 do 中抛出一个错误，catch 会尝试进行匹配，并决定如何处理错误。<a href="https://swiftjectivec.com/swift-error-handling" target="_blank" rel="noopener">*我写的一篇 Swift 错误处理的博客节选</a>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">try</span> haveAWeekend(<span class="number">4</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span> <span class="type">WeekendError</span>.<span class="type">Overtime</span>(<span class="keyword">let</span> hoursWorked)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"You worked (hoursWorked) more than you should have"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span> <span class="type">WeekendError</span>.<span class="type">WorkAllWeekend</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"You worked 48 hours :-0"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Gulping the weekend exception"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>false</strong>：Swift 用于表示布尔值的两个常量值之一，true 的相反值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> alwaysFalse = <span class="literal">false</span>  </span><br><span class="line"><span class="keyword">let</span> alwaysTrue = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> alwaysFalse &#123; <span class="built_in">print</span>(<span class="string">"Won't print, alwaysFalse is false 😉"</span>)&#125;</span><br></pre></td></tr></table></figure><p><strong>is</strong>：类型检查运算符，用于确定实例是否为某个子类类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> : <span class="title">Person</span> </span>&#123;&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nurse</span> : <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> people = [<span class="type">Programmer</span>(), <span class="type">Nurse</span>()]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> aPerson <span class="keyword">in</span> people  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> aPerson <span class="keyword">is</span> <span class="type">Programmer</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This person is a dev"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> aPerson <span class="keyword">is</span> <span class="type">Nurse</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This person is a nurse"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nil</strong>：在 Swift 中表示任意类型的无状态值。</p><blockquote><p>与 Objective-C 中的 nil 不同，Objective-C 中的 nil 表示指向不存在对象的指针。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Place</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任何 Swift 类型或实例可以为 nil</span></span><br><span class="line"><span class="keyword">var</span> statelessPerson:<span class="type">Person?</span> = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">var</span> statelessPlace:<span class="type">Place?</span> = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">var</span> statelessInt:<span class="type">Int?</span> = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">var</span> statelessString:<span class="type">String?</span> = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p><strong>rethrows</strong>：指明当前函数只有当参数抛出 error 时，才会抛出 error。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">networkCall</span><span class="params">(onComplete:<span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) <span class="keyword">rethrows</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">try</span> onComplete()  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">catch</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="type">SomeError</span>.error  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>super</strong>：在子类中，暴露父类的方法、属性、下标。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printName</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Printing a name. "</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> : <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">printName</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">super</span>.printName()  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Hello World!"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aDev = <span class="type">Programmer</span>()  </span><br><span class="line">aDev.printName() <span class="comment">//打印 Printing a name. Hello World!</span></span><br></pre></td></tr></table></figure><p><strong>self</strong>：任何类型的实例都拥有的隐式属性，等同于实例本身。此外还可以用于区分函数参数和成员属性名称相同的情况。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printSelf</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This is me: (self)"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.printSelf() <span class="comment">//打印 "This is me: Person"</span></span><br></pre></td></tr></table></figure><p><strong>Self</strong>：在协议中，表示遵守当前协议的实体类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Printable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printTypeTwice</span><span class="params">(otherMe:<span class="keyword">Self</span>)</span></span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> : <span class="title">Printable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printTypeTwice</span><span class="params">(otherMe: Foo)</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I am me plus (otherMe)"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aFoo = <span class="type">Foo</span>()  </span><br><span class="line"><span class="keyword">let</span> anotherFoo = <span class="type">Foo</span>()</span><br><span class="line"></span><br><span class="line">aFoo.printTypeTwice(otherMe: anotherFoo) <span class="comment">//打印 I am me plus Foo()</span></span><br></pre></td></tr></table></figure><p><strong>throw</strong>：用于在当前上下文，显式抛出 error。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WeekendError</span>: <span class="title">Error</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Overtime</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">WorkAllWeekend</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workOvertime</span> <span class="params">()</span></span> <span class="keyword">throws</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="type">WeekendError</span>.<span class="type">Overtime</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>throws</strong>：指明在一个函数、方法、初始化方法中可能会抛出 error。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WeekendError</span>: <span class="title">Error</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Overtime</span>  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">WorkAllWeekend</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workOvertime</span> <span class="params">()</span></span> <span class="keyword">throws</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="type">WeekendError</span>.<span class="type">Overtime</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//"throws" 表明在调用方法时，需要使用 try，try?，try!</span></span><br><span class="line"><span class="keyword">try</span> workOvertime()</span><br></pre></td></tr></table></figure><p><strong>true</strong>：Swift 用于表示布尔值的两个常量值之一，表示为真。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> alwaysFalse = <span class="literal">false</span>  </span><br><span class="line"><span class="keyword">let</span> alwaysTrue = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> alwaysTrue &#123; <span class="built_in">print</span>(<span class="string">"Always prints"</span>)&#125;</span><br></pre></td></tr></table></figure><p><strong>try</strong>：表明接着调用的函数可能会抛出 error。有三种不同的使用方式：try，try?， try!。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aResult = <span class="keyword">try</span> dangerousFunction() <span class="comment">//处理 error，或者继续传递 error  </span></span><br><span class="line"><span class="keyword">let</span> aResult = <span class="keyword">try</span>! dangerousFunction() <span class="comment">//程序可能会闪退  </span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> aResult = <span class="keyword">try</span>? dangerousFunction() <span class="comment">//解包可选类型。</span></span><br></pre></td></tr></table></figure><h2 id="模式中的关键字"><a href="#模式中的关键字" class="headerlink" title="模式中的关键字"></a>模式中的关键字</h2><p><strong>_</strong>：用于匹配或省略任意值的通配符。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">3</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Just loop 3 times, index has no meaning"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种用法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="number">_</span> = <span class="type">Singleton</span>() <span class="comment">//忽略不使用的变量</span></span><br></pre></td></tr></table></figure><h2 id="以-开头的关键字"><a href="#以-开头的关键字" class="headerlink" title="以#开头的关键字"></a>以#开头的关键字</h2><p><strong>#available</strong>：基于平台参数，通过 <strong>if</strong>，<strong>while</strong>，<strong>guard</strong> 语句的条件，在运行时检查 API 的可用性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">10</span>, *)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"iOS 10 APIs are available"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>#colorLiteral</strong>：在 playground 中使用的字面表达式，用于创建颜色选取器，选取后赋值给变量。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aColor = #colorLiteral <span class="comment">//创建颜色选取器</span></span><br></pre></td></tr></table></figure><p><strong>#column</strong>：一种特殊的字面量表达式，用于获取字面量表示式的起始列数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Some person info - on column (#column)"</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.printInfo() <span class="comment">//Some person info - on column 53</span></span><br></pre></td></tr></table></figure><p><strong>#else</strong>：条件编译控制语句，用于控制程序在不同条件下执行不同代码。与 <strong>#if</strong> 语句结合使用。当条件为 true，执行对应代码。当条件为 false，执行另一段代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> os(iOS)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Compiled for an iOS device"</span>)  </span><br><span class="line">#<span class="keyword">else</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Not on an iOS device"</span>)  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><strong>#elseif</strong>：条件编译控制语句，用于控制程序在不同条件下执行代码。与 <strong>#if</strong> 语句结合使用。当条件为 true，执行对应代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> os(iOS)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Compiled for an iOS device"</span>)  </span><br><span class="line">#elseif os(macOS)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Compiled on a mac computer"</span>)  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><strong>#endif</strong>：条件编译控制语句，用于控制程序在不同条件下执行代码。用于表明条件编译代码的结尾。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> os(iOS)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Compiled for an iOS device"</span>)  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><strong>#file</strong>：特殊字面量表达式，返回当前代码所在源文件的名称。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Some person info - inside file (#file)"</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.printInfo() <span class="comment">//Some person info - inside file /*代码所在 playground 文件路径*/</span></span><br></pre></td></tr></table></figure><p><strong>#fileReference</strong>：playground 字面量语法，用于创建文件选取器，选取并返回 NSURL 实例。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fontFilePath = #fileReference <span class="comment">//创建文件选取器</span></span><br></pre></td></tr></table></figure><p><strong>#function</strong>：特殊字面量表达式，返回函数名称。在方法中，返回方法名。在属性的 getter 或者 setter 中，返回属性名。在特殊的成员中，比如 init 或 subscript 中，返回关键字名称。在文件的最顶层时，返回当前所在模块名称。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Some person info - inside function (#function)"</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.printInfo() <span class="comment">//Some person info - inside function printInfo()</span></span><br></pre></td></tr></table></figure><p><strong>#if</strong>：条件编译控制语句，用于控制程序在不同条件下编译代码。通过判断条件，决定是否执行代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> os(iOS)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Compiled for an iOS device"</span>)  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><strong>#imageLiteral</strong>：playground 字面量语法，创建图片选取器，选择并返回 UIImage 实例。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anImage = #imageLiteral <span class="comment">//在 playground 文件中选取图片</span></span><br></pre></td></tr></table></figure><p><strong>#line</strong>：特殊字面量表达式，用于获取当前代码的行数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Some person info - on line number (#line)"</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.printInfo() <span class="comment">//Some person info - on line number 5</span></span><br></pre></td></tr></table></figure><p><strong>#selector</strong>：用于创建 Objective-C selector 的表达式，可以静态检查方法是否存在，并暴露给 Objective-C。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态检查，确保 doAnObjCMethod 方法存在  </span></span><br><span class="line">control.sendAction(#selector(doAnObjCMethod), to: target, forEvent: event)</span><br></pre></td></tr></table></figure><p><strong>#sourceLocation</strong>：行控制语句，可以指定与原先完全不同的行数和源文件名。通常在 Swift 诊断、debug 时使用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#sourceLocation(file:<span class="string">"foo.swift"</span>, line:<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印新值</span></span><br><span class="line"><span class="built_in">print</span>(#file)  </span><br><span class="line"><span class="built_in">print</span>(#line)</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置行数和文件名</span></span><br><span class="line">#sourceLocation()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(#file)  </span><br><span class="line"><span class="built_in">print</span>(#line)</span><br></pre></td></tr></table></figure><h2 id="特定上下文中的关键字"><a href="#特定上下文中的关键字" class="headerlink" title="特定上下文中的关键字"></a>特定上下文中的关键字</h2><blockquote><p>这些关键字，在处于对应上下文之外时，可以用作标识符。</p></blockquote><p><strong>associativity</strong>：指明同一优先级的运算符，在缺少大括号的情况，按什么顺序结合。使用 <strong>left</strong>、<strong>right</strong>、<strong>none</strong>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ~ &#123; <span class="keyword">associativity</span> <span class="keyword">right</span> <span class="keyword">precedence</span> <span class="number">140</span> &#125;  </span><br><span class="line"><span class="number">4</span> ~ <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>convenience</strong>：次等的便利构造器，最后会调用指定构造器初始化实例。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> name:<span class="type">String</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">self</span>.name = name  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="string">"No Name"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> me = <span class="type">Person</span>()  </span><br><span class="line"><span class="built_in">print</span>(me.name)<span class="comment">//打印 "No Name"</span></span><br></pre></td></tr></table></figure><p><strong>dynamic</strong>：指明编译器不会对类成员或者函数的方法进行内联或虚拟化。这意味着对这个成员的访问是使用 Objective-C 运行时进行动态派发的（代替静态调用）。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="comment">//隐式指明含有 "objc" 属性</span></span><br><span class="line">    <span class="comment">//这对依赖于 Objc-C 黑魔法的库或者框架非常有用</span></span><br><span class="line">    <span class="comment">//比如 KVO、KVC、Swizzling</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> name:<span class="type">String?</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>didSet</strong>：属性观察者，当值存储到属性后马上调用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">didSet</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        tableView.reloadData()  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>final</strong>：防止方法、属性、下标被重写。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> : <span class="title">Person</span> </span>&#123;&#125; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p><strong>get</strong>：返回成员的值。还可以用在计算型属性上，间接获取其它属性的值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.name &#125;  </span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">self</span>.name = newValue&#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> indirectSetName:<span class="type">String</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> aFullTitle = <span class="keyword">self</span>.fullTitle  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">return</span> aFullTitle  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> (newTitle)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//如果没有定义 newTitle，可以使用 newValue</span></span><br><span class="line">            <span class="keyword">self</span>.fullTitle = <span class="string">"(self.name) :(newTitle)"</span>  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>infix</strong>：指明一个用于两个值之间的运算符。如果一个全新的全局运算符被定义为 infix，还需要指定优先级。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> twoIntsAdded = <span class="number">2</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>indirect</strong>：指明在枚举类型中，存在成员使用相同枚举类型的实例作为关联值的情况。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">Entertainment</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> eventType(<span class="type">String</span>)  </span><br><span class="line">    <span class="keyword">case</span> oneEvent(<span class="type">Entertainment</span>)  </span><br><span class="line">    <span class="keyword">case</span> twoEvents(<span class="type">Entertainment</span>, <span class="type">Entertainment</span>)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dinner = <span class="type">Entertainment</span>.eventType(<span class="string">"Dinner"</span>)  </span><br><span class="line"><span class="keyword">let</span> movie = <span class="type">Entertainment</span>.eventType(<span class="string">"Movie"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dateNight = <span class="type">Entertainment</span>.twoEvents(dinner, movie)</span><br></pre></td></tr></table></figure><p><strong>lazy</strong>：指明属性的初始值，直到第一次被使用时，才进行初始化。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> personalityTraits = &#123;  </span><br><span class="line">        <span class="comment">//昂贵的数据库开销  </span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"Nice"</span>, <span class="string">"Funny"</span>]  </span><br><span class="line">    &#125;()  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.personalityTraits <span class="comment">//当 personalityTraits 首次被访问时，数据库才开始工作</span></span><br></pre></td></tr></table></figure><p><strong>left</strong>：指明运算符的结合性是从左到右。在没有使用大括号时，可以用于正确判断同一优先级运算符的执行顺序。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"-" 运算符的结合性是从左到右</span></span><br><span class="line"><span class="number">10</span>-<span class="number">2</span>-<span class="number">4</span> <span class="comment">//根据结合性，可以看做 (10-2) - 4</span></span><br></pre></td></tr></table></figure><p><strong>mutating</strong>：允许在方法中修改结构体或者枚举实例的属性值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> job = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">assignJob</span><span class="params">(newJob:String)</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">self</span> = <span class="type">Person</span>(job: newJob)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.job <span class="comment">//""</span></span><br><span class="line"></span><br><span class="line">aPerson.assignJob(newJob: <span class="string">"iOS Engineer at Buffer"</span>)  </span><br><span class="line">aPerson.job <span class="comment">//iOS Engineer at Buffer</span></span><br></pre></td></tr></table></figure><p><strong>none</strong>：是一个没有结合性的运算符。不允许这样的运算符相邻出现。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"&lt;" 是非结合性的运算符</span></span><br><span class="line"><span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span> <span class="comment">//编译失败</span></span><br></pre></td></tr></table></figure><p><strong>nonmutating</strong>：指明成员的 setter 方法不会修改实例的值，但可能会有其它后果。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Paygrade</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Junior</span>, <span class="type">Middle</span>, <span class="type">Senior</span>, <span class="type">Master</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> experiencePay:<span class="type">String?</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            database.payForGrade(<span class="type">String</span>(describing:<span class="keyword">self</span>))  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">nonmutating</span> <span class="keyword">set</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newPay = newValue  </span><br><span class="line">            &#123;  </span><br><span class="line">                database.editPayForGrade(<span class="type">String</span>(describing:<span class="keyword">self</span>), newSalary:newPay)  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentPay = <span class="type">Paygrade</span>.<span class="type">Middle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 Middle pay 更新为 45k, 但不会修改 experiencePay 值</span></span><br><span class="line">currentPay.experiencePay = <span class="string">"$45,000"</span></span><br></pre></td></tr></table></figure><p><strong>optional</strong>：用于指明协议中的可选方法。遵守该协议的实体类可以不实现这个方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Foo</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">requiredFunction</span><span class="params">()</span></span>  </span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">optionalFunction</span><span class="params">()</span></span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Foo</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">requiredFunction</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Conformance is now valid"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>override</strong>：指明子类会提供自定义实现，覆盖父类的实例方法、类型方法、实例属性、类型属性、下标。如果没有实现，则会直接继承自父类。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I'm just a person!"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> : <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">()</span></span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I'm a person who is a dev!"</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line"><span class="keyword">let</span> aDev = <span class="type">Programmer</span>()</span><br><span class="line"></span><br><span class="line">aPerson.printInfo() <span class="comment">//打印 I'm just a person!  </span></span><br><span class="line">aDev.printInfo() <span class="comment">//打印 I'm a person who is a dev!</span></span><br></pre></td></tr></table></figure><p><strong>postfix</strong>：位于值后面的运算符。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalStr:<span class="type">String?</span> = <span class="string">"Optional"</span>  </span><br><span class="line"><span class="built_in">print</span>(optionalStr!)</span><br></pre></td></tr></table></figure><p><strong>precedence</strong>：指明某个运算符的优先级高于别的运算符，从而被优先使用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ~ &#123; <span class="keyword">associativity</span> <span class="keyword">right</span> <span class="keyword">precedence</span> <span class="number">140</span> &#125;  </span><br><span class="line"><span class="number">4</span> ~ <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>prefix</strong>：位于值前面的运算符。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anInt = <span class="number">2</span>  </span><br><span class="line">anInt = -anInt <span class="comment">//anInt 等于 -2</span></span><br></pre></td></tr></table></figure><p><strong>required</strong>：确保编译器会检查该类的所有子类，全部实现了指定的构造器方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="number">_</span> name:<span class="type">String</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">self</span>.name = name  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> : <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="comment">//如果不实现这个方法，编译不会通过</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="number">_</span> name: <span class="type">String</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>right</strong>：指明运算符的结合性是从右到左的。在没有使用大括号时，可以用于正确判断同一优先级运算符的顺序。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"??" 运算符结合性是从右到左</span></span><br><span class="line"><span class="keyword">var</span> box:<span class="type">Int?</span>  </span><br><span class="line"><span class="keyword">var</span> sol:<span class="type">Int?</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo:<span class="type">Int</span> = box ?? sol ?? <span class="number">0</span> <span class="comment">//Foo 等于 2</span></span><br></pre></td></tr></table></figure><p><strong>set</strong>：通过获取的新值来设置成员的值。同样可以用于计算型属性来间接设置其它属性。如果计算型属性的 setter 没有定义新值的名称，可以使用默认的 newValue。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.name &#125;  </span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">self</span>.name = newValue&#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> indirectSetName:<span class="type">String</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> aFullTitle = <span class="keyword">self</span>.fullTitle  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">return</span> aFullTitle  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> (newTitle)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//如果没有定义 newTitle，可以使用 newValue</span></span><br><span class="line">            <span class="keyword">self</span>.fullTitle = <span class="string">"(self.name) :(newTitle)"</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Type</strong>：表示任意类型的类型，包括类类型、结构类型、枚举类型、协议类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> : <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aDev:<span class="type">Programmer</span>.<span class="type">Type</span> = <span class="type">Programmer</span>.<span class="keyword">self</span></span><br></pre></td></tr></table></figure><p><strong>unowned</strong>：让循环引用中的实例 A 不要强引用实例 B。前提条件是实例 B 的生命周期要长于 A 实例。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> occupation:<span class="type">Job?</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当 Person 实例不存在时，job 也不会存在。job 的生命周期取决于持有它的 Person。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> employee:<span class="type">Person</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(with employee:<span class="type">Person</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">self</span>.employee = employee  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>weak</strong>：允许循环引用中的实例 A 弱引用实例 B ，而不是强引用。实例 B 的生命周期更短，并会被先释放。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> residence:<span class="type">House?</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> occupant:<span class="type">Person?</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me:<span class="type">Person?</span> = <span class="type">Person</span>()  </span><br><span class="line"><span class="keyword">var</span> myHome:<span class="type">House?</span> = <span class="type">House</span>()</span><br><span class="line"></span><br><span class="line">me!.residence = myHome  </span><br><span class="line">myHome!.occupant = me</span><br><span class="line"></span><br><span class="line">me = <span class="literal">nil</span>  </span><br><span class="line">myHome!.occupant <span class="comment">// myHome 等于 nil</span></span><br></pre></td></tr></table></figure><p><strong>willSet</strong>：属性观察者，在值存储到属性之前调用。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String?</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">willSet</span>(newValue) &#123;<span class="built_in">print</span>(<span class="string">"I've got a new name, it's (newValue)!"</span>)&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = <span class="type">Person</span>()  </span><br><span class="line">aPerson.name = <span class="string">"Jordan"</span> <span class="comment">//在赋值之前，打印 "I've got a new name, it's Jordan!"</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>哇噢！</p><p>这真是一次有趣的创作。我学会了好多在写之前没想到的东西。但我认为这里的诀窍并不是要把它记住，而是把它当做一份可以用于测验的定义清单。</p><p>相反地，我建议你把这份清单放在手边，并时不时地回顾一下。如果你能这样做的话，下一次在不同场景下需要使用特定的关键字，你肯定就能马上回想起来并使用它啦。</p><p>下回再见咯。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Jordan Morgan，&lt;a href=&quot;https://www.swiftjectivec.com/swift-keywords-v-3-0-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-02-11&lt;br&gt;译者：&lt;a href=&quot;https://www.jianshu.com/u/076cc5e18bb8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;郑一一&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/Pancf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pancf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;有句话之前我提过，今天还想再说一次。那就是打铁还需自身硬。对于自身能力的严格要求，可以帮助实现我们所有梦寐以求的东西。&lt;/p&gt;
&lt;p&gt;说起来可能有些消极，知识毕竟是永远学不完的。不论如何，今天 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我们先来学习一下 Swift 中的每一个关键字&lt;/a&gt;（V3.0.1），在介绍每个关键字的时候，同时会附带一段代码加以说明。&lt;/p&gt;
&lt;p&gt;在这些关键字之中，会有你熟悉或者不熟悉的部分。但为了最好的阅读和学习体验，我把它们全部列出来了。文章篇幅有些长，你准备好了么？&lt;/p&gt;
&lt;p&gt;让我们现在就开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="swiftjectivec" scheme="https://swift.gg/categories/swiftjectivec/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>给 UIView 来点烟花</title>
    <link href="https://swift.gg/2019/08/14/add-fireworks-and-sparks-to-a-uiview/"/>
    <id>https://swift.gg/2019/08/14/add-fireworks-and-sparks-to-a-uiview/</id>
    <published>2019-08-14T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/programming-blog/2018/09/add-fireworks-and-sparks-to-a-uiview/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-09<br>译者：<a href="https://github.com/joeytat" target="_blank" rel="noopener">Joeytat</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；定稿：<a href="https://github.com/Pancf" target="_blank" rel="noopener">Pancf</a></p></blockquote><!--此处开始正文--><a id="more"></a><p>你也很喜欢常用 app 里的那些小细节吧？当我从 <a href="https://dribbble.com/" target="_blank" rel="noopener">dribbble</a> 中寻找灵感时，就发现了这个漂亮的设计：当用户在某个重要的视图中修改设置或者进行了什么操作时，会有烟花在周围绽放。于是我就在想这个东西有多难实现，然后过了一段时间，我完成了 :)</p><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/hero.gif1565786277.3434784" alt="hero"></p><h2 id="烟花的细节"><a href="#烟花的细节" class="headerlink" title="烟花的细节"></a><em>烟花的细节</em></h2><p>下面是对于这个效果的详细描述。烟花应该在视图周围的某个特殊的位置爆开，可能是按钮在点击事件响应时。当点击发生时，烟花应该在按钮的四角爆开，并且爆炸产生的火花应该按照自身的轨迹移动。</p><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/final.jpg1565786278.2018952" alt="final"></p><p><em>超喜欢这个效果! 不仅让我感受到视觉上的愉悦，还让我想要不停地戳这个按钮！ :) 🎉</em></p><p>现在让我们再看一眼这个动画。每次生成的烟花，其整体行为是大致相似的。但还是在火花的轨迹和大小上有一些区别。让我们拆开来说。</p><ul><li>每一次点击都会产生<em>两处烟花</em>，</li><li>每一处烟花会产生 <em>8 个火花</em>，</li><li>每个火花都遵循着自己的<em>轨迹</em>，</li><li>轨迹看起来<em>相似</em>，但其实<em>不完全一样</em>。从爆炸<em>开始</em>的位置来看，有部分朝<em>右</em>，有部分朝<em>左</em>，剩余的朝<em>上</em>或<em>下</em>。</li></ul><h2 id="火花的分布"><a href="#火花的分布" class="headerlink" title="火花的分布"></a><em>火花的分布</em></h2><p>这个烟花特效有着简单的火花分布规则。将爆炸点分为四块「视线区域」来看：上左，上右，下左，下右，每个区域都有两个火花。</p><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/sparks-distribution.jpg1565786278.5224512" alt="sparks distribution"></p><h2 id="火花的轨迹"><a href="#火花的轨迹" class="headerlink" title="火花的轨迹"></a><em>火花的轨迹</em></h2><p>火花的移动有着自己的轨迹。在一处烟花中有 8 个火花，那至少需要 8 道轨迹。理想状态下应该有更多的轨迹，可以增加一些随机性，这样连续爆发烟花的时候，不会看起来和前一个完全一样。</p><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/spark-trajectories.jpg1565786278.861796" alt="spark-trajectories"></p><p>我为每一个区域创建了 4 条轨迹，这样就赋予了两倍于火花数量的随机性。为了方便计算，我统一了每条轨迹的初始点。因为我用了不同的工具来可视化这些轨迹，所以图上的轨迹和我完成的效果略有不同 - 但你能明白我的想法就行 :)</p><h2 id="实现"><a href="#实现" class="headerlink" title="_实现_"></a>_实现_</h2><p>理论足够了。接下来让我们把各个模块拼凑起来。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SparkTrajectory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 存储着定义轨迹所需要的所有的点</span></span><br><span class="line">    <span class="keyword">var</span> points: [<span class="type">CGPoint</span>] &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 用 path 来表现轨迹</span></span><br><span class="line">    <span class="keyword">var</span> path: <span class="type">UIBezierPath</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个用于表示火花轨迹的协议。为了能够更简单地创建各式各样的轨迹，我定义了这个通用接口协议，并且选择基于三阶 <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank" rel="noopener">贝塞尔曲线</a> 来实现轨迹；还添加了一个 <code>init</code> 方法，这样我就可以通过一行代码来创建轨迹了。三阶贝塞尔曲线必须包含四个点。第一个和最后一个点定义了轨迹的开始和结束的位置，中间的两个点用于控制曲线的弯曲度。你可以用在线数学工具 <a href="https://www.desmos.com/calculator/epunzldltu" target="_blank" rel="noopener">desmos</a> 来调整自己的贝塞尔曲线。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 拥有两个控制点的贝塞尔曲线</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CubicBezierTrajectory</span>: <span class="title">SparkTrajectory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> points = [<span class="type">CGPoint</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> x0: <span class="type">CGFloat</span>, <span class="number">_</span> y0: <span class="type">CGFloat</span>,</span><br><span class="line">         <span class="number">_</span> x1: <span class="type">CGFloat</span>, <span class="number">_</span> y1: <span class="type">CGFloat</span>,</span><br><span class="line">         <span class="number">_</span> x2: <span class="type">CGFloat</span>, <span class="number">_</span> y2: <span class="type">CGFloat</span>,</span><br><span class="line">         <span class="number">_</span> x3: <span class="type">CGFloat</span>, <span class="number">_</span> y3: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.points.append(<span class="type">CGPoint</span>(x: x0, y: y0))</span><br><span class="line">        <span class="keyword">self</span>.points.append(<span class="type">CGPoint</span>(x: x1, y: y1))</span><br><span class="line">        <span class="keyword">self</span>.points.append(<span class="type">CGPoint</span>(x: x2, y: y2))</span><br><span class="line">        <span class="keyword">self</span>.points.append(<span class="type">CGPoint</span>(x: x3, y: y3))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> path: <span class="type">UIBezierPath</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">self</span>.points.<span class="built_in">count</span> == <span class="number">4</span> <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"4 points required"</span>) &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>()</span><br><span class="line">        path.move(to: <span class="keyword">self</span>.points[<span class="number">0</span>])</span><br><span class="line">        path.addCurve(to: <span class="keyword">self</span>.points[<span class="number">3</span>], controlPoint1: <span class="keyword">self</span>.points[<span class="number">1</span>], controlPoint2: <span class="keyword">self</span>.points[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/desmos-tool.png1565786279.294991" alt="desmos-tool"></p><p>接下来要实现的是一个能够创建随机轨迹的工厂。前面的图中你可以看到轨迹是根据颜色来分组的。我只创建了上右和下右两块位置的轨迹，然后进行了镜像复制。这对于我们将要发射的烟花来说已经足够了🚀</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SparkTrajectoryFactory</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ClassicSparkTrajectoryFactoryProtocol</span>: <span class="title">SparkTrajectoryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">randomTopRight</span><span class="params">()</span></span> -&gt; <span class="type">SparkTrajectory</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">randomBottomRight</span><span class="params">()</span></span> -&gt; <span class="type">SparkTrajectory</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassicSparkTrajectoryFactory</span>: <span class="title">ClassicSparkTrajectoryFactoryProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> topRight: [<span class="type">SparkTrajectory</span>] = &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.31</span>, -<span class="number">0.46</span>, <span class="number">0.74</span>, -<span class="number">0.29</span>, <span class="number">0.99</span>, <span class="number">0.12</span>),</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.31</span>, -<span class="number">0.46</span>, <span class="number">0.62</span>, -<span class="number">0.49</span>, <span class="number">0.88</span>, -<span class="number">0.19</span>),</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.10</span>, -<span class="number">0.54</span>, <span class="number">0.44</span>, -<span class="number">0.53</span>, <span class="number">0.66</span>, -<span class="number">0.30</span>),</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.19</span>, -<span class="number">0.46</span>, <span class="number">0.41</span>, -<span class="number">0.53</span>, <span class="number">0.65</span>, -<span class="number">0.45</span>),</span><br><span class="line">        ]</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> bottomRight: [<span class="type">SparkTrajectory</span>] = &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.42</span>, -<span class="number">0.01</span>, <span class="number">0.68</span>, <span class="number">0.11</span>, <span class="number">0.87</span>, <span class="number">0.44</span>),</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.35</span>, <span class="number">0.00</span>, <span class="number">0.55</span>, <span class="number">0.12</span>, <span class="number">0.62</span>, <span class="number">0.45</span>),</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.21</span>, <span class="number">0.05</span>, <span class="number">0.31</span>, <span class="number">0.19</span>, <span class="number">0.32</span>, <span class="number">0.45</span>),</span><br><span class="line">            <span class="type">CubicBezierTrajectory</span>(<span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.18</span>, <span class="number">0.00</span>, <span class="number">0.31</span>, <span class="number">0.11</span>, <span class="number">0.35</span>, <span class="number">0.25</span>),</span><br><span class="line">        ]</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">randomTopRight</span><span class="params">()</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.topRight[<span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(<span class="keyword">self</span>.topRight.<span class="built_in">count</span>)))]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">randomBottomRight</span><span class="params">()</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.bottomRight[<span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(<span class="keyword">self</span>.bottomRight.<span class="built_in">count</span>)))]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先创建了用来表示火花轨迹工厂的抽象协议，还有一个我将其命名为<em>经典烟花</em>的火花轨迹的抽象协议，这样的抽象可以方便后续将其替换成其他的轨迹协议。</p><p>如同我前面提到的，我通过 <a href="https://www.desmos.com/calculator/epunzldltu" target="_blank" rel="noopener">desmos</a> 创建了两组轨迹，对应着右上，和右下两块区域。</p><p><strong>重要提醒</strong>：如果在 desmos 上 y 轴所显示的是正数，那么你应该将其转换成负数。因为在 iOS 系统中，越接近屏幕顶部 y 轴的值越小，所以 y 轴的值需要翻转一下。</p><p>并且值得一提的是，为了后面好计算，所有的轨迹初始点都是 (0,0)。</p><p>我们现在创建好了轨迹。接下来创建一些视图来表示火花。对于经典烟花来说，只需要有颜色的圆圈就行。通过抽象可以让我们在未来以更低的成本，创建不同的火花视图。比如小鸭子图片，或者是胖吉猫 :)</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparkView</span>: <span class="title">UIView</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleColorSparkView</span>: <span class="title">SparkView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(color: <span class="type">UIColor</span>, size: <span class="type">CGSize</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(origin: .zero, size: size))</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = color</span><br><span class="line">        <span class="keyword">self</span>.layer.cornerRadius = <span class="keyword">self</span>.frame.width / <span class="number">2.0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> sparkColorSet1: [<span class="type">UIColor</span>] = &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="type">UIColor</span>(red:<span class="number">0.89</span>, green:<span class="number">0.58</span>, blue:<span class="number">0.70</span>, alpha:<span class="number">1.00</span>),</span><br><span class="line">            <span class="type">UIColor</span>(red:<span class="number">0.96</span>, green:<span class="number">0.87</span>, blue:<span class="number">0.62</span>, alpha:<span class="number">1.00</span>),</span><br><span class="line">            <span class="type">UIColor</span>(red:<span class="number">0.67</span>, green:<span class="number">0.82</span>, blue:<span class="number">0.94</span>, alpha:<span class="number">1.00</span>),</span><br><span class="line">            <span class="type">UIColor</span>(red:<span class="number">0.54</span>, green:<span class="number">0.56</span>, blue:<span class="number">0.94</span>, alpha:<span class="number">1.00</span>),</span><br><span class="line">        ]</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了创建火花视图，我们还需要一个工厂数据以填充，需要的数据是火花的大小，以及用来决定火花在哪个烟花的索引（用于增加随机性）。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SparkViewFactoryData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGSize</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> index: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SparkViewFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(with data: SparkViewFactoryData)</span></span> -&gt; <span class="type">SparkView</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleColorSparkViewFactory</span>: <span class="title">SparkViewFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> colors: [<span class="type">UIColor</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>.sparkColorSet1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(with data: SparkViewFactoryData)</span></span> -&gt; <span class="type">SparkView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> color = <span class="keyword">self</span>.colors[data.index % <span class="keyword">self</span>.colors.<span class="built_in">count</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CircleColorSparkView</span>(color: color, size: data.size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看这样抽象了之后，就算再实现一个像胖吉猫的火花也会很简单。接下来让我们来创建<em>经典烟花</em>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">FireworkSpark</span> = (sparkView: <span class="type">SparkView</span>, trajectory: <span class="type">SparkTrajectory</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Firework</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 烟花的初始位置</span></span><br><span class="line">    <span class="keyword">var</span> origin: <span class="type">CGPoint</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 定义了轨迹的大小. 轨迹都是统一大小</span></span><br><span class="line">    <span class="comment">/// 所以需要在展示到屏幕上前将其放大</span></span><br><span class="line">    <span class="keyword">var</span> scale: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 火花的大小</span></span><br><span class="line">    <span class="keyword">var</span> sparkSize: <span class="type">CGSize</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 获取轨迹</span></span><br><span class="line">    <span class="keyword">var</span> trajectoryFactory: <span class="type">SparkTrajectoryFactory</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 获取火花视图</span></span><br><span class="line">    <span class="keyword">var</span> sparkViewFactory: <span class="type">SparkViewFactory</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sparkViewFactoryData</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">SparkViewFactoryData</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sparkView</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">SparkView</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">trajectory</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">SparkTrajectory</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Firework</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 帮助方法，用于返回火花视图及对应的轨迹</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">spark</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">FireworkSpark</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FireworkSpark</span>(<span class="keyword">self</span>.sparkView(at: index), <span class="keyword">self</span>.trajectory(at: index))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是烟花的抽象。为了表示一个烟花需要这些东西:</p><ul><li><em>origin</em></li><li><em>scale</em></li><li><em>sparkSize</em></li><li><em>trajectoryFactory</em></li><li><em>sparkViewFactory</em></li></ul><p>在我们实现协议之前，还有一个我之前没有提到过的叫做<em>按轨迹缩放</em>的概念。当火花处于轨迹 &lt;-1, 1&gt; 或相似的位置时，我们希望它的大小会跟随轨迹变化。我们还需要放大路径以覆盖更大的屏幕显示效果。此外，我们还需要支持水平翻转路径，以方便我们实现经典烟花左侧部分的轨迹，并且还要让轨迹能朝某个指定方向偏移一点（增加随机性）。下面是两个能够帮助我们达到目的的方法，我相信这段代码已经不需要更多描述了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SparkTrajectory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 缩放轨迹使其符合各种 UI 的要求</span></span><br><span class="line">    <span class="comment">/// 在各种形变和 shift: 之前使用</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">scale</span><span class="params">(by value: CGFloat)</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> copy = <span class="keyword">self</span></span><br><span class="line">        (<span class="number">0</span>..&lt;<span class="keyword">self</span>.points.<span class="built_in">count</span>).forEach &#123; copy.points[$<span class="number">0</span>].multiply(by: value) &#125;</span><br><span class="line">        <span class="keyword">return</span> copy</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 水平翻转轨迹</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flip</span><span class="params">()</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> copy = <span class="keyword">self</span></span><br><span class="line">        (<span class="number">0</span>..&lt;<span class="keyword">self</span>.points.<span class="built_in">count</span>).forEach &#123; copy.points[$<span class="number">0</span>].x *= -<span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> copy</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 偏移轨迹，在每个点上生效</span></span><br><span class="line">    <span class="comment">/// 在各种形变和 scale: 和之后使用</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">shift</span><span class="params">(to point: CGPoint)</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> copy = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">let</span> vector = <span class="type">CGVector</span>(dx: point.x, dy: point.y)</span><br><span class="line">        (<span class="number">0</span>..&lt;<span class="keyword">self</span>.points.<span class="built_in">count</span>).forEach &#123; copy.points[$<span class="number">0</span>].add(vector: vector) &#125;</span><br><span class="line">        <span class="keyword">return</span> copy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，接下来就是实现经典烟花。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassicFirework</span>: <span class="title">Firework</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     x     |     x</span></span><br><span class="line"><span class="comment">        x  |   x</span></span><br><span class="line"><span class="comment">           |</span></span><br><span class="line"><span class="comment">     ---------------</span></span><br><span class="line"><span class="comment">         x |  x</span></span><br><span class="line"><span class="comment">       x   |</span></span><br><span class="line"><span class="comment">           |     x</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">FlipOptions</span>: <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> rawValue: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> horizontally = <span class="type">FlipOptions</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> vertically = <span class="type">FlipOptions</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">Quarter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> topRight</span><br><span class="line">        <span class="keyword">case</span> bottomRight</span><br><span class="line">        <span class="keyword">case</span> bottomLeft</span><br><span class="line">        <span class="keyword">case</span> topLeft</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> origin: <span class="type">CGPoint</span></span><br><span class="line">    <span class="keyword">var</span> scale: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">var</span> sparkSize: <span class="type">CGSize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> maxChangeValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> trajectoryFactory: <span class="type">SparkTrajectoryFactory</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ClassicSparkTrajectoryFactory</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> classicTrajectoryFactory: <span class="type">ClassicSparkTrajectoryFactoryProtocol</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.trajectoryFactory <span class="keyword">as</span>! <span class="type">ClassicSparkTrajectoryFactoryProtocol</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sparkViewFactory: <span class="type">SparkViewFactory</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CircleColorSparkViewFactory</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> quarters = [<span class="type">Quarter</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(origin: <span class="type">CGPoint</span>, sparkSize: <span class="type">CGSize</span>, scale: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.origin = origin</span><br><span class="line">        <span class="keyword">self</span>.scale = scale</span><br><span class="line">        <span class="keyword">self</span>.sparkSize = sparkSize</span><br><span class="line">        <span class="keyword">self</span>.quarters = <span class="keyword">self</span>.shuffledQuarters()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sparkViewFactoryData</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">SparkViewFactoryData</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">DefaultSparkViewFactoryData</span>(size: <span class="keyword">self</span>.sparkSize, index: index)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sparkView</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">SparkView</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.sparkViewFactory.create(with: <span class="keyword">self</span>.sparkViewFactoryData(at: index))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">trajectory</span><span class="params">(at index: Int)</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> quarter = <span class="keyword">self</span>.quarters[index]</span><br><span class="line">        <span class="keyword">let</span> flipOptions = <span class="keyword">self</span>.flipOptions(<span class="keyword">for</span>: quarter)</span><br><span class="line">        <span class="keyword">let</span> changeVector = <span class="keyword">self</span>.randomChangeVector(flipOptions: flipOptions, maxValue: <span class="keyword">self</span>.maxChangeValue)</span><br><span class="line">        <span class="keyword">let</span> sparkOrigin = <span class="keyword">self</span>.origin.adding(vector: changeVector)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.randomTrajectory(flipOptions: flipOptions).scale(by: <span class="keyword">self</span>.scale).shift(to: sparkOrigin)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">flipOptions</span><span class="params">(`<span class="keyword">for</span>` quarter: Quarter)</span></span> -&gt; <span class="type">FlipOptions</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> flipOptions: <span class="type">FlipOptions</span> = []</span><br><span class="line">        <span class="keyword">if</span> quarter == .bottomLeft || quarter == .topLeft &#123;</span><br><span class="line">            flipOptions.insert(.horizontally)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> quarter == .bottomLeft || quarter == .bottomRight &#123;</span><br><span class="line">            flipOptions.insert(.vertically)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flipOptions</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">shuffledQuarters</span><span class="params">()</span></span> -&gt; [<span class="type">Quarter</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> quarters: [<span class="type">Quarter</span>] = [</span><br><span class="line">            .topRight, .topRight,</span><br><span class="line">            .bottomRight, .bottomRight,</span><br><span class="line">            .bottomLeft, .bottomLeft,</span><br><span class="line">            .topLeft, .topLeft</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> shuffled = [<span class="type">Quarter</span>]()</span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;quarters.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> idx = <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(quarters.<span class="built_in">count</span>)))</span><br><span class="line">            shuffled.append(quarters[idx])</span><br><span class="line">            quarters.remove(at: idx)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shuffled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">randomTrajectory</span><span class="params">(flipOptions: FlipOptions)</span></span> -&gt; <span class="type">SparkTrajectory</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> trajectory: <span class="type">SparkTrajectory</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> flipOptions.<span class="built_in">contains</span>(.vertically) &#123;</span><br><span class="line">            trajectory = <span class="keyword">self</span>.classicTrajectoryFactory.randomBottomRight()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            trajectory = <span class="keyword">self</span>.classicTrajectoryFactory.randomTopRight()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flipOptions.<span class="built_in">contains</span>(.horizontally) ? trajectory.flip() : trajectory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">randomChangeVector</span><span class="params">(flipOptions: FlipOptions, maxValue: Int)</span></span> -&gt; <span class="type">CGVector</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> values = (<span class="keyword">self</span>.randomChange(maxValue), <span class="keyword">self</span>.randomChange(maxValue))</span><br><span class="line">        <span class="keyword">let</span> changeX = flipOptions.<span class="built_in">contains</span>(.horizontally) ? -values.<span class="number">0</span> : values.<span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> changeY = flipOptions.<span class="built_in">contains</span>(.vertically) ? values.<span class="number">1</span> : -values.<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGVector</span>(dx: changeX, dy: changeY)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">randomChange</span><span class="params">(<span class="number">_</span> maxValue: Int)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGFloat</span>(arc4random_uniform(<span class="type">UInt32</span>(maxValue)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数代码都是 <code>Firework</code> 协议的实现，所以应该很容易理解。我们在各处传递了需要的工厂类，还添加了一个额外的枚举类型来随机地为每个火花指定轨迹。</p><p>有少数几个方法用来为烟花和火花增加随机性。</p><p>还引入了一个 <code>quarters</code> 属性，其中包含了火花的所有的方位。我们通过  <code>shuffledQuarters:</code> 来重新排列，以确保我们不会总是在相同的方位创建相同数量的火花。</p><p>好了，我们创建好了烟花，接下来怎么让火花动起来呢？这就引入了火花动画启动器的概念。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SparkViewAnimator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animate</span><span class="params">(spark: FireworkSpark, duration: TimeInterval)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法接受一个包含火花视图和其对应轨迹的元组 <code>FireworkSpark</code>，以及动画的持续时间。方法的实现取决于我们。我自己的实现蛮多的，但主要做了三件事情：让火花视图跟随轨迹，同时缩放火花（带有随机性），修改其不透明度。简单吧。同时得益于 <code>SparkViewAnimator</code> 的抽象度，我们还可以很简单地将其替换成任何我们想要的动画效果。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ClassicFireworkAnimator</span>: <span class="title">SparkViewAnimator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animate</span><span class="params">(spark: FireworkSpark, duration: TimeInterval)</span></span> &#123;</span><br><span class="line">        spark.sparkView.isHidden = <span class="literal">false</span> <span class="comment">// show previously hidden spark view</span></span><br><span class="line"></span><br><span class="line">        <span class="type">CATransaction</span>.begin()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 火花的位置</span></span><br><span class="line">        <span class="keyword">let</span> positionAnim = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">"position"</span>)</span><br><span class="line">        positionAnim.path = spark.trajectory.path.cgPath</span><br><span class="line">        positionAnim.calculationMode = kCAAnimationLinear</span><br><span class="line">        positionAnim.rotationMode = kCAAnimationRotateAuto</span><br><span class="line">        positionAnim.duration = duration</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 火花的缩放</span></span><br><span class="line">        <span class="keyword">let</span> randomMaxScale = <span class="number">1.0</span> + <span class="type">CGFloat</span>(arc4random_uniform(<span class="number">7</span>)) / <span class="number">10.0</span></span><br><span class="line">        <span class="keyword">let</span> randomMinScale = <span class="number">0.5</span> + <span class="type">CGFloat</span>(arc4random_uniform(<span class="number">3</span>)) / <span class="number">10.0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> fromTransform = <span class="type">CATransform3DIdentity</span></span><br><span class="line">        <span class="keyword">let</span> byTransform = <span class="type">CATransform3DScale</span>(fromTransform, randomMaxScale, randomMaxScale, randomMaxScale)</span><br><span class="line">        <span class="keyword">let</span> toTransform = <span class="type">CATransform3DScale</span>(<span class="type">CATransform3DIdentity</span>, randomMinScale, randomMinScale, randomMinScale)</span><br><span class="line">        <span class="keyword">let</span> transformAnim = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">"transform"</span>)</span><br><span class="line"></span><br><span class="line">        transformAnim.values = [</span><br><span class="line">            <span class="type">NSValue</span>(caTransform3D: fromTransform),</span><br><span class="line">            <span class="type">NSValue</span>(caTransform3D: byTransform),</span><br><span class="line">            <span class="type">NSValue</span>(caTransform3D: toTransform)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        transformAnim.duration = duration</span><br><span class="line">        transformAnim.timingFunction = <span class="type">CAMediaTimingFunction</span>(name: kCAMediaTimingFunctionEaseOut)</span><br><span class="line">        spark.sparkView.layer.transform = toTransform</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 火花的不透明度</span></span><br><span class="line">        <span class="keyword">let</span> opacityAnim = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">"opacity"</span>)</span><br><span class="line">        opacityAnim.values = [<span class="number">1.0</span>, <span class="number">0.0</span>]</span><br><span class="line">        opacityAnim.keyTimes = [<span class="number">0.95</span>, <span class="number">0.98</span>]</span><br><span class="line">        opacityAnim.duration = duration</span><br><span class="line">        spark.sparkView.layer.opacity = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组合动画</span></span><br><span class="line">        <span class="keyword">let</span> groupAnimation = <span class="type">CAAnimationGroup</span>()</span><br><span class="line">        groupAnimation.animations = [positionAnim, transformAnim, opacityAnim]</span><br><span class="line">        groupAnimation.duration = duration</span><br><span class="line"></span><br><span class="line">        <span class="type">CATransaction</span>.setCompletionBlock(&#123;</span><br><span class="line">            spark.sparkView.removeFromSuperview()</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        spark.sparkView.layer.add(groupAnimation, forKey: <span class="string">"spark-animation"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="type">CATransaction</span>.commit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的代码已经足够让我们在特定的视图上展示烟花了。我又更进了一步，创建了一个 <code>ClassicFireworkController</code> 来处理所有的工作，这样用一行代码就能启动烟花。</p><p>这个烟花控制器还做了另一件事。它可以修改烟花的 <code>zPosition</code>，这样我们可以让烟花一前一后地展示，效果更好看一些。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassicFireworkController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sparkAnimator: <span class="type">SparkViewAnimator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ClassicFireworkAnimator</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createFirework</span><span class="params">(at origin: CGPoint, sparkSize: CGSize, scale: CGFloat)</span></span> -&gt; <span class="type">Firework</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ClassicFirework</span>(origin: origin, sparkSize: sparkSize, scale: scale)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 让烟花在其源视图的角落附近爆开</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addFireworks</span><span class="params">(<span class="built_in">count</span> fireworksCount: Int = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      sparks sparksCount: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">                      around sourceView: UIView,</span></span></span><br><span class="line"><span class="function"><span class="params">                      sparkSize: CGSize = CGSize<span class="params">(width: <span class="number">7</span>, height: <span class="number">7</span>)</span></span></span>,</span><br><span class="line">                      scale: <span class="type">CGFloat</span> = <span class="number">45.0</span>,</span><br><span class="line">                      maxVectorChange: <span class="type">CGFloat</span> = <span class="number">15.0</span>,</span><br><span class="line">                      animationDuration: <span class="type">TimeInterval</span> = <span class="number">0.4</span>,</span><br><span class="line">                      canChangeZIndex: <span class="type">Bool</span> = <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> superview = sourceView.superview <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>() &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> origins = [</span><br><span class="line">            <span class="type">CGPoint</span>(x: sourceView.frame.minX, y: sourceView.frame.minY),</span><br><span class="line">            <span class="type">CGPoint</span>(x: sourceView.frame.maxX, y: sourceView.frame.minY),</span><br><span class="line">            <span class="type">CGPoint</span>(x: sourceView.frame.minX, y: sourceView.frame.maxY),</span><br><span class="line">            <span class="type">CGPoint</span>(x: sourceView.frame.maxX, y: sourceView.frame.maxY),</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;fireworksCount &#123;</span><br><span class="line">            <span class="keyword">let</span> idx = <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(origins.<span class="built_in">count</span>)))</span><br><span class="line">            <span class="keyword">let</span> origin = origins[idx].adding(vector: <span class="keyword">self</span>.randomChangeVector(<span class="built_in">max</span>: maxVectorChange))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> firework = <span class="keyword">self</span>.createFirework(at: origin, sparkSize: sparkSize, scale: scale)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> sparkIndex <span class="keyword">in</span> <span class="number">0</span>..&lt;sparksCount &#123;</span><br><span class="line">                <span class="keyword">let</span> spark = firework.spark(at: sparkIndex)</span><br><span class="line">                spark.sparkView.isHidden = <span class="literal">true</span></span><br><span class="line">                superview.addSubview(spark.sparkView)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> canChangeZIndex &#123;</span><br><span class="line">                    <span class="keyword">let</span> zIndexChange: <span class="type">CGFloat</span> = arc4random_uniform(<span class="number">2</span>) == <span class="number">0</span> ? -<span class="number">1</span> : +<span class="number">1</span></span><br><span class="line">                    spark.sparkView.layer.zPosition = sourceView.layer.zPosition + zIndexChange</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    spark.sparkView.layer.zPosition = sourceView.layer.zPosition</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">self</span>.sparkAnimator.animate(spark: spark, duration: animationDuration)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">randomChangeVector</span><span class="params">(<span class="built_in">max</span>: CGFloat)</span></span> -&gt; <span class="type">CGVector</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGVector</span>(dx: <span class="keyword">self</span>.randomChange(<span class="built_in">max</span>: <span class="built_in">max</span>), dy: <span class="keyword">self</span>.randomChange(<span class="built_in">max</span>: <span class="built_in">max</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">randomChange</span><span class="params">(<span class="built_in">max</span>: CGFloat)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGFloat</span>(arc4random_uniform(<span class="type">UInt32</span>(<span class="built_in">max</span>))) - (<span class="built_in">max</span> / <span class="number">2.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个控制器只做了几件事情。随机选择了一个角落展示烟花。在烟花出现的位置，烟花和火花的数量上增加了一些随机性。然后将火花添加到目标视图上，如果需要的话还会调整 <code>zIndex</code>，最后启动了动画。</p><p>几乎所有的参数都设置了默认参数，所以你可以不管他们。直接通过你的控制器调用这个：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.fireworkController.addFireworks(<span class="built_in">count</span>: <span class="number">2</span>, sparks: <span class="number">8</span>, around: button)</span><br></pre></td></tr></table></figure><p>然后，哇!</p><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/classic.gif1565786279.8336995" alt="classic"></p><p>从这一步起，新添加一个像下面这样的烟花就变得非常简单了。你只需要定义新的轨迹，创建一个新的烟花，并且按照你希望的样子来实现即可。将这些代码放入一个控制器可以让你想在哪里启动烟花都很简单 :) 或者你也可以直接使用这个<em>喷泉烟花</em>，我已经把它放在了我的 github 项目 <a href="https://github.com/tomkowz/fireworks" target="_blank" rel="noopener">tomkowz/fireworks</a> 中。</p><p><img src="https://swift.gg/img/articles/add-fireworks-and-sparks-to-a-uiview/fountain.gif1565786280.6926286" alt="fountain"></p><h2 id="总结"><a href="#总结" class="headerlink" title="_总结_"></a>_总结_</h2><p>这个动画效果的实现并不简单但也不算很难。通过对问题（在我们的情况下是动画效果）的正确分析，我们可以将其分解成多个小问题，逐个解决然后将其组合在一起。真希望我有机会能够在未来的的项目中使用这个效果🎉</p><p>好啦这就是今天的内容。感谢阅读！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Tomasz Szulc，&lt;a href=&quot;http://szulctomasz.com/programming-blog/2018/09/add-fireworks-and-sparks-to-a-uiview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-09&lt;br&gt;译者：&lt;a href=&quot;https://github.com/joeytat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Joeytat&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/WAMaker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WAMaker&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/Pancf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pancf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
    
    </summary>
    
      <category term="Tomasz Szulc" scheme="https://swift.gg/categories/Tomasz-Szulc/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="教程" scheme="https://swift.gg/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Bundles and Packages</title>
    <link href="https://swift.gg/2019/07/19/nshipster-bundles-and-packages/"/>
    <id>https://swift.gg/2019/07/19/nshipster-bundles-and-packages/</id>
    <published>2019-07-19T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/bundles-and-packages/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-12-17<br>译者：<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://bignerdcoding.com/" target="_blank" rel="noopener">BigNerdCoding</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>在这个给予的季节，让我们停下脚步，思考一个现代计算机系统赐予我们的最棒的礼物：抽象。</p><p>在数百万 CPU 晶体管、SSD 扇区和 LCD 像素共同协作下，全球数十亿人能够日常使用计算机和移动设备而对此全然不知。这一切都应归功于像文件，目录，应用和文档这样的抽象。</p><p>这周的 NSHipster，我们将讨论苹果平台上两个重要的抽象：包与包裹。🎁</p><a id="more"></a><hr><p>尽管是不同的概念，包与包裹这两个术语经常会被替换使用。毫无疑问，造成困惑的部分原因出自它们相似的名称，但或许主要原因是许多包恰好也是包裹（反之亦然）。</p><p>在我们深入之前，先定义一下这两个术语：</p><ul><li>包是指具有已知结构的，包含可执行代码，以及代码所需的资源的目录。</li><li>包裹是指在访达中看起来像是文件的目录。</li></ul><p>下图展示了包与包裹之间的关系，将应用、框架包、插件包和文档分别放入一个或多个分类之中：<br><img src="https://nshipster.com/assets/packages-and-bundles-diagram-a604d818c7decc7430fffc8642f0743728d2f6be4dfae15b274a599655cd3e40.svg" alt="diagram"></p><blockquote><p>如果对两者的区别你依然感到困惑，这个类比或许能帮助你理解：<br>把包裹想象成是一个内容被隐藏的盒子（📦），作为一个独立的实体而存在。这点与包不同，包更像是一个背包（🎒） —— 每一款都有特殊的口袋和隔层用来携带你需要的东西，不同的配置用以决定是带去学校，去工作，还是去健身房。如果某样东西既是包也是包裹，恰似行李（🧳）一般：像盒子一样浑然一体，像背包一样分隔自如。</p></blockquote><h2 id="包（Bundles）"><a href="#包（Bundles）" class="headerlink" title="包（Bundles）"></a>包（Bundles）</h2><p>包为代码和资源的组织提供了特定结构，意在<strong>提升开发者的体验</strong>。这个结构不仅允许预测性的加载代码和资源，同时也支持类似于本地化这样的系统性特性。</p><p>包分属于以下三个类别，每一种都有它自己特殊的结构和要求：</p><ul><li><strong>应用包（App Bundles）</strong>：包含一个能被启动的可执行文件，一个描述可执行文件的 <code>Info.plist</code> 文件，应用图标，启动图片，能被可执行文件调用的接口文件，字符串文件，以及数据文件。</li><li><strong>框架包（Framework Bundles）</strong>：包含动态分享库所需要的代码和资源。</li><li><strong>可加载包（Loadable Bundles）</strong>：类似于插件，包含扩展应用功能的可执行代码和资源。</li></ul><h3 id="访问包内容"><a href="#访问包内容" class="headerlink" title="访问包内容"></a>访问包内容</h3><p>对于应用，playgrounds，以及其它你感兴趣的包来说，都能通过 <code>Bundle.main</code> 进行访问。大多数情况，可以使用 <code>url(forResource:withExtension:)</code>（或它的一种变体）来获取特定资源的路径。</p><p>举例来说，如果应用中包含了一个名叫 <code>Photo.jpg</code> 的文件，用下面的方法能获得访问它的 URL：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Bundle</span>.main.url(forResource: <span class="string">"Photo"</span>, withExtension: <span class="string">"jpg"</span>)</span><br></pre></td></tr></table></figure></p><blockquote><p>如果使用 Asset Catalog，你可以从媒体库（<kbd>⇧</kbd><kbd>⌘</kbd><kbd>M</kbd>）拖拽到编辑器来创建图像。</p></blockquote><p>除此之外，<code>Bundle</code> 提供了一些实例方法和变量来获取标准包内容的位置，返回 URL 或 String 类型的路径：</p><table><thead><tr><th>URL</th><th>Path</th><th>描述</th></tr></thead><tbody><tr><td>executableURL</td><td>executablePath</td><td>可执行文件</td></tr><tr><td>url(forAuxiliaryExecutable:)</td><td>path(forAuxiliaryExecutable:)</td><td>辅助的可执行文件</td></tr><tr><td>resourceURL</td><td>resourcePath</td><td>包含资源的子目录</td></tr><tr><td>sharedFrameworksURL</td><td>sharedFrameworksPath</td><td>包含共享框架的子目录</td></tr><tr><td>privateFrameworksURL</td><td>privateFrameworksPath</td><td>包含私有框架的子目录</td></tr><tr><td>builtInPlugInsURL</td><td>builtInPlugInsPath</td><td>包含插件的子目录</td></tr><tr><td>sharedSupportURL</td><td>sharedSupportPath</td><td>包含共享支援文件的子目录</td></tr><tr><td>appStoreReceiptURL</td><td></td><td>App Store 的收据</td></tr></tbody></table><h3 id="获取应用信息"><a href="#获取应用信息" class="headerlink" title="获取应用信息"></a>获取应用信息</h3><p>所有的应用包都必须有一个包含应用信息的 <code>Info.plist</code> 文件。</p><p><code>bundleURL</code> 和 <code>bundleIdentifier</code> 这样的原数据能够通过 bundle 实例被直接访问。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bundle = <span class="type">Bundle</span>.main</span><br><span class="line"></span><br><span class="line">bundle.bundleURL        <span class="comment">// "/path/to/Example.app"</span></span><br><span class="line">bundle.bundleIdentifier <span class="comment">// "com.nshipster.example"</span></span><br></pre></td></tr></table></figure></p><p>通过下标能从 <code>infoDictionary</code> 变量获得其他信息（如果信息要展示给用户，请使用 <code>localizedInfoDictionary</code>）。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">bundle.infoDictionary[<span class="string">"CFBundleName"</span>] <span class="comment">// "Example"</span></span><br><span class="line">bundle.localizedInfoDictionary[<span class="string">"CFBundleName"</span>] <span class="comment">// "Esempio" (`it_IT` locale)</span></span><br></pre></td></tr></table></figure></p><h3 id="获取本地化字符串"><a href="#获取本地化字符串" class="headerlink" title="获取本地化字符串"></a>获取本地化字符串</h3><p>包的存在让本地化变得容易。强制本地化资源的存放位置后，系统便能将加载哪个版本的文件的逻辑从开发者层面抽象出来。</p><p>举个例子，包负责加载应用的本地化字符串。使用 <code>localizedString(forKey:value:table:)</code> 方法就可以获取到这些值。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bundle = <span class="type">Bundle</span>.main</span><br><span class="line">bundle.localizedString(forKey: <span class="string">"Hello, %@"</span>,</span><br><span class="line">                       value: <span class="string">"Hello, $&#123;username&#125;"</span>,</span><br><span class="line">                       table: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p><p>然而，通常来说用 <code>NSLocalizedString</code> 会更好，像 <code>genstrings</code> 这样的工具能够自动取出键和注释到 <code>.strings</code> 文件中便于翻译。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Terminal</span><br><span class="line">$ find . \( -name &quot;*.swift&quot; !           \ # 找出所有 swift 文件</span><br><span class="line">            ! -path &quot;./Carthage/*&quot;      \ # 无视 Carthage 与 CocoaPods 的依赖</span><br><span class="line">            ! -path &quot;./Pods/*&quot;</span><br><span class="line">         \)    |                        \</span><br><span class="line">  tr &apos;\n&apos; &apos;\0&apos; |                        \ # 替换分隔符</span><br><span class="line">  xargs -0 genstrings -o .              \ # 处理带空格的路径</span><br></pre></td></tr></table></figure></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSLocalizedString</span>(<span class="string">"Hello, %@"</span>, comment: <span class="string">"Hello, $&#123;username&#125;"</span>)</span><br></pre></td></tr></table></figure><h2 id="包裹（Packages）"><a href="#包裹（Packages）" class="headerlink" title="包裹（Packages）"></a>包裹（Packages）</h2><p>包裹把相关资源封装和加固成一个独立单元，意在<strong>提升用户体验</strong>。</p><p>满足以下任意一个条件，目录就会被访达认为是包裹：</p><ul><li>目录有类似于 <code>.app</code>，<code>.playground</code> 或 <code>.plugin</code> 等特殊扩展。</li><li>目录有一个被一个应用注册作为文档类型的扩展。</li><li>目录具有有扩展属性，将其指定为包裹。</li></ul><h3 id="访问包裹中的内容"><a href="#访问包裹中的内容" class="headerlink" title="访问包裹中的内容"></a>访问包裹中的内容</h3><p>在访达中，右键展示选中项目的可操作目录。如果选中项目是包裹，“打开”操作下会出现“显示包内容”选项。<br><img src="https://nshipster.com/assets/show-package-contents-c7cc72f58a573cb2fbe349e6f76a4ef29d14fbada3cd9b8376fc37979da16bf3.png" alt></p><p>点击这个选项会从包裹目录打开一个新的访达窗口。</p><p>当然，也可以通过代码访问包裹中的内容。包裹的类型决定了获取内容的最佳方式：</p><ul><li>如果包裹有包的结构，前文所说的 <code>Bundle</code> 就能轻松胜任。</li><li>如果包裹是一个文档，在 macOS 上使用 <code>NSDocument</code> 或在 iOS 上使用 <code>UIDocument</code> 来访问。</li><li>其他情况下，用 <code>FileWrapper</code> 导航目录，文件和符号链接，用 <code>FileHandler</code> 来读写文件描述。</li></ul><h3 id="判断一个目录是否是包裹"><a href="#判断一个目录是否是包裹" class="headerlink" title="判断一个目录是否是包裹"></a>判断一个目录是否是包裹</h3><p>虽说是由访达决定如何展示文件和目录，大多数的判断会被代理给操作系统以及管理统一类型标识（UTI）的服务。</p><p>如果想要确定一个文件扩展是一个内置系统包裹类型，还是一个被已安装的应用使用的文档类型，调用 Core Services 方法 <code>UTTypeCreatePreferredIdentifierForTag(_:_:_:)</code> 与 <code>UTTypeConformsTo(_:_:)</code> 能满足你的需求：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CoreServices</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">directoryIsPackage</span><span class="params">(<span class="number">_</span> url: URL)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> filenameExtension: <span class="type">CFString</span> = url.pathExtension <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> uti = <span class="type">UTTypeCreatePreferredIdentifierForTag</span>(</span><br><span class="line">                        kUTTagClassFilenameExtension,</span><br><span class="line">                        filenameExtension, <span class="literal">nil</span></span><br><span class="line">                    )?.takeRetainedValue()</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">UTTypeConformsTo</span>(uti, kUTTypePackage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xcode = <span class="type">URL</span>(fileURLWithPath: <span class="string">"/Applications/Xcode.app"</span>)</span><br><span class="line">directoryIsPackage(xcode) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><blockquote><p>我们找不到任何描述如何设置所谓的包裹比特（package bit）的文档，但根据 <a href="https://opensource.apple.com/source/CarbonHeaders/CarbonHeaders-8A428/Finder.h" target="_blank" rel="noopener">CarbonCore/Finder.h</a>，在 <code>com.apple.FindlerInfo</code> 扩展参数中设置 <code>kHasBundle（0x2000）</code> 标示能够实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; $ xattr -wx com.apple.FinderInfo /path/to/package \</span><br><span class="line">&gt;  00 00 00 00 00 00 00 00 20 00 00 00 00 00 00 00 \</span><br><span class="line">&gt;  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><hr><p>正如我们看到的那样，并非只有终端用户从抽象中获益 —— 无论是像 Swift 这样的高级编程语言的安全性和表现力，还是像 Foundation 这样的 API 的便利性，作为开发者也可以利用抽象开发出优秀的软件。</p><p>或许我们会抱怨 <a href="https://en.wikipedia.org/wiki/Leaky_abstraction" target="_blank" rel="noopener">抽象泄漏</a> 与 <a href="https://en.wikipedia.org/wiki/Abstraction_inversion" target="_blank" rel="noopener">抽象反转</a> 带来的问题，但重要的是退一步，了解我们每天处理多少有用的抽象，以及它们带给了我们多少可能性。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mattt，&lt;a href=&quot;https://nshipster.com/bundles-and-packages/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-12-17&lt;br&gt;译者：&lt;a href=&quot;https://github.com/WAMaker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WAMaker&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://bignerdcoding.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigNerdCoding&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在这个给予的季节，让我们停下脚步，思考一个现代计算机系统赐予我们的最棒的礼物：抽象。&lt;/p&gt;
&lt;p&gt;在数百万 CPU 晶体管、SSD 扇区和 LCD 像素共同协作下，全球数十亿人能够日常使用计算机和移动设备而对此全然不知。这一切都应归功于像文件，目录，应用和文档这样的抽象。&lt;/p&gt;
&lt;p&gt;这周的 NSHipster，我们将讨论苹果平台上两个重要的抽象：包与包裹。🎁&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的集合（Set）</title>
    <link href="https://swift.gg/2019/07/09/Sets-in-Swift/"/>
    <id>https://swift.gg/2019/07/09/Sets-in-Swift/</id>
    <published>2019-07-09T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/sets-in-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-09-06<br>译者：<a href="https://github.com/rsenjoyer" target="_blank" rel="noopener">rsenjoyer</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>集合（Set）是 Swift 集合类型（collection types）之一，集合用来存储类型相同且没有确定顺序唯一的值。你可以将集合想象成一盒台球：它们在颜色和数量上独一无二，但在盒内是无序的。</p><p><img src="https://swift.gg/img/articles/Sets-in-Swift/billiard.jpg1562643187.9223473" alt></p><a id="more"></a><p><em>提示：这篇文章使用的是 Swift 4 和 Xcode 10</em></p><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>创建一个集合非常简单：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> setA: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br></pre></td></tr></table></figure><p>在这个例子中，创建一个 <code>String</code> 类型的集合，命名为 <code>setA</code>。它存储着 <code>a</code>、<code>b</code>、<code>c</code> 三个值。与数组相比，集合内元素是无序的。通过编译器的类型推导功能，你也可以像如下方式创建集合：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> setB: <span class="type">Set</span> = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br></pre></td></tr></table></figure><p>同样也可以使用集合的构造器：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> setC = <span class="type">Set</span>([<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>])</span><br></pre></td></tr></table></figure><p>跟数组一样，如果使用 <code>let</code> 来定义一个集合，它就是不可变的。使用 <code>var</code>定义的是一个可变集合。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setD = <span class="type">Set</span>([<span class="string">"a"</span>,<span class="string">"b"</span>])</span><br></pre></td></tr></table></figure><p>稍后我们将了解更多有关可变集合的信息。</p><h2 id="访问集合中的元素"><a href="#访问集合中的元素" class="headerlink" title="访问集合中的元素"></a>访问集合中的元素</h2><p>你可以使用循环来访问集合中的元素：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> setA &#123;</span><br><span class="line">     <span class="built_in">print</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：每次运行代码时，循环中值的顺序可能不同。从表面来看，它们像是随机返回一样。</p><h2 id="集合分析"><a href="#集合分析" class="headerlink" title="集合分析"></a>集合分析</h2><p>首先，你可以检查集合是否为空：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(setA.isEmpty)</span><br></pre></td></tr></table></figure><p>也可以获取集合中元素的个数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(setA.<span class="built_in">count</span>)</span><br></pre></td></tr></table></figure><p>上面的操作对数组同样有效，对集合而言，更加普遍的问题是判断集合中是否包含某个元素。为此，你可以使用 <code>contains</code> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(setA.<span class="built_in">contains</span>(<span class="string">"a"</span>))</span><br></pre></td></tr></table></figure><h2 id="从集合中添加和删除元素"><a href="#从集合中添加和删除元素" class="headerlink" title="从集合中添加和删除元素"></a>从集合中添加和删除元素</h2><p>你可以向可变集合里面添加和删除元素:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">setD.insert(<span class="string">"c"</span>)</span><br><span class="line">setD.remove(<span class="string">"a"</span>)</span><br></pre></td></tr></table></figure><p>由于集合元素的唯一性，因此只能将同一个元素添加到集合中一次。可以多次使用相同的值调用 <code>insert</code> 方法，但集合不会改变。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setE: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"> </span><br><span class="line">setE.insert(<span class="number">5</span>)</span><br><span class="line">setE.insert(<span class="number">5</span>)</span><br><span class="line">setE.insert(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(setE) <span class="comment">//[4,5,1,2,3]</span></span><br></pre></td></tr></table></figure><p>和前面所说的一样，上面代码每次执行时输出的顺序可能不同，因为集合元素无序。</p><h2 id="集合比较"><a href="#集合比较" class="headerlink" title="集合比较"></a>集合比较</h2><p>集合间能进行比较。显然，可以比较两个集合是否相等：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> setA: = [“a”, “b”, “<span class="built_in">c</span>”]</span><br><span class="line"><span class="keyword">let</span> setB: = [“a”, “b”, “<span class="built_in">c</span>”]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> setA == setB &#123;</span><br><span class="line">     <span class="built_in">print</span>(“the sets are <span class="built_in">equal</span>”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，集合是相等的。</p><p>比较两个集合的大小是没有明确的定义，但可以检查一个集合是否是另一个集合的子集：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intSetA: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> intSetB: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">intSetB.isSubset(of: intSetA) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>也可以检查集合是否是另一个集合的真子集。这种情况就是该集合是另一个集合的子集但不想等。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intSetA: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> intSetB: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> intSetC: <span class="type">Set</span> = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"> </span><br><span class="line">intSetB.isSubset(of: intSetA) <span class="comment">//true</span></span><br><span class="line">intSetB.isStrictSubset(of: intSetA) <span class="comment">//false</span></span><br><span class="line">intSetC.isSubset(of: intSetA) <span class="comment">// true</span></span><br><span class="line">intSetC.isStrictSubset(of: intSetA) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>与之相对的概念就是超集：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intSetA: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> intSetC: <span class="type">Set</span> = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">intSetA.isSuperset(of: intSetC) <span class="comment">//true</span></span><br><span class="line">intSetA.isStrictSuperset(of: intSetC) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>如果两个集合没有相同的元素，那么就说这两个集合不相交</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intSetA: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> intSetC: <span class="type">Set</span> = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> intSetD: <span class="type">Set</span> = [<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]</span><br><span class="line"> </span><br><span class="line">intSetA.isDisjoint(with: intSetC) <span class="comment">//false</span></span><br><span class="line">intSetA.isDisjoint(with: intSetD) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="集合结合"><a href="#集合结合" class="headerlink" title="集合结合"></a>集合结合</h2><p>你可以将两个集合合并成为一个新集合，新的集合中包含两个集合中所有的元素：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringSetA: <span class="type">Set</span> = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br><span class="line"><span class="keyword">let</span> stringSetB: <span class="type">Set</span> = [<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unionSetAB = stringSetA.union(stringSetB)</span><br><span class="line"><span class="built_in">print</span>(unionSetAB) <span class="comment">//["d", "b", "c", "a", "e"]</span></span><br></pre></td></tr></table></figure><p>另一方面，交集就是仅包含两个集合中共同的元素：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringSetA: <span class="type">Set</span> = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br><span class="line"><span class="keyword">let</span> stringSetB: <span class="type">Set</span> = [<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> intersectionAB = stringSetA.intersection(stringSetB)</span><br><span class="line"><span class="built_in">print</span>(intersectionAB) <span class="comment">//[“c”]</span></span><br></pre></td></tr></table></figure><h2 id="自定义集合元素类型"><a href="#自定义集合元素类型" class="headerlink" title="自定义集合元素类型"></a>自定义集合元素类型</h2><p>你可以在集合中存储自定义的类型。这种类型可以是类或者结构体。为了能正常使用集合，该类型必须遵循 <code>hashable</code> 协议。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">     <span class="keyword">var</span> year: <span class="type">Int</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">init</span>(title: <span class="type">String</span>, year: <span class="type">Int</span>) &#123;</span><br><span class="line">          <span class="keyword">self</span>.title = title</span><br><span class="line">          <span class="keyword">self</span>.year = year</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Movie, rhs: Movie)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> lhs.title == rhs.title &amp;&amp;</span><br><span class="line">          lhs.year == rhs.year</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> title.hashValue ^ year.hashValue</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> terminator = <span class="type">Movie</span>(title: <span class="string">"Terminator"</span>, year: <span class="number">1980</span>)</span><br><span class="line"><span class="keyword">let</span> backToTheFuture = <span class="type">Movie</span>(title: <span class="string">"Back to the Future"</span>, year: <span class="number">1985</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> movieSetA: <span class="type">Set</span> = [terminator,backToTheFuture]</span><br></pre></td></tr></table></figure><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      关于 Swift 中的集合（Set）
    
    </summary>
    
      <category term="thomashanning" scheme="https://swift.gg/categories/thomashanning/"/>
    
    
      <category term="Swift，iOS开发，Swift进阶" scheme="https://swift.gg/tags/Swift%EF%BC%8CiOS%E5%BC%80%E5%8F%91%EF%BC%8CSwift%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>PhotoKit 的数据模型</title>
    <link href="https://swift.gg/2019/07/01/photos-data-model/"/>
    <id>https://swift.gg/2019/07/01/photos-data-model/</id>
    <published>2019-07-01T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/2018/photos-data-model/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-09-28<br>译者：<a href="https://github.com/zhangchi25806" target="_blank" rel="noopener">张弛</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>在 iOS 系统中，<a href="https://developer.apple.com/documentation/photokit" target="_blank" rel="noopener">PhotoKit 框架</a> 不仅被系统的照片 App 所使用，同时它也为开发人员访问设备的照片库提供了接口支持。而它的底层则是 <a href="https://developer.apple.com/documentation/coredata" target="_blank" rel="noopener">Core Data</a> 实现的。</p><a id="more"></a><p>至少从这两个地方，你就可以确认这一点：</p><ol><li>编写一个能够访问照片库的应用，并使用 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/TroubleshootingCoreData.html#//apple_ref/doc/uid/TP40001075-CH26-SW21" target="_blank" rel="noopener"><code>-com.apple.CoreData.SQLDebug 1.</code></a> 来启动这个应用程序。当你访问照片库时，从控制台就可以看到 Core Data 的调试信息。</li><li>如果查看 PhotoKit 框架的 <a href="http://stevenygard.com/projects/class-dump/" target="_blank" rel="noopener">class dump</a>，你将会在主要的类中看到对 <a href="https://developer.apple.com/documentation/coredata/nsmanagedobjectid" target="_blank" rel="noopener"><code>NSManagedObjectID</code></a> 和其他 Core Data 类型的引用，例如， <a href="https://github.com/nst/iOS-Runtime-Headers/blob/fbb634c78269b0169efdead80955ba64eaaa2f21/Frameworks/Photos.framework/PHObject.h" target="_blank" rel="noopener"><code>PHObject</code> 有一个 <code>_objectID：NSManagedObjectID</code> 的 ivar</a>。</li></ol><h2 id="寻找-PhotoKit-的核心数据模型"><a href="#寻找-PhotoKit-的核心数据模型" class="headerlink" title="寻找 PhotoKit 的核心数据模型"></a>寻找 PhotoKit 的核心数据模型</h2><p>为了更好地理解 PhotoKit 框架（特别是它的性能特征），我检查了它的数据模型。我在 Xcode 10.0 应用程序的包内容中找到了一个名为 <code>PhotoLibraryServices.framework / photos.momd / photos-10.0.mom</code> 的文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode-10.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/PrivateFrameworks/PhotoLibraryServices.framework/photos.momd/photos-10.0.mom</span><br></pre></td></tr></table></figure><blockquote><p>你可以使用如下的命令来查找 Xcode 中模拟器运行时内的其他 Core Data 模型：</p><p><code>find /Applications/Xcode-10.app -name &#39;*.mom&#39;</code></p></blockquote><h2 id="在-Xcode-中打开已编译的-Core-Data-模型"><a href="#在-Xcode-中打开已编译的-Core-Data-模型" class="headerlink" title="在 Xcode 中打开已编译的 Core Data 模型"></a>在 Xcode 中打开已编译的 Core Data 模型</h2><p><code>.mom</code> 文件是<em>已编译的</em> Core Data 数据模型。Xcode 无法直接打开它，但可以将它<em>导入</em>到另一个 Core Data 模型中。通过如下的步骤，我们就可以在 Xcode 中查看这个模型：</p><ol><li>创建一个新的空项目。因为使用 Xcode 10 在项目之外显示 Core Data 模型包并不是一个好的选择。</li><li>在项目中创建一个全新的“Core Data 数据模型”文件。 这将创建一个 <code>.xcdatamodeld</code> 包。</li><li>打开新数据模型，然后选择 编辑器 &gt; 导入…. ，选择要导入的 <code>.mom</code> 文件。</li></ol><p>不幸的是，编译的模型并不存储 Xcode 的模型编辑器的布局信息，因此你必须手动将编辑器中的实体拖出来一个漂亮的样式中。这花了我几个小时。</p><blockquote><p>温馨提示：你可以使用箭头键（和 shift 键+箭头键）精确定位事物。</p><p>专家提示：请勿点击 ⌘Z 撤消移动操作。对图形的编辑不会被 Xcode 视作一个可撤销的操作，因此 Xcode 可能会撤消一开始的导入操作，这意味着你将丢失所有未保存的工作。</p></blockquote><h2 id="带有良好格式的-PhotoKit-的模型"><a href="#带有良好格式的-PhotoKit-的模型" class="headerlink" title="带有良好格式的 PhotoKit 的模型"></a>带有良好格式的 PhotoKit 的模型</h2><p>这是与 Xcode 10.0（iOS 12.0）捆绑在一起的 <code>photos-10.0.mom</code>：</p><p><img src="https://oleb.net/media/photos-10.0-core-data-model-5974px.png" alt="iOS 12.0 中 PhotoLibraryServices.framework 的 Core Data 数据模型。请下载图片并在本地打开以获得最佳效果。"></p><p>并非所有的内容都能在这张图片中被看到。你可以 <a href="https://github.com/ole/AppleCoreDataModels" target="_blank" rel="noopener">下载完整模型</a> 并在 Xcode 中查看它的一些属性。</p><p>请注意，这不一定是 iOS 上的照片的完整数据模型。更多的一些 Core Data 模型被放置在 <code>PrivateFrameworks/PhotoAnalysis.framework</code> 中。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      PhotoKit 的数据模型
    
    </summary>
    
      <category term="PhotoKit" scheme="https://swift.gg/categories/PhotoKit/"/>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/PhotoKit/Ole-Begemann/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>将 Swift 序列切分为头部和尾部</title>
    <link href="https://swift.gg/2019/06/24/sequence-head-tail/"/>
    <id>https://swift.gg/2019/06/24/sequence-head-tail/</id>
    <published>2019-06-24T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/2018/sequence-head-tail/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-11-29<br>译者：<a href="https://github.com/WAMaker" target="_blank" rel="noopener">WAMaker</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://bignerdcoding.com/" target="_blank" rel="noopener">BigNerdCoding</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>函数式编程语言的一个常用范式是把一个列表切分为头部（第一个元素）和尾部（其余元素）。在 Haskell 中，<a href="https://en.wikibooks.org/wiki/Haskell/Pattern_matching" target="_blank" rel="noopener">x:xs</a> 会匹配非空列表，将头部绑定给变量 x，尾部绑定给 xs。</p><p><a href="https://academy.realm.io/posts/tryswift-rob-napier-swift-legacy-functional-programming/" target="_blank" rel="noopener">Swift 不是一门函数式编程语言</a>。既没有内置的 <code>List</code> 类型，也没有集合的特定匹配语法。<a href="#foot1" id="1"><sup>[1]</sup></a></p><a id="more"></a><h2 id="集合（Collections）"><a href="#集合（Collections）" class="headerlink" title="集合（Collections）"></a>集合（Collections）</h2><p>尽管如此，将 <code>Sequence</code> 或 <code>Collection</code> 切分成头部和尾部偶尔很有用。对于集合来说这很容易：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> headAndTail: (head: <span class="type">Element</span>, tail: <span class="type">SubSequence</span>)? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head = first <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> (head, <span class="built_in">dropFirst</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> (firstLetter, remainder) = <span class="string">"Hello"</span>.headAndTail &#123;</span><br><span class="line">    <span class="comment">// firstLetter: Character == "H"</span></span><br><span class="line">    <span class="comment">// remainder: Substring == "ello"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="序列（Sequence）"><a href="#序列（Sequence）" class="headerlink" title="序列（Sequence）"></a>序列（Sequence）</h2><p>对于序列来说却很困难，因为它们可以是单向（single-pass）的：一些序列只能被迭代一次，迭代器会消耗其中的元素。以网络流为例，一旦你从缓冲区里读取了一个字节，操作系统便将它抛弃了。你无法让它重新来一遍。</p><p>一个可能的解决方案是 <a href="https://developer.apple.com/documentation/swift/sequence/2885155-makeiterator" target="_blank" rel="noopener">创建一个迭代器</a> 读取第一个元素，并把当前的迭代器状态包裹进一个新的 <a href="https://developer.apple.com/documentation/swift/anysequence" target="_blank" rel="noopener">AnySequence</a> 实例：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> headAndTail: (head: <span class="type">Element</span>, tail: <span class="type">AnySequence</span>&lt;<span class="type">Element</span>&gt;)? &#123;</span><br><span class="line">    <span class="keyword">var</span> iterator = makeIterator()</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = iterator.next() <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> tail = <span class="type">AnySequence</span> &#123; iterator &#125;</span><br><span class="line">    <span class="keyword">return</span> (head, tail)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码能够实现功能，但不是一个好的通用解决方案，尤其是对满足 <code>Collection</code> 的类型而言。将尾部包进 <code>AnySequence</code> 会是一个 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0234-remove-sequence-subsequence.md#type-erasure-performance" target="_blank" rel="noopener">性能杀手</a>，也不可以使用合适的集合类型 <a href="https://developer.apple.com/documentation/swift/sequence/1641117-subsequence#" target="_blank" rel="noopener">SubSequence</a>。</p><p>为了保护集合的 <code>SubSequence</code> 类型，最好给 <code>Collection</code> 和 <code>Sequence</code> 分别写扩展。（我们也将会看到，这是 Swift 5 所推崇的方案，这点会在后面谈到。）</p><h2 id="保护-SubSequence-类型"><a href="#保护-SubSequence-类型" class="headerlink" title="保护 SubSequence 类型"></a>保护 SubSequence 类型</h2><p>我没有找到一个通用的方案，能够让尾部的 <code>SubSequence</code> 类型完好，也同时能让单向序列正常工作。很感谢 <a href="https://twitter.com/dennisvennink" target="_blank" rel="noopener">Dennis Vennink</a> 能够找出一个解决方案并 <a href="https://twitter.com/dennisvennink/status/1060158576679882753" target="_blank" rel="noopener">分享给我</a>。下面是 <a href="https://gist.github.com/dennisvennink/e8b1921916d3c2f90ab52f47291145ef" target="_blank" rel="noopener">他的代码</a>（我略微对格式进行了修改）：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> headAndTail: (head: <span class="type">Element</span>, tail: <span class="type">SubSequence</span>)? &#123;</span><br><span class="line">    <span class="keyword">var</span> first: <span class="type">Element?</span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">let</span> tail = drop(<span class="keyword">while</span>: &#123; element <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> first == <span class="literal">nil</span> &#123;</span><br><span class="line">            first = element</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = first <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (head, tail)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dennis 的窍门是调用 <a href="https://developer.apple.com/documentation/swift/sequence/2965501-drop" target="_blank" rel="noopener">Sequence.drop(while:)</a>，为尾部保留了 <code>SubSequence</code> 类型，同时在 <code>drop(while:)</code> 内部“捕获”了第一个元素。干得漂亮！</p><h2 id="Swift-5"><a href="#Swift-5" class="headerlink" title="Swift 5"></a>Swift 5</h2><p>上面的代码使用 Swift 4.2。在 Swift 5 中由于序列不再会有关联 <code>SubSequence</code> 类型，只存在于集合中（<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0234-remove-sequence-subsequence.md" target="_blank" rel="noopener">Swift Evolution proposal SE-0234</a>），以上代码会崩溃。<a href="#foot2" id="2"><sup>[2]</sup></a></p><p>这个改变有很多优势，但同样意味着不可能有一种通用的方法能够让 <code>SubSequence</code> 同时对 <code>Sequence</code> 和 <code>Collection</code> 有效。</p><p>相对的，我们把那个简单的解决方案添加给 <code>Collection</code>：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> headAndTail: (head: <span class="type">Element</span>, tail: <span class="type">SubSequence</span>)? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = first <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> (head, <span class="built_in">dropFirst</span>())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们需要让 <code>Sequence</code> 拥有同样的功能，就需要添加一个独立的扩展，使用新的 <code>DropWhileSequence</code> 作为返回类型的尾部：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> headAndTail: (head: <span class="type">Element</span>, tail: <span class="type">DropWhileSequence</span>&lt;<span class="type">Self</span>&gt;)? &#123;</span><br><span class="line">    <span class="keyword">var</span> first: <span class="type">Element?</span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">let</span> tail = drop(<span class="keyword">while</span>: &#123; element <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> first == <span class="literal">nil</span> &#123;</span><br><span class="line">            first = element</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head = first <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (head, tail)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（实现和之前的代码一样，仅仅改变了返回的类型。）</p><hr><p><a id="foot1" href="#1"><sup>[1]</sup></a>为集合添加一种模式匹配结构作为一个 <a href="https://forums.swift.org/t/review-se-0074-implementation-of-binary-search-functions/2438/9" target="_blank" rel="noopener">可行</a> 的特性已经在论坛多次被 <a href="https://forums.swift.org/t/pattern-matching-with-arrays/4735/3" target="_blank" rel="noopener">提及</a>。有了它，你可以像下面这样将一个有序集合解构成头部和尾部：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = <span class="number">1</span>...<span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> [head, tail...] = numbers</span><br><span class="line"><span class="comment">// head == 1</span></span><br><span class="line"><span class="comment">// tail == 2...10</span></span><br></pre></td></tr></table></figure><p>在 <code>switch</code> 表达式中会很有用。</p><p><a id="foot2" href="#2"><sup>[2]</sup></a>很遗憾我们被误导性的名字 <code>Sequence</code> 给束缚住了。要将 <code>Collection.SubSequence</code> 重命名成更合适的 <code>Slice</code> 会造成 <a href="https://forums.swift.org/t/rationalizing-sequence-subsequence/17586/13" target="_blank" rel="noopener">严重的代码破坏</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/2018/sequence-head-tail/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-11-29&lt;br&gt;译者：&lt;a href=&quot;https://github.com/WAMaker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WAMaker&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://bignerdcoding.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigNerdCoding&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;函数式编程语言的一个常用范式是把一个列表切分为头部（第一个元素）和尾部（其余元素）。在 Haskell 中，&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Pattern_matching&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;x:xs&lt;/a&gt; 会匹配非空列表，将头部绑定给变量 x，尾部绑定给 xs。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://academy.realm.io/posts/tryswift-rob-napier-swift-legacy-functional-programming/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift 不是一门函数式编程语言&lt;/a&gt;。既没有内置的 &lt;code&gt;List&lt;/code&gt; 类型，也没有集合的特定匹配语法。&lt;a href=&quot;#foot1&quot; id=&quot;1&quot;&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>使用 Swift 实现基于堆的优先级队列</title>
    <link href="https://swift.gg/2019/05/06/implementing-a-heap-based-priority-queue-using-swift/"/>
    <id>https://swift.gg/2019/05/06/implementing-a-heap-based-priority-queue-using-swift/</id>
    <published>2019-05-06T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：APPCODA EDITORIAL TEAM，<a href="https://appcoda.com/swift-algorithm/" target="_blank" rel="noopener">原文链接</a>，原文日期：2019-01-07<br>译者：Roc Zhang；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>在计算机科学中，有很多问题可以通过将底层数据结构用优先级队列实现来改善算法的时间复杂度。其中 Dijkstra 的最短路径算法便是一个例子，该算法使用了优先级队列来在图中搜索两个顶点间的最短路径。</p><p>不幸的是，Swift 的标准库中并没有提供优先级队列的默认实现。所以我们将会研究如何自行实现基于堆的优先级队列。</p><a id="more"></a><p>如果你想在自己的 IDE 中一起动手来操作，点击 <a href="https://github.com/JimmyMAndersson/HeapPriorityQueue" target="_blank" rel="noopener">此链接</a> 便可获取到源码。</p><h2 id="什么是优先级队列？"><a href="#什么是优先级队列？" class="headerlink" title="什么是优先级队列？"></a>什么是优先级队列？</h2><p>优先级队列是一种可以对具有相对优先级的对象进行高效排序的数据结构。它会根据队列中每个对象的优先级，一个个将队列中的对象进行排序。</p><p>假设你创建了一系列任务并准备在将来的某个时间点运行它们，利用优先级队列就可以让这些任务按照你预期执行。</p><p>在接下来的文章中，我们将使用堆结构来实现我们的优先级队列。</p><h2 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h2><p>我们可以把堆看作是每个节点最多只有两个子节点的树，但与树不同的是，向堆中添加新节点时要尽可能往顶层左侧放置。如下图所示：</p><p><img src="https://appcoda.com/wp-content/uploads/2019/01/Conceptual-sketch-of-a-new-node-being-inserted-into-a-heap.png" alt></p><p>同时，堆还具有着一些与节点间相对大小关系相关的特性。一个最小堆（就是我们即将要使用的）有着每一个节点比其子节点都要小的特性。最大堆则正好相反。</p><p>为了能够维持这种性质，我们需要通过一些操作来得到节点的正确位置顺序。当我们插入一个新节点时，先将它放在树的顶层左侧开始的第一个空余可用的位置上。如果在放置后最小堆的性质不成立，则将此节点与它的父节点交换，直到最小堆性质成立为止。下图展示了向一个已有的最小堆中插入数字 2 的情况。</p><p><img src="https://appcoda.com/wp-content/uploads/2019/01/Maintaining-the-min-heap-property-on-insertion.png" alt></p><p>当要把一个对象移出队列时，需限制只从队列的某一端进行操作。在这里我们将通过限定只能删除根节点的方式来实现。当根节点被移除时，会被顶层最右边的节点替代。由于新节点成为根节点后有很大概率会过大，我们将把它向下移动，把它与最小的子节点交换，直到我们恢复最小堆。</p><h2 id="关于实现本身的简短说明"><a href="#关于实现本身的简短说明" class="headerlink" title="关于实现本身的简短说明"></a>关于实现本身的简短说明</h2><p>我们将采用数组来实现一个既快速又节省空间的树结构。这里我不打算过于深入其中的数学运算，但如果你有兴趣的话，可以看一看这个 <a href="https://en.wikipedia.org/wiki/Heap_%28data_structure%29#Implementation" target="_blank" rel="noopener">链接</a>，它解释了数学在其中运用的方式与背后的原因。</p><p>准备好了吗？我们开始吧。</p><h2 id="设计协议"><a href="#设计协议" class="headerlink" title="设计协议"></a>设计协议</h2><p>同往常一样，我们先来定义对象要展示给外部用户怎样的功能。我们以定义协议的方式来完成这件事，稍后再让具体的类来遵循它。我为队列设计的协议如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">associatedtype</span> <span class="type">DataType</span>: <span class="type">Comparable</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  将一个新元素插入到队列中。</span></span><br><span class="line"><span class="comment">  - 参数 item：要添加的元素。</span></span><br><span class="line"><span class="comment">  - 返回值：插入是否成功。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@discardableResult</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> item: DataType)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  删除首个元素。</span></span><br><span class="line"><span class="comment">  - 返回值：被移除的元素。</span></span><br><span class="line"><span class="comment">  - 抛出值：QueueError 类型的错误。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@discardableResult</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">DataType</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  获取到队列中的首个元素，并将其移出队列。</span></span><br><span class="line"><span class="comment">  - 返回值：一个包含队列中首个元素的可选值。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">DataType?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  获取队列中的首个元素，但不将它移出队列。</span></span><br><span class="line"><span class="comment">  - 返回值：一个包含队列中首个元素的可选值。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">()</span></span> -&gt; <span class="type">DataType?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  清空队列。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> -&gt; <span class="type">Void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该协议明确了我们需要实现的功能，供外部用户调用。协议同样还说明了其中的某一个方法可能会抛出错误，且根据文档我们能够了解到它会是一个 QueueError 类型的错误，因此我们同样也要实现它。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">QueueError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> noSuchItem(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码非常简明扼要：当用户尝试从空队列中删除元素时，我们会抛出上面这样的错误。</p><p>现在所有的准备工作已经完成，让我们开始实现队列本身。</p><h2 id="实现优先级队列"><a href="#实现优先级队列" class="headerlink" title="实现优先级队列"></a>实现优先级队列</h2><p>我们将首先从声明 PriorityQueue 类开始，然后再实现它的初始化方法与存储元素，同时完成一些“有则更好”的方法。代码看起来是这样的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 基于堆数据结构的 PriorityQueue 实现。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">DataType</span>: <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   队列的存储。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> queue: <span class="type">Array</span>&lt;<span class="type">DataType</span>&gt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   当前队列的大小。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> size: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.queue.<span class="built_in">count</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">self</span>.queue = <span class="type">Array</span>&lt;<span class="type">DataType</span>&gt;()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也许注意到了，我们目前还没有实现队列的协议。当我们进行编码时，通常希望事物之间能保持相对分离。并且希望能创建出一个概览从而方便我们去进行查找。有些类可能会逐渐变得非常大，解决这种情况的方法之一是使用扩展作用域。这样，每一个扩展倾向于只做一个任务（比如去遵循一个协议，处理存储与初始化，又或是嵌套类的声明等），事后再去查找时就会容易很多。让我们在这里也尝试使用这种方式。首先，实现一个 Int 类型的私有扩展，这能够帮助我们执行一些预先定义好的索引计算:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> leftChild: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * <span class="keyword">self</span>) + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> rightChild: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * <span class="keyword">self</span>) + <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> parent: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span> - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是私有的访问权限，这个扩展只在 PriorityQueue 文件中可用。这里聚集了我们将要使用的获取某个节点的子节点与父节点的计算。这样我们就可以通过调用 .leftChild 属性来方便的获取到左子节点的索引，而不必在实现中去进行一堆的数学运算了，以此类推。</p><p>下面是我们对 Queue 协议的遵循实现:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PriorityQueue</span>: <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="meta">@discardableResult</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> item: DataType)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.queue.append(item)</span><br><span class="line">    <span class="keyword">self</span>.heapifyUp(from: <span class="keyword">self</span>.queue.<span class="built_in">count</span> - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@discardableResult</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">DataType</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">self</span>.queue.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">QueueError</span>.noSuchItem(<span class="string">"Attempt to remove item from an empty queue."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.popAndHeapifyDown()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">DataType?</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">self</span>.queue.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.popAndHeapifyDown()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">()</span></span> -&gt; <span class="type">DataType?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.queue.first</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.queue.removeAll()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  弹出队列中的第一个元素，并通过将根元素移向队尾的方式恢复最小堆排序。</span></span><br><span class="line"><span class="comment">  - 返回值: 队列中的第一个元素。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">popAndHeapifyDown</span><span class="params">()</span></span> -&gt; <span class="type">DataType</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> firstItem = <span class="keyword">self</span>.queue[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.queue.<span class="built_in">count</span> == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">self</span>.queue.remove(at: <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> firstItem</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.queue[<span class="number">0</span>] = <span class="keyword">self</span>.queue.remove(at: <span class="keyword">self</span>.queue.<span class="built_in">count</span> - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.heapifyDown()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> firstItem</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   通过将元素移向队头的方式恢复最小堆排序。</span></span><br><span class="line"><span class="comment">   - 参数 index: 要移动的元素的索引值。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">heapifyUp</span><span class="params">(from index: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> child = index</span><br><span class="line">    <span class="keyword">var</span> parent = child.parent</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> parent &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">self</span>.queue[parent] &gt; <span class="keyword">self</span>.queue[child] &#123;</span><br><span class="line">      <span class="built_in">swap</span>(parent, with: child)</span><br><span class="line">      child = parent</span><br><span class="line">      parent = child.parent</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   通过将根元素移向队尾的方式恢复队列的最小堆排序。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">heapifyDown</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> parent = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> leftChild = parent.leftChild</span><br><span class="line">      <span class="keyword">if</span> leftChild &gt;= <span class="keyword">self</span>.queue.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">let</span> rightChild = parent.rightChild</span><br><span class="line">      <span class="keyword">var</span> minChild = leftChild</span><br><span class="line">      <span class="keyword">if</span> rightChild &lt; <span class="keyword">self</span>.queue.<span class="built_in">count</span> &amp;&amp; <span class="keyword">self</span>.queue[minChild] &gt; <span class="keyword">self</span>.queue[rightChild] &#123;</span><br><span class="line">        minChild = rightChild</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">self</span>.queue[parent] &gt; <span class="keyword">self</span>.queue[minChild] &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="built_in">swap</span>(parent, with: minChild)</span><br><span class="line">        parent = minChild</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   交换存储中位于两处索引值位置的元素。</span></span><br><span class="line"><span class="comment">   - 参数 firstIndex：第一个要交换元素的索引。</span></span><br><span class="line"><span class="comment">   - 参数 secondIndex：第二个要交换元素的索引。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(<span class="number">_</span> firstIndex: Int, with secondIndex: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> firstItem = <span class="keyword">self</span>.queue[firstIndex]</span><br><span class="line">    <span class="keyword">self</span>.queue[firstIndex] = <span class="keyword">self</span>.queue[secondIndex]</span><br><span class="line">    <span class="keyword">self</span>.queue[secondIndex] = firstItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的内容有点多，你也许会想多读上一两次。其中，最上面是我们先前在协议中所定义好的所有方法，下面则是一些私有的，仅在此类中可用的辅助方法。我已经为这些辅助方法加上了注释，以便你能快速的了解到它们是用来做什么的。此外，记得关注一下先前对 Int 的扩展在这里是如何被使用的。依我看来，这是非常简洁实用的设计。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，我们已经完成了所有 PriorityQueue 所需要的功能。现在我们将添加对 CustomStringConvertible 协议的实现，以便在向 print 函数传入一个队列后能得到一些可阅读的内容:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PriorityQueue</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.queue.description</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赞!</p><p>上述就是这次的全部内容了。现在你已经知道了如何去实现一个基于堆数据结构的优先级队列。如果有任何疑问，欢迎发表评论。</p><p>要了解 iOS 开发的更多信息，请查看我之前的文章:<br><a href="https://medium.com/swlh/introduction-to-protocol-oriented-programming-1ff3862f9a3c" target="_blank" rel="noopener">Introduction To Protocol Oriented Programming</a><br><a href="https://medium.com/@JimmyMAndersson/using-swift-extensions-to-clean-up-our-code-1aed32da24bc" target="_blank" rel="noopener">Using Swift Extensions To Clean Up Our Code</a></p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文解释了优先级队列、堆等相关概念，并展示了如何使用 Swift 实现基于堆的优先级队列。
    
    </summary>
    
      <category term="AppCoda" scheme="https://swift.gg/categories/AppCoda/"/>
    
      <category term="iOS" scheme="https://swift.gg/categories/AppCoda/iOS/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="Algorithm" scheme="https://swift.gg/tags/Algorithm/"/>
    
      <category term="Data Structure" scheme="https://swift.gg/tags/Data-Structure/"/>
    
      <category term="Priority Queue" scheme="https://swift.gg/tags/Priority-Queue/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5 字符串插值-简介</title>
    <link href="https://swift.gg/2019/04/22/swift5-stringinterpolation-part1/"/>
    <id>https://swift.gg/2019/04/22/swift5-stringinterpolation-part1/</id>
    <published>2019-04-22T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/2018/12/15/swift5-stringinterpolation-part1/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-12-15<br>译者：<a href="https://nemocdz.github.io/" target="_blank" rel="noopener">Nemocdz</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote> <!--此处开始正文--><p> <code>StringInterpolation</code> 协议最初的设计效率低下又不易扩展，为了在后续的版本中能够将其彻底重构，Swift 4 中将该协议标记为废弃。即将在 Swift 5 中亮相的 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0228-fix-expressiblebystringinterpolation.md" target="_blank" rel="noopener">SE-0228</a> 提案介绍了一种新的 <code>StringInterpolation</code> 设计，使得 String 有了更大的潜能。</p> <a id="more"></a><p> 在 Swift 的 <code>master</code> 分支里实现之后，就可以下载一个 <a href="https://swift.org/download/#snapshots" target="_blank" rel="noopener">快照</a> 来安装最新的 Swift 5 工具链到 Xcode 中，来尝试全新的 <code>StringInterpolation</code>。让我们来把玩一下。</p><h2 id="全新的-StringInterpolation-设计"><a href="#全新的-StringInterpolation-设计" class="headerlink" title="全新的 StringInterpolation 设计"></a>全新的 StringInterpolation 设计</h2><p> 我强烈建议本篇文章的读者阅读一下 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0228-fix-expressiblebystringinterpolation.md" target="_blank" rel="noopener">SE-0228</a> 提案，感受一下新 API 的背后的设计思路和动机。</p><p> 要让一个类型遵循 <code>ExpressibleByStringInterpolation</code>，最基本的你需要：</p><ul><li>让这个类型拥有一个类型为 <code>StringInterpolation</code> 的子类型，这个子类型遵循 <code>StringInterpolationProtocol</code> 并将负责解释插值</li><li>这个子类型仅需要实现 <code>appendLiteral(_ literal: String)</code> 方法，再选择一个或多个你自己想要支持的 <code>appendInterpolation(...)</code> 签名的方法</li><li>这个 <code>StringInterpolation</code> 子类型会作为“构造器”服务于你的主类型，然后编译器会调用那些 <code>append…</code> 方法一步一步地构造对象</li><li>然后你的主类型需要实现 <code>init(stringInterpolation: StringInterpolation)</code> ，它会用上一步的结果来实例化它自己。</li></ul><p>你可以实现任何你喜欢的 <code>appenInterpolation(...)</code> 方法，这意味着你可以任意选择支持什么插值。这是一个带来巨大的可能性的超强功能。</p><p>举个例子，如果你实现了 <code>func appendInterpolation(_ string: String, pad: Int)</code>，那么意味着你将可以用类似这样的插值：<code>&quot;Hello \(name, pad: 10), how are you?&quot;</code> 来构造你的类型。插值只需要匹配你的 <code>StringInterpolation</code> 子类型其中一个支持的 <code>appendInterpolation</code> 方法签名。</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>让我用一个简单的例子来演示一下插值是如何运作的。一起来构造一个允许引用 issue 编号和用户的 <code>GitHubComment</code> 类型吧。</p><p>这个例子的目标是做到类似下面的写法：</p> <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> comment: <span class="type">GitHubComment</span> = <span class="string">"""</span></span><br><span class="line"><span class="string">  See \(issue: 123) where \(user: "alisoftware") explains the steps to reproduce.</span></span><br><span class="line"><span class="string">  """</span></span><br></pre></td></tr></table></figure><p>所以我们该怎么实现它呢？</p><p>首先，让我们声明基本的结构体 <code>struct GitHubComment</code> 并让它遵循 <code>ExpressibleByStringLiteral</code>（因为 <code>ExpressibleByStringInterpolation</code> 继承自这个协议所以我们将它的实现抽离）和 <code>CustomStringConvertible</code>（为了 debug 时友好地在控制台中打印）。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GitHubComment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> markdown: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">GitHubComment</span>: <span class="title">ExpressibleByStringLiteral</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>(stringLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.markdown = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">GitHubComment</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.markdown</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们让 <code>GitHubComment</code> 遵循 <code>ExpressibleByStringInterpolation</code>。这意味着在剩下需要实现的功能，将由一个 <code>StringInterpolation</code> 子类型来完成：</p><ul><li><p>首先初始化它自己：<code>init(literalCapacity: Int, interpolationCount: Int)</code> 提供给你保留一部分数据到缓冲区的能力，在一步步构造类型时就会用到这个能力。在这个例子中，我们可以在构造实例的时候，简单用一个 <code>String</code> 并往它上面追加片段，不过这里我采用一个 <code>parts: [String]</code> 来代替，之后再将它组合起来</p></li><li><p>实现 <code>appendLiteral(_ string: String)</code> 逐个追加文本到 <code>parts</code> 里</p></li><li><p>实现 <code>appendInterpolation(user: String)</code> 在遇到 <code>\(user: xxx)</code> 时逐个追加 markdown 表示的用户配置链接</p></li><li><p>实现 <code>appendInterpolation(issue: Int)</code> 逐个追加用 markdown 表示的 issue 链接</p></li><li><p>然后在 <code>GitHubComment</code> 上实现 <code>init(stringInterpolation: StringInterpolation)</code> 将 <code>parts</code> 构造成一个评论</p></li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">GitHubComment</span>: <span class="title">ExpressibleByStringInterpolation</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">StringInterpolation</span>: <span class="title">StringInterpolationProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parts: [<span class="type">String</span>]</span><br><span class="line">      <span class="keyword">init</span>(literalCapacity: <span class="type">Int</span>, interpolationCount: <span class="type">Int</span>) &#123;</span><br><span class="line">      <span class="keyword">self</span>.parts = []</span><br><span class="line">      <span class="comment">// - literalCapacity 文本片段的字符数 (L)</span></span><br><span class="line">      <span class="comment">// - interpolationCount 插值片段数 (I)</span></span><br><span class="line">      <span class="comment">// 我们预计通常结构会是像 "LILILIL"</span></span><br><span class="line">      <span class="comment">// — e.g. "Hello \(world, .color(.blue))!" — 因此是 2n+1</span></span><br><span class="line">      <span class="keyword">self</span>.parts.reserveCapacity(<span class="number">2</span>*interpolationCount+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendLiteral</span><span class="params">(<span class="number">_</span> literal: String)</span></span> &#123;</span><br><span class="line">      <span class="keyword">self</span>.parts.append(literal)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(user name: String)</span></span> &#123;</span><br><span class="line">      <span class="keyword">self</span>.parts.append(<span class="string">"[\(name)](https://github.com/\(name))"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(issue number: Int)</span></span> &#123;</span><br><span class="line">      <span class="keyword">self</span>.parts.append(<span class="string">"[#\(number)](issues/\(number))"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">init</span>(stringInterpolation: <span class="type">StringInterpolation</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.markdown = stringInterpolation.parts.joined()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就完事了！我们成功了！</p><p>注意，因为那些我们实现了的 <code>appendInterpolation</code> 方法签名，我们允许使用 <code>Hello \(user: &quot;alisoftware&quot;)</code> 但不能使用 <code>Hello \(user: 123)</code>，因为 <code>appendInterpolation(user:)</code> 期望一个 <code>String</code> 作为形参。类似的是，在你的字符串中 <code>\(issue: 123)</code> 只能允许一个 <code>Int</code> 因为 <code>appendInterpolation(issue:)</code> 采用一个 <code>Int</code> 作为形参。</p><p>实际上，如果你尝试在你的 <code>StringInterpolation</code> 子类中用不支持的插值，编译器会给你提示报错：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> comment: <span class="type">GitHubComment</span> = <span class="string">"""</span></span><br><span class="line"><span class="string">See \(issue: "bob") where \(username: "alisoftware") explains the steps to reproduce.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">//             ^~~~~         ^~~~~~~~~</span></span><br><span class="line"><span class="comment">// 错误: 无法转换 ‘String’ 类型的值到期望的形参类型 ‘Int’</span></span><br><span class="line"><span class="comment">// 错误: 调用 (have 'username:', expected 'user:')实参标签不正确</span></span><br></pre></td></tr></table></figure><h2 id="这仅仅只是个开始"><a href="#这仅仅只是个开始" class="headerlink" title="这仅仅只是个开始"></a>这仅仅只是个开始</h2><p>这个新的设计打开了一大串脑洞让你去实现自己的 <code>ExpressibleByStringInterpolation</code> 类型。这些想法包括：</p><ul><li>创建一个 <code>HTML</code> 类型并遵循，你就可以用插值写 HTML </li><li>创建一个 <code>SQLStatement</code> 类型并遵循，你就可以写更简单的 SQL 语句</li><li>用字符串插值支持更多自定义格式，比如在你的插值字符串中用格式化 <code>Double</code> 或者 <code>Date</code> 值</li><li>创建一个 <code>RegEX</code> 类型并遵循，你就可以用花里胡哨的语法写正则表达式</li><li>创建一个 <code>AttributedString</code> 类型并遵循，就可以用字符串插值构建 <code>NSAttributedString</code> </li></ul><p>带来新的字符串插值设计的 <a href="https://github.com/brentdax" target="_blank" rel="noopener">Brent Royal-Gordon</a> 和 <a href="https://github.com/milseman" target="_blank" rel="noopener">Michael Ilseman</a>，提供了更多例子在这个 <a href="https://gist.github.com/brentdax/0b46ce25b7da1049e61b4669352094b6" target="_blank" rel="noopener">要点列表</a> 中。</p><p>我个人尝试了一下支持 <code>NSAttributedString</code> 的实现，并想 <a href="http://alisoftware.github.io/swift/2018/12/16/swift5-stringinterpolation-part2/" target="_blank" rel="noopener">在专门的一篇文章里分享它的初步实现</a>，因为我发现它非常优雅。我们下一篇文章再见！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Olivier Halligon，&lt;a href=&quot;http://alisoftware.github.io/swift/2018/12/15/swift5-stringinterpolation-part1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-12-15&lt;br&gt;译者：&lt;a href=&quot;https://nemocdz.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nemocdz&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
 &lt;!--此处开始正文--&gt;
&lt;p&gt; &lt;code&gt;StringInterpolation&lt;/code&gt; 协议最初的设计效率低下又不易扩展，为了在后续的版本中能够将其彻底重构，Swift 4 中将该协议标记为废弃。即将在 Swift 5 中亮相的 &lt;a href=&quot;https://github.com/apple/swift-evolution/blob/master/proposals/0228-fix-expressiblebystringinterpolation.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SE-0228&lt;/a&gt; 提案介绍了一种新的 &lt;code&gt;StringInterpolation&lt;/code&gt; 设计，使得 String 有了更大的潜能。&lt;/p&gt;
    
    </summary>
    
      <category term="Crunchy Development" scheme="https://swift.gg/categories/Crunchy-Development/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>在 iOS 11 中使用 Core Bluetooth</title>
    <link href="https://swift.gg/2019/04/15/core-bluetooth/"/>
    <id>https://swift.gg/2019/04/15/core-bluetooth/</id>
    <published>2019-04-15T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://appcoda.com/core-bluetooth/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-17<br>译者：<a href="https://github.com/dzyding" target="_blank" rel="noopener">灰s</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>作为 iOS 开发，我们十分清楚人们都喜欢互通性。我们喜欢通过无线设备与其他人进行沟通这一点是显而易见的。最近，我们开始希望能够与那些曾经被认为是独立的普通设备进行<em>通信</em>。我们开始喜欢，甚至是期望，部分无线设备可以收集并且分析自己的数据（通常称为“可穿戴设备”）。许多设备已经成为我们生活里的一部分，还为还有一个专门的术语来描述它：“Internet of Things” 或者 “IoT”（物联网）。现在地球上有数十亿的无线通讯设备。在这篇教程中，我们将聚焦 IoT 其中的一部分：蓝牙。  </p><p>我将说明蓝牙技术背后的基本概念，以及：  </p><ul><li>展示如何精通蓝牙方向的软件开发，从而为你提供巨大的职业机遇  </li><li>提醒你必须去确认在发布一个使用蓝牙技术的应用时是否需要通过“资格审查”  </li><li>给你提供 Apple 的<a href="https://developer.apple.com/documentation/corebluetooth" target="_blank" rel="noopener"><strong><em>Core Bluetooth</em></strong></a> 框架概述 (<a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html#//apple_ref/doc/uid/TP40013257-CH1-SW1" target="_blank" rel="noopener"><strong>也可以参阅这里</strong></a>)  </li><li>最后，带领你使用 Swift 4 并通过 <em>Core Bluetooth</em> 和一个蓝牙设备来开发一款用于监控心率的 iOS 应用程序</li></ul><blockquote><p>提示：注意跟随阅读文章中包含的超链接。对于开发者这是重要的资料，它确保你完全理解蓝牙的工作方式以及苹果是如何支持蓝牙这种技术的。</p></blockquote><a id="more"></a><h2 id="蓝牙-一项迅速发展的技术"><a href="#蓝牙-一项迅速发展的技术" class="headerlink" title="蓝牙 - 一项迅速发展的技术"></a>蓝牙 - 一项迅速发展的技术</h2><p>在一篇文章中不可能说清楚如何为整个物联网开发软件，但实际上，对所有这些无线设备进行数据分析是很有启发性的 - 实际上是很不可思议的。连接着的东西无处不在并且可以预测这个小东西的增长速度将是惊人的。如果你观察一下我们今天讨论的内容，在“短程段”中，使用如蓝牙和无线网的技术，然后添加上“广域类别”中，使用如电话的技术（比如: CDMA），<a href="https://www.ericsson.com/en/mobility-report/internet-of-things-forecast" target="_blank" rel="noopener"><strong>你将看到</strong></a> ~ 2014 年的 125 亿设备迅速增加到 2022 年预计的 300 亿。  </p><p>蓝牙是一种短距离无线通讯技术的标准化规范。<a href="https://www.bluetooth.com/zh-cn" target="_blank" rel="noopener"><strong>Bluetooth Special Interest Group（蓝牙技术联盟）</strong></a> 管理和保护这种短程无线技术背后的研发、发展还有知识产权。SIG 确保关于蓝牙的制造商，开发者和销售者他们的硬件和软件都是基于标准化规范。  </p><p>根据 Bluetooth SIG 报道，<a href="https://www.bluetooth.com/bluetooth-technology" target="_blank" rel="noopener"><strong>“今年有将近 40 亿台设备使用蓝牙进行连接。蓝牙将连接手机、平板电脑、个人电脑，蓝牙将会将我们彼此连接。”</strong></a>。一家对短程通讯技术进行深度投资的公司 Ellisys 对此表示认同，并 <a href="https://globenewswire.com/news-release/2018/02/22/1379920/0/en/Ellisys-Increases-Support-for-Bluetooth-Mesh-Networking-on-Protocol-Solutions.html" target="_blank" rel="noopener"><strong>“预估 2018 年将有近 40 亿台新的蓝牙设备上市”</strong></a>。请记住，<em>仅在今年</em>就有 40 亿<em>新</em>蓝牙设备上市。  </p><p>根据这个趋势，一家收集“市场和消费数据”的公司 Statista 认为全球的蓝牙设备 <a href="https://www.statista.com/statistics/283638/installed-base-forecast-bluetooth-enabled-devices-2012-2018/" target="_blank" rel="noopener"><strong>将从 2012 年的 35 亿增长到 2018 年预估的 100 亿</strong></a>。</p><h2 id="对于你的职业生涯，蓝牙意味着什么"><a href="#对于你的职业生涯，蓝牙意味着什么" class="headerlink" title="对于你的职业生涯，蓝牙意味着什么"></a>对于你的职业生涯，蓝牙意味着什么</h2><p>Dogtown Media 有限责任公司，一家 iOS 端“物联网蓝牙应用”精品开发商，该公司声称 <a href="http://www.dogtownmedia.com/app-development-services/internet-of-things-bluetooth-app-development/" target="_blank" rel="noopener"><strong>“根据麦肯锡全球研究所（McKinsey Global Institute）的专家预测，在未来 9 年内，物联网将对全球经济产生超过 6 万亿美元的影响”</strong></a> 。这对于像你我这样的 iOS 开发意味着什么？Dogtown 说 <a href="http://www.dogtownmedia.com/app-development-services/internet-of-things-bluetooth-app-development/" target="_blank" rel="noopener"><strong>“未来几年，对那些有远见的初创企业和创业者来说，将是令人兴奋的、多产的，而且非常有利可图的。”</strong></a><br>翻译：作为一个有前瞻性或者想创业的青年，应该学习使用蓝牙来进行应用程序的开发，因为在这个迅速扩大的市场，你的下个任务或者岗位有很大可能需要这个技能。  </p><p><strong>免责声明</strong>：  </p><blockquote><ul><li><em>我与 Dogtown Media, LLC 之间没有任何的从属关系。在搜索到这篇文章的期间，我发现了这家公司的网站，看到他们专门从事 iOS 端的蓝牙开发。</em>  </li><li><em>我是 Bluetooth SIG 的一名 “Adopter” 级别成员。</em>  </li></ul></blockquote><h2 id="在提交你使用-Core-Bluetooth-开发的应用程序被审核之前"><a href="#在提交你使用-Core-Bluetooth-开发的应用程序被审核之前" class="headerlink" title="在提交你使用 Core Bluetooth 开发的应用程序被审核之前"></a>在提交你使用 Core Bluetooth 开发的应用程序被审核之前</h2><p>在蓝牙技术刚展露头角之际，我经常看到开发者们找一些参考资料，然后立即投入到涉及无线设备的应用开发中，并提交蓝牙应用到 Apple 的 AppStore 中。我想说：别那么快，伙计。  </p><p>Bluetooth SIG 规定，<a href="https://www.bluetooth.com/develop-with-bluetooth/qualification-listing" target="_blank" rel="noopener"><strong>“所有使用蓝牙技术的产品必须完成 Bluetooth Qualification Process（蓝牙资格审核）。”</strong></a> 我听到有人说，“市面上有太多基于蓝牙的应用；没有人会注意到我的”。呃，并不是这样。蓝牙技术有 <a href="https://www.bluetooth.com/about-us/governing-documents" target="_blank" rel="noopener"><strong>版权，专利，并且授权</strong></a> 给应用开发者。如果你想让你的应用程序被聚焦并且展示你集成了蓝牙技术的事实，请记住：  </p><blockquote><p><em>Bluetooth</em> 商标 - 包括 BLUETOOTH 文字商标，图形商标（符文 B 和椭圆形设计），还有组合商标（蓝牙文字商标和设计）- 这些都被 Bluetooth SIG 所拥有。只有 Bluetooth SIG 的成员并且拥有对应资格和申报过的产品才可以展示，相关功能或者使用任何商标。为了保护这些商标，Bluetooth SIG 管理了一套执行程序，监控市场并进行审核，以确保会员使用商标的行为符合蓝牙品牌指南，并确保最终发布的产品与已通过资格审查程序的商品和服务相对应。</p></blockquote><p>来看一下 Bluetooth SIG 的 <a href="https://www.bluetooth.com/develop-with-bluetooth/qualification-listing" target="_blank" rel="noopener"><strong>资质 FAQ</strong></a>：</p><blockquote><p>如果我没有给我的产品申请相应的资质会怎么样?  </p><p>如果你没有给你的产品申请相应的资质，你将成为执法行动的对象。请阅读这里的 <a href="https://www.bluetooth.com/develop-with-bluetooth/qualification-listing" target="_blank" rel="noopener"><strong>更新策略</strong></a>，其中我们概述了升级计划。如果没有采取纠正措施，您的 Bluetooth SIG 会员资质可能被暂停或撤销。</p></blockquote><p>别傻了，别去冒险。最重要的一点是，我们所有人都应该努力追求最高的诚信和诚实，在应该给予信任的时候给予信任，并促进遵守标准，使协同工作成为规范，而不是例外。数千个人贡献了数千个小时的工作和数百万美元用于发展蓝牙的标准和 <a href="http://www.ipwatchdog.com/2015/05/10/evolution-of-technology-bluetooth-the-once-and-future-king/id=57473/" target="_blank" rel="noopener"><strong>多项专利</strong></a>，从而创造了一套明显有用的知识财产。</p><h2 id="别让我吓着你"><a href="#别让我吓着你" class="headerlink" title="别让我吓着你"></a>别让我吓着你</h2><p>人们常常被「商标」、「专利」、「版权」、「资质」、「会员」、等严厉的词语所吓倒，尤其是 “强制执行。”不要开始担心使用蓝牙进行开发的事。<em>加入 Bluetooth SIG！它是免费的！</em> <a href="https://www.bluetooth.com/develop-with-bluetooth/join" target="_blank" rel="noopener"><strong>点击这里</strong></a>，然后：</p><blockquote><p>首先成为一个 Adopter 级别的会员。使用蓝牙技术开发一款产品，会员资格是必须的，Adopter 级别会员拥有以下这些福利：<br>• 根据 <a href="https://www.bluetooth.com/~/media/downloads/pcla%20esign%20version%20version%2011.ashx?la=en" target="_blank" rel="noopener"><strong>Bluetooth Patent/Copyright License Agreement（蓝牙专利/版权许可协议）</strong></a> 使用蓝牙技术生产产品的许可<br>• 根据 <a href="https://www.bluetooth.com/~/media/files/membership/btla.ashx?la=en" target="_blank" rel="noopener"><strong>Bluetooth Trademark License Agreement（蓝牙商标许可协议）</strong></a> 在符合条件的产品上使用蓝牙商标的许可<br>• 能够与数以万计的 Bluetooth SIG 成员建立网络，并在各种各样的行业中合作 — 从芯片制造商到应用程序的开发者，设备制造商和服务提供商<br>• 能够参加 <a href="https://www.bluetooth.com/specifications/working-groups/working-groups-committees" target="_blank" rel="noopener"><strong>SIG 专家组、研究小组和工作组中的子小组</strong></a><br>• 访问诸如 Profile Tuning Suite（PTS）之类的工具，提供协议和协同测试……</p></blockquote><h2 id="成为-Bluetooth-SIG-的一员"><a href="#成为-Bluetooth-SIG-的一员" class="headerlink" title="成为 Bluetooth SIG 的一员"></a>成为 Bluetooth SIG 的一员</h2><p>成为 SIG 的一员 <a href="https://www.bluetooth.com/develop-with-bluetooth/build" target="_blank" rel="noopener"><strong>会包含很多好处</strong></a>。你可以免费使用教育工具包、培训视频、网络研讨会、开发人员论坛、开发人员支持服务、白皮书、产品测试工具，并帮助确保您的应用程序满足国际监管要求（主要是关于 <a href="https://www.fda.gov/MedicalDevices/DigitalHealth/WirelessMedicalDevices/default.htm" target="_blank" rel="noopener"><strong>射频排放</strong></a>）。  </p><p>你只要成为会员就会得到一些曝光。我的公司是它的一个成员，所以在 Bluetooth SIG’s Member Directory 中可以 <a href="https://www.bluetooth.com/develop-with-bluetooth/join/member-directory?q=microIT%20Infrastructure,%20LLC" target="_blank" rel="noopener"><strong>被看到</strong></a>：<br><img src="https://appcoda.com/wp-content/uploads/2018/04/membership.png" alt>  </p><p>一旦你开发了一款应用，使其通过 SIG 认证，并获得 Apple App Store 的许可，那么你的产品同时也会被 SIG 公开上市，这时你将获得更多的曝光。  </p><h2 id="对应用程序进行资格认证既简单又便宜"><a href="#对应用程序进行资格认证既简单又便宜" class="headerlink" title="对应用程序进行资格认证既简单又便宜"></a>对应用程序进行资格认证既简单又便宜</h2><p>当你对自己基于 Core Bluetooth 开发的应用程序感到满意，并准备将其提交到 Apple App Store 进行审核，请停下，然后前往 Bluetooth SIG 的网页对你的应用程序进行 <a href="https://www.bluetooth.com/develop-with-bluetooth/qualification-listing" target="_blank" rel="noopener"><strong>认证</strong></a>。SIG 将为您提供一个整洁的 <a href="https://launchstudio.bluetooth.com/" target="_blank" rel="noopener"><strong>“Launch Studio”</strong></a>，它是您用来完成 Bluetooth Qualification Process 的在线工具。”  </p><p>对于大多数应用程序，比如我将在本教程中介绍的 “GATT - based Profile Client（app），”认证和上市的费用是 100 美元。花一些精力来确保您的代码符合 Bluetooth 规范和做一些测试，将是非常值得的。最后，可以给你的应用程序印上蓝牙的商标。这个 <a href="https://www.bluetooth.com/develop-with-bluetooth/marketing-branding" target="_blank" rel="noopener"><strong>商标</strong></a> “在全球范围内都是可识别的，消费者认知度高达92%。”  </p><p>请不要担心 100 美元的问题。你更有可能获得一份拥有丰厚薪水或者时薪的工作，并为公司处理这些蓝牙的合规问题。</p><h2 id="理解-Core-Bluetooth"><a href="#理解-Core-Bluetooth" class="headerlink" title="理解 Core Bluetooth"></a>理解 Core Bluetooth</h2><p>大多数情况下，使用蓝牙设备是非常简单的。开发与蓝牙通讯的软件却有可能非常复杂。这就是为什么 Apple 创造了 <a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/CoreBluetoothOverview/CoreBluetoothOverview.html#//apple_ref/doc/uid/TP40013257-CH2-SW1" target="_blank" rel="noopener"><strong><em>Core Bluetooth</em></strong> <strong>框架</strong></a>：  </p><blockquote><p>Core Bluetooth 框架让您的 iOS 和 Mac 应用程序与蓝牙低能耗设备通信。例如，您的应用程序可以发现、搜索低能量的外围设备还有与之交互，比如心率监视器、数字恒温器，甚至其他 iOS 设备。  </p></blockquote><blockquote><p>该框架是蓝牙 4.0 规范中关于使用低能耗设备的抽象。就是说，它为你，也就是开发者，隐藏了规范中很多底层的细节，使你更容易开发与低能耗设备进行交互的应用程序。因为该框架是基于标准规范的，所有规范中的很多概念和术语被采用了……  </p></blockquote><p>请注意是“低能量设备”。当使用 <em>Core Bluetooth</em> 我们并不是处理如无线扬声器这样的经典蓝牙设备。与这类设备的通讯会很快的耗尽电池能量。<em>Core Bluetooth</em> 是针对“Bluetooth Low Energy”（BLE）的 API，也称为“Bluetooth 4.0”。BLE 使用的电力要少得多，因为它的设计目的是通信少量的数据。BLE 设备的一个很好的例子是心率监测器（HRM）。它几乎每秒钟只发送几个字节的数据。这就是为什么人们可以带着一个 HRM 或者带着他们的 iPhone 跑一个小时，记录跑步期间心率的变化，而看不到电池电量的巨大消耗。注意，随着本文的进行，像 BLE 这种首字母缩略词的数量正在增加。  </p><p>为了我们能够一起流畅的讨论 <em>Core Bluetooth</em> 你需要学习一个新的词汇表。  </p><p>分别从 <a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/CoreBluetoothOverview/CoreBluetoothOverview.html#//apple_ref/doc/uid/TP40013257-CH2-SW17" target="_blank" rel="noopener"><strong>客户端/服务端和生产者/消费者模型</strong></a> 的角度考虑 BLE 协议。<br><img src="https://appcoda.com/wp-content/uploads/2018/04/central-peripheral.png" alt>  </p><h2 id="The-Peripheral（外围设备）"><a href="#The-Peripheral（外围设备）" class="headerlink" title="The Peripheral（外围设备）"></a>The Peripheral（外围设备）</h2><p><em>外围设备</em>是硬件/软件的一部分，就像 HRM。大多数 HRM 设备搜集或/和计算数据，如每分钟心跳、HRM 的电池电量水平、以及所谓的“RR-Interval”。设备传输这些数据到另一个需要它们的实体或实体组。外围设备是<em>服务者</em>和<em>生产者</em>。市场上比较流行的 HRM 有 <a href="https://www.wahoofitness.com/devices/heart-rate-monitors/wahoo-tickr-heart-rate-strap" target="_blank" rel="noopener"><strong>Wahoo TICKR，</strong></a><a href="https://www.polar.com/us-en/products/accessories/h10_heart_rate_sensor" target="_blank" rel="noopener"><strong>Polar H7，</strong></a>和 <a href="https://www.scosche.com/rhythm-plus-heart-rate-monitor-armband" target="_blank" rel="noopener"><strong>Scosche Rhythm+</strong></a>。<br><img src="https://appcoda.com/wp-content/uploads/2018/04/heart-rate-monitor-device.png" alt>  </p><p>我将通过编写连接到这三种设备的 Swift 4 代码来展示 BLE 等标准的重要性。  </p><p><strong><em>Core Bluetooth 视角</em></strong>  </p><p>来自 <a href="https://developer.apple.com/documentation/corebluetooth/cbperipheraldelegate" target="_blank" rel="noopener"><strong>苹果的文档</strong></a>：  </p><blockquote><p>CBPeripheralDelegate  </p><p><a href="https://developer.apple.com/documentation/corebluetooth/cbperipheral" target="_blank" rel="noopener"><code>CBPeripheral</code></a> 对象的代理必须遵守 <a href="https://developer.apple.com/documentation/corebluetooth/cbperipheraldelegate" target="_blank" rel="noopener"><code>CBPeripheralDelegate</code></a> 协议。代理使用这个协议的方法来对一个远程外围设备的服务和属性，进行发现、探索、还有交互方面的监控。这个协议里面没有必须遵守的方法。  </p></blockquote><h2 id="The-Central（中央设备）"><a href="#The-Central（中央设备）" class="headerlink" title="The Central（中央设备）"></a>The Central（中央设备）</h2><p><em>中央设备</em>是硬件/软件的一部分，就像 iPhone、iPad、MacBook、<br>iMac 等。这些设备可以使用应用程序扫描像 HRM 这样的蓝牙外围设备。中央设备是一个<em>客户</em>以及 <em>消费者</em>。它们与 HRM 是连通的，所以它们可以使用从外围设备中取出的像每分钟心跳、电池的电量水平、还有“RR-Interval”这样的数据。中央设备接收这些数据，可以对数据执行增值计算，或者只是通过用户界面显示数据，或者是存储数据以供将来分析、展示，或者是聚合和数据分析（就像统计分析需要足够的数据来确定重要的和有意义的趋势），或其他类似的操作。  </p><p><strong><em>Core Bluetooth 视角</em></strong>  </p><p>来自 <a href="https://developer.apple.com/documentation/corebluetooth/cbcentralmanagerdelegate" target="_blank" rel="noopener"><strong>苹果的文档</strong></a>：  </p><blockquote><p><a href="https://developer.apple.com/documentation/corebluetooth/cbcentralmanagerdelegate" target="_blank" rel="noopener"><code>CBCentralManagerDelegate</code></a> 协议定义了方法，<a href="https://developer.apple.com/documentation/corebluetooth/cbcentralmanager" target="_blank" rel="noopener"><code>CBCentralManager</code></a> 对象的代理必须遵守它。协议中的可选方法允许代理来监控对外围设备的发现、连接、还有检索。唯一必须实现的方法表明中央设备的可用性，并且当中央设备的状态发生更新时被调用。</p></blockquote><h2 id="通过广播找到外围设备"><a href="#通过广播找到外围设备" class="headerlink" title="通过广播找到外围设备"></a>通过广播找到外围设备</h2><p>如果你的 iPhone 或 iPad 找不到这些外设从而不能连接到它们，那么 HRM 之类的外设就没什么用了。因此，它们不断通过无线频段发送着数据的小片段（包），说着类似这样的话：“嘿，我是 Scosche Rhythm+ 心率检测器；我能提供类似我的穿戴者每分钟心率的功能；我能提供类似我的电池电量水平的信息。”当一个对心率感兴趣的<em>中央设备</em>通过<em>扫描</em>找到了这个<em>外围设备</em>，中央设备将连接到它并且它会停止广播。  </p><p>你可能已经使用过 iPhone -&gt; <em>设置</em> -&gt; <em>蓝牙</em> 来开启或关闭蓝牙（包括传统的和 BLE）。当切换到开启，你可以看到你的 iPhone 扫描设备并与它们建立连接，就像下面我所截的两张图，搜索，并且将我的 iPhone 连接到一个 Scosche Rhythm+ HRM：<br><img src="https://appcoda.com/wp-content/uploads/2018/04/bluetooth-found-ryhthm.png" alt>  </p><p>依照 <a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/CoreBluetoothOverview/CoreBluetoothOverview.html#//apple_ref/doc/uid/TP40013257-CH2-SW17" target="_blank" rel="noopener"><strong>苹果</strong></a> 的说法：  </p><blockquote><p>外围设备以广播包的形式广播一些数据。一个广播包是一个相对较小的数据束，其中可能包含外围设备所能提供的有用信息，比如外围设备的名字还有主要功能。例如，数字恒温器可能会广播它能提供房间的当前温度。在 BLE 中，广播是外围设备展示其存在的主要方式。另一方面，中央设备可以扫描和监听任何外围设备，只要这些设备的广播信息是它感兴趣的……  </p></blockquote><p>在这篇教程中，过一会我会向你展示怎样使用 Swift 4 来编码进行外围设备的扫描并连接它们。</p><h2 id="外围设备的各种服务"><a href="#外围设备的各种服务" class="headerlink" title="外围设备的各种服务"></a>外围设备的各种服务</h2><p>服务可能不是你认为的那样。服务<em>描述</em>外围设备提供的主要特性或功能。但它并不是一种具体的测量方法，如每分钟心跳数，而是一种描述从外围设备可以得到的与心脏相关的测量方法的分类。  </p><p>依照 <a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/CoreBluetoothOverview/CoreBluetoothOverview.html#//apple_ref/doc/uid/TP40013257-CH2-SW17" target="_blank" rel="noopener"><strong>苹果</strong></a> 的说法：  </p><blockquote><p>服务是一个数据和相关行为的集合，用于实现设备（或设备的一部分）的功能或特性。比如，心率检测器的一项服务可能是公开来自监测器的心率传感器的心率数据。</p></blockquote><p>具体定义一个蓝牙“服务”，我们应该看看 Bluetooth SIG 的 <a href="https://www.bluetooth.com/specifications/gatt/services" target="_blank" rel="noopener"><strong>“GATT Services（服务）”</strong></a> 列表，这里 GATT 代表 <a href="https://www.bluetooth.com/specifications/gatt" target="_blank" rel="noopener"><strong>“Generic Attributes（通用属性）”</strong></a>。  </p><p>向下滚动服务 <a href="https://www.bluetooth.com/specifications/gatt/services" target="_blank" rel="noopener"><strong>列表</strong></a>，直到你在 <strong>Name（名字）</strong> 列中看到 “Heart Rate”。注意， <strong>Uniform Type Identifier (统一类型标识符)</strong> 对应的是 “org.bluetooth.service.heart_rate”，<strong>Assigned Number（指定编码）</strong> 则是 0x180D。请注意在后面的代码中我们将使用 0x180D 这个值。  </p><p>点击 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.heart_rate.xml" target="_blank" rel="noopener"><strong>“Heart Rate（心率）”</strong></a>，你将打开一个网页，上面用粗体字写着 <strong>Name: Heart Rate</strong>。请注意 <strong>Summary（摘要）</strong> ，“HEART RATE Service（心率服务）公开心率和其他与心率传感器相关的数据，用于健身应用。”向下滚动页面就会发现 <strong>Heart Rate</strong> <em>service</em> 本身并不会提供每分钟跳动的实际心率。这个服务是一个其他数据片段的集合，它们被称为 <em>characteristics（特征）</em>。最后，你会得到一个特征来提供重要数据：心率。  </p><p><strong><em>Core Bluetooth 视角</em></strong>  </p><p>来自 <a href="https://developer.apple.com/documentation/corebluetooth/cbservice" target="_blank" rel="noopener"><strong>苹果的文档</strong></a>：  </p><blockquote><p><a href="https://developer.apple.com/documentation/corebluetooth/cbservice" target="_blank" rel="noopener"><code>CBService</code></a> 和它的子类 <a href="https://developer.apple.com/documentation/corebluetooth/cbmutableservice" target="_blank" rel="noopener"><code>CBMutableService</code></a> 代表一个外围设备的服务 - 为实现设备（或设备的一部分）的功能或特性而收集的数据和相关行为。<code>CBService</code> 对象特指远程外围设备（使用 <a href="https://developer.apple.com/documentation/corebluetooth/cbperipheral" target="_blank" rel="noopener"><code>CBPeripheral</code></a> 对象来表示）的服务。服务组可能是主要的，也有可能是次要的，可能会包含一个特征组的代码，也有可能会包含一个服务组（代表其他的服务组）。  </p></blockquote><h2 id="外围设备服务的特征"><a href="#外围设备服务的特征" class="headerlink" title="外围设备服务的特征"></a>外围设备服务的特征</h2><p>外围设备的服务常常被分解成更细化但相关的信息。特征通常是我们找到重要信息、真实<em>数据</em>的地方。再次查看 <a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/CoreBluetoothOverview/CoreBluetoothOverview.html#//apple_ref/doc/uid/TP40013257-CH2-SW17" target="_blank" rel="noopener"><strong>苹果</strong></a> 的说明：  </p><blockquote><p>服务本身是由特征或包含的服务（这里指别的服务）组成。特征更详细的提供了外围设备的服务信息。例如，刚才描述的心率服务，可能包含一个描述设备的心率传感器所在目标身体位置的特征和另一个传递心率测量数据的特征。  </p></blockquote><p>让我们继续使用 HRM 作为例子。请返回那个用粗体字写着 <strong>Name: Heart Rate（名字：心率）</strong> 的 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.heart_rate.xml" target="_blank" rel="noopener"><strong>界面</strong></a>。向下滚动直到你看到 <strong>Service Characteristics（服务特征）</strong>。那是一个包含大量元数据（<em>关于</em>信息的数据）的大表格。请找到 <strong>Heart Rate Measurement（心率测量）</strong> 并点击 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.heart_rate_measurement.xml" target="_blank" rel="noopener"><strong>org.bluetooth.characteristic.heart_rate_measurement</strong></a> 然后审查。稍后我会对这个界面进行解释。  </p><p><strong><em>Core Bluetooth 视角</em></strong><br>来自 <a href="https://developer.apple.com/documentation/corebluetooth/cbcharacteristic" target="_blank" rel="noopener"><strong>苹果的文档</strong></a>： </p><blockquote><p><a href="https://developer.apple.com/documentation/corebluetooth/cbcharacteristic" target="_blank" rel="noopener"><code>CBCharacteristic</code></a> 和它的子类 <a href="https://developer.apple.com/documentation/corebluetooth/cbmutablecharacteristic" target="_blank" rel="noopener"><code>CBMutableCharacteristic</code></a> 代表关于外围设备服务的详细信息。<code>CBCharacteristic</code> 对象特指远程外围设备（远程外围设备使用 <code>CBPeripheral</code> 对象表示）服务的特征。一个特征包含一个单一的值以及任意个描述符来描述这个值。特征的属性描述了如何使用这个特征的值以及如何访问这些描述符。</p></blockquote><h2 id="GATT-规范"><a href="#GATT-规范" class="headerlink" title="GATT 规范"></a>GATT 规范</h2><p>当你使用 <em>Core Bluetooth</em> 开发一款需要与蓝牙外围设备交互的应用程序时，你首先应该前往 Bluetooth SIG 的首页。  </p><p>让我们一起回顾我曾经的经历，那会我在开发一个应用程序，用 HRM 做了各种各样非常好玩的功能。查看 <a href="https://www.bluetooth.com/specifications/gatt" target="_blank" rel="noopener"><strong>GATT Specifications（GATT 技术指标）</strong></a> 部分，然后在 <a href="https://www.bluetooth.com/specifications/gatt/services" target="_blank" rel="noopener"><strong>GATT Services（GATT 服务）</strong></a> 下面找到你需要的外围设备服务。  </p><p>在本文介绍的 HRM 示例中，首先在 <a href="https://www.bluetooth.com/specifications/gatt/services" target="_blank" rel="noopener"><strong>GATT Services（GATT 服务）</strong></a> 界面的 <strong>Name（名字）</strong> 列中找到 “Heart Rate”（也就是一个超链接）项。点击 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.heart_rate.xml" target="_blank" rel="noopener"><strong>“Heart Rate（心率）”</strong></a> 链接并且查看完整的网站。请记住 <strong>Assigned Number（分配符）</strong>（0x180D）然后滑动到底部的 <strong>Service Characteristics（服务特征）</strong> 表。仔细的查看表格并且找到有兴趣的特征。  </p><p>在这个例子中，阅读 <strong>Heart Rate Measurement（心率测量）</strong> 和 <strong>Body Sensor Location（传感器所在身体部位）</strong> 分区，然后点击各自的详细链接，<a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.heart_rate_measurement.xml" target="_blank" rel="noopener"><strong>org.bluetooth.characteristic.heart_rate_measurement</strong></a> 和 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.body_sensor_location.xml" target="_blank" rel="noopener"><strong>org.bluetooth.characteristic.body_sensor_location</strong></a>。  </p><p>在 <strong>Heart Rate Measurement（心率测量）</strong> 以及 <strong>Body Sensor Location（传感器所在身体部位）</strong> 界面中，分别记住它们的 <strong>Assigned Number（分配符）</strong>，（0x2A37）和（0x2A38），然后查看界面中的所有信息，以便了解将被发送到该 HRM 应用程序中的蓝牙编码数据结构该如何解译。编写代码时必须把蓝牙编码数据转换成人类可读的格式。  </p><p>随着本教程的深入，我将向你介绍更多细节，特别是当我向你展示，我用来与 BLE HRM 通信的应用程序代码。  </p><p>如果你 <a href="https://www.bluetooth.com/develop-with-bluetooth/join" target="_blank" rel="noopener"><strong>加入</strong></a> Bluetooth SIG ，你可以获得更多关于使用服务和特征进行编程的详细信息。  </p><h2 id="编写-Core-Bluetooth-代码"><a href="#编写-Core-Bluetooth-代码" class="headerlink" title="编写 Core Bluetooth 代码"></a>编写 Core Bluetooth 代码</h2><p>在这次讨论中，我将假设你了解 iOS 应用程序开发的基础知识，包括 Swift 编程语言和 Xcode <em>Single View App</em>（单视图应用程序）模板。测试应用程序的用户界面（UI），包括 Auto Layout（自动布局），代码如下所示，非常简单。  </p><p>我将用一系列步骤来描述代码 — 这些步骤在下面的代码中<em>同样</em>会被解释。因此，在阅读本节中的步骤时，请参阅下面代码中对应的步骤。整个过程基本上是线性的。请记住，其中一些步骤表示回调 — 正在调用的委托方法。  </p><p>在编写应用程序时，我会将 <a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html#//apple_ref/doc/uid/TP40013257-CH1-SW1" target="_blank" rel="noopener"><strong><em>Core Bluetooth</em></strong></a> 组件分解成协议或类 — 例如，将核心功能从 UI 中分离出来。但这段代码的目的是向您展示 <em>Core Bluetooth</em> 如何在最少的干扰下工作。我的注释很简单，而且有实际意义。在一个页面中你只会看到重要部分。  </p><h2 id="示例应用程序样式"><a href="#示例应用程序样式" class="headerlink" title="示例应用程序样式"></a>示例应用程序样式</h2><p>针对这篇文章我所开发的应用程序 UI 极其简单。当应用程序被启动，它开始扫描并尝试匹配一个 HRM。扫描的过程通过 <code>UIActivityIndicatorView</code> 类在屏幕上显示并旋转来表明。当没有匹配上任一 HRM 时，通过一个红色正方形的 <code>UIView</code> 来表明。一旦发现一个 HRM 并初步链接，<code>UIActivityIndicatorView</code> 停止旋转并隐藏，并且红色 <code>UIView</code> 转变为绿色。当 HRM 完全链接并被访问，我会显示 HRM 的品牌型号和穿戴者放置在身体上的预定位置。此时我会开始读取并且显示穿戴者每分钟的心率，大约每秒更新。大多数 HRM 都是每秒发送一次每分钟心率值。我人为地设计了一个心率数字的脉冲动画让应用看起来更有吸引力，但是你看到的是我<em>真实</em>的心率。当 HRM 断开链接，我清空所有的信息文本，将正方形 <code>UIView</code> 转变为红色，显示 <code>UIActivityIndicatorView</code> 并开始旋转，同时再次开始扫描 HRM。  </p><p>以下是我的应用程序在与三个不同品牌的 HRM 匹配运行时的样式 — Scosche Rhythm+，Wahoo TICKR，还有Polar H7：  </p><p><img src="https://appcoda.com/wp-content/uploads/2018/04/hrm-demo-1024x433.png" alt>  </p><p>Rhythm+ 使用红外光“看”我的静脉以确定心率。TICKR 和 H7 使用电极检测告诉我心跳的电脉冲。</p><h2 id="逐步了解我的代码"><a href="#逐步了解我的代码" class="headerlink" title="逐步了解我的代码"></a>逐步了解我的代码</h2><p>你可以在下一段找到完整的源代码。在这里，我将向你介绍实现步骤。  </p><p><strong>Step 0.00 ：</strong> 我必须导入 <code>CoreBluetooth</code> 框架。  </p><p><strong>Step 0.0 ：</strong> 指定 GATT 中的 <strong>Assigned Numbers（分配符）</strong> 为常量。我这样做让蓝牙规范的标识符更具可读性和可维护性，针对 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.heart_rate.xml" target="_blank" rel="noopener"><strong>“心率”</strong></a> 服务，其 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.heart_rate_measurement.xml" target="_blank" rel="noopener"><strong>“心率测量”</strong></a> 特征，还有其 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.body_sensor_location.xml" target="_blank" rel="noopener"><strong>“身体传感器位置”</strong></a> 特征。  </p><p><strong>Step 0.1 ：</strong> 创建一个 <code>UIViewController</code> 的子类 <code>HeartRateMonitorViewController</code>。使 <code>HeartRateMonitorViewController</code> 遵守 <a href="https://developer.apple.com/documentation/corebluetooth/cbcentralmanagerdelegate" target="_blank" rel="noopener"><code>**CBCentralManagerDelegate**</code></a> 和 <a href="https://developer.apple.com/documentation/corebluetooth/cbperipheraldelegate" target="_blank" rel="noopener"><code>**CBPeripheralDelegate**</code></a> 协议。我使用协议和委托的设计模式，正如我在 AppCoda 文章中 <a href="https://appcoda.com/protocol-oriented-programming/" target="_blank" rel="noopener"><strong>这里</strong></a> 还有 <a href="https://appcoda.com/swift-delegate/" target="_blank" rel="noopener"><strong>这里</strong></a> 分别描述的那样。我们将实现来自两个协议的方法。我们将调用一些 <em>Core Bluetooth</em> 的方法，一些方法将由 <em>Core Bluetooth</em> 为我们调用，以响应我们自己的调用。  </p><p><strong>Step 0.2 ：</strong> 我们在 <code>HeartRateMonitorViewController</code> 类中定义实例变量，它们代表 <code>CBCentralManager</code> 和 <code>CBPeripheral</code> 类，所以它们在应用程序的生命周期内都是<em>持续存在</em>的。  </p><p><strong>Step 1 ：</strong> 我们为进程在后台创建一个并发队列。我希望 <em>Core Bluetooth</em> 的运行发生在后台。我希望 UI 保持响应。说不定，在一个更复杂的应用程序中，HRM 可能会运行数小时，为用户收集心率数据。用户可能希望使用其他应用程序特性，例如，修改应用程序设置，或者，如果用户正在跑步，并且希望使用 <code>Core Location</code> 来跟踪跑步的路线。因此，在心率数据正在收集和显示的同时，用户可以收集和/或查看他们的地理位置。  </p><p><strong>Step 2 ：</strong> 创建用于扫描、连接、管理和从外围设备收集数据的控制中心。这是<em>必要</em>的一步。缺少了控制中心 <em>Core Bluetooth</em> 将无法工作。另一个必要的：由于 <code>HeartRateMonitorViewController</code> 采用了 <code>CBCentralManagerDelegate</code>，我们将 <code>centralManager</code> 的委托属性设置成 <code>HeartRateMonitorViewController</code>（<code>self</code>）。同时我们还为控制中心指定了 <code>DispatchQueue</code>。  </p><p><strong>Step 3.1 ：</strong> <code>centralManagerDidUpdateState</code> 方法的调用基于设备的蓝牙状态。理想情况下，我们应该考虑一个场景，在该场景中，用户无意（或故意）在 <code>Settings（设置）</code> 应用程序中关闭蓝牙。我们<em>只能</em>在蓝牙为 <code>.poweredOn</code> 状态时才能扫描外围设备。  </p><p><strong>Step 3.2 ：</strong> 控制中心应该扫描感兴趣的外围设备，但<em>前提</em>是设备（如iPhone）开启了蓝牙。还记得上面标题为“通过广播找到外围设备”的部分吗？我们就是这样处理这个调用的。我们的监听<em>只</em>针对正在广播 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.heart_rate.xml" target="_blank" rel="noopener"><strong>心率</strong></a> 服务（0x180D）的 HRM。我们可以通过添加特定服务的 <code>CBUUIDs</code> 到 <code>serviceUUIDs</code> 数组参数（标记为 <code>withServices</code>），从而达到监听并且连接更多外围设备的目的。例如，在一些健康相关的应用程序中，我们可以监听并连接到 HRM <em>和</em>血压监测器或者 BPM（尽管我们需要再创建一个 <code>CBPeripheral</code> 类的实例变量）。注意，如果我们做了这个调用：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">centralManager?.scanForPeripherals(withServices: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>我们可以监听范围内<em>所有</em>蓝牙设备的广播。在一些蓝牙功能类的应用程序中它可能有用。  </p><p><strong>Step 4.1 ：</strong> 找到这个应用程序可以连接哪些<em>感兴趣的</em>外围设备（HRM）。这个 <code>didDiscover</code> 方法告诉我们，在扫描时，控制中心已经发现了正在广播的 HRM。  </p><p><strong>Step 4.2 ：</strong> 我们<em>必须</em>在类的实例变量中保存刚刚发现的外围设备的引用，它将持续存在。如果我们仅仅只是使用了一个局部变量，我们会倒霉的。  </p><p><strong>Step 4.3 ：</strong> 因为 <code>HeartRateMonitorViewController</code> 采用了 <code>CBPeripheralDelegate</code> 协议，所以 <code>peripheralHeartRateMonitor</code> 对象必须将它的 <code>delegate</code> 属性设置为 <code>HeartRateMonitorViewController</code>（<code>self</code>）。  </p><p><strong>Step 5 ：</strong> 我们在 <code>didDiscover</code> 中告诉控制中心停止扫描以便保护电池寿命。当已经连接的 HRM 或外围设备断开连接时，我们可以再次开启扫描。  </p><p><strong>Step 6 ：</strong> 此时还在 <code>didDiscover</code> 中，我们连接到被发现的感兴趣的外围设备，一个 HRM。  </p><p><strong>Step 7 ：</strong> <code>didConnect</code> 方法<em>仅仅</em>“当成功与一个外围设备连接时调用。”请注意“成功”这个词。如果你发现一个外围设备但不能连接，那么你需要进行一些调试。请注意我更新了 UI 用来显示我连接了那个外围设备，并表明我已经停止扫描，以及其他一些事情。  </p><p><strong>Step 8 ：</strong> 此时还在 <code>didConnect</code> 方法中，我们在外围设备上寻找感兴趣的服务。具体来说，我们希望找到 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.heart_rate.xml" target="_blank" rel="noopener"><strong>Heart Rate（心率）</strong></a>（0x180D）服务。  </p><p><strong>Step 9 ：</strong> 当 <code>didDiscoverServices</code> 方法被调用的时候，说明在我们所连接的外围设备上发现了 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.heart_rate.xml" target="_blank" rel="noopener"><strong>“Heart Rate（心率）”</strong></a> 服务。请记住我们需要寻找感兴趣的<em>特征</em>。这里我对 <strong>Heart Rate（心率）</strong> 服务的所有特征进行了一次循环以找到我接下来要用的那个。如果你前往 Bluetooth SIG 网页中 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.heart_rate.xml" target="_blank" rel="noopener"><strong>“Heart Rate（心率）”</strong></a> 服务对应的页面，滚动到下面标记为 <strong>Service Characteristics（服务特征）</strong> 的分区，就可以查看那三个可用的特征。  </p><p><strong>Step 10 ：</strong> <code>didDiscoverCharacteristicsFor service</code> 方法证明我们已经发现了感兴趣的服务中所有的特征。  </p><p><strong>Step 11 ：</strong> 首先，我订阅了一个通知 - “read” - 关于感兴趣的 <strong>Body Sensor Location（传感器所在身体部位）</strong> 特征。前往 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.heart_rate.xml" target="_blank" rel="noopener"><strong>“Heart Rate（心率）”</strong></a> 服务的页面，你会发现这个特征被标记为“Read Mandatory。”调用 <code>peripheral.readValue</code> 将会引起 <code>peripheral:didUpdateValueForCharacteristic:error:</code> 方法稍后被调用，所以我可以将这个特征解析成人类语言。其次，我订阅了一个定期通知 — “notify” — 关于感兴趣的 <strong>Heart Rate Measurement（心率测量）</strong> 特征。前往 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.heart_rate.xml" target="_blank" rel="noopener"><strong>“Heart Rate（心率）”</strong></a> 服务的页面，你会发现这个特征被标记为“Notify Mandatory。”调用 <code>peripheral.setNotifyValue</code> 将会引起 <code>peripheral:didUpdateValueForCharacteristic:error:</code> 方法稍后被调用，并且是几乎<em>每一秒钟</em>触发一次，所以我可以将这个特征解析成人类语言。  </p><p><strong>Step 12 ：</strong> 因为我对特征 <strong>Body Sensor Location（传感器所在身体部位）</strong> （0x2A38）订阅了读取值，并且对特征 <strong>Heart Rate Measurement（心率测量）</strong> （0x2A37）订阅了定期获取通知，所以如果它们发送值或者定期更新，我将分别获得这两个二进制值。  </p><p><strong>Step 13 ：</strong> 将 BLE <strong>Heart Rate Measurement（心率测量）</strong> 的数据解译成人们可读的格式。前往 GATT 规范的 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.heart_rate_measurement.xml" target="_blank" rel="noopener"><strong>页面</strong></a> 找到这个特征。第一个字节是关于其余数据的元数据 (<strong>标记</strong>)。规范告诉我看第一个字节的最低有效位，<strong>Heart Rate Value Format bit（心率值的标识位）</strong>。如果是 0（zero），每分钟的心跳数将以 <code>UINT8</code> 格式在第二字节。我从来没有遇到过一个 HRM 使用第二个字节以外的任何字节，我在这里演示的三个 HRM 也不例外。这就是为什么我忽略了 <strong>Heart Rate Value Format bit（心率值的标识位）</strong> 值为 1（one）的用例。我看过所有被提到的实现，但从来没有能够测试这些实现。对于我无法重现的情况，我不会发表任何看法。  </p><p><strong>Step 14 ：</strong> 将 BLE <strong>Body Sensor Location（传感器所在身体部位）</strong> 的数据解译成人们可读的格式。前往 GATT 规范的 <a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.body_sensor_location.xml" target="_blank" rel="noopener"><strong>页面</strong></a> 找到这个特征。这个特征非常简单。将值 1、2、3、4、5、6 或 7 存储在 8 位中。形成的文本字符串与这些值以解译为目的的展示是一样的。  </p><p><strong>Step 15 ：</strong> 当一个外围设备从控制中心断开时，采取适当的行动。我更新我的 UI 以及……  </p><p><strong>Step 16 ：</strong> 开始扫描，为了发现一个正在广播 <strong>Heart Rate（心率）</strong> 服务（0x180D）的外围设备。  </p><h2 id="我的源代码"><a href="#我的源代码" class="headerlink" title="我的源代码"></a>我的源代码</h2><p>这里是对于我们刚刚所讨论的实现，完整的源代码：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">// STEP 0.00: 必须导入 CoreBluetooth framework</span></span><br><span class="line"><span class="keyword">import</span> CoreBluetooth</span><br><span class="line"></span><br><span class="line"><span class="comment">// STEP 0.0: 指定 GATT 中的 "Assigned Numbers" 为常量，这样它们会拥有更好的可读性和可维护性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - Core Bluetooth 服务 ID</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">BLE_Heart_Rate_Service_CBUUID</span> = <span class="type">CBUUID</span>(string: <span class="string">"0x180D"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - Core Bluetooth 特征 ID</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">BLE_Heart_Rate_Measurement_Characteristic_CBUUID</span> = <span class="type">CBUUID</span>(string: <span class="string">"0x2A37"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">BLE_Body_Sensor_Location_Characteristic_CBUUID</span> = <span class="type">CBUUID</span>(string: <span class="string">"0x2A38"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// STEP 0.1: 这个类同时采用了控制中心和外围设备的委托协议，所以必须遵守这些协议的要求</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeartRateMonitorViewController</span>: <span class="title">UIViewController</span>, <span class="title">CBCentralManagerDelegate</span>, <span class="title">CBPeripheralDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: - Core Bluetooth 类的成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// STEP 0.2: 分别创建 CBCentralManager 和 CBPeripheral 的实例变量</span></span><br><span class="line">    <span class="comment">// 所以它们在应用程序的生命周期里持续存在</span></span><br><span class="line">    <span class="keyword">var</span> centralManager: <span class="type">CBCentralManager?</span></span><br><span class="line">    <span class="keyword">var</span> peripheralHeartRateMonitor: <span class="type">CBPeripheral?</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: - UI outlets / 成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> connectingActivityIndicator: <span class="type">UIActivityIndicatorView!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> connectionStatusView: <span class="type">UIView!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> brandNameTextField: <span class="type">UITextField!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> sensorLocationTextField: <span class="type">UITextField!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> beatsPerMinuteLabel: <span class="type">UILabel!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> bluetoothOffLabel: <span class="type">UILabel!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 HealthKit </span></span><br><span class="line">    <span class="keyword">let</span> healthKitInterface = <span class="type">HealthKitInterface</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: - UIViewController delegate</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// 在视图加载完成以后，通常是通过一个 nib，做所有附加的设置。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最初，我们在进行扫描并且没有产生连接</span></span><br><span class="line">        connectingActivityIndicator.backgroundColor = <span class="type">UIColor</span>.white</span><br><span class="line">        connectingActivityIndicator.startAnimating()</span><br><span class="line">        connectionStatusView.backgroundColor = <span class="type">UIColor</span>.red</span><br><span class="line">        brandNameTextField.text = <span class="string">"----"</span></span><br><span class="line">        sensorLocationTextField.text = <span class="string">"----"</span></span><br><span class="line">        beatsPerMinuteLabel.text = <span class="string">"---"</span></span><br><span class="line">        <span class="comment">// 以防 Bluetooth 被关闭</span></span><br><span class="line">        bluetoothOffLabel.alpha = <span class="number">0.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// STEP 1: 为控制中心在后台创建一个并发队列</span></span><br><span class="line">        <span class="keyword">let</span> centralQueue: <span class="type">DispatchQueue</span> = <span class="type">DispatchQueue</span>(label: <span class="string">"com.iosbrain.centralQueueName"</span>, attributes: .concurrent)</span><br><span class="line">        <span class="comment">// STEP 2: 创建用于扫描、连接、管理和从外围设备收集数据的控制中心。</span></span><br><span class="line">        centralManager = <span class="type">CBCentralManager</span>(delegate: <span class="keyword">self</span>, queue: centralQueue)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从 HKHealthStore 读取心率数据</span></span><br><span class="line">        <span class="comment">// healthKitInterface.readHeartRateData()</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从 HKHealthStore 读取性别类型</span></span><br><span class="line">        <span class="comment">// healthKitInterface.readGenderType()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// 处理任何可以重新创建的资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: - CBCentralManagerDelegate methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// STEP 3.1: 这个方法的调用基于设备的蓝牙状态； </span></span><br><span class="line">    <span class="comment">// 仅在 Bluetooth 为 .poweredOn 时才可以扫描外围设备</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">centralManagerDidUpdateState</span><span class="params">(<span class="number">_</span> central: CBCentralManager)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> central.state &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> .unknown:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Bluetooth status is UNKNOWN"</span>)</span><br><span class="line">            bluetoothOffLabel.alpha = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">case</span> .resetting:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Bluetooth status is RESETTING"</span>)</span><br><span class="line">            bluetoothOffLabel.alpha = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">case</span> .unsupported:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Bluetooth status is UNSUPPORTED"</span>)</span><br><span class="line">            bluetoothOffLabel.alpha = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">case</span> .unauthorized:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Bluetooth status is UNAUTHORIZED"</span>)</span><br><span class="line">            bluetoothOffLabel.alpha = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">case</span> .poweredOff:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Bluetooth status is POWERED OFF"</span>)</span><br><span class="line">            bluetoothOffLabel.alpha = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">case</span> .poweredOn:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Bluetooth status is POWERED ON"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.bluetoothOffLabel.alpha = <span class="number">0.0</span></span><br><span class="line">                <span class="keyword">self</span>.connectingActivityIndicator.startAnimating()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// STEP 3.2: 扫描我们感兴趣的外围设备</span></span><br><span class="line">            centralManager?.scanForPeripherals(withServices: [<span class="type">BLE_Heart_Rate_Service_CBUUID</span>])</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="comment">// END switch</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// END func centralManagerDidUpdateState</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// STEP 4.1: 找到这个应用程序可以连接哪些感兴趣的外围设备</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">centralManager</span><span class="params">(<span class="number">_</span> central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : <span class="keyword">Any</span>], rssi RSSI: NSNumber)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(peripheral.name!)</span><br><span class="line">        decodePeripheralState(peripheralState: peripheral.state)</span><br><span class="line">        <span class="comment">// STEP 4.2: 必须储存一个外围设备的引用到类的实例变量中</span></span><br><span class="line">        peripheralHeartRateMonitor = peripheral</span><br><span class="line">        <span class="comment">// STEP 4.3: 因为 HeartRateMonitorViewController 采用了 CBPeripheralDelegate 协议，</span></span><br><span class="line">        <span class="comment">// 所以 peripheralHeartRateMonitor 必须设置他的 </span></span><br><span class="line">        <span class="comment">// delegate 属性为 HeartRateMonitorViewController (self)</span></span><br><span class="line">        peripheralHeartRateMonitor?.delegate = <span class="keyword">self</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// STEP 5: 停止扫描以保护电池的寿命；当断开链接的时候再次扫描。</span></span><br><span class="line">        centralManager?.stopScan()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// STEP 6: 与已经发现的，感兴趣的外围设备建立连接</span></span><br><span class="line">        centralManager?.connect(peripheralHeartRateMonitor!)</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// END func centralManager(... didDiscover peripheral</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// STEP 7: “当一个与外围设备的连接被成功创建时调用。”</span></span><br><span class="line">    <span class="comment">// 只有当我们知道与外围设备的连接建立成功之后才能前往下一步</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">centralManager</span><span class="params">(<span class="number">_</span> central: CBCentralManager, didConnect peripheral: CBPeripheral)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.brandNameTextField.text = peripheral.name!</span><br><span class="line">            <span class="keyword">self</span>.connectionStatusView.backgroundColor = <span class="type">UIColor</span>.green</span><br><span class="line">            <span class="keyword">self</span>.beatsPerMinuteLabel.text = <span class="string">"---"</span></span><br><span class="line">            <span class="keyword">self</span>.sensorLocationTextField.text = <span class="string">"----"</span></span><br><span class="line">            <span class="keyword">self</span>.connectingActivityIndicator.stopAnimating()</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// STEP 8: 在外围设备上寻找感兴趣的服务</span></span><br><span class="line">        peripheralHeartRateMonitor?.discoverServices([<span class="type">BLE_Heart_Rate_Service_CBUUID</span>])</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">// END func centralManager(... didConnect peripheral</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// STEP 15: 当一个外围设备断开连接，使用适当的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">centralManager</span><span class="params">(<span class="number">_</span> central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// print("Disconnected!")</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.brandNameTextField.text = <span class="string">"----"</span></span><br><span class="line">            <span class="keyword">self</span>.connectionStatusView.backgroundColor = <span class="type">UIColor</span>.red</span><br><span class="line">            <span class="keyword">self</span>.beatsPerMinuteLabel.text = <span class="string">"---"</span></span><br><span class="line">            <span class="keyword">self</span>.sensorLocationTextField.text = <span class="string">"----"</span></span><br><span class="line">            <span class="keyword">self</span>.connectingActivityIndicator.startAnimating()</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// STEP 16: 在这个用例中，开始扫描相同或其他的外设，只要它们是 HRM，就可以重新联机</span></span><br><span class="line">        centralManager?.scanForPeripherals(withServices: [<span class="type">BLE_Heart_Rate_Service_CBUUID</span>])</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// END func centralManager(... didDisconnectPeripheral peripheral</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - CBPeripheralDelegate methods</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">peripheral</span><span class="params">(<span class="number">_</span> peripheral: CBPeripheral, didDiscoverServices error: Error?)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> service <span class="keyword">in</span> peripheral.services! &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> service.uuid == <span class="type">BLE_Heart_Rate_Service_CBUUID</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Service: \(service)"</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// STEP 9: 在感兴趣的服务中寻找感兴趣的特征</span></span><br><span class="line">                peripheral.discoverCharacteristics(<span class="literal">nil</span>, <span class="keyword">for</span>: service)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// END func peripheral(... didDiscoverServices</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// STEP 10: 从感兴趣的服务中，确认我们所发现感兴趣的特征</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">peripheral</span><span class="params">(<span class="number">_</span> peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> characteristic <span class="keyword">in</span> service.characteristics! &#123;</span><br><span class="line">            <span class="built_in">print</span>(characteristic)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> characteristic.uuid == <span class="type">BLE_Body_Sensor_Location_Characteristic_CBUUID</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// STEP 11: 订阅关于感兴趣特征的单次通知；</span></span><br><span class="line">                <span class="comment">// “当你使用这个方法去读取特征的值时，外围设备将会调用…… </span></span><br><span class="line">                <span class="comment">// peripheral:didUpdateValueForCharacteristic:error:”</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// Read    Mandatory</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                peripheral.readValue(<span class="keyword">for</span>: characteristic)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> characteristic.uuid == <span class="type">BLE_Heart_Rate_Measurement_Characteristic_CBUUID</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// STEP 11: 订阅关于感兴趣特征的持续通知；</span></span><br><span class="line">                <span class="comment">// “当你启用特征值的通知时，外围设备调用……</span></span><br><span class="line">                <span class="comment">// peripheral(_:didUpdateValueFor:error:)” </span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// Notify    Mandatory</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                peripheral.setNotifyValue(<span class="literal">true</span>, <span class="keyword">for</span>: characteristic)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="comment">// END for</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// END func peripheral(... didDiscoverCharacteristicsFor service</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// STEP 12: 每当一个特征值定期更新或者发布一次时，我们都会收到通知；</span></span><br><span class="line">    <span class="comment">// 阅读并解译我们订阅的特征值</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">peripheral</span><span class="params">(<span class="number">_</span> peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> characteristic.uuid == <span class="type">BLE_Heart_Rate_Measurement_Characteristic_CBUUID</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// STEP 13: 通常我们需要将 BLE 的数据解析成人类可读的格式</span></span><br><span class="line">            <span class="keyword">let</span> heartRate = deriveBeatsPerMinute(using: characteristic)</span><br><span class="line">            </span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                </span><br><span class="line">                <span class="type">UIView</span>.animate(withDuration: <span class="number">1.0</span>, animations: &#123;</span><br><span class="line">                    <span class="keyword">self</span>.beatsPerMinuteLabel.alpha = <span class="number">1.0</span></span><br><span class="line">                    <span class="keyword">self</span>.beatsPerMinuteLabel.text = <span class="type">String</span>(heartRate)</span><br><span class="line">                &#125;, completion: &#123; (<span class="literal">true</span>) <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">self</span>.beatsPerMinuteLabel.alpha = <span class="number">0.0</span></span><br><span class="line">                &#125;)</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="comment">// END DispatchQueue.main.async...</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="comment">// END if characteristic.uuid ==...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> characteristic.uuid == <span class="type">BLE_Body_Sensor_Location_Characteristic_CBUUID</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// STEP 14: 通常我们需要将 BLE 的数据解析成人类可读的格式</span></span><br><span class="line">            <span class="keyword">let</span> sensorLocation = readSensorLocation(using: characteristic)</span><br><span class="line"></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.sensorLocationTextField.text = sensorLocation</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// END if characteristic.uuid ==...</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// END func peripheral(... didUpdateValueFor characteristic</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: - Utilities</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deriveBeatsPerMinute</span><span class="params">(using heartRateMeasurementCharacteristic: CBCharacteristic)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> heartRateValue = heartRateMeasurementCharacteristic.value!</span><br><span class="line">        <span class="comment">// 转换为无符号 8 位整数数组</span></span><br><span class="line">        <span class="keyword">let</span> buffer = [<span class="type">UInt8</span>](heartRateValue)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// UInt8: “一个 8 位无符号整数类型。”</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在缓冲区的第一个字节（8 位）是标记（元数据，用于管理包中其余部分）；</span></span><br><span class="line">        <span class="comment">// 如果最低有效位（LSB）是 0，心率（bpm）则是 UInt8 格式，</span></span><br><span class="line">        <span class="comment">// 如果 LSB 是 1，BPM 则是 UInt16</span></span><br><span class="line">        <span class="keyword">if</span> ((buffer[<span class="number">0</span>] &amp;amp; <span class="number">0x01</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 第二个字节：“心率的格式被设置为 UINT8”</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"BPM is UInt8"</span>)</span><br><span class="line">            <span class="comment">// 将心率写入 HKHealthStore</span></span><br><span class="line">            <span class="comment">// healthKitInterface.writeHeartRateData(heartRate: Int(buffer[1]))</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Int</span>(buffer[<span class="number">1</span>])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 我从来没有看到过这个用例，所以我把它留给理论学家去争论</span></span><br><span class="line">            <span class="comment">// 第二个和第三个字节：“心率的格式被设置为 UINT16”</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"BPM is UInt16"</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// END func deriveBeatsPerMinute</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">readSensorLocation</span><span class="params">(using sensorLocationCharacteristic: CBCharacteristic)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> sensorLocationValue = sensorLocationCharacteristic.value!</span><br><span class="line">        <span class="comment">//  转换为无符号 8 位整数数组</span></span><br><span class="line">        <span class="keyword">let</span> buffer = [<span class="type">UInt8</span>](sensorLocationValue)</span><br><span class="line">        <span class="keyword">var</span> sensorLocation = <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只看 8 位</span></span><br><span class="line">        <span class="keyword">if</span> buffer[<span class="number">0</span>] == <span class="number">1</span></span><br><span class="line">        &#123;</span><br><span class="line">            sensorLocation = <span class="string">"Chest"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> buffer[<span class="number">0</span>] == <span class="number">2</span></span><br><span class="line">        &#123;</span><br><span class="line">            sensorLocation = <span class="string">"Wrist"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sensorLocation = <span class="string">"N/A"</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sensorLocation</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// END func readSensorLocation</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">decodePeripheralState</span><span class="params">(peripheralState: CBPeripheralState)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> peripheralState &#123;</span><br><span class="line">            <span class="keyword">case</span> .disconnected:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Peripheral state: disconnected"</span>)</span><br><span class="line">            <span class="keyword">case</span> .connected:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Peripheral state: connected"</span>)</span><br><span class="line">            <span class="keyword">case</span> .connecting:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Peripheral state: connecting"</span>)</span><br><span class="line">            <span class="keyword">case</span> .disconnecting:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Peripheral state: disconnecting"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// END func decodePeripheralState(peripheralState</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// END class HeartRateMonitorViewController</span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我希望你喜欢这篇教程。买或者借一个 BLE 设备，然后使用我的代码或自己编写代码来连接它。遵循教程中所有我提供的超链接并且阅读它们。查阅 Bluetooth SIG 的 <a href="https://www.bluetooth.com/" target="_blank" rel="noopener"><strong>网页</strong></a> 以及苹果的 <a href="https://developer.apple.com/documentation/corebluetooth" target="_blank" rel="noopener"><strong><em>Core Bluetooth</em></strong></a>（<a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html#//apple_ref/doc/uid/TP40013257-CH1-SW1" target="_blank" rel="noopener"><strong>这里</strong></a> 也可以看到）框架文档，你一定可以对蓝牙技术有一个概览。  </p><p>感谢阅读。记得享受你的工作。不要忘记，当你的简历上面有蓝牙的经验将是你的职业生涯的一大亮点。  </p><p>作为参考，你可以 <a href="https://github.com/appcoda/HealthKit-and-Bluetooth-HRM" target="_blank" rel="noopener"><strong>在 GitHub 上面查看完整的源代码</strong></a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      详细描述了使用 Core Bluetooth 的全流程。包括注册成为 Bluetooth SIG 的会员，以及 GATT 规范的查阅。
    
    </summary>
    
      <category term="appcoda" scheme="https://swift.gg/categories/appcoda/"/>
    
    
      <category term="教程" scheme="https://swift.gg/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Void</title>
    <link href="https://swift.gg/2019/02/25/void/"/>
    <id>https://swift.gg/2019/02/25/void/</id>
    <published>2019-02-25T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/void/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-10-31<br>译者：<a href="https://github.com/zhongWJ" target="_blank" rel="noopener">zhongWJ</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>从 <a href="https://nshipster.com/nil/" target="_blank" rel="noopener">我们第一篇关于 Objective-C 中的 <code>nil</code> 的文章</a> 到 <a href="https://nshipster.com/never/" target="_blank" rel="noopener">最近对 Swift 中 <code>Never</code> 类型的一瞥</a>，“不存在”一直是 NSHipster 讨论的话题。但今天的文章可能是它们当中充斥着最多如 <a href="https://en.wikipedia.org/wiki/Horror_vacui" target="_blank" rel="noopener">恐怖留白</a> 般细节的 —— 因为我们将目光聚焦在了 Swift 中的 <code>Void</code> 上。</p><a id="more"></a><p><code>Void</code> 是什么？在 Swift 中，它只不过是一个空元组。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Void</span> = ()</span><br></pre></td></tr></table></figure><p>我们使用 <code>Void</code> 时才会开始关注它。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> void: <span class="type">Void</span> = ()</span><br><span class="line">void. <span class="comment">// 没有代码补全提示</span></span><br></pre></td></tr></table></figure><p><code>Void</code> 类型的值没有成员：既没有成员方法，也没有成员变量，甚至连名字都没有。它并不比 <code>nil</code> 多些什么。对于一个空容器，Xcode 不会给我们任何代码补全提示。</p><h2 id="为“不存在”而生之物"><a href="#为“不存在”而生之物" class="headerlink" title="为“不存在”而生之物"></a>为“不存在”而生之物</h2><p>在标准库中，<code>Void</code> 类型最显著和奇特的用法是在 <code>ExpressibleByNilLiteral</code> 协议中。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ExpressibleByNilLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(nilLiteral: ())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵从 <code>ExpressibleByNilLiteral</code> 协议的类型可以用 <code>nil</code> 字面量来初始化。大多数类型并不遵从这个协议，因为用 <code>Optional</code> 来表示值可能不存在会更容易理解。但偶尔你也会碰到 <code>ExpressibleByNilLiteral</code>。</p><p><code>ExpressibleByNilLiteral</code> 的指定构造方法不接收任何实际参数。（假设接收了，那结果会怎么样？）然而，该协议的指定构造方法不能仅仅只是一个空构造方法 <code>init()</code>，因为很多类型用它作为默认构造方法。</p><p>你可以将指定构造方法改为一个返回 <code>nil</code> 的类型方法（Type Method）来尝试解决这个问题，但一些强制内部可见的状态在构造方法外就不能使用了。在这里我们使用一种更好的解决方案，给构造方法增加一个带 <code>Void</code> 参数的 <code>nilLiteral</code> 标签。这巧妙的利用已有的功能来实现非常规的结果。</p><h2 id="如何比较“不存在”之物"><a href="#如何比较“不存在”之物" class="headerlink" title="如何比较“不存在”之物"></a>如何比较“不存在”之物</h2><p>元组以及元类型（例如 <code>Int.Type</code>，<code>Int.self</code> 返回结果），函数类型（例如 <code>(String) -&gt; Bool</code>），existential 类型（例如 <code>Encodable &amp; Decodable</code>）组成了非正式类型。与包含 swift 大部分的正式类型或命名类型不同，非正式类型是相对其他类型来定义的。</p><p>非正式类型不能被扩展。<code>Void</code> 是一个空元组，而由于元组是非正式类型，所以你不能给 <code>Void</code> 添加方法、属性或者遵从协议。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Void</span> </span>&#123;&#125; <span class="comment">// 非正式类型 `Void` 不能被扩展</span></span><br></pre></td></tr></table></figure><p><code>Void</code> 不遵从 <code>Equatable</code>协议，因为它不能这么做。然而当我们调用等于操作符（<code>==</code>）时，它如我们期望的一样运行正确。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">void == void <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>下面这个全局函数定义在所有正式协议之外，它实现了这个看似矛盾的行为。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> == <span class="params">(lhs: <span class="params">()</span></span></span>, rhs: ()) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小于操作符（<code>&lt;</code>）也被同样处理，用这种方式来替代 <code>Comparable</code> 协议及其衍生出的其他比较操作符。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> &lt; (lhs: (), rhs: ()) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Swift 标准库为大小最多为 6 的元组提供了比较函数的实现。然而这是一种 hack 方式。Swift 核心团队在许多时候都显露过想要给元组增加对 <code>Equatable</code> 协议的支持的兴趣，但在实现的时候，并没有讨论过正式的提议。</p></blockquote><h2 id="壳中之鬼"><a href="#壳中之鬼" class="headerlink" title="壳中之鬼"></a>壳中之鬼</h2><p>作为非正式类型，<code>Void</code> 不能被扩展。但 <code>Void</code> 毕竟是一个类型，所以能被当作泛型约束来使用。</p><p>例如，考虑以下单个值的泛型容器：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value: <span class="type">Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当泛型容器所包装的值的类型本身遵循 <code>Equatable</code> 协议时，利用 Swift 4.1 的杀手锏特性 <a href="https://swift.org/blog/conditional-conformance/" target="_blank" rel="noopener">条件遵循</a>，我们首先可以扩展 <code>Wrapper</code> 让其支持 <code>Equatable</code> 协议。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Wrapper</span>: <span class="title">Equatable</span> <span class="title">where</span> <span class="title">Value</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Wrapper&lt;Value&gt;, rhs: Wrapper&lt;Value&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.value == rhs.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用同之前一样的技巧，我们可以实现一个接受 <code>Wrapper&lt;Void&gt;</code> 参数的 <code>==</code> 全局函数，来达到和 <code>Equatable</code> 协议几乎一样的效果。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Wrapper&lt;Void&gt;, rhs: Wrapper&lt;Void&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，我们就可以比较两个包装了 <code>Void</code> 值的 <code>Wrapper</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Wrapper</span>(value: void) == <span class="type">Wrapper</span>(value: void) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>然而，当我们尝试将这样一个包装值赋值给一个变量时，编译器会生成诡异的错误。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapperOfVoid = <span class="type">Wrapper</span>&lt;<span class="type">Void</span>&gt;(value: void)</span><br><span class="line"><span class="comment">// 👻 错误: 不能赋值:</span></span><br><span class="line"><span class="comment">// 由于找不到对应符号，无法销毁 wrapperOfVoid</span></span><br></pre></td></tr></table></figure><p><code>Void</code> 的可怕之处反过来再次自我否定。</p><h2 id="幽灵类型"><a href="#幽灵类型" class="headerlink" title="幽灵类型"></a>幽灵类型</h2><p>即使你不敢提及它的非正式名字，你依然逃不过 <code>Void</code> 的掌心。</p><p>任何没有显式声明返回值的函数会隐式的返回一个 <code>Void</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>这个行为很奇怪，但不是特别有用。并且当你将一个返回 <code>Void</code> 类型的函数的返回值赋值给一个变量时，编译器会生成一个警告。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">doSomething() <span class="comment">// 没有警告</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = doSomething()</span><br><span class="line"><span class="comment">// ⚠️ 常量 `result` 指向的是一个 `Void` 类型的值，这种行为的结果不可预测</span></span><br></pre></td></tr></table></figure><p>你可以显式指定变量类型为 <code>Void</code> 来消除警告。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result: <span class="type">Void</span> = doSomething() <span class="comment">// ()</span></span><br></pre></td></tr></table></figure><blockquote><p>相反的，当函数的返回值类型为非 <code>Void</code> 时，你如果不将返回值赋值给其他变量，编译器也会产生警告。更多详情可以参考 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0047-nonvoid-warn.md" target="_blank" rel="noopener">SE-0047 “默认当非 <code>Void</code> 函数返回结果未使用时告警”</a>。</p></blockquote><h2 id="试着从-Void-恢复过来"><a href="#试着从-Void-恢复过来" class="headerlink" title="试着从 Void 恢复过来"></a>试着从 Void 恢复过来</h2><p>如果你斜视 <code>Void?</code>，时间足够长，你可能会将它和 <code>Bool</code> 弄混。这两种类型类似，都仅有两种状态：<code>true</code> / <code>.some(())</code> 以及 <code>false</code> / <code>.none</code>。</p><p>但类似并不意味着一样。它们两最明显的不同是，<code>Bool</code> 遵循 <code>ExpressibleByBooleanLiteral</code> 协议，而 <code>Void</code> 不是也不能遵循 <code>ExpressibleByBooleanLiteral</code> 协议，和它不能遵循 <code>Equatable</code> 协议的原因一样。所以你不能这样做：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(<span class="literal">true</span> <span class="keyword">as</span> <span class="type">Void?</span>) <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Void</code> 可能是 Swift 中最令人毛骨悚的类型了。但是当给 <code>Bool</code> 起一个 <code>Booooooool</code> 别名时， 就和 <code>Void</code> 不相上下了。</p></blockquote><p>但 <code>Void?</code> 硬坳的话是能够表现的像 <code>Bool</code> 一样。比如下面这个随机抛出错误的函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Failure</span>: <span class="title">Error</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failsRandomly</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">Bool</span>.random() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">Failure</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确方式是，在一个 <code>do / catch</code> 代码块中用 <code>try</code> 表达式来调用这个函数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> failsRandomly()</span><br><span class="line">    <span class="comment">// 成功执行</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// 失败执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>failsRandomly()</code> 隐式返回 <code>Void</code>，利用这一事实可以达到同样效果，虽然不正确但表面上可行。<code>try?</code> 表达式会处理可能抛出异常的语句，将结果包装为一个可选类型值。对于 <code>failsRandomly()</code> 这种情况而言，结果是 <code>Void?</code>。假如 <code>Void?</code> 有 <code>.some</code> 值（即，<code>!= nil</code>），这意味着函数没有出错直接返回。如果 <code>success</code> 是 <code>nil</code>，那我们就知道函数生成了一个错误。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> success: <span class="type">Void?</span> = <span class="keyword">try</span>? failsRandomly()</span><br><span class="line"><span class="keyword">if</span> success != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 成功执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 失败执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多人可能不喜欢 <code>do / catch</code> 代码块，但你不得不承认，相比这里的代码，<code>do / catch</code> 代码块更加优雅。</p><p>在某些特殊场景下，这种变通方式可能会很有用。例如为了保存每一次自评估闭包执行的副作用，你可以在类上使用静态属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> oneTimeSideEffect: <span class="type">Void?</span> = &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">try</span>? data.write(to: fileURL)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>虽然这样可行，但更好的办法是使用 <code>Error</code> 和 <code>Bool</code> 类型。</p><h2 id="夜晚才会响（”Clang”）的东西"><a href="#夜晚才会响（”Clang”）的东西" class="headerlink" title="夜晚才会响（”Clang”）的东西"></a>夜晚才会响（”Clang”）的东西</h2><p>当读到这么令人发寒的描述时，如果你开始打寒颤了，你可以引导 <code>Void</code> 类型的坏死能量来召唤巨大的热量给自己的精神加热：</p><p>也就是说，通过以下代码让 <code>lldb-rpc-server</code> 全力开启 CPU（译者注：编译器会卡死）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span>: <span class="title">ExpressibleByBooleanLiteral</span> <span class="title">where</span> <span class="title">Wrapped</span> == <span class="title">Void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">BooleanLiteralType</span> = <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(booleanLiteral value: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> value &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(())!</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(nilLiteral: ())!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pseudoBool: <span class="type">Void?</span> = <span class="literal">true</span> <span class="comment">// 我们永远都不会发现是这里导致的</span></span><br></pre></td></tr></table></figure><p>按照洛夫克拉夫特式恐怖小说的传统，<code>Void</code> 有一个计算机无法处理的物理结构；我们简单地见证了它如何使一个进程无可救药的疯狂。</p><h2 id="徒有其表的胜利"><a href="#徒有其表的胜利" class="headerlink" title="徒有其表的胜利"></a>徒有其表的胜利</h2><p>我们用一段熟悉的代码来结束这段神奇的学习之旅：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">Value</span>, <span class="title">Error</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">Value</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你还记得之前 <a href="https://nshipster.com/never" target="_blank" rel="noopener">我们关于 <code>Never</code> 类型的文章</a>，你应该知道，将 <code>Result</code> 的 <code>Error</code> 类型设为 <code>Never</code> 可以让它表示某些总会成功的操作。</p><p>类似的，操作成功但不会生成有意义的结果，用 <code>Void</code> 作为 <code>Value</code> 类型可以表示。</p><p>例如，应用可能会通过简单的网络请求定时“ping”服务器来实现一个 <a href="https://en.wikipedia.org/wiki/The_Tell-Tale_Heart" target="_blank" rel="noopener">心跳</a>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(<span class="number">_</span> url: URL, completion: <span class="params">(Result&lt;Void, Error&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>根据 HTTP 语义，一个虚拟 <code>/ping</code> 终端正确的状态码应该是 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/204" target="_blank" rel="noopener">204 No Content</a>。</p></blockquote><p>在请求的回调中，通过下面的调用来表示成功：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">completion(.success(()))</span><br></pre></td></tr></table></figure><p>假如你觉得括号太多了（其实又有什么问题呢？），给 <code>Result</code> 加一个关键的扩展可以让事情更简单点：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Result</span> <span class="title">where</span> <span class="title">Value</span> == <span class="title">Void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> success: <span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .success(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有付出就有收获。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">completion(.success)</span><br></pre></td></tr></table></figure><p><br></p><p>虽然这看起来像一次纯理论甚至抽象的练习，但对 <code>Void</code> 的探究能让我们对 Swift 这门编程语言的基础有一个更深刻的认知。</p><p>在 Swift 还没有面世很久之前，元组在编程语言中扮演着重要角色。它们可以表示参数列表和枚举关联值，依场景不同而扮演不同角色。但在某些情况下，这个模型崩溃了。编程语言依然没有调和好这些不同结构之间的差异。</p><p>依据 Swift 神话，<code>Void</code> 将会是那些老神（译者注：旧的编程语言）的典范：它是一个真正的单例，你压根一丁点儿都不会注意到它的作用和影响；编译器也会忽略它。</p><p>可能这一切都只是我们理解力的边缘发明，是我们对这门语言前景担忧的一种表现。总之，当你凝视 <code>Void</code> 时，<code>Void</code> 也在凝视着你。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了 Swift 中 Void 的
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5 字符串插值之美</title>
    <link href="https://swift.gg/2019/02/21/the-beauty-of-swift-5-string-interpolation/"/>
    <id>https://swift.gg/2019/02/21/the-beauty-of-swift-5-string-interpolation/</id>
    <published>2019-02-21T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Erica Sadun，<a href="https://ericasadun.com/2018/12/12/the-beauty-of-swift-5-string-interpolation/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-12-12<br>译者：<a href="https://www.roczhang.com/" target="_blank" rel="noopener">RocZhang</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>感谢提案 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0228-fix-expressiblebystringinterpolation.md" target="_blank" rel="noopener">SE-0228</a>，让我们能够精确控制字符串插值的打印方式。感谢 Brent 带给我们这个非常棒的功能。让我来分享一些例子。</p><a id="more"></a><p>回想一下在我们要打印可选值的时候，会这样写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="string">"There's \(value1) and \(value2)"</span></span><br></pre></td></tr></table></figure><p>但这样写会立即得到一个警告：</p><p><img src="https://swift.gg/img/articles/the-beauty-of-swift-5-string-interpolation/Screen-Shot-2018-12-12-at-2.38.51-PM.pngw=1065&amp;ssl=11550726099.018731" alt></p><p>我们可以点击修复按钮来消除这些警告，得到如下的代码。但我们仍然会看到一个类似于这样的输出：“There’s Optional(23) and nil”。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="string">"There's \(String(describing: value1)) and \(String(describing: value2))"</span></span><br></pre></td></tr></table></figure><p>现在我们可以通过下面这种方式去掉输出中的“Optional”，直接打印出“There’s 23 and nil”：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>.<span class="title">StringInterpolation</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 提供 `Optional` 字符串插值</span></span><br><span class="line">  <span class="comment">/// 而不必强制使用 `String(describing:)`</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(<span class="number">_</span> value: T?, <span class="keyword">default</span> defaultValue: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> value = value &#123;</span><br><span class="line">      appendInterpolation(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      appendLiteral(defaultValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// There's 23 and nil</span></span><br><span class="line"><span class="string">"There's \(value1, default: "</span><span class="literal">nil</span><span class="string">") and \(value2, default: "</span><span class="literal">nil</span><span class="string">")"</span></span><br></pre></td></tr></table></figure><p>我们也可以创建一组样式，从而使可选值能够保持一致的输出展示方式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>.<span class="title">StringInterpolation</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 可选值插值样式</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">OptionalStyle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 有值和没有值两种情况下都包含单词 `Optional`</span></span><br><span class="line">    <span class="keyword">case</span> descriptive</span><br><span class="line">    <span class="comment">/// 有值和没有值两种情况下都去除单词 `Optional`</span></span><br><span class="line">    <span class="keyword">case</span> stripped</span><br><span class="line">    <span class="comment">/// 使用系统的插值方式，在有值时包含单词 `Optional`，没有值时则不包含</span></span><br><span class="line">    <span class="keyword">case</span> `<span class="keyword">default</span>`</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 使用提供的 `optStyle` 样式来插入可选值</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(<span class="number">_</span> value: T?, optStyle style: String.StringInterpolation.OptionalStyle)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> style &#123;</span><br><span class="line">    <span class="comment">// 有值和没有值两种情况下都包含单词 `Optional`</span></span><br><span class="line">    <span class="keyword">case</span> .descriptive:</span><br><span class="line">      <span class="keyword">if</span> value == <span class="literal">nil</span> &#123;</span><br><span class="line">        appendLiteral(<span class="string">"Optional(nil)"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        appendLiteral(<span class="type">String</span>(describing: value))</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 有值和没有值两种情况下都去除单词 `Optional`</span></span><br><span class="line">    <span class="keyword">case</span> .stripped:</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> value = value &#123;</span><br><span class="line">        appendInterpolation(value)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        appendLiteral(<span class="string">"nil"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 使用系统的插值方式，在有值时包含单词 `Optional`，没有值时则不包含</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      appendLiteral(<span class="type">String</span>(describing: value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 使用 `stripped` 样式来对可选值进行插值</span></span><br><span class="line">  <span class="comment">/// 有值和没有值两种情况下都省略单词 `Optional`</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(describing value: T?)</span></span> &#123;</span><br><span class="line">    appendInterpolation(value, optStyle: .stripped)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "There's Optional(23) and nil"</span></span><br><span class="line"><span class="string">"There's \(value1, optStyle: .default) and \(value2, optStyle: .default)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "There's Optional(23) and Optional(nil)"</span></span><br><span class="line"><span class="string">"There's \(value1, optStyle: .descriptive) and \(value2, optStyle: .descriptive)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "There's 23 and nil"</span></span><br><span class="line"><span class="string">"There's \(describing: value1) and \(describing: value2)"</span></span><br></pre></td></tr></table></figure><p>插值不仅仅用于调整可选值的输出方式，在其他方面也很有用。比如你想控制输出是否带有特定的字符，就不需要写一个带有空字符串的三元表达式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功时包含（感谢 Nate Cook）</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>.<span class="title">StringInterpolation</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 只有 `condition` 的返回值为 `true` 才进行插值</span></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span><span class="params">(<span class="keyword">if</span> condition: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>, <span class="number">_</span> literal: <span class="type">StringLiteralType</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> condition() <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    appendLiteral(literal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="string">"Cheese Sandwich \(isStarred ? "</span>(*)<span class="string">" : "</span><span class="string">")"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="string">"Cheese Sandwich \(if: isStarred, "</span>(*)<span class="string">")"</span></span><br></pre></td></tr></table></figure><p>我们还可以用字符串插值来做更多有趣的事情。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文对 Swift 5 中 SE-0228 对 String Interpolation 相关功能的改进进行了举例说明，展示了一些控制字符串插值的方式。
    
    </summary>
    
      <category term="Erica Sadun" scheme="https://swift.gg/categories/Erica-Sadun/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>协议中的私有属性</title>
    <link href="https://swift.gg/2019/02/18/protocols-private-properties/"/>
    <id>https://swift.gg/2019/02/18/protocols-private-properties/</id>
    <published>2019-02-18T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/protocols/2018/09/02/protocols-private-properties/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-09-02<br>译者：<a href="https://github.com/dzyding" target="_blank" rel="noopener">灰s</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://linusling.com" target="_blank" rel="noopener">小铁匠Linus</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>在 Swift 中，协议中声明的属性没有访问控制的能力。如果协议中列出了某个属性，则必须使遵守协议的类型显式声明这些属性。  </p><p>不过有些时候，尽管你会在协议中声明一些属性，但你是要利用这些属性来提供你的实现，并不希望这些属性在类型的外部被使用。让我们看看如何解决这个问题。 </p><a id="more"></a><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>假设你需要创建一个专门的对象来管理你的视图控制器（ViewControllers）导航，比如一个协调器（Coordinator）。  </p><p>每个协调器都有一个根控制器 <code>UINavigationController</code>，并共享一些通用的功能，比如在它上面推进（push）和弹出（pop）其他 ViewController。所以最初它看起来可能是这样 <a href="#foot1" id="1"><sup>[1]</sup></a>：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Coordinator.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Coordinator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> navigationController: <span class="type">UINavigationController</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> childCoordinator: <span class="type">Coordinator?</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(viewController: UIViewController, animated: Bool)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(childViewController: UIViewController, animated: Bool)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">(animated: Bool)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Coordinator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(viewController: UIViewController, animated: Bool = <span class="literal">true</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.navigationController.pushViewController(viewController, animated: animated)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(childCoordinator: Coordinator, animated: Bool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.navigationController.present(childCoordinator.navigationController, animated: animated) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>?.childCoordinator = childCoordinator</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">(animated: Bool = <span class="literal">true</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> childCoordinator = <span class="keyword">self</span>.childCoordinator &#123;</span><br><span class="line">      <span class="keyword">self</span>.dismissViewController(animated: animated) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.childCoordinator = <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">self</span>.navigationController.popViewController(animated: animated)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们想要声明一个新的 <code>Coordinator</code> 对象时，会像这样做：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MainCoordinator.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainCoordinator</span>: <span class="title">Coordinator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> navigationController: <span class="type">UINavigationController</span> = <span class="type">UINavigationController</span>()</span><br><span class="line">  <span class="keyword">var</span> childCoordinator: <span class="type">Coordinator?</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">showTutorialPage1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> vc = makeTutorialPage(<span class="number">1</span>, coordinator: <span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.push(viewController: vc)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">showTutorialPage2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> vc = makeTutorialPage(<span class="number">2</span>, coordinator: <span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.push(viewController: vc)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">makeTutorialPage</span><span class="params">(<span class="number">_</span> num: Int, coordinator: Coordinator)</span></span> -&gt; <span class="type">UIViewController</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：泄漏实现细节"><a href="#问题：泄漏实现细节" class="headerlink" title="问题：泄漏实现细节"></a>问题：泄漏实现细节</h2><p>这个解决方案在 <code>protocol</code> 的可见性上有两个问题：  </p><ul><li>每当我们想要声明一个新的 <code>Coordinator</code> 对象，都必须显式的声明一个 <code>let navigationController: UINavigationController</code> 属性和一个 <code>var childCoordinator: Coordinator?</code> 属性。<strong>虽然，在遵守协议的类型现实中，我们并没有显式的使用他们</strong> - 但它们就在那里，因为我们需要它们作为默认的实现来供 <code>protocol Coordinator</code> 正常工作。  </li><li>我们必须声明的这两个属性具有与 <code>MainCoordinator</code> 相同的可见性（在本例中为隐式 <code>internal（内部）</code> 访问控制级别），因为这是 <code>protocol Coordinator</code> 的必备条件。这使得它们对外部可见，就像在编码时可以使用 <code>MainCoordinator</code>。  </li></ul><p>所以问题是我们每次都要声明一些属性——即使它只是一些实现细节，而且这些实现细节会通过外部接口被泄漏，从而允许类的访问者做一些本不应该被允许的事，例如：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mainCoord = <span class="type">MainCoordinator</span>()</span><br><span class="line"><span class="comment">// 访问者不应该被允许直接访问 navigationController ，但是他们可以</span></span><br><span class="line">mainCoord.navigationController.dismissViewController(animated: <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 他们也不应该被允许做这样的事情</span></span><br><span class="line">mainCoord.childCoordinator = mainCoord</span><br></pre></td></tr></table></figure><p>也许你会认为，既然我们不希望它们是可见的，那么可以直接在第一段代码的 <code>protocol</code> 中不声明这两个属性。但是如果我们这样做，将无法通过 <code>extension Coordinator</code> 来提供默认的实现，因为默认的实现需要这两个属性存在以便它们的代码被编译。  </p><p>你可能希望 Swift 允许在协议中申明这些属性为 <code>fileprivate</code>，但是在 Swift 4 中，你不能在 <code>protocols</code> 中使用任何访问控制的关键字。  </p><p>所以我们如何才能解决这个“既要提供用到这个属性的默认实现，有不让这些属性对外暴露”的问题呢？</p><h2 id="一个解决方案"><a href="#一个解决方案" class="headerlink" title="一个解决方案"></a>一个解决方案</h2><p>实现这一点的一个技巧是将这些属性隐藏在中间对象中，并在该对象中将对应的属性声明为 <code>fileprivate</code>。  </p><p>通过这种方式，尽管我们依旧在对应类型的公共接口中声明了属性，但是接口的访问者却不能访问该对象的内部属性。而我们对于协议的默认实现却能够访问它们 —— 只要它们在同一个文件中被声明就行了（因为它们是 <code>fileprivate</code> ）。  </p><p>看起来就像这样：  </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Coordinator.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoordinatorComponents</span> </span>&#123;</span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">let</span> navigationController: <span class="type">UINavigationController</span> = <span class="type">UINavigationController</span>()</span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">var</span> childCoordinator: <span class="type">Coordinator?</span> = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Coordinator</span>: <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> coordinatorComponents: <span class="type">CoordinatorComponents</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(viewController: UIViewController, animated: Bool)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(childCoordinator: Coordinator, animated: Bool)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">(animated: Bool)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Coordinator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(viewController: UIViewController, animated: Bool = <span class="literal">true</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.coordinatorComponents.navigationController.pushViewController(viewController, animated: animated)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(childCoordinator: Coordinator, animated: Bool = <span class="literal">true</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> childVC = childCoordinator.coordinatorComponents.navigationController</span><br><span class="line">    <span class="keyword">self</span>.coordinatorComponents.navigationController.present(childVC, animated: animated) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>?.coordinatorComponents.childCoordinator = childCoordinator <span class="comment">// retain the child strongly</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">(animated: Bool = <span class="literal">true</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> privateAPI = <span class="keyword">self</span>.coordinatorComponents</span><br><span class="line">    <span class="keyword">if</span> privateAPI.childCoordinator != <span class="literal">nil</span> &#123;</span><br><span class="line">      privateAPI.navigationController.dismiss(animated: animated) &#123; [<span class="keyword">weak</span> privateAPI] <span class="keyword">in</span></span><br><span class="line">        privateAPI?.childCoordinator = <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      privateAPI.navigationController.popViewController(animated: animated)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，遵守协议的 <code>MainCoordinator</code> 类型：  </p><ul><li>仅需要声明一个 <code>let coordinatorComponents = CoordinatorComponents()</code> 属性，并不用知道 <code>CoordinatorComponents</code> 类型的内部有些什么（隐藏了实现细节）。  </li><li>在 <code>MainCoordinator.swift</code> 文件中，不能访问 <code>coordinatorComponents</code> 的任何属性，因为它们被声明为 <code>fileprivate</code>。  </li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainCoordinator</span>: <span class="title">Coordinator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> coordinatorComponents = <span class="type">CoordinatorComponents</span>()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">showTutorialPage1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> vc = makeTutorialPage(<span class="number">1</span>, coordinator: <span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.push(viewController: vc)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">showTutorialPage2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> vc = makeTutorialPage(<span class="number">2</span>, coordinator: <span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.push(viewController: vc)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">makeTutorialPage</span><span class="params">(<span class="number">_</span> num: Int, coordinator: Coordinator)</span></span> -&gt; <span class="type">UIViewController</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你仍然需要在遵守协议的类型中声明 <code>let coordinatorComponents</code> 来提供存储，这个声明必须是可见的（不能是 <code>private</code>），因为这是遵守 <code>protocol Coordinator</code> 所要求的一部分。但是：  </p><ul><li>只需要声明 1 个属性，取代之前的 2 个（在更复杂的情况下会有更多）。  </li><li>更重要的是，即使它可以从遵守协议的类型的实现中访问，也可以从外部接口访问，你却不能对它做任何事情。  </li></ul><p>当然，你仍然可以访问 <code>myMainCoordinator.coordinatorComponents</code>，但是不能使用它做任何事情，因为它所有的属性都是 <code>fileprivate</code> ！  </p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Swift 可能无法提供你想要的所有功能。你可能希望有朝一日 <code>protocols</code> 允许对它声明需要的属性和方法使用访问控制关键字，或者通过某种方式将它们在公共 API 中隐藏。  </p><p>但与此同时，掌握这些技巧和变通方法可以使你的公共 API 更好、更安全，避免泄露实现细节或者访问在实现之外不应该被修改的属性，同时仍然使用 <a href="http://alisoftware.github.io/swift/protocol/2015/11/08/mixins-over-inheritance/" target="_blank" rel="noopener">Mixin pattern</a> 并提供默认实现。  </p><hr><p><a id="foot1" href="#1"><sup>[1]</sup></a>.这是一个简化的例子；不要将注意力集中在 Coordinator 的实现 - 它不是这个例子的重点，更应该关注的是需要在协议中声明公开可访问的属性。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      通过另一种方式来控制协议中属性和方法的访问权限
    
    </summary>
    
      <category term="Olivier Halligon" scheme="https://swift.gg/categories/Olivier-Halligon/"/>
    
      <category term="Swift" scheme="https://swift.gg/categories/Olivier-Halligon/Swift/"/>
    
    
      <category term="协议" scheme="https://swift.gg/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>SwiftSyntax</title>
    <link href="https://swift.gg/2019/01/25/nshipster-swiftsyntax/"/>
    <id>https://swift.gg/2019/01/25/nshipster-swiftsyntax/</id>
    <published>2019-01-25T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/swiftsyntax/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-10-22<br>译者：<a href="https://dingtz.com/" target="_blank" rel="noopener">jojotov</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p><a href="https://github.com/apple/swift-syntax" target="_blank" rel="noopener">SwiftSyntax</a> 是一个可以分析、生成以及转换 Swift 源代码的 Swift 库。它是基于 <a href="https://github.com/apple/swift/tree/master/lib/Syntax" target="_blank" rel="noopener">libSyntax</a> 库开发的，并于 <a href="https://github.com/apple/swift-syntax/commit/909d336aefacdcbdd45ec6130471644c1ae929f5" target="_blank" rel="noopener">2017 年 8 月</a> 从 Swift 语言的主仓库中分离出来，单独建立了一个仓库。</p><a id="more"></a><p>总的来说，这些库都是为了给结构化编辑（structured editing）提供安全、正确且直观的工具。关于结构化编辑，在 <a href="https://github.com/apple/swift/blob/master/lib/Syntax/README.md#swift-syntax-and-structured-editing-library" target="_blank" rel="noopener">thusly</a> 中有具体的描述:</p><blockquote><p>什么是结构化编辑？结构化编辑是一种编辑的策略，它对源代码的<em>结构</em>更加敏感，而源代码的表示（例如字符或者字节）则没那么重要。这可以细化为以下几个部分：替换标识符，将对全局方法的调用转为对方法的调用，或者根据已定的规则识别并格式化整个源文件。</p></blockquote><p>在写这篇文章时，SwiftSyntax 仍处于在开发中并进行 API 调整的阶段。不过目前你已经可以使用它对 Swift 代码进行一些编程工作。</p><p>目前，<a href="https://github.com/apple/swift/tree/master/lib/Migrator" target="_blank" rel="noopener">Swift Migrator</a> 已经在使用 SwiftSyntax 了，并且在对内和对外层面上，对 SwiftSyntax 的接入也在不断地努力着。</p><h2 id="SwiftSyntax-如何工作？"><a href="#SwiftSyntax-如何工作？" class="headerlink" title="SwiftSyntax 如何工作？"></a>SwiftSyntax 如何工作？</h2><p>为了明白 SwiftSyntax 如何工作，我们首先要回头看看 Swift 编译器的架构：</p><p><img src="https://swift.gg/img/articles/nshipster-swiftsyntax/swift-compilation-diagram-8af7d0078f72cdaa8f50430e608f15a9d4214f5772439d2fd6904bb5a8a53c60.png1548390462.3512783" alt></p><p>Swift 编译器的主要职责是把 Swift 代码转换为可执行的机器代码。整个过程可以划分为几个离散的步骤，一开始，<a href="https://github.com/apple/swift/tree/master/lib/Parse" target="_blank" rel="noopener">语法分析器</a> 会生成一个抽象语法树（AST）。之后，语义分析器会进行工作并生成一个通过类型检查的 AST。至此步骤，代码会降级到 <a href="https://github.com/apple/swift/blob/master/docs/SIL.rst" target="_blank" rel="noopener">Swift 中间层语言</a>；随后 SIL 会继续转换并优化自身，降级为 <a href="http://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">LLVM IR</a>，并最终编译为机器代码。</p><p>对于我们的讨论来说，最重要的关键点是 SwiftSyntax 的操作目标是编译过程第一步所生成的 AST。但也由于这样，SwiftSyntax 无法告知你任何关于代码的语义或类型信息。</p><p>与 SwiftSyntax 相反，一些如 <a href="https://github.com/apple/swift/tree/master/tools/SourceKit" target="_blank" rel="noopener">SourceKit</a> 之类的工具，操作的目标为更容易理解的 Swift 代码。这可以帮助此类工具实现一些编辑器相关的特性，例如代码补全或者文件之间的跳转。虽然 SwiftSyntax 不能像 SourceKit 一样实现跳转或者补全的功能，但在语法层面上也有很多应用场景，例如代码格式化和语法高亮。</p><h3 id="揭秘-AST"><a href="#揭秘-AST" class="headerlink" title="揭秘 AST"></a>揭秘 AST</h3><p>抽象语法树在抽象层面上比较难以理解。因此我们先生成一个示例来一睹其貌。</p><p>留意一下如下的一行 Swift 代码，它声明了一个名为 <code>one()</code> 的函数，函数返回值为 <code>1</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">one</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>在命令行中对此文件运行 <code>swiftc</code> 命令并传入 <code>-frontend -emit-syntax</code> 参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcrun swiftc -frontend -emit-syntax ./One.swift</span></span><br></pre></td></tr></table></figure><p>运行的结果为一串 JSON 格式的 AST。当你用 JSON 格式来展示时，AST 的结构会表现的更加清晰：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"kind"</span>: <span class="string">"SourceFile"</span>,</span><br><span class="line">    <span class="attr">"layout"</span>: [&#123;</span><br><span class="line">        <span class="attr">"kind"</span>: <span class="string">"CodeBlockItemList"</span>,</span><br><span class="line">        <span class="attr">"layout"</span>: [&#123;</span><br><span class="line">            <span class="attr">"kind"</span>: <span class="string">"CodeBlockItem"</span>,</span><br><span class="line">            <span class="attr">"layout"</span>: [&#123;</span><br><span class="line">                <span class="attr">"kind"</span>: <span class="string">"FunctionDecl"</span>,</span><br><span class="line">                <span class="attr">"layout"</span>: [<span class="literal">null</span>, <span class="literal">null</span>, &#123;</span><br><span class="line">                    <span class="attr">"tokenKind"</span>: &#123;</span><br><span class="line">                        <span class="attr">"kind"</span>: <span class="string">"kw_func"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"leadingTrivia"</span>: [],</span><br><span class="line">                    <span class="attr">"trailingTrivia"</span>: [&#123;</span><br><span class="line">                        <span class="attr">"kind"</span>: <span class="string">"Space"</span>,</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">1</span></span><br><span class="line">                    &#125;],</span><br><span class="line">                    <span class="attr">"presence"</span>: <span class="string">"Present"</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    <span class="attr">"tokenKind"</span>: &#123;</span><br><span class="line">                        <span class="attr">"kind"</span>: <span class="string">"identifier"</span>,</span><br><span class="line">                        <span class="attr">"text"</span>: <span class="string">"one"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"leadingTrivia"</span>: [],</span><br><span class="line">                    <span class="attr">"trailingTrivia"</span>: [],</span><br><span class="line">                    <span class="attr">"presence"</span>: <span class="string">"Present"</span></span><br><span class="line">                &#125;, ...</span><br></pre></td></tr></table></figure><p>Python 中的 <code>json.tool</code> 模块提供了便捷地格式化 JSON 的能力。且几乎所有的 macOS 系统都已经集成了此模块，因此每个人都可以使用它。举个例子，你可以使用如下的命令对编译的输出结果使用 <code>json.tool</code> 格式化：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcrun swiftc -frontend -emit-syntax ./One.swift | python -m json.tool</span></span><br></pre></td></tr></table></figure><p>在最外层，可以看到 <code>SourceFile</code>，它由 <code>CodeBlockItemList</code> 以及 <code>CodeBlockItemList</code> 内部的 <code>CodeBlockItem</code> 这几个部分组成。对于这个示例来说，仅有一个 <code>CodeBlockItem</code> 对应函数的定义（<code>FunctionDecl</code>），其自身包含了几个子组件如函数签名、参数闭包和返回闭包。</p><p>术语 trivia 用于描述任何没有实际语法意义的东西，例如空格。每个标记符（Token）可以有一个或多个行前和行尾的 trivia。例如，在返回的闭包（<code>-&gt; Int</code>）中的 <code>Int</code> 后的空格可以用如下的行尾 trivia 表示：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"kind"</span>: <span class="string">"Space"</span>,</span><br><span class="line">  <span class="attr">"value"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理文件系统限制"><a href="#处理文件系统限制" class="headerlink" title="处理文件系统限制"></a>处理文件系统限制</h3><p>SwiftSyntax 通过代理系统的 <code>swiftc</code> 调用来生成抽象语法树。但是，这也限制了代码必须放在某个文件才能进行处理，而我们却经常需要对以字符串表示的代码进行处理。</p><p>为了解决这个限制，其中一种办法是把代码写入一个临时文件并传入到编译器中。</p><p><a href="https://nshipster.com/nstemporarydirectory/" target="_blank" rel="noopener">我们曾经尝试过写入临时文件</a>，但目前，有更好的 API 可以帮助我们完成这项工作，它由  <a href="https://github.com/apple/swift-package-manager" target="_blank" rel="noopener">Swift Package Manager</a> 本身提供。在你的 <code>Package.swift</code> 文件中，添加如下的包依赖关系，并把 <code>Utility</code> 依赖添加到正确的 target 中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.package(url: <span class="string">"https://github.com/apple/swift-package-manager.git"</span>, from: <span class="string">"0.3.0"</span>),</span><br></pre></td></tr></table></figure><p>现在，你可以像下面这样引入 <code>Basic</code> 模块并使用 <code>TemporaryFile</code> API：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Basic</span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> code: <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tempfile = <span class="keyword">try</span> <span class="type">TemporaryFile</span>(deleteOnClose: <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">defer</span> &#123; tempfile.fileHandle.closeFile() &#125;</span><br><span class="line">tempfile.fileHandle.write(code.data(using: .utf8)!)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(fileURLWithPath: tempfile.path.asString)</span><br><span class="line"><span class="keyword">let</span> sourceFile = <span class="keyword">try</span> <span class="type">SyntaxTreeParser</span>.parse(url)</span><br></pre></td></tr></table></figure><h2 id="我们可以用-SwiftSyntax-做什么"><a href="#我们可以用-SwiftSyntax-做什么" class="headerlink" title="我们可以用 SwiftSyntax 做什么"></a>我们可以用 SwiftSyntax 做什么</h2><p>现在我们对 SwiftSyntax 如何工作已经有了足够的理解，是时候讨论一下几个使用它的方式了！</p><h3 id="编写-Swift-代码：地狱模式"><a href="#编写-Swift-代码：地狱模式" class="headerlink" title="编写 Swift 代码：地狱模式"></a>编写 Swift 代码：地狱模式</h3><p>我们第一个想到，但却是最没有实际意义的 SwiftSyntax 用例就是让编写 Swift 代码的难度提升几个数量级。</p><p>利用 SwiftSyntax 中的 <code>SyntaxFactory</code> APIs，我们可以生成完整的 Swift 代码。不幸的是，编写这样的代码并不像闲庭散步般轻松。</p><p>留意一下如下的示例代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftSyntax</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> structKeyword = <span class="type">SyntaxFactory</span>.makeStructKeyword(trailingTrivia: .spaces(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> identifier = <span class="type">SyntaxFactory</span>.makeIdentifier(<span class="string">"Example"</span>, trailingTrivia: .spaces(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> leftBrace = <span class="type">SyntaxFactory</span>.makeLeftBraceToken()</span><br><span class="line"><span class="keyword">let</span> rightBrace = <span class="type">SyntaxFactory</span>.makeRightBraceToken(leadingTrivia: .newlines(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">let</span> members = <span class="type">MemberDeclBlockSyntax</span> &#123; builder <span class="keyword">in</span></span><br><span class="line">    builder.useLeftBrace(leftBrace)</span><br><span class="line">    builder.useRightBrace(rightBrace)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> structureDeclaration = <span class="type">StructDeclSyntax</span> &#123; builder <span class="keyword">in</span></span><br><span class="line">    builder.useStructKeyword(structKeyword)</span><br><span class="line">    builder.useIdentifier(identifier)</span><br><span class="line">    builder.useMembers(members)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(structureDeclaration)</span><br></pre></td></tr></table></figure><p><em>唷。</em>那最后这段代码让我们得到了什么呢？</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>令人窒息的操作。</em></p><p>这绝不是为了取代 <a href="https://nshipster.com/swift-gyb/" target="_blank" rel="noopener">GYB</a> 来用于每天的代码生成。（事实上，<a href="https://github.com/apple/swift/blob/master/lib/Syntax/SyntaxKind.cpp.gyb" target="_blank" rel="noopener">libSyntax</a> 和 <a href="https://github.com/apple/swift-syntax/blob/master/Sources/SwiftSyntax/SyntaxKind.swift.gyb" target="_blank" rel="noopener">SwiftSyntax</a> 都使用了 <code>gyb</code> 来生成接口。</p><p>但这个接口在某些特殊的问题上却格外有用。例如，你或许会使用 SwiftSyntax 来实现一个 Swift 编译器的 <a href="https://en.wikipedia.org/wiki/Fuzzing" target="_blank" rel="noopener">模糊测试</a>，使用它可以随机生成一个表面有效却实际上非常复杂的程序，以此来进行压力测试。</p><h2 id="重写-Swift-代码"><a href="#重写-Swift-代码" class="headerlink" title="重写 Swift 代码"></a>重写 Swift 代码</h2><p><a href="https://github.com/apple/swift-syntax#example" target="_blank" rel="noopener">在 SwiftSyntax 的 README 中有一个示例</a> 展示了如何编写一个程序来遍历源文件中的整型并把他们的值加 1。</p><p>通过这个，你应该已经推断得出如何使用它来创建一个典型的 <code>swift-format</code> 工具。</p><p>但现在，我们先考虑一个相当<em>没有</em>效率——并且可能在万圣节（🎃）这种需要捣蛋的场景才合适的用例，源代码重写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftSyntax</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZalgoRewriter</span>: <span class="title">SyntaxRewriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(<span class="number">_</span> token: TokenSyntax)</span></span> -&gt; <span class="type">Syntax</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> .stringLiteral(text) = token.tokenKind <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> token</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> token.withKind(.stringLiteral(zalgo(text)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/mattt/b46ab5027f1ee6ab1a45583a41240033" target="_blank" rel="noopener"><code>zalgo</code></a> 函数是用来做什么的？可能不知道会更好……</p><p>不管怎样，在你的源代码中运行这个重写器，可以把所有的文本字符串转换为像下面一样的效果：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Before 👋😄</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, world!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// After 🦑😵</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"H͞͏̟̂ͩel̵ͬ͆͜ĺ͎̪̣͠ơ̡̼͓̋͝, w͎̽̇ͪ͢ǒ̩͔̲̕͝r̷̡̠͓̉͂l̘̳̆ͯ̊d!"</span>)</span><br></pre></td></tr></table></figure><p><em>鬼魅一般，对吧？</em></p><h2 id="高亮-Swift-代码"><a href="#高亮-Swift-代码" class="headerlink" title="高亮 Swift 代码"></a>高亮 Swift 代码</h2><p>让我们用一个真正实用的东西来总结我们对 SwiftSyntax 的探究：一个 Swift 语法高亮工具。</p><p>从语法高亮工具的意义上来说，它可以把源代码按某种方式格式化为显示更为友好的 HTML。</p><p><a href="https://github.com/NSHipster/nshipster.com" target="_blank" rel="noopener">NSHipster 通过 Jekyll 搭建</a>，并使用了 Ruby 的库 <a href="https://github.com/jneen/rouge" target="_blank" rel="noopener">Rouge</a> 来渲染你在每篇文章中看到的示例代码。尽管如此，由于 Swift 的复杂语法和过快迭代，渲染出来的 HTML 并不是 100% 正确。</p><p>不同于 <a href="https://github.com/jneen/rouge/blob/master/lib/rouge/lexers/swift.rb" target="_blank" rel="noopener">处理一堆麻烦的正则表达式</a>，我们可以构造一个 <a href="https://github.com/NSHipster/SwiftSyntaxHighlighter" target="_blank" rel="noopener">语法高亮器</a> 来放大 SwiftSyntax 对语言的理解的优势。</p><p>根据这个核心目的，实现的方法可以很直接：实现一个 <code>SyntaxRewriter</code> 的子类并重写 <code>visit(_:)</code> 方法，这个方法会在遍历源文件的每个标识符时被调用。通过判断每种不同的标识符类型，你可以把相应的可高亮标识符映射为 HTML 标记。</p><p>例如，数字文本可以用类名是 <code>m</code> 开头的 <code>&lt;span&gt;</code> 元素来表示（<code>mf</code> 表示浮点型，<code>mi</code> 表示整型）。如下是对应的在 <code>SyntaxRewriter</code> 子类中的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftSyntax</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwiftSyntaxHighlighter</span>: <span class="title">SyntaxRewriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> html: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(<span class="number">_</span> token: TokenSyntax)</span></span> -&gt; <span class="type">Syntax</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> token.tokenKind &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> .floatingLiteral(<span class="keyword">let</span> string):</span><br><span class="line">            html += <span class="string">"&lt;span class=\"mf\"&gt;\(string)&lt;/span&gt;"</span></span><br><span class="line">        <span class="keyword">case</span> .integerLiteral(<span class="keyword">let</span> string):</span><br><span class="line">            <span class="keyword">if</span> string.hasPrefix(<span class="string">"0b"</span>) &#123;</span><br><span class="line">                html += <span class="string">"&lt;span class=\"mb\"&gt;\(string)&lt;/span&gt;"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> string.hasPrefix(<span class="string">"0o"</span>) &#123;</span><br><span class="line">                html += <span class="string">"&lt;span class=\"mo\"&gt;\(string)&lt;/span&gt;"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> string.hasPrefix(<span class="string">"0x"</span>) &#123;</span><br><span class="line">                html += <span class="string">"&lt;span class=\"mh\"&gt;\(string)&lt;/span&gt;"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                html += <span class="string">"&lt;span class=\"mi\"&gt;\(string)&lt;/span&gt;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管 <code>SyntaxRewritere</code> 针对每一种不同类型的语法元素，都已经实现了 <code>visit(:)</code> 方法，但我发现使用一个 <code>switch</code> 语句可以更简单地处理所有工作。（在 <code>default</code> 分支中打印出无法处理的标记符，可以更好地帮助我们找到那些没有处理的情况）。这不是最优雅的实现，但鉴于我对 SwiftSyntax 不足的理解，这是个较好的开端。</p><p>不管怎样，在几个小时的开发工作后，我已经可以在 Swift 大量的语法特性中，生成出比较理想的渲染过的输出。</p><p><img src="https://swift.gg/img/articles/nshipster-swiftsyntax/swiftsyntaxhightlighter-example-output-829aa64ab4bdf73a2e3070aab017e21e3db37ca0ee35079f0e89e22594806df0.png1548390462.5352607" alt></p><p>这个项目需要一个库和命令行工具的支持。快去 <a href="https://github.com/NSHipster/SwiftSyntaxHighlighter" target="_blank" rel="noopener">尝试一下 </a>然后让我知道你的想法吧！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mattt，&lt;a href=&quot;https://nshipster.com/swiftsyntax/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-10-22&lt;br&gt;译者：&lt;a href=&quot;https://dingtz.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jojotov&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/apple/swift-syntax&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SwiftSyntax&lt;/a&gt; 是一个可以分析、生成以及转换 Swift 源代码的 Swift 库。它是基于 &lt;a href=&quot;https://github.com/apple/swift/tree/master/lib/Syntax&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;libSyntax&lt;/a&gt; 库开发的，并于 &lt;a href=&quot;https://github.com/apple/swift-syntax/commit/909d336aefacdcbdd45ec6130471644c1ae929f5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2017 年 8 月&lt;/a&gt; 从 Swift 语言的主仓库中分离出来，单独建立了一个仓库。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>以流的形式执行 Multipart 请求</title>
    <link href="https://swift.gg/2019/01/21/streaming-multipart-requests/"/>
    <id>https://swift.gg/2019/01/21/streaming-multipart-requests/</id>
    <published>2019-01-21T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2018/11/streaming-multipart-requests/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-11-14<br>译者：<a href="https://www.jianshu.com/u/076cc5e18bb8" target="_blank" rel="noopener">郑一一</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>Foundation 框架中的 URL 类提供了非常全面的功能，此后还在 iOS 7 中新增了 URLSession 类。尽管如此，基础库中仍然缺少 multipart 文件上传的功能。</p><a id="more"></a><h2 id="什么是-multipart-请求？"><a href="#什么是-multipart-请求？" class="headerlink" title="什么是 multipart 请求？"></a>什么是 multipart 请求？</h2><p>Multipart 编码实际上就是在网络中上传大型文件的方法。在浏览器中，有时候你会选择一个文件作为表单提交内容的一部分。这个文件便是以 multipart 请求的方式实现上传的。</p><p>乍一看，multipart 请求和一般请求差不多。不同之处是 multipart 请求额外为 <code>HTTP</code> 请求体指定了唯一编码。同 JSON 编码（<code>{&quot;key&quot;: &quot;value&quot;}</code>）或者 URL 字符编码 (<code>key=value</code>) 相比，multipart 编码干的事略微有所不同。因为 multipart 请求体实际上只是一串字节流，接收端实体在解析数据时，需要知道字节流中各个部分之间的界限。所以 multipart 请求需要使用 “boundaries” 来解决这个问题。在请求首部的 <code>Content-Type</code> 中，可以定义 boundary：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept: application/json</span><br><span class="line">Content-Type: multipart/form-data; boundary=khanlou.comNczcJGcxe</span><br></pre></td></tr></table></figure><p>Boundary 的具体内容并不重要，唯一需要注意的是：在请求体中，boundary 是不能重复出现（这样才能体现 boundary 的作用）。你可以使用 UUID 作为 boundary。</p><p>请求的每一部分可以是普通数据（比如图片）或者元数据（一般是文本，对应一个名字，组成一个键值对）。如果数据是图片的话，那它看起来应该是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--&lt;boundary&gt;</span><br><span class="line">Content-Disposition: form-data; name=&lt;name&gt;; filename=&lt;filename.jpg&gt;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">&lt;image data&gt;</span><br></pre></td></tr></table></figure><p>如果是普通文本，则是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--&lt;boundary&gt;</span><br><span class="line">Content-Disposition: form-data; name=&lt;name&gt;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">&lt;some text&gt;</span><br></pre></td></tr></table></figure><p>请求结尾会有一个带着两个连字符的 boundary，<code>--&lt;boundary&gt;--</code>。（此处需要注意，所有新行必须是回车换行。）</p><p>以上就是关于 multipart 请求的所有内容，并不是特别复杂。事实上，当在写第一个有关 multipart 编码的客户端实现时，我有些抵触阅读 multipart/form-data 的 <a href="https://tools.ietf.org/html/rfc7578" target="_blank" rel="noopener">RFC</a>。可是在开始阅读之后，我对这个协议的理解更深了。整个文档可读性很强，很轻易就能直达知识的源头。</p><p>我在开源的 <a href="https://github.com/backchannel/BackchannelSDK-iOS" target="_blank" rel="noopener">Backchannel SDK</a> 实现了上述功能。<a href="https://github.com/backchannel/BackchannelSDK-iOS/blob/master/Source/Image%20Chooser/BAKUploadAttachmentRequest.m" target="_blank" rel="noopener"><code>BAKUploadAttachmentRequest</code></a> 和 <a href="https://github.com/backchannel/BackchannelSDK-iOS/blob/master/Source/Image%20Chooser/BAKMultipartRequestBuilder.m" target="_blank" rel="noopener"><code>BAKMultipartRequestBuilder</code></a> 类包含了处理 mulitipart 的方法。在这个项目中，仅仅包含了处理单个文件的情况，并且没有包括元数据。但是作为范例，依旧很好地展示了 mulitipart 请求是如何构建的。可以通过添加额外的实现代码，来支持元数据和多文件的功能。</p><p>无论是使用一个请求上传多个文件，还是多个请求分别对应上传一个文件，来实现多文件上传功能，都会碰到一个问题。这个问题就是，如果你尝试一次性上传很多文件的话，app 将会闪退。这是因为使用 <a href="https://github.com/backchannel/BackchannelSDK-iOS/blob/master/Source/Image%20Chooser/BAKMultipartRequestBuilder.m#L66-L70" target="_blank" rel="noopener">该版本的代码</a>，加载的数据会直接进入内存，在内存暴涨的情况下，即使使用当下性能最强的旗舰手机也会有闪退发生。</p><h2 id="将硬盘中数据以流的形式读取"><a href="#将硬盘中数据以流的形式读取" class="headerlink" title="将硬盘中数据以流的形式读取"></a>将硬盘中数据以流的形式读取</h2><p>最常见的解决方法是将硬盘中的数据以流的形式读取出来。其核心思想是文件的字节数据会一直保存在硬盘里，直到被读取并发往网络。内存中只保留了很小一部分的镜像数据。</p><p>目前，我想出两种方法可以解决这个问题。第一个方法，把 multipart 请求体中的所有数据写到硬盘的一个新文件中，并使用 URLSession 的 <code>uploadTask(with request: URLRequest, fromFile fileURL: URL)</code> 方法将文件转化为流。这个方法可以奏效，但我并不想为每一个请求新建一个新文件保存到硬盘中。因为这意味着在请求发出后，还需要删除这个文件。</p><p>第二种方法是将内存和硬盘的数据合并在一起，并通过统一的接口向网络输出数据。</p><p>如果你觉得第二种方法听起来像是 <a href="http://khanlou.com/2015/10/clustering/" target="_blank" rel="noopener">类簇</a>，恭喜你，完全正确。很多常用 Cocoa 类都允许创建子类，并实现一些父类方法，使其和父类表现一致。回想一下 <code>NSArray</code> 的 <code>-count</code> 属性和 <code>-objectAtIndex:</code> 方法。因为 <code>NSArray</code> 的所有其它方法都是基于 <code>-count</code> 属性和 <code>-objectAtIndex:</code> 方法实现的，你可以非常轻易地创建优化版本的 <code>NSArray</code> 子类。</p><p>你可以创建一个 <code>NSData</code> 子类，它无需真正从硬盘读取数据，而只是创建一个指针直接指向硬盘中的数据。这样做的好处是是不需要把数据载入内存中进行读取。这种方法称为内存映射，基于 Unix 方法 <code>mmap</code>。你可以通过 <code>.mappedIfSafe</code> 或者 <code>alwaysMapped</code> 选项，来使用 <code>NSData</code> 的这项特性。因为 <code>NSData</code> 是一个类簇，我们将创建一个 <code>ConcatenatedData</code> 子类（就像 <code>FlattenCollection</code> 在 Swift 中的工作方式），该子类会将多个 <code>NSData</code> 对象视作一个连续的 <code>NSData</code>。完成创建以后，我们就做好所有准备来解决这个问题啦。</p><p>通过查看 <code>NSData</code> 所有原生方法，可以发现，需要实现的是 <code>-count</code> 和 <code>-bytes</code>。实现 <code>-count</code> 并不难，我们可以把所有 <code>NSData</code> 对象的大小相加得到；但在实现 <code>-bytes</code> 时则会有个问题。 <code>-bytes</code> 需要返回一个指向一段连续缓冲区的指针，而目前我们并没有这个指针。</p><p>在基础库中，提供了 <code>NSInputStream</code> 类用于处理不连续的数据。非常幸运，<code>NSInputStream</code> 同样是一个类簇。我们可以创建一个子类，将多条流合并。在使用子类时，感觉上就像是一条流。通过使用 <code>+inputStreamWithData:</code> 和 <code>+inputStreamWithURL:</code> 方法，可以轻易地创建一条输入流，用来代表硬盘中的文件和内存中的数据（比如 boundaries）。</p><p>通过阅读最好的第三方网络库源代码，你会发现 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a> 采用了<a href="https://github.com/AFNetworking/AFNetworking/blob/009e3bb6673edc183c4f2baf552ad7cccba94d58/AFNetworking/AFURLRequestSerialization.m#L896-L927" target="_blank" rel="noopener">这种方法</a>。（<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a>，Swift 版本的 AFNetworking，则采用了第一种方法，<a href="https://github.com/Alamofire/Alamofire/blob/ff16ce9e87aeb0ee1f30b28789db1fff01e8fb02/Source/MultipartFormData.swift#L432-L455" target="_blank" rel="noopener">将数据全部加载到内存中</a>，但如果数据量太大，就会写到硬盘的一个文件中。）</p><h2 id="将所有部分拼接起来"><a href="#将所有部分拼接起来" class="headerlink" title="将所有部分拼接起来"></a>将所有部分拼接起来</h2><p>你可以在 <a href="https://gist.github.com/khanlou/8cc2e3cb23ec8d03b1fc187f5922e244" target="_blank" rel="noopener">这里</a> 看看我的串行输入流的实现（是用 Objective-C 实现的，以后我可能还会写一个 Swift 版本的）。</p><p>通过 <code>SKSerialInputStream</code> 类，可以将流组合在一起。下面展示了前缀和后缀属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MultipartComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prefixData: <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> string = <span class="string">"""</span></span><br><span class="line"><span class="string">        \(self.boundary)</span></span><br><span class="line"><span class="string">        Content-Disposition: form-data; name="\(self.name); filename="\(self.filename)"</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> string.data(using: .utf8)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> postfixData: <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\r\n"</span>.data(using: .utf8)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将元数据和文件的 <code>dataStream</code> 组合在一起，得到一条输入流：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MultipartComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inputStream: <span class="type">NSInputStream</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> streams = [</span><br><span class="line">            <span class="type">NSInputStream</span>(data: prefixData),</span><br><span class="line">            <span class="keyword">self</span>.fileDataStream,</span><br><span class="line">            <span class="type">NSInputStream</span>(data: postfixData),</span><br><span class="line">        ]</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="type">SKSerialInputStream</span>(inputStreams: streams)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建好每一部分输入流之后，就可以把所有流组合在一起，得到一条完整输入流。此外，在请求结尾还需要添加一个 boundary：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RequestBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bodyInputStream: <span class="type">NSInputStream</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> stream = parts</span><br><span class="line">            .<span class="built_in">map</span>(&#123; $<span class="number">0</span>.inputStream &#125;)</span><br><span class="line">            + [<span class="type">NSInputStream</span>(data: <span class="string">"--\(self.boundary)--"</span>.data(using: .utf8))]</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="type">SKSerialInputStream</span>(inputStreams: streams)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，将 <code>bodyInputStream</code> 赋值给 URL 请求的 <code>httpBodyStream</code> 属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urlRequest = <span class="type">URLRequest</span>(url: url)</span><br><span class="line"></span><br><span class="line">urlRequest.httpBodyStream = requestBuilder.bodyInputStream;</span><br></pre></td></tr></table></figure><p>注意，<code>httpBodyStream</code> 和 <code>httpBody</code> 两个属性是互斥的——两个属性不会同时生效。设置 <code>httpBodyStream</code> 会使得 <code>Data</code> 版本 <code>httpBody</code> 失效，反之亦然。</p><p>流文件上传的关键是能够将多条输入流合并成一条流。<code>SKSerialInputStream</code> 类完成了整个工作。尽管说子类化 <code>NSInputStream</code> 有一些困难，可一旦解决这个问题，我们就离成功不远啦。</p><h2 id="子类化过程中需要注意的问题"><a href="#子类化过程中需要注意的问题" class="headerlink" title="子类化过程中需要注意的问题"></a>子类化过程中需要注意的问题</h2><p>子类化 <code>NSInputStream</code> 的过程不会太轻松，甚至可以说很困难。你必须实现 9 个方法。其中的 7 个方法，父类只有一些微不足道的默认实现。而在文档中只提到了 9 个方法中的 3 个，所以你还得实现 6 个 <code>NSStream</code> （<code>NSInputStream</code> 的父类）的方法，其中有 2 个是 run loop 方法，并允许空实现。在这之前，你还需要额外 <a href="http://blog.bjhomer.com/2011/04/subclassing-nsinputstream.html" target="_blank" rel="noopener">实现 3 个私有方法</a>，不过现在不必实现了。此外，还需要定义 3 个<code>只读</code>属性：<code>streamStatus</code>，<code>streamError</code>，<code>delegate</code>。</p><p>在处理完上述子类化相关的细节后，接下来的挑战是创建一个 <code>NSInputStream</code> 子类，其行为应该和 API 使用者所期望的保持一致。然而，这个类状态的重度耦合是不容易被人发现的。</p><p>有一些状态需要保证行为一致。举个例子，<code>hasBytesAvailable</code> 是不同于其它状态的，但还是存在细微的联系。在我最近发现的一个 bug 里，<code>hasBytesAvailable</code> 属性会返回 <code>self.currentIndex != self.inputStreams.count</code>，但是这会造成一个 bug，流会一直处于开启的状态，并最终造成请求超时。修复这个 bug 的办法是改为返回 <code>YES</code>，但我一直没有找到这个 bug 的根源所在。</p><p>另外一个状态 <code>streamStatus</code>，存在许多可能的值，其中比较重要的两个值是 <code>NSStreamStatusOpen</code> 和 <code>NSStreamStatusClosed</code>。</p><p>最后一个比较有意思的状态是字节数，从 <code>read</code> 方法中返回值。这个属性除了会返回正整型数之外，还会返回 -1，-1 代表有错误产生，需要进一步检查非空属性 <code>streamError</code> 来获取更多信息。字节数还可以返回 0，根据文档描述，这是标明流结尾的另外一种方式。</p><p>文档并不会告诉你哪些状态的组合是有意义的。比如说流产生一个 <code>streamError</code>，但状态却是 <code>NSStreamStatusClosed</code>，而不是 <code>NSStreamStatusError</code>，在这种情况下是否会有问题？想要管理好所有的状态非常难，不过到最后终究还是能解决的。</p><p>对于 <code>SKSerialStream</code> 类，是否可以在所有情况下都能正常工作，我还不是特别有信心。但看起来，<code>SKSerialStream</code> 通过使用 URLSession 能很好地支持上传 multipart 数据。如果你在使用这份代码的时候发现任何问题，请务必联系我，我们可以一起不断优化这个类。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2018/11/streaming-multipart-requests/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-11-14&lt;br&gt;译者：&lt;a href=&quot;https://www.jianshu.com/u/076cc5e18bb8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;郑一一&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Foundation 框架中的 URL 类提供了非常全面的功能，此后还在 iOS 7 中新增了 URLSession 类。尽管如此，基础库中仍然缺少 multipart 文件上传的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Khanlou" scheme="https://swift.gg/categories/Khanlou/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="Objective-C" scheme="https://swift.gg/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Language Server Protocol</title>
    <link href="https://swift.gg/2019/01/15/nshipster-language-server-protocol/"/>
    <id>https://swift.gg/2019/01/15/nshipster-language-server-protocol/</id>
    <published>2019-01-15T00:00:00.000Z</published>
    <updated>2019-09-27T14:20:11.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/language-server-protocol/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-11-19<br>译者：<a href="https://github.com/mobilefellow" target="_blank" rel="noopener">雨谨</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>上个月，苹果公司 <a href="https://forums.swift.org/t/new-lsp-language-service-supporting-swift-and-c-family-languages-for-any-editor-and-platform/17024" target="_blank" rel="noopener">在 Swift.org 论坛上宣布</a>，正在着手为 Swift 和 C 语言支持 <a href="https://microsoft.github.io/language-server-protocol/" target="_blank" rel="noopener">Language Server Protocol</a>（语言服务器协议，LSP）。</p><blockquote><p>对于苹果公司而言，为所有 Swift 开发者 —— 包括非苹果平台上的 —— 提供高质量的工具支持非常重要。我们希望与开源社区合作，将精力集中在构建 Xcode 和其他编辑器、其他平台可以共享的公共基础设施上。为实现这一目标，[……]，我们决定支持 LSP。</p><p><em>Argyrios Kyrtzidis，2018 年 10 月 15 日</em></p></blockquote><p><strong>这可能是苹果自 2014 年将 Swift 作为开源软件发布以来，为 Swift 做出的最重要的决定。</strong> 这对于 APP 开发者来说是一件大事，对于其他平台上的 Swift 开发者来说更是一件大事。</p><p>为了理解其中的原因，本周的文章将研究 Language Server Protocol 解决了什么问题，它是如何工作的，以及它的长期影响可能是什么。</p><a id="more"></a><blockquote><p><strong>更新</strong>：sourcekit-lsp 项目现在已经可以 <a href="https://github.com/apple/sourcekit-lsp" target="_blank" rel="noopener">在 GitHub 上访问</a> 了。</p></blockquote><hr><p>想象这样一个矩阵，每一行表示不同的编程语言（Swift、JavaScript、Ruby、Python 等），每一列表示不同的代码编辑器（Xcode、Visual Studio、Vim、Atom 等），这样每个单元格表示特定编辑器对一种语言的支持级别。</p><p><img src="https://nshipster.com/assets/lsp-languages-times-editors-b9a398af0dea85f2ad6dcf5412fbcb451a43bc90091d5e3ab3b1140da9926b3e.svg" alt="lsp-languages-times-editors.svg"></p><p>然后，你就发现各种组合形成了一种支离破碎的兼容。有些编辑器和部分语言深度集成，但除此之外几乎什么都干不了；其他编辑器则比较通用，对很多语言都提供了基本的支持。（IDE 这个术语通常用来描述前者。)</p><p>举个奇葩的例子：<em>你不用 Xcode 来开发 APP，却偏用来干其他事情。</em></p><p>为了更好地支持某一特定的语言，编辑器必须编写一些集成代码（integration code）—— 要么直接写在项目里，要么通过插件。由于不同语言和编辑器的实现机制不一样，因此比方说 Vim 改进了对 Ruby 支持，但这并不能让它更好地支持 Python，也不能让 Ruby 在 Atom 上运行地更好。最终的结果是：大量精力浪费在了不同技术的兼容上。</p><p>我们上面描述的情况通常被称为 <em>M × N 问题</em>，即最终的集成方案数量为编译器数量 M 与语言数量 N 的乘积。Language Server Protocol 所做的事情就是将 M × N 问题变成 <em>M + N 问题</em>。</p><p>编辑器不必实现对每种语言的支持，只需支持 LSP 即可。之后，它就能同等程度地支持所有支持 LSP 的语言。</p><p><img src="https://nshipster.com/assets/lsp-languages-plus-editors-904f780fa4a21e89b5b00bfe5fca39795dd54c1c4c67acf3f0fe095aaf09064d.svg" alt="lsp-languages-plus-editors.svg"></p><blockquote><p>Tomohiro Matsuyama 在 2010 年写的 <a href="https://tkf.github.io/2013/06/04/Emacs-is-dead.html" target="_blank" rel="noopener">“Emacs は死んだ” (<em>“Emacs 已死”</em>)</a> 这篇文章就对这种问题做出了一个很好的论述。Matsuyama 描述了 Emacs 脚本语言的局限性（不支持多线程、底层 API 过少、用户基数太小），他认为编写插件的首选方法应该是与外部程序进行交互，而不是原生实现。</p></blockquote><p>Language Server Protocol 为支持的语言提供了一套通用的功能集，包括：</p><ul><li>语法高亮（Syntax Highlighting）</li><li>自动格式化（Automatic Formatting）</li><li>自动补全（Autocomplete）</li><li>语法（Syntax）</li><li>工具提示（Tooltips）</li><li>内联诊断（Inline Diagnostics）</li><li>跳转到定义（Jump to Definition）</li><li>项目内查找引用（Find References in Project）</li><li>高级文本和符号搜索（Advanced Text and Symbol Search）</li></ul><p>各种工具和编辑器可以将精力用于提升可用性和提供更高级的功能，而不是为每种新技术再造个轮子。</p><h2 id="Language-Server-Protocol-的工作原理"><a href="#Language-Server-Protocol-的工作原理" class="headerlink" title="Language Server Protocol 的工作原理"></a>Language Server Protocol 的工作原理</h2><p>如果你是一个 iOS 程序员，那么一定很熟悉 <em>server</em> 和 <em>protocol</em> 这两个术语在 Web 应用程序的 HTTP + JSON 通信场景下的含义。实际上 Language Server Protocol 差不多也是这么工作的。</p><p>对于 LSP，<em>client</em> 是指编辑器 —— 或者更宽泛一点，是指工具，<em>server</em> 是指本地独立进程里运行的一个外部程序。</p><p>至于名字中包含 <em>protocol</em>，是因为 LSP 类似于一个精简版的 HTTP：</p><ul><li>每个消息都由报头部分和内容部分组成。</li><li>报头部分包含一个必填的 <code>Content-Length</code> 字段，用于说明内容部分的大小（以字节为单位），以及一个可选的 <code>Content-Type</code> 字段（默认值为 <code>application/vscode-jsonrpc; charset=utf-8</code>）。</li><li>内容部分使用 <a href="https://www.jsonrpc.org/specification" target="_blank" rel="noopener">JSON-RPC</a> 描述请求、响应和通知的结构。</li></ul><p>每当工具中发生了什么事情，比如用户需要跳转到符号的定义，工具就会向 server 发送一个请求。server 接收到该请求，然后返回适当的响应。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>: <span class="title">Parent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://nshipster.com/assets/lsp-jump-to-definition-f76ae15d897ab30706c101e7300cd299ad97f6b910ed79ce4890351c2805ae56.gif" alt="lsp-jump-to-definition.gif"></p><p>以下是 LSP 如何在幕后实现这种交互：</p><p>首先，当用户打开 Swift 代码时，若 Swift language server 并未运行，编辑器将在一个独立进程中启动它，并执行一些额外的配置。</p><p>当用户执行 “跳转到定义（jump to definition）” 指令时，编辑器向 Swift language server 发送以下请求：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"textDocument/definition"</span>,</span><br><span class="line">  <span class="attr">"params"</span>: &#123;</span><br><span class="line">    <span class="attr">"textDocument"</span>: &#123;</span><br><span class="line">      <span class="attr">"uri"</span>: <span class="string">"file:///Users/NSHipster/Example.swift"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"position"</span>: &#123;</span><br><span class="line">      <span class="attr">"line"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"character"</span>: <span class="number">13</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到这个请求后，Swift language server 使用 <a href="https://github.com/apple/swift/tree/master/tools/SourceKit" target="_blank" rel="noopener">SourceKit</a> 等编译器工具来标识相应的代码实体，并在代码的上一行找到其声明的位置。然后 language server 用以下消息进行响应:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"jsonrpc"</span>: <span class="string">"2.0"</span>,</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"result"</span>: &#123;</span><br><span class="line">    <span class="attr">"uri"</span>: <span class="string">"file:///Users/NSHipster/Example.swift"</span>,</span><br><span class="line">    <span class="attr">"range"</span>: &#123;</span><br><span class="line">      <span class="attr">"start"</span>: &#123;</span><br><span class="line">        <span class="attr">"line"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"character"</span>: <span class="number">6</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"end"</span>: &#123;</span><br><span class="line">        <span class="attr">"line"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"character"</span>: <span class="number">12</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，编辑器导航到文件(在本例中，该文件已经打开)，将光标移动到该范围，并高亮显示出来。</p><p>这种方法的美妙之处在于，编辑器完成所有这些操作时，除了 .swift 文件与 Swift 代码相关以外，对 Swift 编程语言一无所知。编辑器需要做的就是与 language server 对话并更新 UI。而且编辑器知道如何做到这一点后，就可以遵循相同的过程，与任何带有 language server 的语言所编写的代码进行交互。</p><h2 id="Clang-LLVM-里的-Language-Server-Protocol"><a href="#Clang-LLVM-里的-Language-Server-Protocol" class="headerlink" title="Clang / LLVM 里的 Language Server Protocol"></a>Clang / LLVM 里的 Language Server Protocol</h2><p>如果你觉得之前的 <em>M + N</em> 图有点眼熟，那可能是因为 LLVM 也采用了同样的方法。</p><p>LLVM 的核心是中间表示（intermediate representation，IR）。LLVM 所支持的语言使用 <em>编译器前端（compiler frontend）</em> 生成 IR，再使用 <em>编译器后端（compiler backend）</em> 将 IR 生成所支持平台的机器码。</p><p><img src="https://nshipster.com/assets/lsp-llvm-ir-34a10847cbe6519370c1b5e92def8f82b2ebde71aa2440c88880283bd5cbaf0a.svg" alt="lsp-llvm-ir.svg"></p><blockquote><p>如果你想了解 Swift 代码编译的更多细节，请查看 <a href="https://nshipster.com/swiftsyntax/" target="_blank" rel="noopener">我们关于 SwiftSyntax 的文章</a>。</p></blockquote><p><a href="https://clang.llvm.org" target="_blank" rel="noopener">Clang</a> 是 C 语言的 LLVM 编译器前端。Swift 与 Objective-C 的互操作性（inter-operability）就是靠它实现的。在最近的 5.0.0 版本中，Clang 添加了一个名为 <a href="https://clang.llvm.org/extra/clangd.html" target="_blank" rel="noopener">Clangd</a> 的新工具，它是 LLVM 对 Language Server Protocol 的实现。</p><p>2018 年 4 月，<a href="http://lists.llvm.org/pipermail/cfe-dev/2018-April/057668.html" target="_blank" rel="noopener">苹果公司向 LLVM 邮件组宣布</a>，将把开发的重心从 <a href="https://clang.llvm.org/doxygen/group__CINDEX.html" target="_blank" rel="noopener">libclang</a> 转向 Clangd，以其作为创建交互工具的主要方式。</p><p>现在你可能会想，<em>“那又怎样？”</em> 苹果公司是 LLVM 项目最重要的支持者之一，该项目创始人 Chris Lattner 已经在苹果公司工作了十多年。苹果公司决定从不透明的 Clang 工具切换到另一个，似乎是一个实现细节了(可以这么说)。</p><p>这个官宣很有趣的一点是，Clangd 似乎完全是在苹果以外开发的，谷歌和其他公司也做出了重大贡献。这个官宣标志着未来工具开发方向的重大转变 —— 六个月后 Swift.org 论坛将证实这一点。</p><h2 id="苹果支持-Language-Server-Protocol-的潜在影响"><a href="#苹果支持-Language-Server-Protocol-的潜在影响" class="headerlink" title="苹果支持 Language Server Protocol 的潜在影响"></a>苹果支持 Language Server Protocol 的潜在影响</h2><p>根据苹果公司 10 月份发布的 LSP 公告，我们预计在未来几周内（撰写本文时，最早 11 月中旬）将看到该项目的首批代码。</p><p>要感受这些发展的全部影响还需要一些时间，但请相信我：你的耐心是值得的。我相信以下是 LSP 在未来几个月和几年将会发生的一些事情。</p><h3 id="Swift-变成一种更加通用的编程语言"><a href="#Swift-变成一种更加通用的编程语言" class="headerlink" title="Swift 变成一种更加通用的编程语言"></a>Swift 变成一种更加通用的编程语言</h3><p>虽然 Swift 主要用于 APP 开发，但它从一开始就被设计成一种功能强大的通用编程语言。在 <a href="https://www.tensorflow.org/swift/" target="_blank" rel="noopener">Swift for TensorFlow</a>、<br><a href="https://github.com/apple/swift-nio" target="_blank" rel="noopener">SwiftNIO</a> 和其他项目中，我们正开始看到 Swift 承诺的在 App Store 之外的使用。</p><p>到目前为止，阻碍 Swift 被主流采用的最大因素之一是它对 Xcode 的依赖。</p><p>人们会有很多质疑，当有那么多优秀的、门槛低很多的替代方案可选的情况下，为什么还要让 Web 开发者或机器学习工程师仅仅为了尝试 Swift 而去下载 Xcode？支持 Language Server Protocol 可以让苹果生态圈以外的人更容易地使用他们熟悉工具去感受 Swift。</p><h3 id="Xcode-变得更好"><a href="#Xcode-变得更好" class="headerlink" title="Xcode 变得更好"></a>Xcode 变得更好</h3><p>支持 LSP 不仅仅是让 Swift 在其他编辑器中运行地更好，Xcode 也将受益匪浅。</p><p>看看苹果 Swift 项目负责人 Ted Kremenek 的 <a href="https://forums.swift.org/t/new-lsp-language-service-supporting-swift-and-c-family-languages-for-any-editor-and-platform/17024/29" target="_blank" rel="noopener">这篇论坛帖子</a>:</p><blockquote><p>@akyrtzi 所描述的 LSP 服务将比今天的 SourceKit 更强大。</p></blockquote><p>LSP 对 Xcode 团队来说是一个机遇，让他们使用一种新的方法实现 Swift 集成，并可以将其应用在语言和工具自 1.0 版本发布以来四年中的所有改进上。</p><h3 id="Xcode（最终）变得更强大"><a href="#Xcode（最终）变得更强大" class="headerlink" title="Xcode（最终）变得更强大"></a>Xcode（最终）变得更强大</h3><p>LSP 的好处并不限于 Swift 和 Objective-C，<a href="https://forums.swift.org/t/new-lsp-language-service-supporting-swift-and-c-family-languages-for-any-editor-and-platform/17024/33" target="_blank" rel="noopener">Argyrios 在那个帖子的另一个留言中指出</a>：</p><blockquote><p>Xcode 使用我们新的 LSP 服务，这意味着它也可以使用其他 LSP 服务，我们对此很感兴趣，不过目前暂无具体计划。</p></blockquote><p>目前的工作重点是改进 Swift。但是，一旦实现了这一点，就应该能相对简单地将这些优化转移到支持 LSP 的其他语言中。</p><hr><p>软件的架构反映了创建它的组织的结构和价值。在某种程度上，反之亦然。</p><p>通过让 Xcode 支持开放的 Language Server Protocol 标准，苹果正在履行其在苹果生态系统之外的平台上实现 Swift 成功的承诺。我认为这是可行的：工具（或缺少工具）通常是技术获得人心的关键决定因素。但或许更重要的是，我认为这一决定表明，公司内部（至少是一小部分）对合作和透明度的意愿有所增强。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mattt，&lt;a href=&quot;https://nshipster.com/language-server-protocol/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-11-19&lt;br&gt;译者：&lt;a href=&quot;https://github.com/mobilefellow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;雨谨&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;上个月，苹果公司 &lt;a href=&quot;https://forums.swift.org/t/new-lsp-language-service-supporting-swift-and-c-family-languages-for-any-editor-and-platform/17024&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在 Swift.org 论坛上宣布&lt;/a&gt;，正在着手为 Swift 和 C 语言支持 &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Language Server Protocol&lt;/a&gt;（语言服务器协议，LSP）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于苹果公司而言，为所有 Swift 开发者 —— 包括非苹果平台上的 —— 提供高质量的工具支持非常重要。我们希望与开源社区合作，将精力集中在构建 Xcode 和其他编辑器、其他平台可以共享的公共基础设施上。为实现这一目标，[……]，我们决定支持 LSP。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Argyrios Kyrtzidis，2018 年 10 月 15 日&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;这可能是苹果自 2014 年将 Swift 作为开源软件发布以来，为 Swift 做出的最重要的决定。&lt;/strong&gt; 这对于 APP 开发者来说是一件大事，对于其他平台上的 Swift 开发者来说更是一件大事。&lt;/p&gt;
&lt;p&gt;为了理解其中的原因，本周的文章将研究 Language Server Protocol 解决了什么问题，它是如何工作的，以及它的长期影响可能是什么。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
</feed>
