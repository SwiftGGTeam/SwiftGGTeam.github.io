<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftGG</title>
  
  <subtitle>走心的 Swift 翻译组</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swift.gg/"/>
  <updated>2018-08-18T14:57:56.808Z</updated>
  <id>https://swift.gg/</id>
  
  <author>
    <name>SwiftGG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/A%20Trie%20in%20Swift/"/>
    <id>https://swift.gg/2018/08/18/A Trie in Swift/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/A%20practical%20introduction%20to%20functional%20programming/"/>
    <id>https://swift.gg/2018/08/18/A practical introduction to functional programming/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/Cryptography%20in%20Swift%20with%20CommonCrypto/"/>
    <id>https://swift.gg/2018/08/18/Cryptography in Swift with CommonCrypto/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/Swift%202_%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B/"/>
    <id>https://swift.gg/2018/08/18/Swift 2_面向协议编程/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/Swift%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://swift.gg/2018/08/18/Swift中的集合类数据结构/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/Swift%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
    <id>https://swift.gg/2018/08/18/Swift面试题及答案/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/UIGestureRecognizer%E6%95%99%E7%A8%8B%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8/"/>
    <id>https://swift.gg/2018/08/18/UIGestureRecognizer教程：创建自定义手势识别器/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/What&#39;s_New_in_Swift_2/"/>
    <id>https://swift.gg/2018/08/18/What&#39;s_New_in_Swift_2/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/ibeacons_ios%E5%92%8Cswift%E6%95%99%E7%A8%8B/"/>
    <id>https://swift.gg/2018/08/18/ibeacons_ios和swift教程/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/raywenderlich.com%E5%AE%98%E6%96%B9Swift%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
    <id>https://swift.gg/2018/08/18/raywenderlich.com官方Swift风格指南/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/strings-in-Swift2-md/"/>
    <id>https://swift.gg/2018/08/18/strings-in-Swift2-md/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E6%80%9D%E6%83%B3%E9%AB%98%E6%95%88%E8%A7%A3%E6%9E%90JSON/"/>
    <id>https://swift.gg/2018/08/18/使用泛型与函数式思想高效解析JSON/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20iOS%20%E4%B9%A6%E6%9C%AC%E6%89%93%E5%BC%80%E7%9A%84%E5%8A%A8%E7%94%BB%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/"/>
    <id>https://swift.gg/2018/08/18/如何创建一个 iOS 书本打开的动画（第一部分）/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%8D%8F%E8%AE%AE/"/>
    <id>https://swift.gg/2018/08/18/如何正确使用协议/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/%E6%8E%A2%E7%B4%A2%EF%BC%9A%E6%B5%8B%E8%AF%95Swift%E4%B8%AD%E7%9A%84ErrorType(1)/"/>
    <id>https://swift.gg/2018/08/18/探索：测试Swift中的ErrorType(1)/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/%E6%94%B9%E7%94%A8swift%E6%9D%A5%E6%80%9D%E8%80%83/"/>
    <id>https://swift.gg/2018/08/18/改用swift来思考/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD/"/>
    <id>https://swift.gg/2018/08/18/数组、链表及其性能/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://swift.gg/2018/08/18/Checking%20API%20Availability%20With%20Swift/"/>
    <id>https://swift.gg/2018/08/18/Checking API Availability With Swift/</id>
    <published>2018-08-18T14:57:56.808Z</published>
    <updated>2018-08-18T14:57:56.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用类型来让你自己更可靠</title>
    <link href="https://swift.gg/2018/07/03/using-types-to-keep-yourself-honest/"/>
    <id>https://swift.gg/2018/07/03/using-types-to-keep-yourself-honest/</id>
    <published>2018-07-03T00:00:00.000Z</published>
    <updated>2018-08-18T14:57:54.624Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：MATTHIJS HOLLEMANS，<a href="http://machinethink.net/blog/using-types-to-keep-yourself-honest/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016-03-25<br>译者：<a href="undefined">TonyHan</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>这篇文章展示了如何利用 Swift 的类型系统来使你的程序更具表现力和健壮性。</p><p>在最近一周左右的时间里，我一直在倒腾 Swift 的机器学习算法。我们可以通过使用矩阵来简洁有效地实现这些算法。</p><p>如果你忘记了线性代数，那只需将矩阵看作数字表格。</p><p>当提到 “M 是一个 4 乘 3 的矩阵”，意思是指 M 是一个 4 行 3 列的数字表格。关于矩阵你就需要了解这些（译者注:即可将其看作是表格），就可以理解本文后面的讲解。</p><a id="more"></a><p>下面是一个 4×3 矩阵的例子：</p><p><img src="http://machinethink.net/images/using-types-to-keep-yourself-honest/Matrix.png" alt="Matrix"></p><p>下面写代码创建一个 <code>矩阵结构体</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rows: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> columns: <span class="type">Int</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经常需要对矩阵的操作是将它们相乘，因此我创建了一个函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(m1: Matrix, <span class="number">_</span> m2: Matrix)</span></span> -&gt; <span class="type">Matrix</span> &#123;</span><br><span class="line">  <span class="comment">// bunch of math...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一切可能看起来很简单，但是还有些让我很烦的东西。</p><p>即便 m1 和 m2 都是 Matrix 对象，但是实际上它们可能具有不同数量的行和列。这可能是一个问题。</p><p>例如，使用矩阵乘法，两个矩阵的大小必须以特定方式匹配。</p><p><img src="http://machinethink.net/images/using-types-to-keep-yourself-honest/MatrixMultiplication.png" alt="MatrixMultiplication"></p><p>第一个矩阵中的列数必须与第二个矩阵中的行数相同。如果第一个矩阵的大小为 <code>U × V</code>，则第二个矩阵的大小必须为 <code>V × W</code>。这就是数学上规定的。</p><p>结果是大小为 <code>U × W</code> 的新矩阵。如果矩阵的大小不匹配这种特定的方式，我们就不能将它们相乘。</p><p>例如，以下将工作正常：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>(rows: <span class="number">4</span>, columns: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>(rows: <span class="number">3</span>, columns: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">C</span> = multiply(<span class="type">A</span>, <span class="type">B</span>)                <span class="comment">// gives a 4×2 matrix</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在数学中，矩阵通常用大写表示，我在这里遵循变量名称的惯例。</p></blockquote><p>由于 <code>A.columns == B.rows</code>，因此可以将 <code>A</code> 与 <code>B</code> 进行乘法。相反地，以下就不是有效的操作：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">D</span> = multiply(<span class="type">B</span>, <span class="type">A</span>)</span><br></pre></td></tr></table></figure><p>矩阵 <code>B</code> 中的列数与矩阵 <code>A</code> 中的行数不匹配。也就是 <code>B.columns！= A.rows</code>。从数学定义来说，矩阵B和A相乘没有任何意义。</p><p>目前，捕捉这些错误的唯一方法是在运行时触发断言：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(m1: Matrix, <span class="number">_</span> m2: Matrix)</span></span> -&gt; <span class="type">Matrix</span> &#123;</span><br><span class="line">  <span class="comment">// do the matrices have the correct sizes?</span></span><br><span class="line">  <span class="built_in">precondition</span>(m1.columns == m2.rows)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// bunch of math...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做当然可以，但我并不喜欢。Swift 静态类型的重点在于编译器可以在编译期间发现尽可能多的编程错误。如果我们可以使编译器也捕获这种错误，这就会很棒。</p><p>事实证明是可以的！在本文中，我将探讨如何使用 Swift 的类型系统来避免这样的错误。</p><h2 id="不太好的实现"><a href="#不太好的实现" class="headerlink" title="不太好的实现"></a>不太好的实现</h2><p>解决这个问题的比较原始的方法是为不同大小的矩阵创建不同的结构体：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix_4x3</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix_3x2</span>()</span><br></pre></td></tr></table></figure><p>但是，还需要一个将这些特定类型作为参数的 <code>multiply()</code> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(m1: Matrix_4x3, <span class="number">_</span> m2: Matrix_3x2)</span></span> -&gt; <span class="type">Matrix_4x2</span></span><br></pre></td></tr></table></figure><p>这似乎有点傻，导致了很多重复的代码。</p><p>更糟糕的是，编译时可能并不知道矩阵的大小。在机器学习问题中，我们经常需要从文件中加载数据集，但并不会提前知道有多少行。</p><p>所以这不是一个可行的解决方案。然而，为不同大小的矩阵声明不同类型的思路还是有希望的…</p><h2 id="通用的解决方案"><a href="#通用的解决方案" class="headerlink" title="通用的解决方案"></a>通用的解决方案</h2><p>我们希望将矩阵的维度以某种方式并入 Matrix 的类型，而不需要任何矩阵代码，如 <code>multiply()</code> 知道其具体大小。</p><p>定义以下 Matrix：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&lt;<span class="title">R</span>,<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rows: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> columns: <span class="type">Int</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它现在有两个通用参数 <code>R</code> 和 <code>C</code>，其中 <code>R</code> 表示行数，<code>C</code> 表示列数。</p><p>我们可以这样定义 <code>multiply()</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span>&lt;U,V,W&gt;<span class="params">(m1: Matrix&lt;U,V&gt;, <span class="number">_</span> m2: Matrix&lt;V,W&gt;)</span></span> -&gt; <span class="type">Matrix</span>&lt;<span class="type">U</span>,<span class="type">W</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// bunch of math...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">Matrix</span>(rows: m1.rows, columns: m2.columns)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意获取矩阵乘法规则的方法：大小为 <code>U × V</code> 的矩阵乘以大小为 <code>V × W</code> 的矩阵，得到 <code>U × W</code> 大小的新矩阵。</p><p>下面是如何使用新的 <code>Matrix</code> 的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumExamples</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumFeatures</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OneDimensional</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;(rows: <span class="number">20</span>, columns: <span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>&lt;<span class="type">NumFeatures</span>, <span class="type">OneDimensional</span>&gt;(rows: <span class="number">10</span>, columns: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>我们创建了三种新的类型 - 名为 <code>NumExamples</code> ，<code>NumFeatures</code> 和 <code>OneDimensional</code> —— 来表示矩阵的可能维数。注意我如何给出这些类型的描述性名称，从而更容易展现出它们的用途。</p><p><code>NumExamples</code> 和 <code>NumFeatures</code> 的名称来自机器学习，因为我将在其中使用这些矩阵。<code>NumExamples</code> 是数据集中的对象数目，<code>NumFeatures</code> 是每个示例的属性数。(当然，如果你要使用这些矩阵来做别的事情，你可以使用不同的名字。）</p><p><code>OneDimensional</code> 意指矩阵 <code>B</code> 只有一列。在线性代数中，我们称之为列向量而不是矩阵。为了使我们的代码更清晰，如果我们可以这样写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">ColumnVector</span>&lt;<span class="type">Rows</span>&gt; = <span class="type">Matrix</span>&lt;<span class="type">Rows</span>, <span class="type">OneDimensional</span>&gt;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">RowVector</span>&lt;<span class="type">Columns</span>&gt; = <span class="type">Matrix</span>&lt;<span class="type">OneDimensional</span>, <span class="type">Columns</span>&gt;</span><br></pre></td></tr></table></figure><p>类型别名会将 <code>ColumnVector</code> 和 <code>RowVector</code> 标记成 <code>Matrix</code> 的特殊情况。但不幸的是，Swift 2.2 中不支持这种语法。即将发布(<strong>原文日期=2016/03/25</strong>)的 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md" target="_blank" rel="noopener">Swift 3.0</a> 中可能会支持。</p><p>不管怎样让我们回到本例中。当你写下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">C</span> = multiply(<span class="type">A</span>, <span class="type">B</span>)</span><br></pre></td></tr></table></figure><p>它便会按照预期给出了一个新的 20×1矩阵。然而，与之前不同的是，无效的乘法尝试会导致编译器错误：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">D</span> = multiply(<span class="type">B</span>, <span class="type">A</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: cannot convert value of type 'Matrix&lt;NumFeatures, OneDimensional&gt;'</span></span><br><span class="line"><span class="comment">// to expected argument type 'Matrix&lt;_, _&gt;'</span></span><br></pre></td></tr></table></figure><p>错误消息有点模糊，但是使用 Swift 的类型系统来捕获这种错误是极好的。而不是在运行时崩溃应用程序，现在不可能将两个不具有正确维度的矩阵相乘。现在已经实现禁止将两个不具有正确维度的矩阵相乘，避免了在运行时崩溃。</p><p>果真如此么？我们仍然可以骗过编译器：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;(rows: <span class="number">20</span>, columns: <span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>&lt;<span class="type">NumFeatures</span>, <span class="type">OneDimensional</span>&gt;(rows: <span class="number">500</span>, columns: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>通过将 <code>B</code> 的行数改为 500，我们仍然处于与之前相同的情况。现在 <code>multiply(A, B)</code> 不再有效。</p><p>只有这些额外的类型是不够的…我们需要确保类型 <code>NumFeatures</code> 无论它在哪里使用，总会以某种方式引用相同的数字。</p><h2 id="使用协议弥补"><a href="#使用协议弥补" class="headerlink" title="使用协议弥补"></a>使用协议弥补</h2><p>我们可以像这样做：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumExamples</span> </span>&#123; <span class="keyword">let</span> size = <span class="number">20</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumFeatures</span> </span>&#123; <span class="keyword">let</span> size = <span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure><p>但是运行时这些维度的大小便被固定了。请记住，我们希望能够在运行时设置矩阵大小，例如通过从文件读取数据集——而且我们可能不知道该文件中有多少数据。对矩阵大小进行硬编码不是一种好办法。</p><p>相反，让我们定义一个新协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Dimension</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> size: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是 <code>Matrix</code> 变成了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&lt;<span class="title">R</span>: <span class="title">Dimension</span>, <span class="title">C</span>: <span class="title">Dimension</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rows: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> columns: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">self</span>.rows = <span class="type">R</span>.size</span><br><span class="line">    <span class="keyword">self</span>.columns = <span class="type">C</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>init(rows:columns:)</code> 方法已经被去掉。矩阵的大小直接由泛型 <code>R</code> 和 <code>C</code> 决定。</p><p>最后一步是使我们的维度类型符合新协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumExamples</span>: <span class="title">Dimension</span> </span>&#123; <span class="keyword">static</span> <span class="keyword">var</span> size = <span class="number">20</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumFeatures</span>: <span class="title">Dimension</span> </span>&#123; <span class="keyword">static</span> <span class="keyword">var</span> size = <span class="number">10</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OneDimensional</span>: <span class="title">Dimension</span> </span>&#123; <span class="keyword">static</span> <span class="keyword">var</span> size = <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>然后可以如下实现 <code>multiply()</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span>&lt;U: Dimension, V: Dimension, W: Dimension&gt;</span></span><br><span class="line"><span class="function">             <span class="params">(m1: Matrix&lt;U,V&gt;, <span class="number">_</span> m2: Matrix&lt;V,W&gt;)</span></span> -&gt; <span class="type">Matrix</span>&lt;<span class="type">U</span>,<span class="type">W</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// bunch of math...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">Matrix</span>&lt;<span class="type">U</span>,<span class="type">W</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，矩阵 m1 和 m2 不可能不匹配。编译器根本不会接受这种情况。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>&lt;<span class="type">NumFeatures</span>, <span class="type">OneDimensional</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">C</span> = multiply(<span class="type">A</span>, <span class="type">B</span>)   <span class="comment">// yay!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">D</span> = multiply(<span class="type">B</span>, <span class="type">A</span>)   <span class="comment">// compiler error</span></span><br></pre></td></tr></table></figure><p>这样就不会出现无意的错误。当然，你仍然可以通过这样做来欺骗系统：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">A</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;()</span><br><span class="line"><span class="type">NumFeatures</span>.size = <span class="number">500</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">B</span> = <span class="type">Matrix</span>&lt;<span class="type">NumFeatures</span>, <span class="type">OneDimensional</span>&gt;()</span><br></pre></td></tr></table></figure><p>即便 Swift 的类型系统也无法阻止出于恶意的行为。（也许在 <code>multiply()</code> 中保留 <code>precondition()</code> 是明智的。）</p><p>顺便说一句，你实际上需要有改变 <code>NumFeatures.size</code> 的能力。但你使用时应该多加小心。正如直到我们运行该程序才能知道它特定大小，它也没有理由会一直保持不变。例如，你可能需要使用相同的流程来处理不同大小的多个数据集。</p><p>当然，你可以使用矩阵来做更多事情，而不仅仅是乘以它们。以下是这些维度类型用处的另一个示例：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processData</span>&lt;M: Dimension, N: Dimension&gt;</span></span><br><span class="line"><span class="function">                <span class="params">(X: Matrix&lt;M, N&gt;, <span class="number">_</span> y: Matrix&lt;M, OneDimensional&gt;)</span></span> </span><br><span class="line">                -&gt; <span class="type">Matrix</span>&lt;<span class="type">OneDimensional</span>, <span class="type">N</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// do impressive stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">X</span> = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">NumFeatures</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> y = <span class="type">Matrix</span>&lt;<span class="type">NumExamples</span>, <span class="type">OneDimensional</span>&gt;()</span><br><span class="line">processData(<span class="type">X</span>, y)</span><br></pre></td></tr></table></figure><p>该函数采用矩阵 <code>X</code> 和列向量 <code>y</code> ，并对它们进行一些处理。例如，可能会训练学习系统。这里的约束是 <code>X</code> 和 <code>y</code> 必须具有相同的行数。多亏了我们的维度类型，编译器可以强制执行该约束。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们使用类型来更好地告诉编译器我们的程序正在做什么。这有助于编译器捕获错误。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：MATTHIJS HOLLEMANS，&lt;a href=&quot;http://machinethink.net/blog/using-types-to-keep-yourself-honest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-03-25&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;TonyHan&lt;/a&gt;；校对：&lt;a href=&quot;http://blog.yousanflics.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yousanflics&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;这篇文章展示了如何利用 Swift 的类型系统来使你的程序更具表现力和健壮性。&lt;/p&gt;
&lt;p&gt;在最近一周左右的时间里，我一直在倒腾 Swift 的机器学习算法。我们可以通过使用矩阵来简洁有效地实现这些算法。&lt;/p&gt;
&lt;p&gt;如果你忘记了线性代数，那只需将矩阵看作数字表格。&lt;/p&gt;
&lt;p&gt;当提到 “M 是一个 4 乘 3 的矩阵”，意思是指 M 是一个 4 行 3 列的数字表格。关于矩阵你就需要了解这些（译者注:即可将其看作是表格），就可以理解本文后面的讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="machinethink" scheme="https://swift.gg/categories/machinethink/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的强制编译时报错</title>
    <link href="https://swift.gg/2018/06/25/forcing-compiler-errors-in-swift/"/>
    <id>https://swift.gg/2018/06/25/forcing-compiler-errors-in-swift/</id>
    <published>2018-06-25T00:00:00.000Z</published>
    <updated>2018-08-18T14:57:54.624Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Erica Sadun，<a href="https://ericasadun.com/2018/04/18/forcing-compiler-errors-in-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-04-18<br>译者：<a href="http://wuqiuhao.github.io" target="_blank" rel="noopener">Hale</a>；校对：<a href="undefined">梁杰</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>得益于<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0196-diagnostic-directives.md" target="_blank" rel="noopener">SE-0196</a>，Swift 4.2 将引进 <code>#warning()</code> 和 <code>#error()</code> 两个编译指令。这两个指令允许你在编译期间合并诊断消息和抛出错误。下面这个例子来自已被确定接受的提议并且已经被实施。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#warning(<span class="string">"this is incomplete"</span>)</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> <span class="type">MY_BUILD_CONFIG</span> &amp;&amp; <span class="type">MY_OTHER_BUILD_CONFIG</span></span><br><span class="line">  #error(<span class="string">"MY_BUILD_CONFIG and MY_OTHER_BUILD_CONFIG cannot both be set"</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><code>#error</code> 指令的例子使用条件编译标志（用-D选项设置）来检察编译是否产生了配置冲突。</p><p>我(原文作者)已经写了很多关于我不喜欢在Swift中使用蛇形命名法（THINGS_LIKE_THIS）的文章。但不可避免的，开发者们都喜欢使用蛇形命名法则来定义条件编译标志。无论是 <code>MY_BUILD_CONFIG</code> 、 <code>MY_OTHER_BUILD_CONFIG</code> 还是 <code>DEBUG</code> 。虽然这是行业标准，但感觉这和Swift的美学存在冲突。</p><p>我也写过关于如何不显示使用 <code>DEBUG</code> 标志来<a href="https://ericasadun.com/2018/04/15/writing-swift-adventures-in-compiler-mods/" target="_blank" rel="noopener">检测调试条件的提议</a>。这边我附上了提议的链接，你们可以点击查看更多该提议的相关内容。</p><p>言归正传，Swift新近提出的 <code>#error</code> 和 <code>#warning</code> 指令，在当前的实践基础上有了很大进步。它们通常依赖于运行时的反馈而非编译时。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> !<span class="type">DEBUG</span></span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">"This code is incomplete. Please fix before release."</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>这个代码块中的缩进样式是 Swift 默认的，主要是为了避免条件编译块中出现轻微的<a href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming" target="_blank" rel="noopener">Pyramid of doom</a>)(金字塔厄运)。但如果把里面的代码缩进，在这个条件块的周围代码还是纵向增长的，主观上感觉有点丑。为了避免这种情况，一些编码人员采用内联方式，用最少的条件块和更简洁的方法强制编译时（而不是运行时）报错。</p><p>以下是我从 John Estropia 那发现的一个例子（他借鉴于他的同事）。他使用条件编译指令来设置 <code>TODO</code> 或 <code>FIXME</code> 等类型别名，然后在需要的地方使用它们。在 debug 环境时，编译能够通过而在 release 环境下编译就会报错：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span> </span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">typealias</span> <span class="type">TODO</span>&lt;<span class="type">T</span>&gt; = <span class="type">T</span></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Remove this later"</span>) <span class="keyword">as</span> <span class="type">TODO</span></span><br></pre></td></tr></table></figure><p>这个主意很棒。<code>TODO</code> 类型别名将支持 debug 过程中在想要注释的行末尾使用 <code>as TODO</code> ，在 release 编译环境下就会抛出异常。这确保了所有用 <code>TODO</code> 标注的点能够实现编译时反馈。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">error: <span class="type">ManyWays</span>.playground:<span class="number">5</span>:<span class="number">31</span>: error: use of undeclared type '<span class="type">TODO'</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Remove this later"</span>) <span class="keyword">as</span> <span class="type">TODO</span></span><br></pre></td></tr></table></figure><p>虽然不是很美观，但这很有效。它包含了关于代码调用的位置信息和你要发送的信息。如果我正在使用这个方法，我可能会创建一个 <code>todo</code> 方法，而不是直接使用上面的方法。在下面的例子中，我使用驼峰式命名使调用看起来更具有指令性，而不像标准的全局函数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">enum</span> <span class="title">IssueLevel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">    mildImportance,</span><br><span class="line">    moderateImportance,</span><br><span class="line">    highImportance,</span><br><span class="line">    criticalImportance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">ToDo</span><span class="params">(<span class="number">_</span> level: IssueLevel, <span class="number">_</span> string: String)</span></span> &#123;&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供编译错误、描述信息和优先级</span></span><br><span class="line"><span class="type">ToDo</span>(.highImportance, <span class="string">"Remove this later"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: ManyWays.playground:13:1: error: use of unresolved identifier 'ToDo'</span></span><br><span class="line"><span class="comment">// ToDo(.highImportance, "Remove this later")</span></span><br></pre></td></tr></table></figure><p>这种方式最大的好处就是从 debug 环境到 release 环境，只需通过 <code>#if</code> 进行判断。这种做法很诱人，只要确保全局都在需要标注的地方使用，然后在切换到 release 之前解决或移除所有的标注即可。</p><p>目前，Swift 不支持用 <code>#message</code> 指令来执行类似的任务。很多开发者将警告视为错误，他们无法在两者之间进行细微的区分。如果 <code>#warning</code> 被发布了，你就可以使用 <code>#warning</code> 实现类似“fix me”的反馈了。进一步改良的话，<code>#messageOrDie</code> （或者其他叫法，命名真的很难）可以在 debug build 时发送警告消息，在 release build 时报出错误，通过 <code>断言</code> 来判断申明是否发生。</p><p>Dave DeLong 为结构性项目语义提供了另一种方法。他介绍了一个 <code>Fatal</code> 类型为开发中一些比较常见的结果判断例如 <code>noImplemented</code>、<code>unreachable</code> 和 <code>mustOverride</code> 等提供<a href="https://forums.swift.org/t/introducing-namespacing-for-common-swift-error-scenarios/10773" target="_blank" rel="noopener">运行时线索</a>,它没有用“you need to remember to implement this”这样的提示，而是以运行时奔溃的形式，通过上报完整的位置和方法信息来解释。另一个检索被命名为 <code>silenceXcode()</code> 允许你添加你认为永远不会实现的一些方法，如果你使用了它也会报错。</p><p>Swift 仍有很大的空间来扩展这方面的支持。我不介意看到这两种方式都被添加到未来 Swift 的实现中。一种用于编译时（像 <code>#messageOrDie</code> ）另一种用于运行时（像 <code>Fatal</code> 命名空间的静态检索方法）</p><p>你们怎么看待这些？在 Swift 中还有哪些部分是元编程开发过程中（像宏）让你感到困惑的？我很想知道还有哪些已经确定发布的特性能够更好地支持开发。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了Swift4.2即将发布的
    
    </summary>
    
      <category term="iAchieved.it" scheme="https://swift.gg/categories/iAchieved-it/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
</feed>
