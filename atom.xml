<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftGG</title>
  
  <subtitle>走心的 Swift 翻译组</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swift.gg/"/>
  <updated>2018-12-03T07:23:57.622Z</updated>
  <id>https://swift.gg/</id>
  
  <author>
    <name>SwiftGG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 中的面向协议编程：是否优于面向对象编程？</title>
    <link href="https://swift.gg/2018/12/03/pop-vs-oop/"/>
    <id>https://swift.gg/2018/12/03/pop-vs-oop/</id>
    <published>2018-12-03T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://www.appcoda.com/pop-vs-oop/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018/03/28<br>译者：<a href="https://github.com/YangGao1991" target="_blank" rel="noopener">阳仔</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://lision.me/" target="_blank" rel="noopener">Lision</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote> <!--此处开始正文--><p>在本文中，我们将深入讨论 Swift 4 中的面向协议编程。这是一个系列两篇文章中的第二篇。如果你还没有读过 <a href="https://www.appcoda.com/protocol-oriented-programming/" target="_blank" rel="noopener">前一篇介绍文章</a>，请在继续阅读本文之前先阅读前一篇。</p><a id="more"></a><p>在本文中，我们将探讨为什么 Swift 被认为是一门“面向协议”的语言；对比面向协议编程（POP）和面向对象编程（OOP）；对比“值语义”和“引用语义”；讨论 local reasoning；用协议实现代理模式；用协议代替类型；使用协议多态性；重审我的面向协议的实际代码；最终讨论为什么我没有 100% 使用 POP 编程。</p><blockquote><p>关于 WWDC 链接的一点说明<br>在这一系列关于 POP 的两篇文章中，我至少添加了三个 Apple Worldwide Developers Conference (WWDC) 视频的链接。在 Safari 中点击这些链接将直接跳转至视频中的具体小节（并往往会从该处开始播放视频）。如果你使用的不是 Safari，则需要浏览视频，手动跳转至某一小节，或者查看该视频的文字版本。</p></blockquote><h2 id="Swift-为什么是“面向协议”的语言？"><a href="#Swift-为什么是“面向协议”的语言？" class="headerlink" title="Swift 为什么是“面向协议”的语言？"></a>Swift 为什么是“面向协议”的语言？</h2><p>我在 <a href="https://www.appcoda.com/protocol-oriented-programming/" target="_blank" rel="noopener">前一篇 POP 介绍文章</a> 中，提到 Apple 声称”从核心上说，Swift 是面向协议的”。相信我，确实是这样的。为什么呢？在回答这个问题之前，让我们先来比较几种编程语言。</p><p>我们最好对其他语言也有所了解，因为在某些情况下这将会有用处，比如在需要将 C++ 库链接到 iOS 应用中的时候。我的很多 iOS 和 OSX 的应用链接了 C++ 的库，因为这些应用有 Windows 平台的版本。这些年，我支持了许多“平台无关”的应用。</p><p>OOP 语言早已支持了接口。接口和 Swift 中的协议很相似，但并不是完全一样。</p><p>这些语言中的接口指定了遵循该接口的类和（或）结构体必须实现哪些方法和（或）属性。我这里使用了“和（或）”，是因为比如 C++ 中没有接口的概念，而是使用抽象类。并且，一个 C++ <code>struct</code> 可以继承自一个类。C# 中的接口允许指定其中的属性和方法，<code>struct</code> 可以遵循接口。Objective-C 中称“协议”而不是“接口”，协议也可以指定要求实现的方法和属性，但只有类可以声明遵循接口，<code>struct</code> 不可以。</p><p>这些接口和 Objective-C 中的协议，并没有方法的具体实现。它们只是指定一些要求，作为遵循该协议的类/结构体实现时的“蓝图”。</p><p>协议构成了 <a href="http://swiftdoc.org" target="_blank" rel="noopener">Swift 标准库</a> 的基础。正如我在 <a href="https://www.appcoda.com/protocol-oriented-programming/" target="_blank" rel="noopener">第一篇文章</a> 中所展示，协议是 POP 方法论和范式的关键所在。</p><p>Swift 中的协议有其他语言都不支持的特点：<a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID521" target="_blank" rel="noopener">协议扩展</a>。以下摘自 Apple 官方描述：</p><blockquote><p>协议可以被扩展，来给遵循该协议的类型提供方法、初始化方法、下标、计算属性的具体实现。这就可以允许协议自身定义一些行为，而不是由各个类型自己去实现，或是由一个全局方法来实现。<br>通过扩展，我们可以为协议所要求的任何方法和计算属性提供一个默认的实现。如果一个遵循该协议的类型为某个方法或属性提供了其自己的实现，那么该实现将会替代协议扩展中的实现。</p></blockquote><p>在上一篇文章中，你已经看到我是怎么使用协议扩展的，在本文中你会再次看到。它们是使得 Swift POP 如此强大的秘诀。</p><p>在 Swift 出现之前，协议在 iOS 中就已经十分重要。还记得我对 iOS 开发人员多年来采用的 UITableViewDataSource 和 UITableViewDelegate 等协议的 <a href="https://appcoda.com/protocol-oriented-programming/" target="_blank" rel="noopener">讨论</a> 吗？再想一想你每天写的 Swift 代码吧。</p><p>用 Swift 编程的时候，不可能不利用 <a href="http://swiftdoc.org" target="_blank" rel="noopener">标准库</a> 中的协议。例如，<code>Array</code> （一个继承了 <a href="http://swiftdoc.org/v3.1/type/Array/hierarchy/" target="_blank" rel="noopener">10 个协议</a> 的 <code>struct</code>），<code>Bool</code> （一个继承了 <a href="http://swiftdoc.org/v3.1/type/Bool/hierarchy/" target="_blank" rel="noopener">7 个协议</a> 的 <code>struct</code>），<code>Comparable</code> （一个 <a href="http://swiftdoc.org/v3.1/protocol/Comparable/hierarchy/" target="_blank" rel="noopener">继承自另一个协议的协议，并且是很多其他 Swift 类型的继承先祖</a>），以及 <code>Equatable</code> （一个 <a href="http://swiftdoc.org/v3.1/protocol/Equatable/hierarchy/" target="_blank" rel="noopener">很多 Swift 协议和类型的继承先祖</a>）。</p><p>花一些时间阅览 <a href="http://swiftdoc.org" target="_blank" rel="noopener">Swift 标准库</a>，跟随链接查看所有类型、协议、操作符、全局变量、函数。一定要看几乎所有页面都会有的 “Inheritance” 一节，并点击 “VIEW PROTOCOL HIERARCHY -&gt;” 链接。你将会看到很多协议，协议的定义，以及协议继承关系的图表。</p><p>记住很重要的一点：大部分 iOS（以及 OSX）SDK 中的代码都是以类继承的层次结构实现的。我相信很多我们使用的核心框架仍然是用 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Cocoa.html" target="_blank" rel="noopener">Objective-C</a>（以及一些 C++ 和 C）编写的，例如 <code>Fundation</code> 和 <code>UIKit</code>。拿 <code>UIKit</code> 中的 <code>UIbutton</code> 举例。利用 Apple 官方文档页面中的“继承自”链接，我们可以从叶节点 <code>UIButton</code> 一直沿着继承链向上查找到根节点 <code>NSObject</code>：<code>UIButton</code> 到 <code>UIControl</code> 到 <code>UIView</code> 到 <code>UIResponder</code> 到 <code>NSObject</code>。可以形象表示为：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/03/UIButton-Inheritance.png" alt=""></p><h2 id="POP-和-OOP"><a href="#POP-和-OOP" class="headerlink" title="POP 和 OOP"></a>POP 和 OOP</h2><p>OOP 的优点已经被开发者们讨论得很多了，所以在这里我只想简单列举一下。如果想了解详尽的内容，可以参考 <a href="http://iosbrain.com/blog/2017/02/26/intro-to-object-oriented-principles-in-swift-3-via-a-message-box-class-hierarchy/" target="_blank" rel="noopener">我写的这篇有关 OOP 在 Swift 中的实现的具体介绍</a>。</p><blockquote><p>注意：如果你读这篇文章的时候还不了解 OOP，我建议你在考虑学习 POP 之前，先学习 OOP。</p></blockquote><p>OOP 的优点包括可重用性，继承，可维护性，对复杂性的隐藏（封装），抽象性，多态性，对一个类的属性和方法的访问权限控制。我这里可能还有所遗漏，因为开发者们已经总结出太多 OOP 的优点了。</p><p>简单地说，OOP 和 POP 都拥有大部分上述的特点，主要的一点不同在于：类只能继承自其它一个类，但协议可以继承自多个协议。</p><p>正是由于 OOP 的继承的特点，我们在开发中最好把继承关系限制为单继承。因为多继承会使代码很快变得一团乱。</p><p>然而，协议却可以继承自一个或多个不同的协议。</p><p>为什么需要推动面向协议编程呢？当我们建立起一个庞大的类层次结构的时候，许多的属性和方法会被继承。开发者更倾向于把一些通用功能增加到顶层的——主要是高层的父类中（并且会一直加下去）。中层和底层的类的职责会更加明确和具体。新的功能会被放到父类中，这经常会使得父类充满了许多额外的，无关的职责，变得“被污染”或是“臃肿”。中层和底层的类也因此继承了很多它们并不需要的功能。</p><p>这些有关 OOP 的担忧并非成文的规定。一个优秀的开发者可以躲避很多刚才提到的陷阱。这需要时间、实践和经验。例如，开发者可以这样解决父类功能臃肿的问题：将其他类的实例添加为当前类的成员变量，而非继承这些类（也就是使用组合代替继承）。</p><p>在 Swift 中使用 POP 还有一个好处：不仅仅是类，值类型也可以遵循协议，比如 <code>struct</code> 和 <code>enum</code>。我们在下面将会讨论使用值类型的一些优点。</p><p>但我的确对遵循多协议的做法有一些顾虑。我们是否只是将代码的复杂性和难度转移成另一种形式了呢？即，将 OOP 继承中的“垂直”的复杂性转移成了 POP 继承中的“水平”的复杂性了呢？</p><p>将之前展示的 <code>UIButton</code> 的类继承结构和 Swift 中的 <code>Array</code> 所遵循的协议进行对比：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/03/Array-Protocol-Tangle.png" alt=""></p><blockquote><p>图像来源：<a href="http://swiftdoc.org/v3.1/type/Array/hierarchy/" target="_blank" rel="noopener">http://swiftdoc.org/v3.1/type/Array/hierarchy/</a></p></blockquote><p>Local reasoning 对这两种情况都不适用，因为个体和关系太多了。</p><h2 id="值语义-vs-引用语义"><a href="#值语义-vs-引用语义" class="headerlink" title="值语义 vs. 引用语义"></a>值语义 vs. 引用语义</h2><p>正如我上一篇文章所提到的，Apple 正在大力推广 POP 和值语义的相关概念（他们还正在推广另一个与 POP 相关的范式，下文会讲到）。上一次，我向你们展示了代码，这次依然会用代码来明确展示“引用语义”和“值语义”的不同意义。请参阅我 <a href="https://www.appcoda.com/protocol-oriented-programming/" target="_blank" rel="noopener">上一周的文章</a> 中的 <code>ObjectThatFlies</code> 协议，以及今天文章中的 <code>List</code>，<code>FIFO</code>，<code>LIFO</code> 以及相关协议。</p><p>Apple 工程师 Alex 说我们 <a href="https://developer.apple.com/videos/play/wwdc2016/419/?time=36" target="_blank" rel="noopener">“应当使用值类型和协议来让应用变得更好”</a>。Apple <a href="https://developer.apple.com/sample-code/swift/downloads/standard-library.zip" target="_blank" rel="noopener">sample playground</a> 中，一节题为“理解值类型”的代码文档这么说：</p><blockquote><p>标准库中的序列和容器使用了值类型，这让写代码变得更加容易。每一个变量都有一个独立的值，对这个值的引用并非共享的。例如，当你向一个函数传递一个数组，这个函数并不会导致调用方对这个数组的拷贝突然被改变。</p></blockquote><p>这当然对所有使用值语义的数据类型都是适用的。我强烈建议你下载并完整阅览整个 playground。</p><p>我并不是要抛弃类这个使用引用语义的概念。我做不到。我自己已经写了太多的基于类的代码。我帮助我的客户整理了数百万行基于类的代码。我同意值类型一般来说比引用类型安全。当我写新的代码，或是重构已有代码的时候，我会考虑在某些个案中积极尝试。</p><p>引用语义下，类实例（引用）会导致 <a href="https://developer.apple.com/videos/play/wwdc2015-414/?time=112" target="_blank" rel="noopener">“意料之外的数据共享”</a>。也有人称之为“意料之外的改变”。有一些 <a href="https://developer.apple.com/videos/play/wwdc2015-414/?time=210" target="_blank" rel="noopener">方法</a> 可以最小化引用语义的副作用，不过我还是会越来越多地使用值语义。</p><p>值语义能够使变量避免受到无法预计的更改，这实在很棒。因为“每个变量有一个独立的值，对这个值的引用是不共享的“，我们能够避免这种无法预计的更改导致的副作用。</p><p>因为 Swift 中的 <code>struct</code> 是一种值类型，并且能够遵循协议，苹果也在大力推进 POP 以取代 OOP，在 <a href="https://developer.apple.com/videos/play/wwdc2016/419/" target="_blank" rel="noopener">面向协议和值编程</a> 你可以找到这背后的原因。</p><h2 id="Local-reasoning"><a href="#Local-reasoning" class="headerlink" title="Local reasoning"></a>Local reasoning</h2><p>让我们探讨一个很棒的主题，Apple 称之为 <a href="https://developer.apple.com/videos/play/wwdc2016-419/?time=41" target="_blank" rel="noopener">“Local reasoning”</a>。这是由 Apple 一位叫 Alex 的工程师在 WWDC 2016 - Session 419，“UIKit 应用中的面向协议和值编程”中提出的。这也是 Apple 与 POP 同时大力推动的概念。</p><p>我认为这不是个新鲜的概念。许多年以前，教授、同事、导师、开发者们都在讨论这些：永远不要写高度超过一个屏幕的函数（即不长于一页，或许更短）；将大的函数拆解成若干小的函数；将大的代码文件拆解成若干小的代码文件；使用有意义的变量名；在写代码之前花点时间去设计代码；保持空格和缩进风格的一致性；将相关的属性和行为整合成类和/或结构体；将相关的类和/或结构体整合进框架或库中。但 Apple 在解释 POP<br>的时候，正式提出了这个概念。Alex 告诉我们：</p><blockquote><p>Local reasoning 意味着，当你看你面前的代码的时候，你不需要去思考，剩下的代码怎样去和这个函数进行交互。也许你之前已经有过这种感觉。例如，当你刚加入一个新的团队，有大量的代码要去看，同时上下文的信息也非常匮乏，你能明白某一个函数的作用吗？做到 Local reasoning 的能力很重要，因为这能够使得维护代码、编写代码、测试代码变得更加容易。</p></blockquote><p>哈哈，你曾经有过这种感觉吗？我曾经读过一些其他人写的真的很好的代码。我也曾经写过一些易读性非常好的代码。说实话，在 30 年的工作经验中，我要去支持和升级的绝大部分现存的代码都不会让我感受到 Alex 所描述的这种感觉。相反，我经常会变得非常困惑，因为当我看一段代码的时候，我往往对这段代码的作用毫无头绪。</p><p>Swift 语言的源代码是开源的。请快速浏览一遍 <a href="https://github.com/apple/swift/blob/master/stdlib/public/SDK/Foundation/NSFastEnumeration.swift" target="_blank" rel="noopener">下列函数</a>，也不要花上三个小时去试图理解它：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Any</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> index + <span class="number">1</span> &gt; <span class="built_in">count</span> &#123;</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line"><span class="comment">// 确保没有 self 的成员变量被捕获</span></span><br><span class="line">        <span class="keyword">let</span> enumeratedObject = enumerable</span><br><span class="line">        <span class="keyword">var</span> localState = state</span><br><span class="line">        <span class="keyword">var</span> localObjects = objects</span><br><span class="line">        </span><br><span class="line">        (<span class="built_in">count</span>, useObjectsBuffer) = <span class="built_in">withUnsafeMutablePointer</span>(to: &amp;localObjects) &#123;</span><br><span class="line">            <span class="keyword">let</span> buffer = <span class="type">AutoreleasingUnsafeMutablePointer</span>&lt;<span class="type">AnyObject</span>?&gt;($<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">withUnsafeMutablePointer</span>(to: &amp;localState) &#123; (statePtr: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">NSFastEnumerationState</span>&gt;) -&gt; (<span class="type">Int</span>, <span class="type">Bool</span>) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> result = enumeratedObject.countByEnumerating(with: statePtr, objects: buffer, <span class="built_in">count</span>: <span class="number">16</span>)</span><br><span class="line">                <span class="keyword">if</span> statePtr.pointee.itemsPtr == buffer &#123;</span><br><span class="line">    <span class="comment">// 大多数 cocoa 类会返回它们自己的内部指针缓存，不使用默认的路径获取值。也有例外的情况，比如 NSDictionary 和 NSSet。</span></span><br><span class="line">    <span class="keyword">return</span> (result, <span class="literal">true</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里是通常情形，比如 NSArray。</span></span><br><span class="line">    <span class="keyword">return</span> (result, <span class="literal">false</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        state = localState <span class="comment">// 重置 state 的值</span></span><br><span class="line">        objects = localObjects <span class="comment">// 将对象指针拷贝回 self </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> &#123; index += <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> !useObjectsBuffer &#123;</span><br><span class="line">        <span class="keyword">return</span> state.itemsPtr![index]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> index &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> objects.<span class="number">0</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> objects.<span class="number">1</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> objects.<span class="number">2</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> objects.<span class="number">3</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> objects.<span class="number">4</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">return</span> objects.<span class="number">5</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">return</span> objects.<span class="number">6</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">return</span> objects.<span class="number">7</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="keyword">return</span> objects.<span class="number">8</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>: <span class="keyword">return</span> objects.<span class="number">9</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">return</span> objects.<span class="number">10</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>: <span class="keyword">return</span> objects.<span class="number">11</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>: <span class="keyword">return</span> objects.<span class="number">12</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>: <span class="keyword">return</span> objects.<span class="number">13</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">14</span>: <span class="keyword">return</span> objects.<span class="number">14</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">case</span> <span class="number">15</span>: <span class="keyword">return</span> objects.<span class="number">15</span>!.takeUnretainedValue()</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">fatalError</span>(<span class="string">"Access beyond storage buffer"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你浏览过一遍之后，说实话，你能理解这段代码吗？我并没有。我不得不花些时间多读几遍，并查阅函数定义之类的代码。以我的经验，这种代码是普遍存在的，并且不可避免需要经常修补的。</p><p>现在，让我们考虑理解一种 Swift 类型（不是一个函数）。查看 Swift 中的 <code>Array</code> 的 <a href="http://swiftdoc.org/v3.1/type/Array/" target="_blank" rel="noopener">定义</a>。我的天，它继承了11个协议，<code>BidirectionalCollection</code>，<code>Collection</code>，<code>CustomDebugStringConvertible</code>，<code>CustomReflectable</code>，<code>CustomStringConvertible</code>，<code>ExpressibleByArrayLiteral</code>，<code>MutableCollection</code>，<code>RandomAccessCollection</code>，<code>RangeReplaceableCollection</code>，<code>Sequence</code>。点击下方的“VIEW PROTOCOL HIERARCHY -&gt;”链接按钮——天哪，<a href="http://swiftdoc.org/v3.1/type/Array/hierarchy/" target="_blank" rel="noopener">看这一坨面条一样的线条</a>！</p><p>如果你是在开发一个新项目，并且整个团队能够遵循一套最佳开发指导方案的话，要做到 Local reasoning 会容易很多。少量代码的重构也是做到 local reasoning 的较好的机会。对我来说，像其他大部分事情一样，代码的重构需要慎重和仔细，要做到适度。</p><p>牢记：你几乎一直要面对非常复杂的业务逻辑，这些逻辑如果写成代码，并且要让一个团队新人流畅读懂，需要他/她接收一些业务知识的训练和指导。他/她很可能需要查找一些函数、类、结构体、枚举值、变量的定义。</p><h2 id="代理和协议"><a href="#代理和协议" class="headerlink" title="代理和协议"></a>代理和协议</h2><p>代理模式是 iOS 中广泛使用的模式，其中一个必需的组成部分就是协议。在这里我们不需要再去重复。你可以阅读我有关该主题的 AppCoda <a href="https://www.appcoda.com/swift-delegate/" target="_blank" rel="noopener">博客</a>。</p><h2 id="协议类型以及协议多态性"><a href="#协议类型以及协议多态性" class="headerlink" title="协议类型以及协议多态性"></a>协议类型以及协议多态性</h2><p>在这些主题上我不准备花太多时间。我已经讲过很多有关协议的知识，并向你展示了大量代码。作为任务，我想让你自己研究一下，Swift 协议类型（就像在代理中一样）的重要性，它们能给我们带来的灵活性，以及它们所展示的多态性。</p><p><em>协议类型</em><br>在我 <a href="https://www.appcoda.com/swift-delegate/" target="_blank" rel="noopener">关于代理的文章</a> 中，我定义了一个属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> delegate: <span class="type">LogoDownloaderDelegate</span>?</span><br></pre></td></tr></table></figure><p>其中 <code>LogoDownloaderDelegate</code> 是一个协议。然后，我调用了这个协议的一个方法。</p><p><em>协议多态性</em><br>正如在面向对象中一样，我们可以通过遵循父协议的数据类型，来与多种遵循同一个协议族的子协议的数据类型进行交互。用代码举例来说明：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Top</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> protocolName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Middle</span>: <span class="title">Top</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Bottom</span>: <span class="title">Middle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TopStruct</span> : <span class="title">Top</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> protocolName: <span class="type">String</span> = <span class="string">"TopStruct"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MiddleStruct</span> : <span class="title">Middle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> protocolName: <span class="type">String</span> = <span class="string">"MiddleStruct"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BottomStruct</span> : <span class="title">Bottom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> protocolName: <span class="type">String</span> = <span class="string">"BottomStruct"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> top = <span class="type">TopStruct</span>()</span><br><span class="line"><span class="keyword">let</span> middle = <span class="type">MiddleStruct</span>()</span><br><span class="line"><span class="keyword">let</span> bottom = <span class="type">BottomStruct</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> topStruct: <span class="type">Top</span></span><br><span class="line">topStruct = bottom</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(topStruct)</span>\n"</span>)</span><br><span class="line"><span class="comment">// 输出 "BottomStruct(protocolName: "BottomStruct")"</span></span><br><span class="line"></span><br><span class="line">topStruct = middle</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(topStruct)</span>\n"</span>)</span><br><span class="line"><span class="comment">// 输出 "MiddleStruct(protocolName: "MiddleStruct")"</span></span><br><span class="line"></span><br><span class="line">topStruct = top</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(topStruct)</span>\n"</span>)</span><br><span class="line"><span class="comment">// 输出 "TopStruct(protocolName: "TopStruct")"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> protocolStructs:[<span class="type">Top</span>] = [top,middle,bottom]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> protocolStruct <span class="keyword">in</span> protocolStructs &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(protocolStruct)</span>\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你运行一下 Playground 中的代码，以下是终端的输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BottomStruct(protocolName: &quot;BottomStruct&quot;)</span><br><span class="line"></span><br><span class="line">MiddleStruct(protocolName: &quot;MiddleStruct&quot;)</span><br><span class="line"></span><br><span class="line">TopStruct(protocolName: &quot;TopStruct&quot;)</span><br><span class="line"></span><br><span class="line">TopStruct(protocolName: &quot;TopStruct&quot;)</span><br><span class="line"></span><br><span class="line">MiddleStruct(protocolName: &quot;MiddleStruct&quot;)</span><br><span class="line"></span><br><span class="line">BottomStruct(protocolName: &quot;BottomStruct&quot;)</span><br></pre></td></tr></table></figure><h2 id="真实的-UIKit-应用中的协议"><a href="#真实的-UIKit-应用中的协议" class="headerlink" title="真实的 UIKit 应用中的协议"></a>真实的 UIKit 应用中的协议</h2><p>现在，让我们来看一些实质性的东西，写一些 Swift 4 的代码——这些代码是在我自己的应用中真实使用的。这些代码应当能使你开始思考用协议来构建和/或拓展你的代码。这也就是我在这两篇文章中一直在描述的，“面向协议编程”，或者 POP。</p><p>我选择向你展示如何去扩展或者说是延伸（随便哪种说法）<code>UIKit</code> 的类，因为 1) 你很可能非常习惯使用它们 2) 扩展 iOS SDK 中的类，比如 <code>UIView</code>，是比用你自己的类更加困难一些的。</p><p>所有 <code>UIView</code> 的扩展代码都是用 Xcode 9 工程中的 <em>Single View App</em> 模板写的。</p><p>我使用默认协议扩展来对 <code>UIView</code> 进行扩展——这么做的关键是一种 Apple 称之为 <a href="https://swift.org/blog/conditional-conformance/" target="_blank" rel="noopener">“条件遵循”</a> 的做法（也可以看 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID277" target="_blank" rel="noopener">这里</a>）。因为我只想对 <code>UIView</code> 这个类进行扩展，我们可以让编译器来把这个变成一项强制要求。</p><p>我经常使用 <code>UIView</code> 作为一个容器来组织屏幕上的其他 UI 元素。也有时候，我会用这些容器视图来更好地查看、感觉、排布我的 UI 视图。</p><p>这里是一张 GIF 图片，展示了使用下面创建的三个协议来自定义 <code>UIView</code> 的外观的结果：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/03/Extend-UIView.gif" alt=""></p><p>注意，这里我也遵守了 ”Local reasoning“ 的原则。我每一个基于协议的函数都控制在一屏幕之内。我希望你能阅读每一个函数，因为它们并没有太多代码量，但却很有效。</p><h2 id="为-UIView-添加一个默认的边框"><a href="#为-UIView-添加一个默认的边框" class="headerlink" title="为 UIView 添加一个默认的边框"></a>为 UIView 添加一个默认的边框</h2><p>假设我希望获得很多拥有相同边框的 <code>UIView</code> 实例——例如在一个支持颜色主题的应用中那样。一个这样的例子就是上面那张图片中，最上面那个绿色的视图。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SimpleViewWithBorder</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的："addBorder" 方法只会被添加到 UIView 的实例。</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SimpleViewWithBorder</span> <span class="title">where</span> <span class="title">Self</span> : <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBorder</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        layer.borderColor = <span class="type">UIColor</span>.green.cgColor</span><br><span class="line">        layer.borderWidth = <span class="number">10.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleUIViewWithBorder</span> : <span class="title">UIView</span>, <span class="title">SimpleViewWithBorder</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要创建、配置、显示一个 <code>SimpleUIViewWithBorder</code> 的实例，我在我的 <code>ViewController</code> 子类中的 <code>IBAction</code> 中写了如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">addViewButtonTapped</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> customFrame0 = <span class="type">CGRect</span>(x: <span class="number">110</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">let</span> customView0 = <span class="type">SimpleUIViewWithBorder</span>(frame: customFrame0)</span><br><span class="line">    customView0.addBorder()</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(customView0)</span><br></pre></td></tr></table></figure><p>我不需要为这个 <code>UIView</code> 的子类去创建一个特殊的初始化方法。</p><h2 id="为-UIView-添加一个默认的背景色"><a href="#为-UIView-添加一个默认的背景色" class="headerlink" title="为 UIView 添加一个默认的背景色"></a>为 UIView 添加一个默认的背景色</h2><p>假设我希望很多 <code>UIView</code> 的实例都有相同的背景色。一个这样的例子是上图中，中间的蓝色视图。注意，我向可配置的 <code>UIView</code> 又更进了一步。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ViewWithBackground</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> customBackgroundColor: <span class="type">UIColor</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewWithBackground</span> <span class="title">where</span> <span class="title">Self</span> : <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBackgroundColor</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        backgroundColor = customBackgroundColor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIViewWithBackground</span> : <span class="title">UIView</span>, <span class="title">ViewWithBackground</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> customBackgroundColor: <span class="type">UIColor</span> = .blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要创建、配置、展示一个 <code>UIViewWithBackground</code> 的实例，我在我的 <code>ViewController</code> 子类中的 <code>IBAction</code> 中写了如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> customFrame1 = <span class="type">CGRect</span>(x: <span class="number">110</span>, y: <span class="number">210</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> customView1 = <span class="type">UIViewWithBackground</span>(frame: customFrame1)</span><br><span class="line">customView1.addBackgroundColor()</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(customView1)</span><br></pre></td></tr></table></figure><p>我不需要为这个 <code>UIView</code> 的子类去创建一个特殊的初始化方法。</p><h2 id="为-UIView-添加一个可配置的边框颜色"><a href="#为-UIView-添加一个可配置的边框颜色" class="headerlink" title="为 UIView 添加一个可配置的边框颜色"></a>为 UIView 添加一个可配置的边框颜色</h2><p>现在，我希望能够配置 <code>UIView</code> 边框的颜色和宽度。用下列实现代码，我可以随意创建不同边框颜色、宽度的视图。这样的一个例子是上图中，最下面的红色视图。向我的协议中去添加可配置的属性有一点代价，我需要能够初始化这些属性，因此，我为我的协议添加了一个 <code>init</code> 方法。这意味着，我也可以调用 <code>UIView</code> 的初始化方法。读完代码，你就会明白：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ViewWithBorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> borderColor: <span class="type">UIColor</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> borderThickness: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">init</span>(borderColor: <span class="type">UIColor</span>, borderThickness: <span class="type">CGFloat</span>, frame: <span class="type">CGRect</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewWithBorder</span> <span class="title">where</span> <span class="title">Self</span> : <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBorder</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        layer.borderColor = borderColor.cgColor</span><br><span class="line">        layer.borderWidth = borderThickness</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIViewWithBorder</span> : <span class="title">UIView</span>, <span class="title">ViewWithBorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> borderColor: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">let</span> borderThickness: <span class="type">CGFloat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// UIView 的必要初始化方法</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(borderColor: <span class="type">UIColor</span>, borderThickness: <span class="type">CGFloat</span>, frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.borderColor = borderColor</span><br><span class="line">        <span class="keyword">self</span>.borderThickness = borderThickness</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UIView 的必要初始化方法</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要创建、配置、显示一个 <code>UIViewWithBorder</code> 的实例，我在我的 <code>ViewController</code> 子类中的 <code>IBAction</code> 中写了如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> customFrame2 = <span class="type">CGRect</span>(x: <span class="number">110</span>, y: <span class="number">320</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> customView2 = <span class="type">UIViewWithBorder</span>(borderColor: .red, borderThickness: <span class="number">10.0</span>, frame: customFrame2)</span><br><span class="line">customView2.addBorder()</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(customView2)</span><br></pre></td></tr></table></figure><h2 id="我不想做的事"><a href="#我不想做的事" class="headerlink" title="我不想做的事"></a>我不想做的事</h2><p>我不想去创建像这样的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBorder</span><span class="params">()</span></span> &#123;  ...  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBackgroundColor</span><span class="params">()</span></span> &#123;  ...  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样也许在一些情况下是有效的，但我感觉这种实现太粗泛了，容易丧失很多细颗粒度的控制。这种实现也容易使得这种构造方法变成 <code>UIView</code> 相关扩展方法的垃圾场，换句话说，代码容易变得臃肿。随着方法越来越多，代码也变得越来越难以阅读和维护。</p><p>在上述所有基于 <code>UIKit</code> 的协议中，我都使用了 <code>UIView</code> 的子类——引用类型。子类化能够让我能直接访问父类 <code>UIView</code> 中的任何内容，让我的代码清晰、简短、易读。如果我使用的是 <code>struct</code>，我的代码会变得更加冗长，至于为什么，留给你们当做练习。</p><h2 id="我做的事情"><a href="#我做的事情" class="headerlink" title="我做的事情"></a>我做的事情</h2><p>时刻记住，所有这些默认协议 <code>extensions</code> 可以在类扩展中覆盖。用一个例子和图片来解释：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SimpleViewWithBorder</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SimpleViewWithBorder</span> <span class="title">where</span> <span class="title">Self</span> : <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBorder</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        layer.borderColor = <span class="type">UIColor</span>.green.cgColor</span><br><span class="line">        layer.borderWidth = <span class="number">10.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleUIViewWithBorder</span> : <span class="title">UIView</span>, <span class="title">SimpleViewWithBorder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 覆盖 extension 中的默认实现</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addBorder</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        layer.borderColor = <span class="type">UIColor</span>.darkGray.cgColor</span><br><span class="line">        layer.borderWidth = <span class="number">20.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我在 <code>SimpleUIViewWithBorder</code> 中的注释。看下图中最上面的视图：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/03/Override-Extended-UIView.gif" alt=""></p><h2 id="真实的，基于协议的泛型数据结构"><a href="#真实的，基于协议的泛型数据结构" class="headerlink" title="真实的，基于协议的泛型数据结构"></a>真实的，基于协议的泛型数据结构</h2><p>我非常骄傲在我自己的应用中，我能够写尽量少的 POP 代码，来创建完整功能的泛型的栈和队列的数据结构。想了解有关 Swift 中的泛型，请阅读我 AppCoda 中的 <a href="https://appcoda.com/swift-generics/" target="_blank" rel="noopener">文章</a>。</p><p>请注意，我使用协议继承来帮助我利用抽象的 <code>List</code> 协议去创建更加具体的 <code>FIFO</code> 和 <code>LIFO</code> 协议。然后，我利用协议扩展来实现 <code>Queue</code> 和 <code>Stack</code> 值类型。你可以在下面的 Xcode 9 playground 中看到这些 <code>struct</code> 的实例。</p><p>我想向你展示的是如何像 Apple 建议的一样，通过其他协议来实现自己自定义的协议，因此，我创建了 <code>ListSubscript</code>，<code>ListPrintForwards</code>，<code>ListPrintBackwards</code>，<code>ListCount</code>协议。它们现在还很简单，但在一个实际的应用中将会展现出其作用。</p><p>这种继承多个其他协议的做法可以让开发者为现有代码增加新的功能，而且不会因为太多额外不相关的功能对代码造成”污染“或”臃肿“。这些协议中，每一个都是独立的。如果是作为类被添加到继承层级中叶级以上的话，根据它们所处的位置，这些功能将会至少自动被其他一些类继承。</p><p>关于 POP，我已经讲了足够多来帮助你阅读和理解代码。再给出一个我是如何让我的数据结构支持泛型的提示：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID189" target="_blank" rel="noopener">关联类型的定义</a>。</p><blockquote><p>当定义一个协议的时候，有时可以声明一个或多个关联类型，作为协议定义的一部分。一个关联类型提供了一个占位名，用来表示协议中的一种类型。这个关联类型真正的数据类型直到该协议被使用的时候才确定。使用 <code>associatedtype</code> 关键字来指明一个关联类型。</p></blockquote><p>代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ListSubscript</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">AnyType</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> elements : [<span class="type">AnyType</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ListSubscript</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Any</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ListPrintForwards</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">AnyType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> elements : [<span class="type">AnyType</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ListPrintForwards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showList</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> elements.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> line = <span class="string">""</span></span><br><span class="line">            <span class="keyword">var</span> index = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> element <span class="keyword">in</span> elements &#123;</span><br><span class="line">                line += <span class="string">"<span class="subst">\(element)</span> "</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(line)</span>\n"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"EMPTY\n"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ListPrintBackward</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">AnyType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> elements : [<span class="type">AnyType</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ListPrintBackwards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showList</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> elements.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> line = <span class="string">""</span></span><br><span class="line">            <span class="keyword">var</span> index = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> elements.reversed() &#123;</span><br><span class="line">                line += <span class="string">"<span class="subst">\(element)</span> "</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(line)</span>\n"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"EMPTY\n"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ListCount</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">AnyType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> elements : [<span class="type">AnyType</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ListCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elements.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">AnyType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> elements : [<span class="type">AnyType</span>] &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">()</span></span> -&gt; <span class="type">AnyType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> element: AnyType)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> element: AnyType)</span></span> &#123;</span><br><span class="line">        elements.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">FIFO</span> : <span class="title">List</span>, <span class="title">ListCount</span>, <span class="title">ListPrintForwards</span>, <span class="title">ListSubscript</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FIFO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">()</span></span> -&gt; <span class="type">AnyType</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> elements.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> elements.removeFirst()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"******EMPTY******"</span> <span class="keyword">as</span>! <span class="type">AnyType</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&lt;<span class="title">AnyType</span>&gt;: <span class="title">FIFO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elements: [<span class="type">AnyType</span>] = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> queue = <span class="type">Queue</span>&lt;<span class="type">Any</span>&gt;()</span><br><span class="line">queue.add(<span class="string">"Bob"</span>)</span><br><span class="line">queue.showList()</span><br><span class="line">queue.add(<span class="number">1</span>)</span><br><span class="line">queue.showList()</span><br><span class="line">queue.add(<span class="number">3.0</span>)</span><br><span class="line"><span class="number">_</span> = queue[<span class="number">0</span>] <span class="comment">// 该下标输出 "Bob"</span></span><br><span class="line"><span class="number">_</span> = queue.<span class="built_in">count</span>()</span><br><span class="line">queue.showList()</span><br><span class="line">queue.remove()</span><br><span class="line">queue.showList()</span><br><span class="line">queue.remove()</span><br><span class="line">queue.showList()</span><br><span class="line">queue.remove()</span><br><span class="line">queue.showList()</span><br><span class="line"><span class="number">_</span> = queue.<span class="built_in">count</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LIFO</span> : <span class="title">List</span>, <span class="title">ListCount</span>, <span class="title">ListPrintBackwards</span>, <span class="title">ListSubscript</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LIFO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">()</span></span> -&gt; <span class="type">AnyType</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> elements.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> elements.removeLast()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"******EMPTY******"</span> <span class="keyword">as</span>! <span class="type">AnyType</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">AnyType</span>&gt;: <span class="title">LIFO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elements: [<span class="type">AnyType</span>] = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stack = <span class="type">Stack</span>&lt;<span class="type">Any</span>&gt;()</span><br><span class="line">stack.add(<span class="string">"Bob"</span>)</span><br><span class="line">stack.showList()</span><br><span class="line">stack.add(<span class="number">1</span>)</span><br><span class="line">stack.showList()</span><br><span class="line">stack.add(<span class="number">3.0</span>)</span><br><span class="line"><span class="number">_</span> = stack[<span class="number">0</span>] <span class="comment">// 该下标输出 3</span></span><br><span class="line"><span class="number">_</span> = stack.<span class="built_in">count</span>()</span><br><span class="line">stack.showList()</span><br><span class="line">stack.remove()</span><br><span class="line">stack.showList()</span><br><span class="line">stack.remove()</span><br><span class="line">stack.showList()</span><br><span class="line">stack.remove()</span><br><span class="line">stack.showList()</span><br><span class="line"><span class="number">_</span> = stack.<span class="built_in">count</span>()</span><br></pre></td></tr></table></figure><p>这一段代码片段在控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bob</span><br><span class="line"></span><br><span class="line">Bob 1</span><br><span class="line"></span><br><span class="line">Bob 1 3.0</span><br><span class="line"></span><br><span class="line">1 3.0</span><br><span class="line"></span><br><span class="line">3.0</span><br><span class="line"></span><br><span class="line">EMPTY</span><br><span class="line"></span><br><span class="line">Bob</span><br><span class="line"></span><br><span class="line">1 Bob</span><br><span class="line"></span><br><span class="line">3.0 1 Bob</span><br><span class="line"></span><br><span class="line">1 Bob</span><br><span class="line"></span><br><span class="line">Bob</span><br><span class="line"></span><br><span class="line">EMPTY</span><br></pre></td></tr></table></figure><h2 id="我没有-100-使用-POP"><a href="#我没有-100-使用-POP" class="headerlink" title="我没有 100% 使用 POP"></a>我没有 100% 使用 POP</h2><p>在 WWDC 有关 POP 的视频之一中，一位工程师/讲师说 <a href="https://developer.apple.com/videos/play/wwdc2015-408/?time=882" target="_blank" rel="noopener">”在 Swift 中我们有一种说法，不要从一个类开始写代码，从一个协议开始“</a>。嘛~也许吧。这家伙开始了有关如何使用协议来写一个二分查找的冗长的讨论。我有点怀疑，这是不是我许多读者印象最深的部分。看完你失眠了吗？</p><p>这有点像是为了寻找一个 POP 解决方案而人为设计出的一个问题。也许问题是实际的，也许这种解决方案有优点，我也不知道。我的时间很宝贵，没有时间浪费在这种象牙塔理论上。如果读懂一段代码需要超过 5 分钟的时间，我就觉得这段代码违背了 Apple 的 ”local reasoning“ 原则。</p><p>如果你和我一样也是一个软件开发者，最好始终对新的方法论保持一个开放的心态，并且始终将控制复杂度作为你的主要工作重心。我绝不反对赚钱，但看得更高更远一点是有好处的。记住，Apple 是一家公司，一家大公司，主要使命是赚大钱，上周五的市值已经接近 8370 亿美元，拥有数千亿的现金和现金等价物。他们想让每个人都使用 Swift，而这些公司吸引人到自家生态系统的方法之一就是提供别人都提供不了的产品和服务。是的，<a href="https://developer.apple.com/swift/blog/?id=34" target="_blank" rel="noopener">Swift 是开源的</a>，但 Apple 从 App Store 赚了大钱，因此应用正是让所有 Apple 设备变得有用的关键，许许多多的开发者正在向 Swift 迁移。</p><p>我觉得没有任何理由只用 POP 进行编程。我认为 POP 和我使用的其他许多技术，甚至是 OOP 一样，都有一些问题。我们是在对现实建模，或者至少说，我们是在对现实进行拟合。没有完美的解决方案。所以，将 POP 作为你的开发工具箱中的一种吧，就像人们长年以来总结出的其他优秀的方案一样。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>30 年的开发经验，让我能够平心静气地说，<strong>你应该了解协议和 POP。</strong>开始设计并书写你自己的 POP 代码吧。</p><p>我已经花费了不少时间试用 POP，并且已经将这篇文章中的协议使用在了我自己的应用中，比如 <code>SimpleViewWithBorder</code>，<code>ViewWithBackground</code>，<code>ViewWithBorder</code>，<code>List</code>，<code>FIFO</code>，<code>LIFO</code>。POP 威力无穷。</p><p>正如我在前一篇文章中提到的，学习并接受一种新方法，比如 POP，并不是一个非对即错的事情。POP 和 OOP 不仅能并存，还能够互相补充。</p><p>所以，开始试验、练习、学习吧。最后，尽情享受生活和工作吧。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了面向协议编程的优缺点，以及与面向对象编程的对比。
    
    </summary>
    
      <category term="appcoda" scheme="https://swift.gg/categories/appcoda/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的设计模式 #3 外观模式与适配器模式</title>
    <link href="https://swift.gg/2018/11/29/design-pattern-structural/"/>
    <id>https://swift.gg/2018/11/29/design-pattern-structural/</id>
    <published>2018-11-29T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://www.appcoda.com/design-pattern-structural/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-09-04<br>译者：<a href="https://www.jianshu.com/u/076cc5e18bb8" target="_blank" rel="noopener">郑一一</a>；校对：<a href="https://bignerdcoding.com/" target="_blank" rel="noopener">BigNerdCoding</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>本文是我的设计模式系列教程的第三篇。在第一篇文章中，我介绍了 <a href="https://swift.gg/2018/09/10/design-pattern-creational/"><strong>创建型模式</strong>中的<em>工厂模式</em>和<em>单例模式</em></a>。在第二篇文章中，又讨论了一下 <a href="https://swift.gg/2018/11/26/design-pattern-behavorial/"><strong>行为型模式</strong>中的<em>观察者模式</em>和<em>备忘录模式</em></a>。</p><a id="more"></a><p>在本文中，我会就结构型模式中的<strong>外观模式</strong>和<strong>适配器模式</strong>分别举一个例子。首先，我建议你先去阅读前面提到的两篇文章，这会有助于你更熟悉软件设计模式的一些概念。除了简短地介绍一下设计模式的组成，我不会再重复介绍所有关于设计模式的概念了。如果需要了解，都可以在前面写的 <a href="https://swift.gg/2018/09/10/design-pattern-creational/"><strong>第一篇</strong></a>、 <a href="https://swift.gg/2018/11/26/design-pattern-behavorial/"><strong>第二篇</strong></a> 中找到。</p><p>接下来的几节，我们先来简单回顾一下设计模式的通用概念。“Gang of Four” (“GoF”) Erich Gamma，Richard Helm，Ralph Johonson，和 John Vlissides 在他们“<a href="https://smile.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8/" target="_blank" rel="noopener"><strong>设计模式：面向对象软件设计复用的基本原理</strong></a>”的重要著作里整理了 23 种经典的设计模式。今天我们重点关注的是两种结构型设计模式：<strong>外观模式</strong>和<strong>适配器模式</strong>。</p><h2 id="值语义的面向协议编程"><a href="#值语义的面向协议编程" class="headerlink" title="值语义的面向协议编程"></a>值语义的面向协议编程</h2><p>你可能会发现世面上非常多设计模式教程的示例代码，仍然是基于面向对象编程原则（OOP）、引用语义和 <a href="http://iosbrain.com/blog/2018/06/07/swift-4-memory-management-via-arc-for-reference-types-classes/" target="_blank" rel="noopener"><strong>引用类型</strong></a>（classes）编写的。所以，我决定编写一套基于 <a href="https://www.appcoda.com/pop-vs-oop/" target="_blank" rel="noopener"><strong>面向协议编程原则</strong></a>（POP）、值语义和 <a href="https://developer.apple.com/videos/play/wwdc2015/414/" target="_blank" rel="noopener"><strong>值类型</strong></a>（structs）的设计模式系列教程。如果你已经看过了我之前写的两篇文章，我希望你还能够熟悉一下 OOP 和 POP，引用语义和值语义这些概念。如果你还不是特别熟悉，我强烈建议赶紧去了解一下这些主题。本文所举的例子是全部基于 POP 和值语义的。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是开发者用于管理软件复杂性极其重要的工具。作为常见的模板技术，它很好地对软件中类似的、重复出现的、容易识别的问题进行了概念化抽象。我们可以将它视作最佳实践，从而应用到日常中会遇到的那些编程场景中。举一个具体的例子，回想一下你在平常写代码过程中有多少次会使用或写了遵守 <a href="https://www.appcoda.com/design-pattern-behavorial/" target="_blank" rel="noopener"><strong>观察者设计模式</strong></a> 的代码吧。</p><p>在观察者模式中，被观察者（一般来说是一个关键资源）会给所有依赖于自己的观察者，广播通知其内部状态的变化。观察者必须告知被观察者自己想接收通知，换句话说，观察者必须订阅通知。用户授权的 iOS 弹窗推送通知，就是一个典型的观察者模式的例子。</p><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p>GoF 将 23 种设计模式归纳为三种类型，分别是“<a href="https://www.appcoda.com/design-pattern-creational/" target="_blank" rel="noopener"><strong>创建型</strong></a>”、“<a href="https://www.appcoda.com/design-pattern-behavorial/" target="_blank" rel="noopener"><strong>行为型</strong></a>”、“结构型”。本文会介绍两种<strong>结构型</strong>设计模式。先看一下结构这个词的定义：</p><blockquote><p>“以一种确定方式构建的事物以及实体中各部分元素之间不同关系的汇总。”<br>- <a href="https://www.merriam-webster.com/dictionary/structure" target="_blank" rel="noopener">https://www.merriam-webster.com/dictionary/structure</a></p></blockquote><p>结构型设计模式的主要作用是明确一段代码的功能，并说明如何使用。大部分的结构型设计模式可以通过编写易读接口，来实现对一段代码的简化使用。因为一段代码势必要与其它代码联系，如果要为代码段编写出良好的接口，必须明确清晰地定义代码之间的各种关系。</p><h2 id="外观设计模式"><a href="#外观设计模式" class="headerlink" title="外观设计模式"></a><em>外观</em>设计模式</h2><blockquote><p>“外观可以定义为特殊结构化的建筑物表面或者错误的、表面上的、人为的外形或效果”。<br>- <a href="https://www.merriam-webster.com/dictionary/facade" target="_blank" rel="noopener">https://www.merriam-webster.com/dictionary/facade</a></p></blockquote><p>大部分情况下，可以使用外观模式，为一组复杂接口创建一个简单接口。或许你已经写过“封装”代码。“封装”的意思就是对一段复杂代码的简化使用。</p><h3 id="外观设计模式的示例-app"><a href="#外观设计模式的示例-app" class="headerlink" title="外观设计模式的示例 app"></a><em>外观</em>设计模式的示例 app</h3><p>外观设计模式示例的 playground 文件，可以在 <a href="https://github.com/appcoda/swift-design-patterns/tree/master/Facade" target="_blank" rel="noopener"><strong>GitHub</strong></a> 找到。在这个例子里展示了，如何通过外观设计模式，来为沙盒文件系统创建一个简单的接口，供所有的 iOS app 使用。iOS 文件系统是一个庞大的操作系统子系统，功能包括创建、读取、删除、移动、重命名、拷贝文件和目录。允许获取和设置文件和目录的元数据，比如列出在指定目录下的所有文件。允许查看文件和目录的状态，比如某个指定文件是否可写。提供苹果推荐、预定义的目录名。实际上其包含的功能远远不止上面提到的这些。</p><p>由于 iOS 文件系统是一个拥有如此多特性和功能的宏大主题，因此也是一个非常好的例子，用来讲解如何通过外观设计模式来简化代码的使用。外观接口会废弃掉无关功能和杂乱代码的部分。另一方面，外观接口只会定义在某个具体 app 需要使用到的功能。或者在我的例子中，我将功能缩减到只有经常使用的那部分。这样做的好处是保证代码在不同 app 中都是可复用、可扩展，可维护的。</p><p>基于面向协议编程和值语义，我将 iOS 文件系统的主要特性进行了划分，从而将其变成可复用、可扩展的单元：协议和协议扩展。</p><p>我<a href="http://iosbrain.com/blog/2018/04/22/ios-file-management-with-filemanager-in-protocol-oriented-swift-4/" target="_blank" rel="noopener"><strong>将四个协议组合成一个结构体，这个结构体代表了可以在所有 iOS 应用中使用的沙盒 iOS 目录</strong></a>（还可以看 <a href="http://iosbrain.com/blog/2018/05/29/the-ios-file-system-in-depth/" target="_blank" rel="noopener"><strong>这篇文章</strong></a>）。因为未来你肯定会更多接触到更多面向协议编程和值语义相关的主题，要注意术语 <strong>composed</strong> 和 <strong>composition</strong> 在这里属于同义词。</p><p>除此之外，为了让你更专注于理解外观设计模式的使用，在后面的代码中，我省略了 Swift 错误处理和通用错误检查的代码。</p><h3 id="外观设计模式的示例代码"><a href="#外观设计模式的示例代码" class="headerlink" title="外观设计模式的示例代码"></a>外观设计模式的示例代码</h3><p>接下来就看看我的代码吧。先确保已经下载了我在 <a href="https://github.com/appcoda/swift-design-patterns/tree/master/Facade" target="_blank" rel="noopener"><strong>GitHub</strong></a> 上的 playground 文件。下面是苹果官方推荐的用于文件系统操作的预定义目录。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AppDirectories</span> : <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Documents</span> = <span class="string">"Documents"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Inbox</span> = <span class="string">"Inbox"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Library</span> = <span class="string">"Library"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Temp</span> = <span class="string">"tmp"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将文件操作限定在上述目录中，避免了复杂性，并遵循了人机界面指南的原则。</p><p>在探究文件操作的核心代码之前，先来看看使用外观设计模式所设计出来的接口吧。我创建了 <code>iOSAppFileSystemDirectory</code> 结构体，作为文件系统常用功能的简单可读接口。这个接口适用于 <code>AppDirectories</code> 枚举下的所有目录。事实上，我原本还可以加入诸如 <a href="https://developer.apple.com/documentation/foundation/filemanager/1414652-createsymboliclink" target="_blank" rel="noopener"><strong>符号化链接的创建</strong></a>，或者使用 <code>FileHandle</code> 类实现对文件的精细控制。但是在实际情况中，我几乎不太使用到这些功能，更重要的一点是，我想要保持代码的简洁性。</p><p>我创建了由四个协议组成的外观。（我知道你看到下面的代码中只遵循了三个协议，这其实是因为其中有一个协议继承自另一个协议）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iOSAppFileSystemDirectory</span> : <span class="title">AppFileManipulation</span>, <span class="title">AppFileStatusChecking</span>, <span class="title">AppFileSystemMetaData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> workingDirectory: <span class="type">AppDirectories</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(using directory: <span class="type">AppDirectories</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.workingDirectory = directory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(containing text: String, withName name: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> writeFile(containing: text, to: workingDirectory, withName: name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(withName name: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> readFile(at: workingDirectory, withName: name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deleteFile</span><span class="params">(withName name: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deleteFile(at: workingDirectory, withName: name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showAttributes</span><span class="params">(forFile named: String)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fullPath = buildFullPath(forFileName: named, inDirectory: workingDirectory)</span><br><span class="line">        <span class="keyword">let</span> fileAttributes = attributes(ofFile: fullPath)</span><br><span class="line">        <span class="keyword">for</span> attribute <span class="keyword">in</span> fileAttributes &#123;</span><br><span class="line">            <span class="built_in">print</span>(attribute)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">list</span><span class="params">()</span></span> &#123;</span><br><span class="line">        list(directory: getURL(<span class="keyword">for</span>: workingDirectory))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 完成结构体 iOSAppFileSystemDirectory 的定义</span></span><br></pre></td></tr></table></figure><p>下面是一些用于测试 <code>iOSAppFileSystemDirectory</code> 结构体的代码： </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iOSDocumentsDirectory = iOSAppFileSystemDirectory(using: .<span class="type">Documents</span>)</span><br><span class="line"></span><br><span class="line">iOSDocumentsDirectory.writeFile(containing: <span class="string">"New file created."</span>, withName: <span class="string">"myFile3.txt"</span>)</span><br><span class="line">iOSDocumentsDirectory.list()</span><br><span class="line">iOSDocumentsDirectory.readFile(withName: <span class="string">"myFile3.txt"</span>)</span><br><span class="line">iOSDocumentsDirectory.showAttributes(forFile: <span class="string">"myFile3.txt"</span>)</span><br><span class="line">iOSDocumentsDirectory.deleteFile(withName: <span class="string">"myFile3.txt"</span>)</span><br></pre></td></tr></table></figure><p>接下来的代码是在运行了 playground 文件中代码之后的控制台输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------------</span><br><span class="line">LISTING: /var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Facade-Design-Pattern-1C4BD3E3-E23C-4991-A344-775D5585D1D7/Documents</span><br><span class="line"></span><br><span class="line">File: &quot;myFile3.txt&quot;</span><br><span class="line">File: &quot;Shared Playground Data&quot;</span><br><span class="line"></span><br><span class="line">----------------------------</span><br><span class="line"></span><br><span class="line">File created with contents: New file created.</span><br><span class="line"></span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileType), value: NSFileTypeRegular)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFilePosixPermissions), value: 420)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileSystemNumber), value: 16777223)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileExtendedAttributes), value: &#123;</span><br><span class="line">    &quot;com.apple.quarantine&quot; = &lt;30303836 3b356238 36656364 373b5377 69667420 46616361 64652044 65736967 6e205061 74746572 6e3b&gt;;</span><br><span class="line">&#125;)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileReferenceCount), value: 1)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileSystemFileNumber), value: 24946094)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileGroupOwnerAccountID), value: 20)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileModificationDate), value: 2018-08-29 18:58:31 +0000)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileCreationDate), value: 2018-08-29 18:58:31 +0000)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileSize), value: 17)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileExtensionHidden), value: 0)</span><br><span class="line">(key: __C.FileAttributeKey(_rawValue: NSFileOwnerAccountID), value: 502)</span><br><span class="line"></span><br><span class="line">File deleted.</span><br></pre></td></tr></table></figure><p>我们来简单讨论下 <code>iOSAppFileSystemDirectory</code> 结构体所遵循的几个协议。<code>AppDirectoryNames</code> 协议和扩展定义和实现了以 <code>URL</code> 类型获取 <code>AppDirectories</code> 枚举中目录完整路径的方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentsDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inboxDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">libraryDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tempDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getURL</span><span class="params">(<span class="keyword">for</span> directory: AppDirectories)</span></span> -&gt; <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buildFullPath</span><span class="params">(forFileName name: String, inDirectory directory: AppDirectories)</span></span> -&gt; <span class="type">URL</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end protocol AppDirectoryNames</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentsDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask).first!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inboxDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask)[<span class="number">0</span>].appendingPathComponent(<span class="type">AppDirectories</span>.<span class="type">Inbox</span>.rawValue) <span class="comment">// "Inbox")</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">libraryDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: <span class="type">FileManager</span>.<span class="type">SearchPathDirectory</span>.libraryDirectory, <span class="keyword">in</span>: .userDomainMask).first!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tempDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.temporaryDirectory</span><br><span class="line">        <span class="comment">//urls(for: .documentDirectory, in: .userDomainMask)[0].appendingPathComponent(AppDirectories.Temp.rawValue) //"tmp")</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getURL</span><span class="params">(<span class="keyword">for</span> directory: AppDirectories)</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> directory &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Documents</span>:</span><br><span class="line">            <span class="keyword">return</span> documentsDirectoryURL()</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Inbox</span>:</span><br><span class="line">            <span class="keyword">return</span> inboxDirectoryURL()</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Library</span>:</span><br><span class="line">            <span class="keyword">return</span> libraryDirectoryURL()</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Temp</span>:</span><br><span class="line">            <span class="keyword">return</span> tempDirectoryURL()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buildFullPath</span><span class="params">(forFileName name: String, inDirectory directory: AppDirectories)</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getURL(<span class="keyword">for</span>: directory).appendingPathComponent(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end extension AppDirectoryNames</span></span><br></pre></td></tr></table></figure><p><code>AppFileStatusChecking</code> 协议和扩展封装了获取文件状态数据的方法。这些文件同样存储于 <code>AppDirectories</code> 枚举定义下的目录。通过“状态”，可以确定某个文件是否存在，是否可读等。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AppFileStatusChecking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isWritable</span><span class="params">(file at: URL)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isReadable</span><span class="params">(file at: URL)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">exists</span><span class="params">(file at: URL)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppFileStatusChecking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isWritable</span><span class="params">(file at: URL)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.isWritableFile(atPath: at.path) &#123;</span><br><span class="line">            <span class="built_in">print</span>(at.path)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(at.path)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isReadable</span><span class="params">(file at: URL)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.isReadableFile(atPath: at.path) &#123;</span><br><span class="line">            <span class="built_in">print</span>(at.path)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(at.path)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">exists</span><span class="params">(file at: URL)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.fileExists(atPath: at.path) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end extension AppFileStatusChecking</span></span><br></pre></td></tr></table></figure><p><code>AppFileSystemMetaData</code> 协议和扩展实现了列出目录内容和获取扩展文件的功能。 其目录也是定义在 <code>AppDirectories</code> 枚举下。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AppFileSystemMetaData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">list</span><span class="params">(directory at: URL)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">attributes</span><span class="params">(ofFile atFullPath: URL)</span></span> -&gt; [<span class="type">FileAttributeKey</span> : <span class="type">Any</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppFileSystemMetaData</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">list</span><span class="params">(directory at: URL)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> listing = <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.contentsOfDirectory(atPath: at.path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> listing.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\n----------------------------"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"LISTING: <span class="subst">\(at.path)</span>"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> listing &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"File: <span class="subst">\(file.debugDescription)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"----------------------------\n"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">attributes</span><span class="params">(ofFile atFullPath: URL)</span></span> -&gt; [<span class="type">FileAttributeKey</span> : <span class="type">Any</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.attributesOfItem(atPath: atFullPath.path)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//  end extension AppFileSystemMetaData</span></span><br></pre></td></tr></table></figure><p>最后是 <code>AppFileManipulation</code> 协议和扩展，封装了 <code>AppDirectories</code> 枚举目录下的所有文件操作方法，包括了读、写、删除、重命名、移动、拷贝修改文件扩展名等。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AppFileManipulation</span> : <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(containing: String, to path: AppDirectories, withName name: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(at path: AppDirectories, withName name: String)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deleteFile</span><span class="params">(at path: AppDirectories, withName name: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">renameFile</span><span class="params">(at path: AppDirectories, with oldName: String, to newName: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">moveFile</span><span class="params">(withName name: String, inDirectory: AppDirectories, toDirectory directory: AppDirectories)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copyFile</span><span class="params">(withName name: String, inDirectory: AppDirectories, toDirectory directory: AppDirectories)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">changeFileExtension</span><span class="params">(withName name: String, inDirectory: AppDirectories, toNewExtension newExtension: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppFileManipulation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(containing: String, to path: AppDirectories, withName name: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filePath = getURL(<span class="keyword">for</span>: path).path + <span class="string">"/"</span> + name</span><br><span class="line">        <span class="keyword">let</span> rawData: <span class="type">Data</span>? = containing.data(using: .utf8)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.createFile(atPath: filePath, contents: rawData, attributes: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(at path: AppDirectories, withName name: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filePath = getURL(<span class="keyword">for</span>: path).path + <span class="string">"/"</span> + name</span><br><span class="line">        <span class="keyword">let</span> fileContents = <span class="type">FileManager</span>.<span class="keyword">default</span>.contents(atPath: filePath)</span><br><span class="line">        <span class="keyword">let</span> fileContentsAsString = <span class="type">String</span>(bytes: fileContents!, encoding: .utf8)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"File created with contents: <span class="subst">\(fileContentsAsString!)</span>\n"</span>)</span><br><span class="line">        <span class="keyword">return</span> fileContentsAsString!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deleteFile</span><span class="params">(at path: AppDirectories, withName name: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filePath = buildFullPath(forFileName: name, inDirectory: path)</span><br><span class="line">        <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.removeItem(at: filePath)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\nFile deleted.\n"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">renameFile</span><span class="params">(at path: AppDirectories, with oldName: String, to newName: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> oldPath = getURL(<span class="keyword">for</span>: path).appendingPathComponent(oldName)</span><br><span class="line">        <span class="keyword">let</span> newPath = getURL(<span class="keyword">for</span>: path).appendingPathComponent(newName)</span><br><span class="line">        <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.moveItem(at: oldPath, to: newPath)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// highlights the limitations of using return values</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">moveFile</span><span class="params">(withName name: String, inDirectory: AppDirectories, toDirectory directory: AppDirectories)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> originURL = buildFullPath(forFileName: name, inDirectory: inDirectory)</span><br><span class="line">        <span class="keyword">let</span> destinationURL = buildFullPath(forFileName: name, inDirectory: directory)</span><br><span class="line">        <span class="comment">// warning: constant 'success' inferred to have type '()', which may be unexpected</span></span><br><span class="line">        <span class="comment">// *let success =*</span></span><br><span class="line">        <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.moveItem(at: originURL, to: destinationURL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copyFile</span><span class="params">(withName name: String, inDirectory: AppDirectories, toDirectory directory: AppDirectories)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> originURL = buildFullPath(forFileName: name, inDirectory: inDirectory)</span><br><span class="line">        <span class="keyword">let</span> destinationURL = buildFullPath(forFileName: name, inDirectory: directory)</span><br><span class="line">        <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.copyItem(at: originURL, to: destinationURL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">changeFileExtension</span><span class="params">(withName name: String, inDirectory: AppDirectories, toNewExtension newExtension: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> newFileName = <span class="type">NSString</span>(string:name)</span><br><span class="line">        newFileName = newFileName.deletingPathExtension <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">        newFileName = (newFileName.appendingPathExtension(newExtension) <span class="keyword">as</span> <span class="type">NSString</span>?)!</span><br><span class="line">        <span class="keyword">let</span> finalFileName:<span class="type">String</span> =  <span class="type">String</span>(newFileName)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> originURL = buildFullPath(forFileName: name, inDirectory: inDirectory)</span><br><span class="line">        <span class="keyword">let</span> destinationURL = buildFullPath(forFileName: finalFileName, inDirectory: inDirectory)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>! <span class="type">FileManager</span>.<span class="keyword">default</span>.moveItem(at: originURL, to: destinationURL)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end extension AppFileManipulation</span></span><br></pre></td></tr></table></figure><h2 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a><em>适配器</em>设计模式</h2><blockquote><p>“适配”的含义是“通过修改让一个事物更适合（用于新用途）。”<br>- <a href="https://www.merriam-webster.com/dictionary/adapts" target="_blank" rel="noopener">https://www.merriam-webster.com/dictionary/adapts</a></p></blockquote><blockquote><p>“适配器”的含义是“用于适配不在初始使用意图范围内设备的一种附加装置。”<br>- <a href="https://www.merriam-webster.com/dictionary/adapter" target="_blank" rel="noopener">https://www.merriam-webster.com/dictionary/adapter</a></p></blockquote><p>适配器设计模式的作用是在不修改已有代码库 “A” 的前提下，仍旧可以使用与代码库 “A” 不兼容的代码库 “B”，并保证 “A” 可以正常工作。我们可以创建适配器来保证 “A” 和 “B” 可以一起工作。其中一定要牢记的原则是代码库 “A” 是不能被修改的。（这是因为修改会破坏原有代码或者我们根本就没有这段源代码）</p><h3 id="适配器设计模式示例-app"><a href="#适配器设计模式示例-app" class="headerlink" title="适配器设计模式示例 app"></a><em>适配器</em>设计模式示例 app</h3><p>适配器的 playground 文件，可以在 <a href="https://github.com/appcoda/swift-design-patterns/tree/master/Adapter" target="_blank" rel="noopener"><strong>GitHub</strong></a> 上找到。在这部分代码中，我们基于 iOS 文件系统进行适配器模式的讨论，并基于 iOS 文件系统设计了一个适配器模式的例子。之前一章，我们已经实现了将 iOS 文件系统中所有目录和文件的路径表示为 <code>URL</code> 实例。想象一下下面的场景，在原有工程中已经存在了大量关于 iOS 文件系统的代码，但是所有目录和文件的路径都表示成了字符串形式。那我们就必须要让基于 URL 和基于 String 的代码可以协同工作。</p><h4 id="适配器设计模式的示例代码"><a href="#适配器设计模式的示例代码" class="headerlink" title="适配器设计模式的示例代码"></a><em>适配器</em>设计模式的示例代码</h4><p>接下来就看看代码吧。先确保已经下载了在 <a href="https://github.com/appcoda/swift-design-patterns/tree/master/Adapter" target="_blank" rel="noopener"><strong>GitHub</strong></a> 上的 playground 文件。为了在接下来的分析中更加专注于适配器模式的讨论，下面会使用简化版本的 <code>AppDirectories</code> 枚举和 <code>AppDirectoryNames</code> 协议和扩展。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AppDirectories</span> : <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Documents</span> = <span class="string">"Documents"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Temp</span> = <span class="string">"tmp"</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentsDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tempDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentsDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask).first!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tempDirectoryURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>.<span class="keyword">default</span>.temporaryDirectory</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种方法是创建一个“专用”适配器。这个适配器会返回字符串路径，这些路径全部归属于在 <code>AppDirectories</code> 下的目录和文件。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 专用适配器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iOSFile</span> : <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fileName: <span class="type">URL</span></span><br><span class="line">    <span class="keyword">var</span> fullPathInDocuments: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> documentsDirectoryURL().appendingPathComponent(fileName.absoluteString).path</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fullPathInTemporary: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tempDirectoryURL().appendingPathComponent(fileName.absoluteString).path</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> documentsStringPath: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> documentsDirectoryURL().path</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> temporaryStringPath: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tempDirectoryURL().path</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">init</span>(fileName: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fileName = <span class="type">URL</span>(string: fileName)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一部分是用于测试 <code>iOSFile</code> “专用”适配器的代码，请注意代码中的注释。 </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iOSfile = iOSFile(fileName: <span class="string">"myFile.txt"</span>)</span><br><span class="line">iOSfile.fullPathInDocuments</span><br><span class="line">iOSfile.documentsStringPath</span><br><span class="line"> </span><br><span class="line">iOSfile.fullPathInTemporary</span><br><span class="line">iOSfile.temporaryStringPath</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过 `AppDirectoryNames` 协议，仍然能够访问到 URL</span></span><br><span class="line">iOSfile.documentsDirectoryURL()</span><br><span class="line">iOSfile.tempDirectoryURL()</span><br></pre></td></tr></table></figure><p>最后是 playground 文件中每一行代码对应的右侧输出，这些输出代表了运行时每一行代码的值。参照上一段代码，我们可以进行逐行对照。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iOSFile</span><br><span class="line">&quot;/var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Adapter-Design-Pattern-0A71F81A-9388-41F5-ACBE-52A1A61A9B99/Documents/myFile.txt&quot;</span><br><span class="line">&quot;/var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Adapter-Design-Pattern-0A71F81A-9388-41F5-ACBE-52A1A61A9B99/Documents&quot;</span><br><span class="line"> </span><br><span class="line">&quot;/Users/softwaretesting/Library/Developer/XCPGDevices/52E1A81A-98AF-42DE-ADCF-E69AC8FA2791/data/Containers/Data/Application/F08EFF4F-8C4F-4BB7-B220-980E16344F18/tmp/myFile.txt&quot;</span><br><span class="line">&quot;/Users/softwaretesting/Library/Developer/XCPGDevices/52E1A81A-98AF-42DE-ADCF-E69AC8FA2791/data/Containers/Data/Application/F08EFF4F-8C4F-4BB7-B220-980E16344F18/tmp&quot;</span><br><span class="line"> </span><br><span class="line">file:///var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Adapter-Design-Pattern-0A71F81A-9388-41F5-ACBE-52A1A61A9B99/Documents/</span><br><span class="line">file:///Users/softwaretesting/Library/Developer/XCPGDevices/52E1A81A-98AF-42DE-ADCF-E69AC8FA2791/data/Containers/Data/Application/F08EFF4F-8C4F-4BB7-B220-980E16344F18/tmp/</span><br></pre></td></tr></table></figure><p>另外，我还倾向为字符串类型的路径设计一个适配器协议。这样就可以很方便地使用<code>字符串</code>路径来替代 <code>URL</code> 路径。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Protocol-oriented approach</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AppDirectoryAndFileStringPathNamesAdpater</span> : <span class="title">AppDirectoryNames</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> fileName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> workingDirectory: <span class="type">AppDirectories</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentsDirectoryStringPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tempDirectoryStringPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fullPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// end protocol AppDirectoryAndFileStringPathAdpaterNames</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDirectoryAndFileStringPathNamesAdpater</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentsDirectoryStringPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> documentsDirectoryURL().path</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tempDirectoryStringPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tempDirectoryURL().path</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fullPath</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> workingDirectory &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Documents</span>:</span><br><span class="line">            <span class="keyword">return</span> documentsDirectoryStringPath() + <span class="string">"/"</span> + fileName</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Temp</span>:</span><br><span class="line">            <span class="keyword">return</span> tempDirectoryStringPath() + <span class="string">"/"</span> + fileName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125; <span class="comment">// end extension AppDirectoryAndFileStringPathNamesAdpater</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AppDirectoryAndFileStringPathNames</span> : <span class="title">AppDirectoryAndFileStringPathNamesAdpater</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> fileName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> workingDirectory: <span class="type">AppDirectories</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(fileName: <span class="type">String</span>, workingDirectory: <span class="type">AppDirectories</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fileName = fileName</span><br><span class="line">        <span class="keyword">self</span>.workingDirectory = workingDirectory</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// end struct AppDirectoryAndFileStringPathNames</span></span><br></pre></td></tr></table></figure><p>接下来是用于测试 <code>AppDirectoryAndFileStringPathNames</code> 结构体的代码。这个结构体遵守了 <code>AppDirectoryAndFileStringPathNamesAdpater</code> 适配器协议。协议继承自 <code>AppDirectoryNames</code> 协议。注意在代码中的两段注释。 </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> appFileDocumentsDirectoryPaths = <span class="type">AppDirectoryAndFileStringPathNames</span>(fileName: <span class="string">"myFile.txt"</span>, workingDirectory: .<span class="type">Documents</span>)</span><br><span class="line">appFileDocumentsDirectoryPaths.fullPath()</span><br><span class="line">appFileDocumentsDirectoryPaths.documentsDirectoryStringPath()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过 `AppDirectoryNames` 协议仍然可以访问 URL</span></span><br><span class="line">appFileDocumentsDirectoryPaths.documentsDirectoryURL()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> appFileTemporaryDirectoryPaths = <span class="type">AppDirectoryAndFileStringPathNames</span>(fileName: <span class="string">"tempFile.txt"</span>, workingDirectory: .<span class="type">Temp</span>)</span><br><span class="line">appFileTemporaryDirectoryPaths.fullPath()</span><br><span class="line">appFileTemporaryDirectoryPaths.tempDirectoryStringPath()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过 `AppDirectoryNames` 协议仍然可以访问 URL</span></span><br><span class="line">appFileTemporaryDirectoryPaths.tempDirectoryURL()</span><br></pre></td></tr></table></figure><p>最后是在 playground 文件中右侧的输出。每一行代表了运行时的代码值，下面的输出同样和上一段代码是逐行对应的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppDirectoryAndFileStringPathNames</span><br><span class="line">&quot;/var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Adapter-Design-Pattern-A3DE7CC8-D60F-4448-869F-2A19556C62B2/Documents/myFile.txt&quot;</span><br><span class="line">&quot;/var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Adapter-Design-Pattern-A3DE7CC8-D60F-4448-869F-2A19556C62B2/Documents&quot;</span><br><span class="line"> </span><br><span class="line">file:///var/folders/5_/kd8__nv1139__dq_3nfvsmhh0000gp/T/com.apple.dt.Xcode.pg/containers/com.apple.dt.playground.stub.iOS_Simulator.Swift-Adapter-Design-Pattern-A3DE7CC8-D60F-4448-869F-2A19556C62B2/Documents/</span><br><span class="line"> </span><br><span class="line">AppDirectoryAndFileStringPathNames</span><br><span class="line">&quot;/Users/softwaretesting/Library/Developer/XCPGDevices/52E1A81A-98AF-42DE-ADCF-E69AC8FA2791/data/Containers/Data/Application/CF3D4156-E773-4BC4-B117-E7BDEFA3F34C/tmp/tempFile.txt&quot;</span><br><span class="line">&quot;/Users/softwaretesting/Library/Developer/XCPGDevices/52E1A81A-98AF-42DE-ADCF-E69AC8FA2791/data/Containers/Data/Application/CF3D4156-E773-4BC4-B117-E7BDEFA3F34C/tmp&quot;</span><br><span class="line"> </span><br><span class="line">file:///Users/softwaretesting/Library/Developer/XCPGDevices/52E1A81A-98AF-42DE-ADCF-E69AC8FA2791/data/Containers/Data/Application/CF3D4156-E773-4BC4-B117-E7BDEFA3F34C/tmp/</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>设计模式不仅有利于代码复用，还能保证代码是不变、易读、松耦合的，从而提高了可维护性和拓展性。当重复出现并且能加以抽象的功能在你的 app 中出现的时候，我希望你能应用一下设计模式，并 <a href="http://iosbrain.com/blog/2018/01/13/building-swift-4-frameworks-and-including-them-in-your-apps-xcode-9/" target="_blank" rel="noopener"><strong>封装进框架</strong></a> 中。这样子你只需要写一次代码，就可以一直复用啦。</p><p>再次感谢大家来 AppCoda 给我捧场。享受工作，坚持学习，下次再见吧！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Andrew Jaffee，&lt;a href=&quot;https://www.appcoda.com/design-pattern-structural/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-09-04&lt;br&gt;译者：&lt;a href=&quot;https://www.jianshu.com/u/076cc5e18bb8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;郑一一&lt;/a&gt;；校对：&lt;a href=&quot;https://bignerdcoding.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigNerdCoding&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;，&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;本文是我的设计模式系列教程的第三篇。在第一篇文章中，我介绍了 &lt;a href=&quot;https://swift.gg/2018/09/10/design-pattern-creational/&quot;&gt;&lt;strong&gt;创建型模式&lt;/strong&gt;中的&lt;em&gt;工厂模式&lt;/em&gt;和&lt;em&gt;单例模式&lt;/em&gt;&lt;/a&gt;。在第二篇文章中，又讨论了一下 &lt;a href=&quot;https://swift.gg/2018/11/26/design-pattern-behavorial/&quot;&gt;&lt;strong&gt;行为型模式&lt;/strong&gt;中的&lt;em&gt;观察者模式&lt;/em&gt;和&lt;em&gt;备忘录模式&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
    
      <category term="Design Patterns" scheme="https://swift.gg/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的设计模式 #2 观察者模式与备忘录模式</title>
    <link href="https://swift.gg/2018/11/26/design-pattern-behavorial/"/>
    <id>https://swift.gg/2018/11/26/design-pattern-behavorial/</id>
    <published>2018-11-26T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://www.appcoda.com/design-pattern-behavorial/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-08-06<br>译者：<a href="https://dingtz.com/" target="_blank" rel="noopener">jojotov</a>；校对：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>本次教程是 AppCoda <a href="https://swift.gg/2018/09/10/design-pattern-creational/">上周开启</a> 的设计模式系列的第二期。在软件设计领域的四位大师级人物（GoF，又称“四人帮”或“Gang of Four”） —— Erich Gamma, Richard Helm, Ralph Johnson 和 John Vlissides 所著的 《设计模式：可复用面向对象软件的基础》一书中，首次对软件设计中总共 23 种设计模式进行了定义和归类，并对它们作了专业阐述。今天，我们将聚焦于其中两个行为型设计模式 —— “观察者模式” 和 “备忘录模式”。</p><a id="more"></a><p>软件开发领域致力于对真实世界的场景进行建模，并期望能创造出一系列工具来提高人类对这些场景的理解与体验。与 10 年前相比，一些类似银行应用和辅助购物应用（如亚马逊或 eBay 的 iOS 客户端应用）的财务类工具的出现，无疑让顾客们的生活变得更加简单。当我们回顾软件开发的发展历程，定会感叹我们在软件开发领域上走过了漫长而又成功的道路。如今，软件应用的功能普遍变得强大且易用，但对于开发者来说，开发这些软件却变得 <a href="http://iosbrain.com/blog/2018/04/29/controlling-chaos-why-you-should-care-about-adding-error-checking-to-your-ios-apps/#chaos" target="_blank" rel="noopener">越来越复杂</a>。</p><p>开发者们为了管理软件的复杂性，创造了一系列的最佳实践 —— 例如面向对象编程、面向协议编程、值语义、局部推理（Local Reasoning）、把大块的代码切分成一系列小块的代码并附上友好的接口（如 Swift 中的扩展）、语法糖等。但在众多的最佳实践之中，有一个非常重要且值得我们关注的最佳实践并没有在上文中提及 —— 那就是设计模式的使用。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>对于开发者来说，设计模式是管理代码复杂度问题的一个极其重要的工具。我们理解设计模式最好的办法，就是把设计模式概念化为 —— 有固定模版的通用技术，每个设计模式都旨在解决相应的一个反复出现且易于辨别的特定问题。你可以把设计模式看作是一系列最佳实践的集合，它们可以用于一些经常出现的编码场景：例如如何利用一系列有关联的对象创建出新的对象，并且不需要去理解原本那一系列对象中“又臭又长”的代码实现。设计模式最重要的意义是其可以应用于那些常见的场景。同时，由于设计模式都是已经创造出来的固定模式，拿来即用的特质令它具有很高的易用性。为了能更好的理解设计模式，我们来看一个例子：</p><p>设计模式并不能解决一些非常具体的问题。例如 “如何在 Swift 中遍历一个包含 11 个整型（<code>Int</code>）的 数组”之类的的问题。我们从一个例子来更好地理解为什么设计模式不能解决此类具体问题 —— GoF 定义了<em>迭代器</em>模式，为“便捷地遍历集合的所有元素，而不需要知道集合中元素的类型” 的问题提出通用的解决方案，。因此，我们不能单纯地把设计模式当作某种语言的代码，它只是用于解决通用软件开发场景的规则和指引。</p><p>我曾经在 AppCoda 中讨论过 <a href="https://www.appcoda.com/mvvm-vs-mvc/" target="_blank" rel="noopener">“Model-View-ViewModel” 或 “MVVM”</a>  设计模式 —— 当然也少不了那个 Apple 和 众多 iOS 开发者们长期喜爱着的经典设计模式 <a href="https://www.appcoda.com/mvvm-vs-mvc/" target="_blank" rel="noopener">“Model-View-Controller” 或 “MVC”</a> </p><p>这两种设计模式通常来说会应用于<em>整个应用层面</em>。MVVM 和 MVC 可以看作是<em>架构层面上</em>的设计模式，它们主要的作用可以简单分成四个方面：隔离用户界面（UI）与应用的数据；隔离用户界面（UI）与负责展示逻辑的代码；隔离应用的数据与核心数据处理逻辑；隔离应用的数据与业务逻辑。GoF 的设计模式都具有特殊性，它们都旨在解决一些在应用的<em>代码库中</em>较为特别的问题。你可能会在开发一个应用的时候用到好几个 GoF 的设计模式。同时你需要记得设计模式并不只是一些具体的代码实例，它们解决的是一些更抽象层面上的问题（希望你没忘记上面的<em>迭代器</em>例子）。除此之外我还想提及一个没有在 GoF 列出的 23 个设计模式之中，但却是设计模式的 <a href="https://www.appcoda.com/swift-delegate/" target="_blank" rel="noopener">典型例子</a> —— 代理模式。</p><p>虽然 GoF 关于设计模式的书已经被众多开发者视为圣经般的存在，但仍存在一些对其批判的声音。我们会在本文结尾的部分讨论这个问题。</p><h2 id="设计模式类别"><a href="#设计模式类别" class="headerlink" title="设计模式类别"></a>设计模式类别</h2><p>GoF 把他们提出的 23 种设计模式整理到了 3 种大的类别中：“创建型模式”、“结构型模式”以及“行为型模式”。本次的教程会讨论<em>行为型模式</em>类别中的两种设计模式。行为型模式的主要作用是对类和结构体（参与者）的行为赋予安全性、合理性，以及定义一些统一的规则、统一的的形式和最佳实践。对于整个应用中的参与者，我们都希望有一个良好的、统一的、并且可预测的行为。同时，我们不仅希望参与者本身拥有良好的行为，也希望不同的参与者之间的交互/通信可以拥有良好的行为。对于参与者的行为评估，其时机应该在编译之前以及编译时 —— 我通常把这段时间称之为“设计时间”，以及在运行时 —— 此时我们会有大量的类和结构体的实例在各司其职或与其他实例交互/通信。由于实例间的通信会导致软件复杂度的增加，因此制定一系列关于一致性、高效率和安全通信的规则是极为重要的，但与此同时，在构建每个单独的参与者时，这个概念不应以任何方式降低设计的质量。由于需要非常着重于行为，我们必须牢记一点 —— 在赋予参与者职责时必须使用一致的模式。</p><p>在高谈阔论太多理论之前，让我先说明一下本次教程中你会有哪些收获，同时所有的相关实践代码我都会用 Swift 来实现。在本次教程中，我们会了解到如何能够通过一致地赋予职责来维持参与者的状态。我们会了解到如何一致地赋予职责给一个参与者，让他能够发送通知给其他观察者。与之对应，我们也会了解到如何一致地赋予职责给观察者们注册通知。</p><p>当你讨论设计模式时，你应该把一致性当成最显而易见的基本概念。在 <a href="https://www.appcoda.com/design-pattern-creational/" target="_blank" rel="noopener">上周的推送</a> 中，我们着重讨论了一个概念：<a href="http://iosbrain.com/blog/2017/02/26/intro-to-object-oriented-principles-in-swift-3-via-a-message-box-class-hierarchy/#advantages" target="_blank" rel="noopener">高复杂度（封装）</a>。你必须把这个概念当作中心思想牢记于心，因为它会随着我们更深入地讨论设计模式而出现地越发频繁。举个例子，面向对象（OOP）中的众多类，可以在不需要开发者知道任何其内部实现的前提下，提供非常复杂、成熟且强大的功能。同样， Swift 的 <a href="https://www.appcoda.com/pop-vs-oop/" target="_blank" rel="noopener">面向协议编程</a> 也是一项对于控制复杂度来说极为重要的新技术。对开发者来说，想要管理好 <a href="http://iosbrain.com/blog/2018/01/02/understanding-swift-4-generics-and-applying-them-to-your-code/#complexity" target="_blank" rel="noopener">复杂度</a> 是一件异常困难的事情，但我们现在即将把这头野兽驯服！</p><h2 id="关于此教程的提醒"><a href="#关于此教程的提醒" class="headerlink" title="关于此教程的提醒"></a>关于此教程的提醒</h2><p>在这次的教程中，我决定把文字聚焦于对示例代码的解释。我将对今天所要介绍的设计模式概念进行一些简单明了的陈述，但同时为了能够让你更好地理解我所分享的技术，希望你可以认真看看代码和注释。毕竟作为一名程序员，如果你只能谈论代码而不能编写代码，那你可能会在很多面试中失利 —— 因为你还不够硬核。</p><p>你也许会留意到，我对与行为型设计模式的定义是遵循于苹果的 <a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html" target="_blank" rel="noopener">文档规范</a>:</p><blockquote><p>传统意义上来说，我们视一个类的实例为一个对象。虽然如此，但相对于其他语言而言，Swift 中的结构体和类在功能上非常相似，且本章节大部分内容描述了类或者结构体实例的功能。因此，我们使用更为通用的描述——实例。</p></blockquote><p>在设计时，我把对类和结构体的任何引用都描述为“参与者”。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>在使用苹果的移动设备时，观察者模式可能是贯穿整个应用使用过程的东西 —— 你应该在编写 iOS 应用时也发现了这一点。在我生活的地方，每当下雨天的时候，包括我在内的很大一部分人都会收到 iPhone 上的通知。不管是锁屏的状态还是解锁的状态，只要下起雨来，你都会收到一条类似下面这样的通知：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/08/PushNotification.png" alt="PushNotification demo"></p><p>作为所有通知的<em>源头</em>，苹果会代表国家气象局（National Weather Service）向<em>成千上万</em>的 iPhone 用户发送（广播）通知，提醒他们在其区域内是否有洪水灾害的风险。更具体一点地在 iOS 应用层级上说，当某一个实例（也就是被观察者）的状态发生改变时，它会通知其他（不止一个）的被称为<em>观察者</em>的实例，告诉他们自己的某个状态发生了变化。所有参与此次广播通信的实例都不需要知道除了自身以外的任何其他实例。这是一个关于 <a href="https://www.webopedia.com/TERM/L/loose_coupling.html" target="_blank" rel="noopener">松耦合</a> 的绝佳示例。</p><p>被观察的实例（通常是一个重要的资源）会广播关于自身状态改变的通知给其他众多观察者实例。对这些状态改变有兴趣的观察者必须通过订阅来获取关于状态改变通知。</p><p>这次我们不得不说苹果还是很靠谱的，iOS 已经内置了一个广为人知的用于观察者模式的特性：<a href="https://developer.apple.com/documentation/foundation/notificationcenter" target="_blank" rel="noopener">NotificationCenter</a>。在这里我不会对其作过多介绍，读者可自行在 <a href="http://iosbrain.com/blog/2018/02/09/nsnotificationcenter-in-swift-4-intra-app-communication-sending-receiving-listening-stop-listening-for-messages/" target="_blank" rel="noopener">这里</a> 学习相关内容。</p><h3 id="观察者模式用例"><a href="#观察者模式用例" class="headerlink" title="观察者模式用例"></a>观察者模式用例</h3><p>我的观察者模式示例项目展示了这种广播类型的通信是如何工作的，你可以在 <a href="https://github.com/appcoda/Observer-Pattern-Swift" target="_blank" rel="noopener">Github 上找到它</a>。</p><p>假设我们有一个工具来监视网络连接状况，并对已连接或未连接的状态作出响应。这个工具我们可以称之为广播者。为了实现此工具，你需要一个参与者遵循我提供的 <code>ObservedProtocol</code> 协议。虽然我知道这么做并不太符合苹果的 iOS Human Interface Guideline 的建议，但我为了更好地演示观察者模式，我需要以网络状况作为仅有的一个关键资源。</p><p>假设现在有许多个不同的观察者实例全都向被观察的对象订阅了关于网络连接状况的通知，例如一个图片下载类，一个通过 REST API 验证用户资格的登录业务实例，以及一个应用内浏览器。为了实现这些，你需要创建多个继承于我提供的 <code>Observer</code> 抽象类（此基类同时遵循 <code>ObserverProtocol</code> 协议）的自定义子类。（我稍后会解释为何我会把我关于观察者的示例代码放在一个类中）。</p><p>为了实现我示例应用中的观察者们，我创建了一个 <code>NetworkConnectionHandler</code> 类。当这个类的具体实例接收到 <code>NetworkConnectionStatus.connected</code> 通知时，这些实例会把几个视图变成绿色；当接收到 <code>NetworkConnectionStatus.disconnected</code> 通知时，会把视图变成红色。</p><p>下面是我的代码在 iPhone 8 Plus 设备上运行的效果：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/08/ObserverAppDemo.gif" alt="img"></p><p>上面的运行过程中，Xcode 控制台的输出如下：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/08/ObserverAppConsoleOutput.gif" alt="img"></p><h3 id="观察者模式应用的示例代码"><a href="#观察者模式应用的示例代码" class="headerlink" title="观察者模式应用的示例代码"></a>观察者模式应用的示例代码</h3><p>关于我上面所说的代码，你可以在项目中的 <code>Observable.swift</code> 文件找到。每段代码我都加上了详细的注释。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义通知名常量。</span></span><br><span class="line"><span class="comment">// 使用常量作为通知名，不要使用字符串或者数字。</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Notification</span>.<span class="title">Name</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> networkConnection = <span class="type">Notification</span>.<span class="type">Name</span>(<span class="string">"networkConnection"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> batteryStatus = <span class="type">Notification</span>.<span class="type">Name</span>(<span class="string">"batteryStatus"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> locationChange = <span class="type">Notification</span>.<span class="type">Name</span>(<span class="string">"locationChange"</span>)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义网络状态常量。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NetworkConnectionStatus</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> connected</span><br><span class="line">    <span class="keyword">case</span> disconnected</span><br><span class="line">    <span class="keyword">case</span> connecting</span><br><span class="line">    <span class="keyword">case</span> disconnecting</span><br><span class="line">    <span class="keyword">case</span> error</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义 userInfo 中的 key 值。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">StatusKey</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> networkStatusKey</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此协议定义了*观察者*的基本结构。</span></span><br><span class="line"><span class="comment">// 观察者即一些实体的集合，它们的操作严格依赖于其他实体的状态。</span></span><br><span class="line"><span class="comment">// 遵循此协议的实例会向某些重要的实体/资源*订阅*并*接收*通知。</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ObserverProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> statusValue: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> statusKey: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> notificationOfInterest: <span class="type">Notification</span>.<span class="type">Name</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">unsubscribe</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handleNotification</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此模版类抽象如何*订阅*和*接受*重要实体/资源的通知的所有必要细节。</span></span><br><span class="line"><span class="comment">// 此类提供了一个钩子方法（handleNotification()），</span></span><br><span class="line"><span class="comment">// 所有的子类可以通过此方法在接收到特定通知时进行各种需要的操作。</span></span><br><span class="line"><span class="comment">// 此类基为一个*抽象*类，并不会在编译时被检测，但这似乎是一个异常场景。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span>: <span class="title">ObserverProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此变量与 notificationOfInterest 通知关联。</span></span><br><span class="line">    <span class="comment">// 使用字符串以尽可能满足需要。</span></span><br><span class="line">    <span class="keyword">var</span> statusValue: <span class="type">String</span></span><br><span class="line">    <span class="comment">// 通知的 userInfo 中的 key 值，</span></span><br><span class="line">    <span class="comment">// 通过此 key 值读取到特定的状态值并存储到 statusValue 变量。</span></span><br><span class="line">    <span class="comment">// 使用字符串以尽可能满足需要。</span></span><br><span class="line">    <span class="keyword">let</span> statusKey: <span class="type">String</span></span><br><span class="line">    <span class="comment">// 此类所注册的通知名。</span></span><br><span class="line">    <span class="keyword">let</span> notificationOfInterest: <span class="type">Notification</span>.<span class="type">Name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过传入的通知名和需要观察的状态的 key 值进行初始化。</span></span><br><span class="line">    <span class="comment">// 初始化时会注册/订阅/监听特定的通知并观察特定的状态。</span></span><br><span class="line">    <span class="keyword">init</span>(statusKey: <span class="type">StatusKey</span>, notification: <span class="type">Notification</span>.<span class="type">Name</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.statusValue = <span class="string">"N/A"</span></span><br><span class="line">        <span class="keyword">self</span>.statusKey = statusKey.rawValue</span><br><span class="line">        <span class="keyword">self</span>.notificationOfInterest = notification</span><br><span class="line">        </span><br><span class="line">        subscribe()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向 NotificationCenter 注册 self(this) 来接收所有存储在 notificationOfInterest 中的通知。</span></span><br><span class="line">    <span class="comment">// 当接收到任意一个注册的通知时，会调用 receiveNotification(_:) 方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(receiveNotification(<span class="number">_</span>:)), name: notificationOfInterest, object: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在不需要监听时注销所有已注册的通知是一个不错的做法，</span></span><br><span class="line">    <span class="comment">// 但这主要是由于历史原因造成的，iOS 9.0 之后 OS 系统会自动做一些清理。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">unsubscribe</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>, name: notificationOfInterest, object: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在任意一个 notificationOfInterest 所定义的通知接收到时调用。</span></span><br><span class="line">    <span class="comment">// 在此方法中可以根据所观察的重要资源的改变进行任意操作。</span></span><br><span class="line">    <span class="comment">// 此方法**必须有且仅有一个参数（NSNotification 实例）。**</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">receiveNotification</span><span class="params">(<span class="number">_</span> notification: Notification)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> userInfo = notification.userInfo, <span class="keyword">let</span> status = userInfo[statusKey] <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">            </span><br><span class="line">            statusValue = status</span><br><span class="line">            handleNotification()</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Notification <span class="subst">\(notification.name)</span> received; status: <span class="subst">\(status)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// receiveNotification 方法结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// **必须重写此方法；且必须继承此类**</span></span><br><span class="line">    <span class="comment">// 我使用了些"技巧"来让此类达到抽象类的形式，因此你可以在子类中做其他任何事情而不需要关心关于 NotificationCenter 的细节。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handleNotification</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"ERROR: You must override the [handleNotification] method."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构时取消对 Notification 的关联，此时已经不需要进行观察了。</span></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Observer unsubscribing from notifications."</span>)</span><br><span class="line">        unsubscribe()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// Observer 类结束</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 一个具体观察者的例子。</span></span><br><span class="line"><span class="comment">// 通常来说，会有一系列（许多？）的观察者都会监听一些单独且重要的资源发出的通知。</span></span><br><span class="line"><span class="comment">// 需要注意此类已经简化了实现，并且可以作为所有通知的 handler 的模板。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkConnectionHandler</span>: <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> view: <span class="type">UIView</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 你可以创建任意类型的构造器，只需要调用 super.init 并传入合法且可以配合 NotificationCenter 使用的通知。</span></span><br><span class="line">    <span class="keyword">init</span>(view: <span class="type">UIView</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.view = view</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(statusKey: .networkStatusKey, notification: .networkConnection)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// **必须重写此方法**</span></span><br><span class="line">    <span class="comment">// 此方法中可以加入任何处理通知的逻辑。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">handleNotification</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> statusValue == <span class="type">NetworkConnectionStatus</span>.connected.rawValue &#123;</span><br><span class="line">            view.backgroundColor = <span class="type">UIColor</span>.green</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            view.backgroundColor = <span class="type">UIColor</span>.red</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// handleNotification() 结束</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// NetworkConnectionHandler 结束</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 一个被观察者的模板。</span></span><br><span class="line"><span class="comment">// 通常被观察者都是一些重要资源，在其自身某些状态发生改变时会广播通知给所有订阅者。</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ObservedProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> statusKey: <span class="type">StatusKey</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> notification: <span class="type">Notification</span>.<span class="type">Name</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">notifyObservers</span><span class="params">(about changeTo: String)</span></span> -&gt; <span class="type">Void</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在任意遵循 ObservedProtocol 示例的某些状态发生改变时，会通知*所有*已订阅的观察者。</span></span><br><span class="line"><span class="comment">// **向所有订阅者广播**</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObservedProtocol</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">notifyObservers</span><span class="params">(about changeTo: String)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">       <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: notification, object: <span class="keyword">self</span>, userInfo: [statusKey.rawValue : changeTo])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// ObservedProtocol 扩展结束</span></span><br></pre></td></tr></table></figure><p>我把大部分关于观察者的通知处理逻辑放在了 <code>ObserverProtocol</code> 的扩展当中，并且这段逻辑会在一个 <code>@objc</code> 修饰的方法中运行（此方法同时会设置为通知的 <code>#selector</code> 的方法）。作为抽象类中的方法，相较于使用基于 block 的 <a href="https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver" target="_blank" rel="noopener"><code>addObserver(forName:object:queue:using:)</code></a> 并把处理通知的闭包传进去，使用 selector 可以让这段通知处理代码显得更加容易理解以及更加适合教学。</p><p>同时，我意识到 Swift 中并没有关于抽象类的官方概念。因此，为了完成我解释观察者模式的教学目的，我强制使用者重写 <code>Observer</code> 的 <code>handleNotification()</code> 方法，以此来达到 “抽象类” 的形态。如此以来，你可以注入任意的处理逻辑，让你的子类实例在接收到通知后有特定的行为。</p><p>下面我将展示示例项目中的 <code>ViewController.swift</code> 文件，在这里你可以看到刚刚讨论过的  <code>Obesever.swift</code> 中的核心代码是如何使用的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此 view controller 遵循 ObservedProtocol 协议，因此在*整个应用期间*</span></span><br><span class="line"><span class="comment">// 其可以通过 NotificationCenter 向*任意*有意接收的实体广播通知。</span></span><br><span class="line"><span class="comment">// 可以看到这个类仅仅需要很少量的代码便可以实现通知的功能。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">ObservedProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> topBox: <span class="type">UIView</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> middleBox: <span class="type">UIView</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> bottomBox: <span class="type">UIView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Mock 一些负责观察网络状况的实体对象。</span></span><br><span class="line">    <span class="keyword">var</span> networkConnectionHandler0: <span class="type">NetworkConnectionHandler</span>?</span><br><span class="line">    <span class="keyword">var</span> networkConnectionHandler1: <span class="type">NetworkConnectionHandler</span>?</span><br><span class="line">    <span class="keyword">var</span> networkConnectionHandler2: <span class="type">NetworkConnectionHandler</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遵循 ObservedProtocol 的两个属性。</span></span><br><span class="line">    <span class="keyword">let</span> statusKey: <span class="type">StatusKey</span> = <span class="type">StatusKey</span>.networkStatusKey</span><br><span class="line">    <span class="keyword">let</span> notification: <span class="type">Notification</span>.<span class="type">Name</span> = .networkConnection</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// 初始化负责监听的实体对象。</span></span><br><span class="line">        networkConnectionHandler0 = <span class="type">NetworkConnectionHandler</span>(view: topBox)</span><br><span class="line">        networkConnectionHandler1 = <span class="type">NetworkConnectionHandler</span>(view: middleBox)</span><br><span class="line">        networkConnectionHandler2 = <span class="type">NetworkConnectionHandler</span>(view: bottomBox)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Mock 一个可以改变状态的重要资源。</span></span><br><span class="line">    <span class="comment">// 此处模拟此 ViewController 可以检测网络连接状况，</span></span><br><span class="line">    <span class="comment">// 当网络可以连接或者网络连接丢失时，通知所有有兴趣的监听者。</span></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">switchChanged</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> swtich:<span class="type">UISwitch</span> = sender <span class="keyword">as</span>! <span class="type">UISwitch</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> swtich.isOn &#123;</span><br><span class="line">            notifyObservers(about: <span class="type">NetworkConnectionStatus</span>.connected.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            notifyObservers(about: <span class="type">NetworkConnectionStatus</span>.disconnected.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// switchChanged 函数结束</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// ViewController 类结束</span></span><br></pre></td></tr></table></figure><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>大部分 iOS 开发者对备忘录模式都很熟悉。回忆一下 iOS 中十分便利的 <a href="https://developer.apple.com/documentation/foundation/archives_and_serialization" target="_blank" rel="noopener">归档和序列化功能</a>，让你能够 “在对象和基本数据类型在 plist、JSON 和其他二进制形式之间自由转换”。再回忆一下 iOS 中的 <a href="https://developer.apple.com/documentation/uikit/view_controllers/preserving_your_app_s_ui_across_launches" target="_blank" rel="noopener">状态保存和恢复功能</a>，它能够记住你的应用被系统强制杀死时的状态，并在之后恢复此状态。</p><p>备忘录模式可以理解为在某个时刻捕捉、展示以及储存任意实例的内部状态，同时允许你可以在随后的时间内查找这些保存下来的状态并恢复它。当你恢复一个实例的某个状态时，它应当完全反映出这个实例在被捕捉时的状态。显然，要达到此效果，你必须保证所有实例属性的访问权限在捕捉和恢复时都是一样的 —— 例如，<code>public</code> 的数据应恢复为 <code>public</code> 的属性，<code>private</code>  的数据应恢复为 <code>private</code> 的属性。</p><p>为了简单起见，我使用 iOS 系统提供的 <code>UserDefaults</code> 作为我存储和恢复实例状态的核心工具。</p><h3 id="备忘录模式用例"><a href="#备忘录模式用例" class="headerlink" title="备忘录模式用例"></a>备忘录模式用例</h3><p>在我知道了 iOS 本身已提供了便捷的归档和序列化的功能后，我随即编写了一些可以保存和恢复类的状态的示例代码。我的代码很出色地抽象出了归档和解档的功能，因此你可以利用这些抽象方法存储和恢复许多不同的实例和实例的属性。不过我的示例代码并非用于生产环境下的，它们只是为了解释备忘录模式而编写的教学性代码。</p><p>你可以在 Github 上找到我的 <a href="https://github.com/appcoda/Memento-Pattern-Swift" target="_blank" rel="noopener">示例项目</a>。这个项目展示了一个包含<code>firstName</code>、<code>lastName</code>  和 <code>age</code> 属性的 <code>User</code> 类实例保存在 <code>UserDefaults</code> 中，并随后从 <code>UserDefaults</code> 恢复的过程。如同下面的效果一样，一开始，并没有任何 <code>User</code> 实例提供给我进行恢复，随后我输入了一个并把它归档，然后再恢复它：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/08/MementoDemoApp.gif" alt="MementoDemoApp"></p><p>上面过程中控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Empty entity.</span><br><span class="line"> </span><br><span class="line">lastName: Adams</span><br><span class="line">age: 87</span><br><span class="line">firstName: John</span><br><span class="line"> </span><br><span class="line">lastName: Adams</span><br><span class="line">age: 87</span><br><span class="line">firstName: John</span><br></pre></td></tr></table></figure><h3 id="备忘录模式示例代码"><a href="#备忘录模式示例代码" class="headerlink" title="备忘录模式示例代码"></a>备忘录模式示例代码</h3><p>我所实现的备忘录模式非常直白。代码中包含了一个 <code>Memento</code> 协议，以及 <code>Memento</code> 协议的扩展，用于在成员属性中存在遵循 <code>Memento</code> 协议的属性时，处理和抽象关于归档与解档的逻辑。与此同时，这个协议扩展允许在任何时候打印实例的所有状态。我使用了一个 <code>Dictionary&lt;String, String&gt;</code> 来存储那些遵循协议的类中的属性 —— 属性名作为字典的 Key，属性值作为字典的 Value。我把属性的值以字符串的类型存储，以此达到代码较简洁且容易理解的目的，但我必须承认实际情况中有许多用例会要求你去操作非常复杂的属性类型。归根到底，这是一个关于设计模式的教程，因此没有任何代码是基于生产环境来编写的。</p><p>需要注意我为 <code>Memento</code> 协议加了一个 <code>persist()</code> 方法和一个 <code>recover()</code> 方法，任何遵循此协议的类都必须实现它们。这两个方法让开发者可以根据实际需要，通过名字来归档和解档某个遵循 <code>Memento</code> 协议的类中的特定属性。换句话说，<code>Memento</code> 中类型为 <code>Dictionary&lt;String, String&gt;</code> 的 <code>state</code> 属性可以一对一地对应到某个遵循此协议的类中的属性，这些属性的名称对应字典中元素的 key，属性的值对应字典中元素的 value。相信你在看完具体的代码后肯定能完全理解。</p><p>由于遵循 <code>Memento</code> 协议的类必须实现  <code>persist()</code> 和 <code>recover()</code> 方法，因此这两个方法必须可以访问所有可见的属性，无论它具有什么样的访问权限 ——  <code>public</code> 、<code>private</code>  还是  <code>fileprivate</code>。</p><p>你或许也想知道我为什么把 <code>Memento</code> 协议设置为类协议（class-only）。原因仅仅是因为 Swift 编译器那诡异的报错：”Cannot use mutating member on immutable value: ‘self’ is immutable”。我们暂且不讨论这个问题，因为它远远超出了本次教程的范围。如果你对这个问题感兴趣，你可以看一下这个 <a href="https://www.bignerdranch.com/blog/protocol-oriented-problems-and-the-immutable-self-error/" target="_blank" rel="noopener">不错的解释</a>。</p><p>接下来就到了代码的部分。首先，你可以在我示例项目中的 <code>Memento.swift</code> 文件找到关于备忘录模式的核心实现：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 由于"Cannot use mutating member on immutable value: ‘self’ is immutable"报错问题，</span></span><br><span class="line"><span class="comment">// 此协议定义为类协议，仅适用于引用类型。</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Memento</span> : <span class="title">class</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问 UserDefaults 中 state 属性的 key 值。</span></span><br><span class="line">    <span class="keyword">var</span> stateName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储遵循此协议的类当前状态下的所有属性名（key）和属性值。</span></span><br><span class="line">    <span class="keyword">var</span> state: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以特定的 stateName 为 key 将 state 属性存入 UserDefaults 中。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以特定的 stateName 为 key 从 UserDefaults 中读取 state。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可自定义，以特定方式把遵循此协议的类的属性存储到 state 字典。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">persist</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 可自定义，以特定方式从 state 字典读取属性。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 state 字典并打印所有成员属性，格式如下：</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 属性 1 名字（key）：属性 1 的值</span></span><br><span class="line">    <span class="comment">// 属性 2 名字（key）：属性 2 的值</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// Memento 协议结束</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存 state 到磁盘中。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(state, forKey: stateName)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从磁盘中读取 state。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">restore</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> dictionary = <span class="type">UserDefaults</span>.standard.object(forKey: stateName) <span class="keyword">as</span>! <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;? &#123;</span><br><span class="line">            state = dictionary</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            state.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// restore() 函数结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以字典的形式保存当前状态可以很方便地进行可视化输出。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> line = <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> state.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (key, value) <span class="keyword">in</span> state &#123;</span><br><span class="line">                line += key + <span class="string">": "</span> + value + <span class="string">"\n"</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(line)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Empty entity.\n"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125; <span class="comment">// show() 函数结束</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// Memento 扩展结束</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过遵循 Memento 协议，任何类都可以方便地在整个应有运行期间</span></span><br><span class="line"><span class="comment">// 保存其完整状态，并能随后任意时间进行读取。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>: <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Memento 必须遵循的属性。</span></span><br><span class="line">    <span class="keyword">let</span> stateName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> state: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此类独有的几个属性，用于保存系统用户账号。</span></span><br><span class="line">    <span class="keyword">var</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> lastName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此构造器可用于保存新用户到磁盘，或者更新一个现有的用户。</span></span><br><span class="line">    <span class="comment">// 持久化储存所用的 key 值为 stateName 属性。</span></span><br><span class="line">    <span class="keyword">init</span>(firstName: <span class="type">String</span>, lastName: <span class="type">String</span>, age: <span class="type">String</span>, stateName: <span class="type">String</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.firstName = firstName</span><br><span class="line">        <span class="keyword">self</span>.lastName = lastName</span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.stateName = stateName</span><br><span class="line">        <span class="keyword">self</span>.state = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        persist()</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// 构造器定义结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此构造器可以从磁盘中读取出一个已存在的用户信息。</span></span><br><span class="line">    <span class="comment">// 读取所使用的 key 值为 stateName 属性。</span></span><br><span class="line">    <span class="keyword">init</span>(stateName: <span class="type">String</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.stateName = stateName</span><br><span class="line">        <span class="keyword">self</span>.state = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.firstName = <span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.lastName = <span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.age = <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        recover()</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// 构造器定义结束</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 持久化存储用户属性。</span></span><br><span class="line">    <span class="comment">// 此处很直观地将每个属性一对一地以"属性名-属性值"的形式存入字典中。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">persist</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        state[<span class="string">"firstName"</span>] = firstName</span><br><span class="line">        state[<span class="string">"lastName"</span>] = lastName</span><br><span class="line">        state[<span class="string">"age"</span>] = age</span><br><span class="line">        </span><br><span class="line">        save() <span class="comment">// leverage protocol extension</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// persist() 函数结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取已存储的用户属性。</span></span><br><span class="line">    <span class="comment">// 从 UserDefaults 中读取了 state 字典后</span></span><br><span class="line">    <span class="comment">// 会简单地以属性名为 key 从字典中读取出属性值。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        restore() <span class="comment">// leverage protocol extension</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> state.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            firstName = state[<span class="string">"firstName"</span>]!</span><br><span class="line">            lastName = state[<span class="string">"lastName"</span>]!</span><br><span class="line">            age = state[<span class="string">"age"</span>]!</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.firstName = <span class="string">""</span></span><br><span class="line">            <span class="keyword">self</span>.lastName = <span class="string">""</span></span><br><span class="line">            <span class="keyword">self</span>.age = <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// recover() 函数结束</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// user 类结束</span></span><br></pre></td></tr></table></figure><p>接下来，你可以在示例项目中的 <code>ViewController.swift</code>  文件中找到我上问所说的关于备忘录模式的使用用例（对 <code>User</code> 类的归档和解档）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> firstNameTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> lastNameTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> ageTextField: <span class="type">UITextField</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// "保存用户" 按钮按下时调用此方法。</span></span><br><span class="line">    <span class="comment">// 以 "userKey" 作为 stateName 的值将 User 类实例的属性</span></span><br><span class="line">    <span class="comment">// 保存到 UserDefaults 中。</span></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">saveUserTapped</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> firstNameTextField.text != <span class="string">""</span> &amp;&amp;</span><br><span class="line">            lastNameTextField.text != <span class="string">""</span> &amp;&amp;</span><br><span class="line">            ageTextField.text != <span class="string">""</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> user = <span class="type">User</span>(firstName: firstNameTextField.text!,</span><br><span class="line">                            lastName: lastNameTextField.text!,</span><br><span class="line">                            age: ageTextField.text!,</span><br><span class="line">                            stateName: <span class="string">"userKey"</span>)</span><br><span class="line">            user.show()</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// saveUserTapped 函数结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在"恢复用户"按钮按下时调用此方法。</span></span><br><span class="line">    <span class="comment">// 以 "userKey" 作为 stateName 的值将 User 类实例的属性</span></span><br><span class="line">    <span class="comment">// 从 UserDefaults 中读取出来。</span></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">restoreUserTapped</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> user = <span class="type">User</span>(stateName: <span class="string">"userKey"</span>)</span><br><span class="line">        firstNameTextField.text = user.firstName</span><br><span class="line">        lastNameTextField.text = user.lastName</span><br><span class="line">        ageTextField.text = user.age</span><br><span class="line">        user.show()</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// ViewController 类结束</span></span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>即便 GoF 的设计模式已经在多数开发者心中被视为圣经般的存在（我在文章开头提到的），但仍有某些对设计模式持有批评意见的人认为，设计模式的使用恰恰是我们对编程语言不够了解或使用不够巧妙的证明，而且在代码中频繁使用设计模式并不是一件好事。我个人并不认同此看法。对于一些拥有几乎所有能想象得到的特性的语言，例如 C++ 这种非常庞大的编程语言来说，这种意见或许会适用，但诸如此类的语言通常极其复杂以致于我们很难去学习、使用并掌握它。能够识别出并解决一些重复出现的问题是我们作为人类的优点之一，我们并不应该抗拒它。而设计模式恰巧是人类从历史错误中吸取教训，并加以改进的绝佳例子。同时，设计模式对一些通用的问题给出了抽象化且标准化的解决方案，提高了解决这些问题的可能性和可部署性。</p><p>把一门简洁的编程语言和一系列最佳实践结合起来是一件美妙的事情，例如 Swift 和设计模式的结合。高一致性的代码通常也有高可读性和高可维护性。同时你要记得一件事，设计模式是通过成千上万的开发者们不断地讨论和交流想法而持续完善的。通过万维网带来的便捷性，开发者们在虚拟世界相互连接，他们的讨论不断碰撞出天才的火花。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Andrew Jaffee，&lt;a href=&quot;https://www.appcoda.com/design-pattern-behavorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-08-06&lt;br&gt;译者：&lt;a href=&quot;https://dingtz.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jojotov&lt;/a&gt;；校对：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;本次教程是 AppCoda &lt;a href=&quot;https://swift.gg/2018/09/10/design-pattern-creational/&quot;&gt;上周开启&lt;/a&gt; 的设计模式系列的第二期。在软件设计领域的四位大师级人物（GoF，又称“四人帮”或“Gang of Four”） —— Erich Gamma, Richard Helm, Ralph Johnson 和 John Vlissides 所著的 《设计模式：可复用面向对象软件的基础》一书中，首次对软件设计中总共 23 种设计模式进行了定义和归类，并对它们作了专业阐述。今天，我们将聚焦于其中两个行为型设计模式 —— “观察者模式” 和 “备忘录模式”。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
    
      <category term="Design Patterns" scheme="https://swift.gg/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>实用的可选项（Optional）扩展</title>
    <link href="https://swift.gg/2018/11/19/useful-optional-extensions/"/>
    <id>https://swift.gg/2018/11/19/useful-optional-extensions/</id>
    <published>2018-11-19T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：terhechte，<a href="https://appventure.me/2018/01/10/optional-extensions/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-01-10<br>译者：<a href="https://github.com/rsenjoyer" target="_blank" rel="noopener">rsenjoyer</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>可选值（Optional）是 Swift 语言最基础的内容。我想每个人都同意它带来了巨大的福音，因为它迫使开发者妥善处理边缘情况。可选值的语言特性能让发者在开发阶段发现并处理整个类别的 bug。</p><p>然而，Swift 标准库中可选值的 API 相当的有限。如果忽略 <code>customMirror</code> 和 <code>debugDescription</code> 属性，<a href="https://developer.apple.com/documentation/swift/optional#topics" target="_blank" rel="noopener">Swift 文档</a> 仅仅列出了几个方法/属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unsafelyUnwrapped: <span class="type">Wrapped</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>? </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>?) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>?</span><br></pre></td></tr></table></figure><a id="more"></a><p>即使方法如此少，可选值仍然非常有用，这是因为 Swift 在语法上通过 <a href="https://appventure.me/2014/06/13/swift-optionals-made-simple/" target="_blank" rel="noopener">可选链</a>、<a href="https://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="noopener">模式匹配</a>、<code>if let</code> 或 <code>guard let</code> 等功能来弥补它。但在某些情况下，可选值容易造成多分支条件。有时，一个非常简洁的方法通常允许你用一行代码表达某个概念，而不是用多行组合的 <code>if let</code> 语句。</p><p>我筛选了 Github 上的 Swift 项目以及 Rust、Scala 或 C＃ 等其他语言的可选实现，目的是为 Optional 找一些有用的补充。以下 14 个可选扩展，我将分类逐一解释，同时给每个类别举几个例子。最后，我将编写一个更复杂的示例，它同时使用多个可选扩展。</p><h2 id="判空（Emptiness）"><a href="#判空（Emptiness）" class="headerlink" title="判空（Emptiness）"></a>判空（Emptiness）</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 可选值为空的时候返回 true</span></span><br><span class="line">    <span class="keyword">var</span> isNone: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> .some:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 可选值非空返回 true</span></span><br><span class="line">    <span class="keyword">var</span> isSome: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !isNone</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是对可选类型最基础的补充。我很喜欢这些补充，因为它们将可选项为空的概念从代码中移除了。在使用的细节上， 使用 <code>optional.isSome</code> 比 <code>if optional == nil</code> 更简洁明了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用前</span></span><br><span class="line"><span class="keyword">guard</span> leftButton != <span class="literal">nil</span>, rightButton != <span class="literal">nil</span> <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"Missing Interface Builder connections"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用后</span></span><br><span class="line"><span class="keyword">guard</span> leftButton.isSome, rightButton.isSome <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"Missing Interface Builder connections"</span>) &#125;</span><br></pre></td></tr></table></figure><h2 id="或（Or）"><a href="#或（Or）" class="headerlink" title="或（Or）"></a>或（Or）</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 返回可选值或默认值</span></span><br><span class="line">    <span class="comment">/// - 参数: 如果可选值为空，将会默认值</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(<span class="number">_</span> <span class="keyword">default</span>: Wrapped)</span></span> -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> ?? `<span class="keyword">default</span>`</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 返回可选值或 `else` 表达式返回的值</span></span><br><span class="line">    <span class="comment">/// 例如. optional.or(else: print("Arrr"))</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(<span class="keyword">else</span>: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Wrapped</span>) -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> ?? `<span class="keyword">else</span>`()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 返回可选值或者 `else` 闭包返回的值</span></span><br><span class="line">    <span class="comment">// 例如. optional.or(else: &#123; </span></span><br><span class="line">    <span class="comment">/// ... do a lot of stuff</span></span><br><span class="line">    <span class="comment">/// &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(<span class="keyword">else</span>: <span class="params">()</span></span></span> -&gt; <span class="type">Wrapped</span>) -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> ?? `<span class="keyword">else</span>`()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 当可选值不为空时，返回可选值</span></span><br><span class="line">    <span class="comment">/// 如果为空，抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(<span class="keyword">throw</span> exception: Error)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> unwrapped = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">throw</span> exception &#125;</span><br><span class="line">        <span class="keyword">return</span> unwrapped</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> <span class="title">where</span> <span class="title">Wrapped</span> == <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 当可选值不为空时，执行 `else`</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">or</span><span class="params">(<span class="number">_</span> <span class="keyword">else</span>: <span class="params">(Error)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> error = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">`<span class="keyword">else</span>`(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isNone / isSome</code> 的另一个抽象概念是能够指定当变量不成立的时需要执行的指令。这能让我们避免编写 <code>if</code> 或 <code>guard</code> 分支，而是将逻辑封装为一个易于理解的方法。</p><p>这个概念非常的有用，它可在四个不同功能中被定义。</p><h2 id="默认值（Default-Value）"><a href="#默认值（Default-Value）" class="headerlink" title="默认值（Default Value）"></a>默认值（Default Value）</h2><p>第一个扩展方法是返回可选值或者默认值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">optional</span>: <span class="type">Int</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">optional</span>.or(<span class="number">10</span>)) <span class="comment">// 打印 10</span></span><br></pre></td></tr></table></figure><h2 id="默认闭包（Default-Closure）"><a href="#默认闭包（Default-Closure）" class="headerlink" title="默认闭包（Default Closure）"></a>默认闭包（Default Closure）</h2><p>默认闭包和默认值非常的相似，但它允许从闭包中返回默认值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">optional</span>: <span class="type">Int</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">optional</span>.or(<span class="keyword">else</span>: secretValue * <span class="number">32</span>)</span><br></pre></td></tr></table></figure><p>由于使用了 <code>@autoclosure</code> 参数, 我们实际上使用的是默认闭包。使用默认值将会自动转换为返回值的闭包。然而，我倾向于将两个实现单独分开，因为它可以让用户用更加复杂的逻辑编写闭包。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cachedUserCount: <span class="type">Int</span>? = <span class="literal">nil</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> cachedUserCount.or(<span class="keyword">else</span>: &#123;</span><br><span class="line">   <span class="keyword">let</span> db = database()</span><br><span class="line">   db.prefetch()</span><br><span class="line">   <span class="keyword">guard</span> db.failures.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">   <span class="keyword">return</span> db.amountOfUsers</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当你对一个为空的可选值赋值的时候，使用 <code>or</code> 就是一个不错的选择。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> databaseController == <span class="literal">nil</span> &#123;</span><br><span class="line">  databaseController = <span class="type">DatabaseController</span>(config: config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以写的更加优雅: </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">databaseController = databaseController.or(<span class="type">DatabaseController</span>(config: config)</span><br></pre></td></tr></table></figure><h2 id="抛出异常（Throw-an-error）"><a href="#抛出异常（Throw-an-error）" class="headerlink" title="抛出异常（Throw an error）"></a>抛出异常（Throw an error）</h2><p>这也是一个非常有用的补充，因为它将 Swift 中可选值与错误处理连接起来。根据项目中的代码，方法或函数通过返回一个为空的可选值（例如访问字典中不存在的键）时，抛出错误来表述这一无效的行为。将两者连接起来能够使代码更加清晰：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildCar</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Car</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tires = <span class="keyword">try</span> machine1.createTires()</span><br><span class="line">  <span class="keyword">let</span> windows = <span class="keyword">try</span> machine2.createWindows()</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> motor = externalMachine.deliverMotor() <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">MachineError</span>.motor</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> trunk = <span class="keyword">try</span> machine3.createTrunk()</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> car = manufacturer.buildCar(tires, windows,  motor, trunk) &#123;</span><br><span class="line">    <span class="keyword">return</span> car</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">MachineError</span>.manufacturer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过调用内部及外部代码共同构建汽车对象，外部代码（<code>external_machine</code> 和 <code>manufacturer</code>）选择使用可选值而不是错误处理。这使得代码变得很复杂，我们可使用 <code>or(throw:)</code> 使函数可读性更高。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build_car</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Car</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tires = <span class="keyword">try</span> machine1.createTires()</span><br><span class="line">  <span class="keyword">let</span> windows = <span class="keyword">try</span> machine2.createWindows()</span><br><span class="line">  <span class="keyword">let</span> motor = <span class="keyword">try</span> externalMachine.deliverMotor().or(<span class="keyword">throw</span>: <span class="type">MachineError</span>.motor)</span><br><span class="line">  <span class="keyword">let</span> trunk = <span class="keyword">try</span> machine3.createTrunk()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">try</span> manufacturer.buildCar(tires, windows,  motor, trunk).or(<span class="keyword">throw</span>: <span class="type">MachineError</span>.manufacturer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误处理（Handling-Errors）"><a href="#错误处理（Handling-Errors）" class="headerlink" title="错误处理（Handling Errors）"></a>错误处理（Handling Errors）</h2><p>当代码中包含 <a href="https://github.com/doozMen" target="_blank" rel="noopener">Stijn Willems 在 Github</a> 自由函数，上面抛出异常部分的代码变更加有用。感谢 Stijn Willems 的建议。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">should</span><span class="params">(<span class="number">_</span> <span class="keyword">do</span>: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Error</span>? &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">try</span> `<span class="keyword">do</span>`()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line"><span class="keyword">return</span> error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个自由函数（可选的，可将它当做一个可选项的类方法）使用 <code>do {} catch {}</code> 块并返回一个错误。当且仅当 <code>do</code> 代码块捕捉到异常。以下面 Swift 代码为例：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> throwingFunction()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">  <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 Swift 中错误处理的基本原则之一，但它不够简单明了。使用上面的提供的函数，你可以使代码变得足够简单。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">should &#123; <span class="keyword">try</span> throwingFunction) &#125;.or(<span class="built_in">print</span>($<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>我觉得在很多情况下，这样进行错误处理效果更好。</p><h2 id="变换（Map）"><a href="#变换（Map）" class="headerlink" title="变换（Map）"></a>变换（Map）</h2><p>正如上面所见，<code>map</code> 和 <code>flatMap</code> 是 Swift 标准库在可选项上面提供的的全部方法。然而，在多数情况下，也可以对它们稍微改进使得更加通用。这有两个扩展 <code>map</code> 允许定义一个默认值，类似于上面 <code>or</code> 的实现方式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 可选值变换返回，如果可选值为空，则返回默认值</span></span><br><span class="line">    <span class="comment">/// - 参数 fn: 映射值的闭包</span></span><br><span class="line">    <span class="comment">/// - 参数 default: 可选值为空时，将作为返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> fn: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>, <span class="keyword">default</span>: <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="built_in">map</span>(fn) ?? `<span class="keyword">default</span>`</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 可选值变换返回，如果可选值为空，则调用 `else` 闭包</span></span><br><span class="line">    <span class="comment">/// - 参数 fn: 映射值的闭包</span></span><br><span class="line">    <span class="comment">/// - 参数 else: The function to call if the optional is empty</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> fn: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>, <span class="keyword">else</span>: () <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="built_in">map</span>(fn) ?? `<span class="keyword">else</span>`()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个方法允许你将可选值 <code>map</code> 成一个新的类型 <code>T</code>. 如果可选值为空，你可以提供一个 <code>T</code> 类型的默认值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> optional1: <span class="type">String</span>? = <span class="string">"appventure"</span></span><br><span class="line"><span class="keyword">let</span> optional2: <span class="type">String</span>? = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前</span></span><br><span class="line"><span class="built_in">print</span>(optional1.<span class="built_in">map</span>(&#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;) ?? <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(optional2.<span class="built_in">map</span>(&#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;) ?? <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用后 </span></span><br><span class="line"><span class="built_in">print</span>(optional1.<span class="built_in">map</span>(&#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;, <span class="keyword">default</span>: <span class="number">0</span>)) <span class="comment">// prints 10</span></span><br><span class="line"><span class="built_in">print</span>(optional2.<span class="built_in">map</span>(&#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;, <span class="keyword">default</span>: <span class="number">0</span>)) <span class="comment">// prints 0</span></span><br></pre></td></tr></table></figure><p>这里改动很小，我们再也不需要使用 <code>??</code> 操作符，取而代之的是更能表达意图的 <code>default</code> 值。</p><p>第二个方法也与第一个很相似，主要区别在于它接受（再次）返回 <code>T</code> 类型的闭包，而不是使用一个默认值。这里有个简单的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">optional</span>: <span class="type">String</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">optional</span>.<span class="built_in">map</span>(&#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;, <span class="keyword">else</span>: &#123; <span class="string">"default"</span>.<span class="built_in">count</span> &#125;)</span><br></pre></td></tr></table></figure><h2 id="组合可选项（Combining-Optionals）"><a href="#组合可选项（Combining-Optionals）" class="headerlink" title="组合可选项（Combining Optionals）"></a>组合可选项（Combining Optionals）</h2><p>这个类别包含了四个函数，允许你定义多个可选项之间的关系。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="comment">///  当可选值不为空时，解包并返回参数 `optional`</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">and</span>&lt;B&gt;<span class="params">(<span class="number">_</span> <span class="keyword">optional</span>: B?)</span></span> -&gt; <span class="type">B</span>? &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">self</span> != <span class="literal">nil</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">optional</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 解包可选值，当可选值不为空时，执行 `then` 闭包，并返回执行结果</span></span><br><span class="line">    <span class="comment">/// 允许你将多个可选项连接在一起</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">and</span>&lt;T&gt;<span class="params">(then: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>?) <span class="keyword">rethrows</span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> unwrapped = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> then(unwrapped)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 将当前可选值与其他可选值组合在一起</span></span><br><span class="line">    <span class="comment">/// 当且仅当两个可选值都不为空时组合成功，否则返回空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">zip2</span>&lt;A&gt;<span class="params">(with other: Optional&lt;A&gt;)</span></span> -&gt; (<span class="type">Wrapped</span>, <span class="type">A</span>)? &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> first = <span class="keyword">self</span>, <span class="keyword">let</span> second = other <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> (first, second)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 将当前可选值与其他可选值组合在一起</span></span><br><span class="line">    <span class="comment">/// 当且仅当三个可选值都不为空时组合成功，否则返回空</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">zip3</span>&lt;A, B&gt;<span class="params">(with other: Optional&lt;A&gt;, another: Optional&lt;B&gt;)</span></span> -&gt; (<span class="type">Wrapped</span>, <span class="type">A</span>, <span class="type">B</span>)? &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> first = <span class="keyword">self</span>,</span><br><span class="line">      <span class="keyword">let</span> second = other,</span><br><span class="line">      <span class="keyword">let</span> third = another <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"><span class="keyword">return</span> (first, second, third)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的四个函数都以传入可选值当做参数，最终都返回一个可选值，然而，他们的实现方式完全不同。</p><h2 id="依赖（Dependencies）"><a href="#依赖（Dependencies）" class="headerlink" title="依赖（Dependencies）"></a>依赖（Dependencies）</h2><p>若一个可选值的解包仅作为另一可选值解包的前提，<code>and&lt;B&gt;(_ optional)</code> 就显得非常使用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用前</span></span><br><span class="line"><span class="keyword">if</span> user != <span class="literal">nil</span>, <span class="keyword">let</span> account = userAccount() ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用后</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> account = user.and(userAccount()) ...</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们对 <code>user</code> 的具体内容不感兴趣，但是要求在调用 <code>userAccount</code> 函数前保证它非空。虽然这种关系也可以使用 <code>user != nil</code>，但我觉得 <code>and</code> 使它们的意图更加清晰。</p><h2 id="链式调用（Chaining）"><a href="#链式调用（Chaining）" class="headerlink" title="链式调用（Chaining）"></a>链式调用（Chaining）</h2><p><code>and&lt;T&gt;(then:)</code> 是另一个非常有用的函数, 它将多个可选项链接起来，以便将可选项 <code>A</code> 的解包值当做可选项 <code>B</code> 的输入。我们从一个简单的例子开始：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UserDatabase</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">current</span><span class="params">()</span></span> -&gt; <span class="type">User</span>?</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">spouse</span><span class="params">(of user: User)</span></span> -&gt; <span class="type">User</span>?</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">father</span><span class="params">(of user: User)</span></span> -&gt; <span class="type">User</span>?</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">childrenCount</span><span class="params">(of user: User)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> database: <span class="type">UserDatabase</span> = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 思考如下关系该如何表达：</span></span><br><span class="line"><span class="comment">// Man -&gt; Spouse -&gt; Father -&gt; Father -&gt; Spouse -&gt; children</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前</span></span><br><span class="line"><span class="keyword">let</span> childrenCount: <span class="type">Int</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> user = database.current(), </span><br><span class="line">   <span class="keyword">let</span> father1 = database.father(user),</span><br><span class="line">   <span class="keyword">let</span> father2 = database.father(father1),</span><br><span class="line">   <span class="keyword">let</span> spouse = database.spouse(father2),</span><br><span class="line">   <span class="keyword">let</span> children = database.childrenCount(father2) &#123;</span><br><span class="line">  childrenCount = children</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  childrenCount = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用后</span></span><br><span class="line"><span class="keyword">let</span> children = database.current().and(then: &#123; database.spouse($<span class="number">0</span>) &#125;)</span><br><span class="line">     .and(then: &#123; database.father($<span class="number">0</span>) &#125;)</span><br><span class="line">     .and(then: &#123; database.spouse($<span class="number">0</span>) &#125;)</span><br><span class="line">     .and(then: &#123; database.childrenCount($<span class="number">0</span>) &#125;)</span><br><span class="line">     .or(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>使用 <code>and(then)</code> 函数对代码有很大的提升。首先，你没必要声明临时变量名（user, father1, father2, spouse, children），其次，代码更加的简洁。而且，使用 <code>or(0)</code> 比 <code>let childrenCount</code> 可读性更好。</p><p>最后，原来的 Swift 代码很容易导致逻辑错误。也许你还没有注意到，但示例中存在一个 bug。在写那样的代码时，就很容易地引入复制粘贴错误。你观察到了么？</p><p>是的，<code>children</code> 属性应该由调用 <code>database.childrenCount(spouse)</code> 创建，但我写成了 <code>database.childrenCount(father2)</code>。很难发现这样的错误。使用 <code>and(then:)</code> 就容易发现这个错误，因为它使用的是变量 <code>$0</code>。</p><h2 id="组合（Zipping）"><a href="#组合（Zipping）" class="headerlink" title="组合（Zipping）"></a>组合（Zipping）</h2><p>这是现有 Swift 概念的另一个扩展，<code>zip</code> 可以组合多个可选值，它们一起解包成功或解包失败。在上面的代码片段中，我提供了 <code>zip2</code> 与 <code>zip3</code> 函数，但你也可以命名为 <code>zip22</code>（好吧，也许对合理性和编译速度有一点点影响）。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildProduct</span><span class="params">()</span></span> -&gt; <span class="type">Product</span>? &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> var1 = machine1.makeSomething(),</span><br><span class="line">    <span class="keyword">let</span> var2 = machine2.makeAnotherThing(),</span><br><span class="line">    <span class="keyword">let</span> var3 = machine3.createThing() &#123;</span><br><span class="line">    <span class="keyword">return</span> finalMachine.produce(var1, var2, var3)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扩展</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildProduct</span><span class="params">()</span></span> -&gt; <span class="type">Product</span>? &#123;</span><br><span class="line">  <span class="keyword">return</span> machine1.makeSomething()</span><br><span class="line">     .zip3(machine2.makeAnotherThing(), machine3.createThing())</span><br><span class="line">     .<span class="built_in">map</span> &#123; finalMachine.produce($<span class="number">0.1</span>, $<span class="number">0.2</span>, $<span class="number">0.3</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码量更少，代码更清晰，更优雅。然而，也存一个缺点，就是更复杂了。读者必须了解并理解 <code>zip</code> 才能完全掌握它。</p><h2 id="On"><a href="#On" class="headerlink" title="On"></a>On</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 当可选值不为空时，执行 `some` 闭包</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(some: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) <span class="keyword">rethrows</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span> != <span class="literal">nil</span> &#123; <span class="keyword">try</span> some() &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 当可选值为空时，执行 `none` 闭包</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="keyword">none</span>: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) <span class="keyword">rethrows</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span> == <span class="literal">nil</span> &#123; <span class="keyword">try</span> <span class="keyword">none</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论可选值是否为空，上面两个扩展都允许你执行一些额外的操作。与上面讨论过的方法相反，这两个方法忽略可选值。<code>on(some:)</code> 会在可选值不为空的时候执行闭包 <code>some</code>，但是闭包 <code>some</code> 不会获取可选项的值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 如果用户不存在将登出</span></span><br><span class="line"><span class="keyword">self</span>.user.on(<span class="keyword">none</span>: &#123; <span class="type">AppCoordinator</span>.shared.logout() &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 当用户不为空时，连接网络</span></span><br><span class="line"><span class="keyword">self</span>.user.on(some: &#123; <span class="type">AppCoordinator</span>.shared.unlock() &#125;)</span><br></pre></td></tr></table></figure><h2 id="Various"><a href="#Various" class="headerlink" title="Various"></a>Various</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 可选值不为空且可选值满足 `predicate` 条件才返回，否则返回 `nil`</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(<span class="number">_</span> predicate: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Wrapped</span>? &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> unwrapped = <span class="keyword">self</span>,</span><br><span class="line">    predicate(unwrapped) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 可选值不为空时返回，否则 crash</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">expect</span><span class="params">(<span class="number">_</span> message: String)</span></span> -&gt; <span class="type">Wrapped</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> value = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(message) &#125;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤（Filter）"><a href="#过滤（Filter）" class="headerlink" title="过滤（Filter）"></a>过滤（Filter）</h3><p>这个方法类似于一个守护者一样，只有可选值满足 <code>predicate</code> 条件时才进行解包。比如说，我们希望所有的老用户都升级为高级账户，以便与我们保持更长久的联系。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅会影响 id &lt; 1000 的用户</span></span><br><span class="line"><span class="comment">// 正常写法</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> aUser = user, user.id &lt; <span class="number">1000</span> &#123; aUser.upgradeToPremium() &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `filter`</span></span><br><span class="line">user.<span class="built_in">filter</span>(&#123; $<span class="number">0</span>.id &lt; <span class="number">1000</span> &#125;)?.upgradeToPremium()</span><br></pre></td></tr></table></figure><p>在这里，<code>user.filter</code> 使用起来更加自然。此外，它的实现类似于 Swift 集合中的功能。</p><h3 id="期望（Expect）"><a href="#期望（Expect）" class="headerlink" title="期望（Expect）"></a>期望（Expect）</h3><p>这是我最喜欢的功能之一。这是我从 <code>Rush</code> 语言中借鉴而来的。我试图避免强行解包代码库中的任何东西。类似于隐式解包可选项。</p><p>然而，当在项目中使用可视化界面构建 UI 时，下面的这种方式很常见：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateLabel</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> label = valueLabel <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"valueLabel not connected in IB"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  label.text = state.title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，另一种方式是强制解包 <code>label</code>, 这么做可能会造成应用程序崩溃类似于 <code>fatalError</code>。 然而，我必须插入 <code>!</code>, 当造成程序崩溃后，<code>!</code> 并不能给明确的错误信息。在这里，使用上面实现的 <code>expect</code> 函数就是一个更好的选择：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateLabel</span><span class="params">()</span></span> &#123;</span><br><span class="line">  valueLabel.expect(<span class="string">"valueLabel not connected in IB"</span>).text = state.title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例（Example）"><a href="#示例（Example）" class="headerlink" title="示例（Example）"></a>示例（Example）</h2><p>至此我们已经实现了一系列非常有用的可选项扩展。我将会给出个综合示例，以便更好的了解如何组合使用这些扩展。首先，我们需要先说明一下这个示例，原谅我使用这个不太恰当的例子：</p><p>假如你是为 80 年代的软件商工作。每个月都有很多的人为你编写应用软件和游戏。你需要追踪销售量，你从会计那里收到一个 XML 文件，你需要进行解析并将结果存入到数据库中（如果在 80 年代就有 Swift 语言 以及 XML，这将是多么奇妙）。你的软件系统有一个XML解析器和一个数据库（当然都是用6502 ASM编写的），它们实现了以下协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">XMLImportNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">firstChild</span><span class="params">(with tag: String)</span></span> -&gt; <span class="type">XMLImportNode</span>?</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">children</span><span class="params">(with tag: String)</span></span> -&gt; [<span class="type">XMLImportNode</span>]</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">attribute</span><span class="params">(with name: String)</span></span> -&gt; <span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">DatabaseUser</span> = <span class="type">String</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">DatabaseSoftware</span> = <span class="type">String</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">user</span><span class="params">(<span class="keyword">for</span> id: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">DatabaseUser</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">software</span><span class="params">(<span class="keyword">for</span> id: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">DatabaseSoftware</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">insertSoftware</span><span class="params">(user: DatabaseUser, name: String, id: String, type: String, amount: Int)</span></span> <span class="keyword">throws</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateSoftware</span><span class="params">(software: DatabaseSoftware, amount: Int)</span></span> <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 文件可能看起来像这样：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"158"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">software</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">type</span>=<span class="string">"game"</span> <span class="attr">name</span>=<span class="string">"Maniac Mansion"</span> <span class="attr">id</span>=<span class="string">"4332"</span> <span class="attr">amount</span>=<span class="string">"30"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">type</span>=<span class="string">"game"</span> <span class="attr">name</span>=<span class="string">"Doom"</span> <span class="attr">id</span>=<span class="string">"1337"</span> <span class="attr">amount</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">type</span>=<span class="string">"game"</span> <span class="attr">name</span>=<span class="string">"Warcraft 2"</span> <span class="attr">id</span>=<span class="string">"1000"</span> <span class="attr">amount</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">software</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解析 XML 的代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ParseError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> msg(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseGamesFromXML</span><span class="params">(from root: XMLImportNode, into database: Database)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> users = root.firstChild(with: <span class="string">"users"</span>)?.children(with: <span class="string">"user"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="type">ParseError</span>.msg(<span class="string">"No Users"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> software = user.firstChild(with: <span class="string">"software"</span>)?</span><br><span class="line">.children(with: <span class="string">"package"</span>),</span><br><span class="line">    <span class="keyword">let</span> userId = user.attribute(with: <span class="string">"id"</span>),</span><br><span class="line">    <span class="keyword">let</span> dbUser = <span class="keyword">try</span>? database.user(<span class="keyword">for</span>: userId)</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">ParseError</span>.msg(<span class="string">"Invalid User"</span>) &#125;</span><br><span class="line"><span class="keyword">for</span> package <span class="keyword">in</span> software &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> type = package.attribute(with: <span class="string">"type"</span>),</span><br><span class="line">    type == <span class="string">"game"</span>,</span><br><span class="line">    <span class="keyword">let</span> name = package.attribute(with: <span class="string">"name"</span>),</span><br><span class="line">    <span class="keyword">let</span> softwareId = package.attribute(with: <span class="string">"id"</span>),</span><br><span class="line">    <span class="keyword">let</span> amountString = package.attribute(with: <span class="string">"amount"</span>)</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">ParseError</span>.msg(<span class="string">"Invalid Package"</span>) &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> existing = <span class="keyword">try</span>? database.software(<span class="keyword">for</span>: softwareId) &#123;</span><br><span class="line"><span class="keyword">try</span> database.updateSoftware(software: existing, </span><br><span class="line">      amount: <span class="type">Int</span>(amountString) ?? <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> database.insertSoftware(user: dbUser, name: name, </span><br><span class="line">      id: softwareId, </span><br><span class="line">    type: type, </span><br><span class="line">  amount: <span class="type">Int</span>(amountString) ?? <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们运用下上面学到的内容：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseGamesFromXML</span><span class="params">(from root: XMLImportNode, into database: Database)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> <span class="keyword">try</span> root.firstChild(with: <span class="string">"users"</span>)</span><br><span class="line">    .or(<span class="keyword">throw</span>: <span class="type">ParseError</span>.msg(<span class="string">"No Users"</span>)).children(with: <span class="string">"user"</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> dbUser = <span class="keyword">try</span> user.attribute(with: <span class="string">"id"</span>)</span><br><span class="line">    .and(then: &#123; <span class="keyword">try</span>? database.user(<span class="keyword">for</span>: $<span class="number">0</span>) &#125;)</span><br><span class="line">    .or(<span class="keyword">throw</span>: <span class="type">ParseError</span>.msg(<span class="string">"Invalid User"</span>))</span><br><span class="line"><span class="keyword">for</span> package <span class="keyword">in</span> (user.firstChild(with: <span class="string">"software"</span>)?</span><br><span class="line">    .children(with: <span class="string">"package"</span>)).or([]) &#123;</span><br><span class="line">    <span class="keyword">guard</span> (package.attribute(with: <span class="string">"type"</span>)).<span class="built_in">filter</span>(&#123; $<span class="number">0</span> == <span class="string">"game"</span> &#125;).isSome</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">    <span class="keyword">try</span> package.attribute(with: <span class="string">"name"</span>)</span><br><span class="line">.zip3(with: package.attribute(with: <span class="string">"id"</span>), </span><br><span class="line">   another: package.attribute(with: <span class="string">"amount"</span>))</span><br><span class="line">.<span class="built_in">map</span>(&#123; (tuple) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">try</span>? database.software(<span class="keyword">for</span>: tuple.<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> e?: <span class="keyword">try</span> database.updateSoftware(software: e, </span><br><span class="line">       amount: <span class="type">Int</span>(tuple.<span class="number">2</span>).or(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">try</span> database.insertSoftware(user: dbUser, name: tuple.<span class="number">0</span>, </span><br><span class="line">   id: tuple.<span class="number">1</span>, type: <span class="string">"game"</span>, </span><br><span class="line">       amount: <span class="type">Int</span>(tuple.<span class="number">2</span>).or(<span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, or: &#123; <span class="keyword">throw</span> <span class="type">ParseError</span>.msg(<span class="string">"Invalid Package"</span>) &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们对比下，至少会有两点映入眼帘：</p><ol><li>代码量更少</li><li>代码看起来更复杂了</li></ol><p>在组合使用可选扩展时，我故意造成一种过载状态。其中的一部分使用很恰当，但是另一部分却不那么合适。然而，使用扩展的关键不在于过度依赖（正如我上面做的那样），而在于这些扩展是否使语义更加清晰明了。比较上面的两个实现方式，<br>在第二个实现中，考虑下是使用 Swift 本身提供的功能好还是使用可选扩展更佳。</p><p>这就是本文的全部内容，感谢阅读！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      关于 Swift 可选项（Optional）扩展
    
    </summary>
    
      <category term="APPVENTURE" scheme="https://swift.gg/categories/APPVENTURE/"/>
    
    
      <category term="Swift，iOS开发，Swift进阶" scheme="https://swift.gg/tags/Swift%EF%BC%8CiOS%E5%BC%80%E5%8F%91%EF%BC%8CSwift%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>Mirror 的工作原理</title>
    <link href="https://swift.gg/2018/11/15/how-mirror-works/"/>
    <id>https://swift.gg/2018/11/15/how-mirror-works/</id>
    <published>2018-11-15T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://swift.org/blog/how-mirror-works/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-09-26<br>译者：<a href="https://nemocdz.github.io/" target="_blank" rel="noopener">Nemocdz</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://linusling.com" target="_blank" rel="noopener">小铁匠Linus</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>尽管 Swift 重心在强调静态类型上，但它同时支持丰富的元数据类型。元数据类型允许代码在运行时检查和操作任意值。这个功能通过 <code>Mirror</code> API 暴露给 Swift 开发者。大家可能会感到困惑，在 Swift 这种如此强调静态类型的语言里，<code>Mirror</code> 这样的特性是怎么工作的？让我们一起来通过这篇文章了解一下。</p><a id="more"></a><h2 id="事先声明"><a href="#事先声明" class="headerlink" title="事先声明"></a>事先声明</h2><p>这里介绍的东西都是内部实现的细节。这些代码的版本是写下文章时的版本，代码可能会随着版本改变。元数据会随着 ABI 稳定的到来而变得稳定和可靠，但在到来那时也会容易发生变化。大家在写日常的 Swift 代码时，不要依赖这里讲的一切。如果你想做比 <code>Mirror</code> 所提供的方式更复杂的反射，这里会给你一些思路。但在 ABI 的稳定前，还需要保持相关变化的关注。如果你想使用 <code>Mirror</code> 本身，这篇文章会提供一些好的思路去做接入和适配。不过再次提醒，这些东西可能会随着版本而改变。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><code>Mirror(reflecting:)</code> 初始化方法可以接受任意值，返回结果是一个提供该值子元素集合 <code>Children</code> 的相关信息的实例。一个 <code>Child</code> 由可选的标签和值构成。可以在编译期且不用知道任何类型信息情况下，在 <code>Child</code> 的值上用 <code>Mirror</code> 去遍历整个对象的层级视图。</p><p><code>Mirror</code> 允许类型用遵循 <code>CustomReflectable</code> 协议的方式提供一个自定义的表示方式。这给那些想表示得比内建形式更友好的类型提供一种有效的方法。 比如 <code>Array</code> 类型遵守 <code>CustomReflectable</code> 协议并且暴露其中的元素为无标签的 <code>Children</code>。<code>Dictionary</code> 使用这种方法暴露其中的键值对为带标签的 <code>Children</code>。</p><p>对于其他类型，<code>Mirror</code> 用魔法去返回一个基于其中的实际子元素的 <code>Children</code> 集合。对于结构体和类，<code>Children</code> 为其中储存的属性值。对于元组，<code>Children</code> 为元组的子元素。枚举则是枚举的 case 和其关联的值（如果有的话）。</p><p>这些神奇的魔法是怎么工作的呢？让我们一起来了解一下。</p><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>反射的 API 有一部分是用 Swift 实现的，另一部分是用 C++ 实现的。Swift 更适合用在实现更 Swift 的接口，并让很多任务变得更简单。Swift 的运行时的底层是使用 C++ 实现的，但是在 Swift 中不能直接访问 C++ 的类，所以有一个 C 的连接层。反射的 Swift 实现在 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/ReflectionMirror.swift" target="_blank" rel="noopener">ReflectionMirror.swift</a>，C++ 实现在 <a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/ReflectionMirror.mm" target="_blank" rel="noopener">ReflectionMirror.mm</a>。</p><p>这两者通过一小组暴露给 Swift 的 C++ 函数进行通信的。与其使用 Swift 生成的 C 桥接层，不如将这些函数在 Swift 中直接声明成指定的自定义符号，而这些名字的 C++ 函数则专门实现为可以被 Swift 直接调用的方式。这两部分的代码可以在不关心桥接机制会在幕后如何处理传递值的情况下交互，但仍需要准确的知道 Swift 应该如何传递参数和返回值。除非你在使用需要它的运行时代码，否则别轻易尝试这些。</p><p>举个例子，让我们看下在 <code>ReflectionMirror.swift</code> 中的 <code>_getChildCount</code> 函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_count"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getChildCount</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T, type: Any.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><p><code>@_silgen_name</code> 修饰符会通知 Swift 编译器将这个函数映射成 <code>swift_reflectionMirror_count</code> 符号，而不是 Swift 通常对应到的 <code>_getChildCount</code> 方法名修饰。需要注意的是，最前面的下划线表示这个修饰符是被保留在标准库中的。在 C++ 这边，这个函数是这样的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SWIFT_CC(swift) SWIFT_RUNTIME_STDLIB_INTERFACE</span><br><span class="line"><span class="keyword">intptr_t</span> swift_reflectionMirror_count(OpaqueValue *value,</span><br><span class="line">                                      <span class="keyword">const</span> Metadata *type,</span><br><span class="line">                                      <span class="keyword">const</span> Metadata *T) &#123;</span><br></pre></td></tr></table></figure><p><code>SWIFT_CC(swift)</code> 会告诉编译器这个函数使用的是 Swift 的调用约定，而不是 C/C++ 的。<code>SWIFT_RUNTIME_STDLIB_INTERFACE</code> 标记这是个函数，在 Swift 侧的一部分接口中，而且它还有标记为 <code>extern &quot;C&quot;</code> 的作用从而避免 C++ 的方法名修饰，并确保它在 Swift 侧会有预期的符号。同时，C++ 的参数会去特意匹配在 Swift 中声明的函数调用。当 Swift 调用 <code>_getChildCount</code> 时，C++ 会用包含的 Swift 值指针的 <code>value</code>，包含类型参数的 <code>type</code>，包含类型相应的范型 <code>&lt;T&gt;</code> 的 <code>T</code> 的函数参数来调用此函数。</p><p><code>Mirror</code> 的在 Swift 和 C++ 之间的全部接口由以下函数组成：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_normalizedType"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getNormalizedType</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T, type: Any.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Any</span>.<span class="type">Type</span></span><br><span class="line"></span><br><span class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_count"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getChildCount</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T, type: Any.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">typealias</span> <span class="type">NameFreeFunc</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">CChar</span>&gt;?) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_subscript"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getChild</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  of: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  type: Any.<span class="keyword">Type</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  index: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">  outName: UnsafeMutablePointer&lt;UnsafePointer&lt;CChar&gt;?&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  outFreeFunc: UnsafeMutablePointer&lt;NameFreeFunc?&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns 'c' (class), 'e' (enum), 's' (struct), 't' (tuple), or '\0' (none)</span></span><br><span class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_displayStyle"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getDisplayStyle</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T)</span></span> -&gt; <span class="type">CChar</span></span><br><span class="line"></span><br><span class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_quickLookObject"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getQuickLookObject</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T)</span></span> -&gt; <span class="type">AnyObject</span>?</span><br><span class="line"></span><br><span class="line">@_silgen_name(<span class="string">"_swift_stdlib_NSObject_isKindOfClass"</span>)</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_isImpl</span><span class="params">(<span class="number">_</span> object: AnyObject, kindOf: AnyObject)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><h2 id="神奇的动态派发"><a href="#神奇的动态派发" class="headerlink" title="神奇的动态派发"></a>神奇的动态派发</h2><p>没有一种单一、通用的方式去获取任意类型中我们想要的信息。元组、结构、类和枚举都需要不同的代码去完成这些繁多的任务，比如说查找子元素的数量。其中还有一些更深、微妙的不同之处，比如对 Swift 和 Objective-C 的类的不同处理。</p><p>所有的这些函数因为需要不同类型的检查而需要派发不同的实现代码。这听起来有点像动态方法派发，除了选择哪种实现去调用比检查对象类型所使用的方法更复杂之外。这些反射代码尝试去简化使用包含 C++ 版本信息的接口的抽象基类，还有一大堆包含各种各样情况的子类进行 C++ 的动态派发。一个单独的函数会将一个 Swift 类型映射成一个其中的 C++ 类的实例。在一个实例上调用一个方法然后派发合适的实现。</p><p>映射的函数叫做 <code>call</code>，声明是这样的：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">call</span><span class="params">(OpaqueValue *passedValue, <span class="keyword">const</span> Metadata *T, <span class="keyword">const</span> Metadata *passedType,</span></span></span><br><span class="line">          const F &amp;f) -&gt; decltype(f(nullptr))</span><br></pre></td></tr></table></figure><p><code>passedValue</code> 是实际需要传入的Swift的值的指针。<code>T</code> 是该值得静态类型，对应 Swift 中的范型参数 <code>&lt;T&gt;</code>。<code>passedType</code> 是被显式传递进 Swift 侧并且会实际应用在反射过程中的类型（这个类型和在使用 <code>Mirror</code> 作为父类的实例在实际运行时的对象类型不一样）。最后，<code>f</code> 参数会传递这个函数查找到的会被调用的实现的对象引用。然后这个函数会返回当这个 <code>f</code> 参数调用时的返回值，可以让使用者更方便的获得返回值。</p><p><code>call</code> 的实现并没有想象中那么令人激动。主要是一个大型的 <code>switch</code> 声明和一些额外的代码去处理特殊的情况。重要的是它会用一个 <code>ReflectionMirrorImpl</code> 的子类实例去结束调用 <code>f</code>，然后会调用这个实例上的方法去让真正的工作完成。</p><p>这是 <code>ReflectionMirrorImpl</code>，接口的所有东西都要传入：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReflectionMirrorImpl</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> Metadata *type;</span><br><span class="line">  OpaqueValue *value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">displayStyle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> intptr_t <span class="title">count</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> AnyReturn <span class="title">subscript</span><span class="params">(<span class="keyword">intptr_t</span> index, <span class="keyword">const</span> <span class="keyword">char</span> **outName,</span></span></span><br><span class="line">                              void (**outFreeFunc)(const char *)) = 0;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">enumCaseName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SWIFT_OBJC_INTEROP</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> id <span class="title">quickLookObject</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nil; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~ReflectionMirrorImpl() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作用在 Swift 和 C++ 组件之间的接口函数就会用 <code>call</code> 去调用相应的方法。比如，<code>swift_reflectionMirror_count</code> 是这样的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SWIFT_CC(swift) SWIFT_RUNTIME_STDLIB_INTERFACE</span><br><span class="line"><span class="keyword">intptr_t</span> swift_reflectionMirror_count(OpaqueValue *value,</span><br><span class="line">                                      <span class="keyword">const</span> Metadata *type,</span><br><span class="line">                                      <span class="keyword">const</span> Metadata *T) &#123;</span><br><span class="line">  <span class="keyword">return</span> call(value, T, type, [](ReflectionMirrorImpl *impl) &#123;</span><br><span class="line">    <span class="keyword">return</span> impl-&gt;count();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元组的反射"><a href="#元组的反射" class="headerlink" title="元组的反射"></a>元组的反射</h2><p>先看看元组的反射，应该是最简单的一种了，但还是做了不少工作。它一开始会返回 <code>&#39;t&#39;</code> 的显示样式来表明这是一个元组：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TupleImpl</span> :</span> ReflectionMirrorImpl &#123;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">displayStyle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'t'</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>虽然用硬编码的常量看起来不是很常见，不过这样做可以完全在同一个地方给 C++ 和 Swift 这个值的引用，并且他们不需要使用桥接层进行交互，这还算是一个合理的选择。</p><p>接下来是 <code>count</code> 方法。此时我们知道 <code>type</code> 实际上是一个 <code>TupleTypeMetadata</code> 类型的指针而不仅仅是一个 <code>Metadata</code> 类型的指针。<code>TupleTypeMetadata</code> 有一个记录元组的元素数量的 <code>NumElements</code> 字段，然后这个方法就完成了：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> count() &#123;</span><br><span class="line">    <span class="keyword">auto</span> *Tuple = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TupleTypeMetadata *&gt;(type);</span><br><span class="line">    <span class="keyword">return</span> Tuple-&gt;NumElements;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>subscript</code> 方法会做更多一点的工作。它也从一样的的 <code>static_cast</code> 函数开始：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AnyReturn <span class="title">subscript</span><span class="params">(<span class="keyword">intptr_t</span> i, <span class="keyword">const</span> <span class="keyword">char</span> **outName,</span></span></span><br><span class="line">                      void (**outFreeFunc)(const char *)) &#123;</span><br><span class="line">    <span class="keyword">auto</span> *Tuple = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TupleTypeMetadata *&gt;(type);</span><br></pre></td></tr></table></figure><p>接下来，会有一个边界检查避免调用者请求了这个元组不存在的索引：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || (<span class="keyword">size_t</span>)i &gt; Tuple-&gt;NumElements)</span><br><span class="line">      swift::crash(<span class="string">"Swift mirror subscript bounds check failure"</span>);</span><br></pre></td></tr></table></figure><p>下标有两个作用：可以检索元素和对应的名字。对于一个结构体或者类来说，这个名字就是所储存的属性名。而对于元组来说，这个名字要么是该元素的元组标签，要么在没有标签的情况下就是一个类似 <code>.0</code> 的数值指示器。</p><p>标签以一个用空格做间隔的列表存储，放在元数据的 <code>Labels</code> 字段中。这段代码查找列表中的第 i 个字符串：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确定是否有一个标签</span></span><br><span class="line"><span class="keyword">bool</span> hasLabel = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">const</span> <span class="keyword">char</span> *labels = Tuple-&gt;Labels) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *space = <span class="built_in">strchr</span>(labels, <span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">intptr_t</span> j = <span class="number">0</span>; j != i &amp;&amp; space; ++j) &#123;</span><br><span class="line">    labels = space + <span class="number">1</span>;</span><br><span class="line">    space = <span class="built_in">strchr</span>(labels, <span class="string">' '</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we have a label, create it.</span></span><br><span class="line">  <span class="keyword">if</span> (labels &amp;&amp; space &amp;&amp; labels != space) &#123;</span><br><span class="line">    *outName = strndup(labels, space - labels);</span><br><span class="line">    hasLabel = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在没有标签的情况下，创建一个合适的数值指示器作为名字：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!hasLabel) &#123;</span><br><span class="line">  <span class="comment">// The name is the stringized element number '.0'.</span></span><br><span class="line">  <span class="keyword">char</span> *str;</span><br><span class="line">  asprintf(&amp;str, <span class="string">".%"</span> PRIdPTR, i);</span><br><span class="line">  *outName = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为要将 Swift 和 C++ 交叉使用，所以不能享受一些方便的特性比如自动内存管理。Swift 有 ARC，C++ 有 RALL， 但是这两种技术没办法兼容。<code>outFreeFunc</code> 允许 C++ 的代码提供一个函数给调用者用来释放返回的名字。标签需要使用 <code>free</code> 进行释放，所以设置给 <code>*outFreeFunc</code> 相应的值如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*outFreeFunc = [](<span class="keyword">const</span> <span class="keyword">char</span> *str) &#123; <span class="built_in">free</span>(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(str)); &#125;;</span><br></pre></td></tr></table></figure><p>值得注意的是名字，但令人惊讶的是，这个值检索起来很简单。<code>Tuple</code> 元数据包含了一个可以用索引去获取元素的相关信息的返回的函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;elt = Tuple-&gt;getElement(i);</span><br></pre></td></tr></table></figure><p><code>elt</code> 包含了一个偏移值，可以应用在元组值上，去获得元素的值指针：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> *bytes = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(value);</span><br><span class="line"><span class="keyword">auto</span> *eltData = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> OpaqueValue *&gt;(bytes + elt.Offset);</span><br></pre></td></tr></table></figure><p><code>elt</code> 还包含了元素的类型。可以通过类型和值的指针，去构造一个包括这个值新的 <code>Any</code> 对象。这个类型有可以分配内存并初始化包含给定类型的值的储存字段的函数指针。用这些函数拷贝值为 <code>Any</code> 类型的对象，然后返回 <code>Any</code> 给调用者。代码是这样的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    Any result;</span><br><span class="line"></span><br><span class="line">    result.Type = elt.Type;</span><br><span class="line">    <span class="keyword">auto</span> *opaqueValueAddr = result.Type-&gt;allocateBoxForExistentialIn(&amp;result.Buffer);</span><br><span class="line">    result.Type-&gt;vw_initializeWithCopy(opaqueValueAddr,</span><br><span class="line">                                       <span class="keyword">const_cast</span>&lt;OpaqueValue *&gt;(eltData));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> AnyReturn(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就是元组的做法。</p><h2 id="swift-getFieldAt"><a href="#swift-getFieldAt" class="headerlink" title="swift_getFieldAt"></a>swift_getFieldAt</h2><p>在结构、类和枚举中查找元素目前来说相当复杂。造成这么复杂的主要原因是，这些类型和包含这些类型相关信息的字段的字段描述符之间缺少直接的引用关系。有一个叫 <code>swift_getField</code> 的帮助函数可以查找给定类型相应的字段描述符。一但我们添加了那个直接的引用，这整个函数应该就没啥作用了，但在同一时刻，它提供了运行时代码怎么能做到用语言的元数据去查找类型信息的一个有趣思路。</p><p>这个函数原型是这样的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> swift::_swift_getFieldAt(</span><br><span class="line">    <span class="keyword">const</span> Metadata *base, <span class="keyword">unsigned</span> index,</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(llvm::StringRef name, FieldType fieldInfo)&gt;</span><br><span class="line">        callback) &#123;</span><br></pre></td></tr></table></figure><p>它会用类型去检查，用字段的索引去查找，还有一个会被在信息找到时回调。</p><p>首先就是获取类型的类型上下文描述，包含着更进一步将会被使用的类型的信息：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> *baseDesc = base-&gt;getTypeContextDescriptor();</span><br><span class="line"><span class="keyword">if</span> (!baseDesc)</span><br><span class="line">  <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>这个工作会分为两个部分。第一步查找类型的字段描述符。字段描述符包括所有有关这个类型的字段信息。一旦字段描述符可用，这个函数可以从描述符中查找所需要的信息。</p><p>从描述符中查找信息被封装成一个叫 <code>getFieldAt</code> 的帮助方法， 可以让各种各样地方的其它代码查找到合适的字段描述符。让我们看下这个查询过程。它从获取一个用来将符号还原器开始，将符号修饰过的类名还原为实际的类型引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> dem = getDemanglerForRuntimeTypeResolution();</span><br></pre></td></tr></table></figure><p>会用缓存来加快多次的查找：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;cache = FieldCache.get();</span><br></pre></td></tr></table></figure><p>如果缓存中已经有字段描述符，调用 <code>getFieldAt</code> 来获得：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> Value = cache.FieldCache.find(base)) &#123;</span><br><span class="line">  getFieldAt(*Value-&gt;getDescription());</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让查找的代码更简单，有一个可以检查 <code>FieldDescriptor</code> 是否是被查找的那一个的帮助方法。如果描述符匹配，那么描述符放入缓存中，调用 <code>getFieldAt</code> ，然后返回成功给调用者。匹配的过程是复杂的，不过本质上归纳起来就是去匹配符号修饰的名字：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> isRequestedDescriptor = [&amp;](<span class="keyword">const</span> FieldDescriptor &amp;descriptor) &#123;</span><br><span class="line">  assert(descriptor.hasMangledTypeName());</span><br><span class="line">  <span class="keyword">auto</span> mangledName = descriptor.getMangledTypeName(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!_contextDescriptorMatchesMangling(baseDesc,</span><br><span class="line">                                         dem.demangleType(mangledName)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  cache.FieldCache.getOrInsert(base, &amp;descriptor);</span><br><span class="line">  getFieldAt(descriptor);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字段描述符可用在运行时注册或在编译时放进二进制。这两个循环查找在匹配中所有已知的的字段描述符：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;section : cache.DynamicSections.snapshot()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> *descriptor : section) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isRequestedDescriptor(*descriptor))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;section : cache.StaticSections.snapshot()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;descriptor : section) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isRequestedDescriptor(descriptor))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发现没有匹配时，记录一个警告信息并且在回调返回一个空元组（仅仅为了给一个回调）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">auto</span> typeName = swift_getTypeName(base, <span class="comment">/*qualified*/</span> <span class="literal">true</span>);</span><br><span class="line">  warning(<span class="number">0</span>, <span class="string">"SWIFT RUNTIME BUG: unable to find field metadata for type '%*s'\n"</span>,</span><br><span class="line">             (<span class="keyword">int</span>)typeName.length, typeName.data);</span><br><span class="line">  callback(<span class="string">"unknown"</span>,</span><br><span class="line">           FieldType()</span><br><span class="line">             .withType(TypeInfo(&amp;METADATA_SYM(EMPTY_TUPLE_MANGLING), &#123;&#125;))</span><br><span class="line">             .withIndirect(<span class="literal">false</span>)</span><br><span class="line">             .withWeak(<span class="literal">false</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是字段描述符的查找过程。<code>getFieldAt</code> 帮助方法将字段描述符转化为名字和回调中返回的字段类型。开始它会从字段描述符中请求字段的引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> getFieldAt = [&amp;](<span class="keyword">const</span> FieldDescriptor &amp;descriptor) &#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;field = descriptor.getFields()[index];</span><br></pre></td></tr></table></figure><p>名字可以直接获得在这个引用中访问到：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> name = field.getFieldName(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果这个字段实际上是一个枚举，那么就可能没有类型。先做这种检查，并执行回调：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!field.hasMangledTypeName()) &#123;</span><br><span class="line">  callback(name, FieldType().withIndirect(field.isIndirectCase()));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段的引用将字段类型储存为一个符号修饰的名字。因为回调预期的是元数据的指针，所以符号修饰的名字必须被转化为一个真实的类型。<code>_getTypeByMangledName</code> 函数处理了大部分工作，不过需要调用者解决这个类型用的所有范型参数。这个工作需要将这个类型的所有范型的上下文抽离出来：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> ContextDescriptor *&gt; descriptorPath;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> *parent = <span class="keyword">reinterpret_cast</span>&lt;</span><br><span class="line">                          <span class="keyword">const</span> ContextDescriptor *&gt;(baseDesc);</span><br><span class="line">  <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;isGeneric())</span><br><span class="line">      descriptorPath.push_back(parent);</span><br><span class="line"></span><br><span class="line">    parent = parent-&gt;Parent.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在获得了符号修饰的名字和类型，将它们传入一个 Lambda 表达式来解决范型参数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> typeName = field.getMangledTypeName(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> typeInfo = _getTypeByMangledName(</span><br><span class="line">    typeName,</span><br><span class="line">    [&amp;](<span class="keyword">unsigned</span> depth, <span class="keyword">unsigned</span> index) -&gt; <span class="keyword">const</span> Metadata * &#123;</span><br></pre></td></tr></table></figure><p>如果请求的深度比描述符的路径大小还大，那么就会失败：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (depth &gt;= descriptorPath.size())</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>除此之外，还有从字段的类型中获取范型参数。这需要将索引和深度转化为单独的扁平化的索引，通过遍历描述符的路径，在每个阶段添加范型参数的数量直到达到深度为止：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> currentDepth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> flatIndex = index;</span><br><span class="line"><span class="keyword">const</span> ContextDescriptor *currentContext = descriptorPath.back();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> *context : llvm::reverse(descriptorPath)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (currentDepth &gt;= depth)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  flatIndex += context-&gt;getNumGenericParams();</span><br><span class="line">  currentContext = context;</span><br><span class="line">  ++currentDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果索引比范型参数可达到的深度大，那么失败：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (index &gt;= currentContext-&gt;getNumGenericParams())</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>除此之外，从基本类型中获得合适的范型参数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> base-&gt;getGenericArgs()[flatIndex];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>像之前那样，如果不能找到类型，就用空元组：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeInfo == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  typeInfo = TypeInfo(&amp;METADATA_SYM(EMPTY_TUPLE_MANGLING), &#123;&#125;);</span><br><span class="line">  warning(<span class="number">0</span>, <span class="string">"SWIFT RUNTIME BUG: unable to demangle type of field '%*s'. "</span></span><br><span class="line">             <span class="string">"mangled type name is '%*s'\n"</span>,</span><br><span class="line">             (<span class="keyword">int</span>)name.size(), name.data(),</span><br><span class="line">             (<span class="keyword">int</span>)typeName.size(), typeName.data());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行回调，无论找到了什么：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  callback(name, FieldType()</span><br><span class="line">                     .withType(typeInfo)</span><br><span class="line">                     .withIndirect(field.isIndirectCase())</span><br><span class="line">                     .withWeak(typeInfo.isWeak()));</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就是 <code>swift_getFieldAt</code>。我们带着这个帮助方法看看其他反射的实现。</p><h2 id="结构体的反射"><a href="#结构体的反射" class="headerlink" title="结构体的反射"></a>结构体的反射</h2><p>结构体的实现也是类似的，但稍微有点复杂。这是因为有些结构体类型不完全支持反射，查找名字和偏移值要花费更多力气，而且结构体可能包含需要反射代码去提取的弱引用。</p><p>首先是一个帮助方法去检查结构体是否完全支持反射。结构体元数据里储存这样一个可被访问的标志位。跟上面元组的代码类似，可以知道 <code>type</code> 实际上是一个 <code>StructMetadata</code> 指针，所以我们可以自由的传入：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StructImpl</span> :</span> ReflectionMirrorImpl &#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isReflectable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> *Struct = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> StructMetadata *&gt;(type);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;Description = Struct-&gt;getDescription();</span><br><span class="line">    <span class="keyword">return</span> Description-&gt;getTypeContextDescriptorFlags().isReflectable();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>结构体的显示样式是 s :</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">displayStyle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'s'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子元素的数量是元数据给出的字段的数量，也可能是 0（如果这个类型实际上不能支持反射的话）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> count() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isReflectable()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> *Struct = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> StructMetadata *&gt;(type);</span><br><span class="line">  <span class="keyword">return</span> Struct-&gt;getDescription()-&gt;NumFields;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像之前那样，<code>subscript</code> 方法是比较复杂的部分。它开始也是类似的，做边界检查和查找偏移值：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AnyReturn <span class="title">subscript</span><span class="params">(<span class="keyword">intptr_t</span> i, <span class="keyword">const</span> <span class="keyword">char</span> **outName,</span></span></span><br><span class="line">                    void (**outFreeFunc)(const char *)) &#123;</span><br><span class="line">  <span class="keyword">auto</span> *Struct = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> StructMetadata *&gt;(type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">0</span> || (<span class="keyword">size_t</span>)i &gt; Struct-&gt;getDescription()-&gt;NumFields)</span><br><span class="line">    swift::crash(<span class="string">"Swift mirror subscript bounds check failure"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the offset from its respective vector.</span></span><br><span class="line">  <span class="keyword">auto</span> fieldOffset = Struct-&gt;getFieldOffsets()[i];</span><br></pre></td></tr></table></figure><p>从结构体字段中获取类型信息会更复杂一点。这项工作通过 <code>_swift_getFieldAt</code> 帮助方法进行：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Any result;</span><br><span class="line"></span><br><span class="line">_swift_getFieldAt(type, i, [&amp;](llvm::StringRef name, FieldType fieldInfo) &#123;</span><br></pre></td></tr></table></figure><p>一但它有字段信息，一切就会进行得和元组对应部分的代码类似。填写名字和计算字段储存的指针：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*outName = name.data();</span><br><span class="line">*outFreeFunc = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> *bytes = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(value);</span><br><span class="line"><span class="keyword">auto</span> *fieldData = <span class="keyword">reinterpret_cast</span>&lt;OpaqueValue *&gt;(bytes + fieldOffset);</span><br></pre></td></tr></table></figure><p>这里有一个额外的步骤去拷贝字段的值到 <code>Any</code> 类型的返回值来处理弱引用。<code>loadSpecialReferenceStorage</code> 方法处理这种情况。如果值没有被载入的话那么那个值用普通的储存，并且以普通的方式拷贝到返回值：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">bool</span> didLoad = loadSpecialReferenceStorage(fieldData, fieldInfo, &amp;result);</span><br><span class="line">      <span class="keyword">if</span> (!didLoad) &#123;</span><br><span class="line">        result.Type = fieldInfo.getType();</span><br><span class="line">        <span class="keyword">auto</span> *opaqueValueAddr = result.Type-&gt;allocateBoxForExistentialIn(&amp;result.Buffer);</span><br><span class="line">        result.Type-&gt;vw_initializeWithCopy(opaqueValueAddr,</span><br><span class="line">                                           <span class="keyword">const_cast</span>&lt;OpaqueValue *&gt;(fieldData));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> AnyReturn(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些就是结构体值得注意的了。</p><h2 id="类的反射"><a href="#类的反射" class="headerlink" title="类的反射"></a>类的反射</h2><p>类和结构体很类似，在 <code>ClassImpl</code> 里的代码几乎是相同的。在操作 Objective-C 上有两点值得注意的不同之处。一个是 <code>quickLookObject</code> 的实现，会调起 Objective-C 的  <code>debugQuickLookObject</code>  方法的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SWIFT_OBJC_INTEROP</span></span><br><span class="line"><span class="function">id <span class="title">quickLookObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  id object = [*<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> id *&gt;(value) retain];</span><br><span class="line">  <span class="keyword">if</span> ([object respondsToSelector:@selector(debugQuickLookObject)]) &#123;</span><br><span class="line">    id quickLookObject = [object debugQuickLookObject];</span><br><span class="line">    [quickLookObject retain];</span><br><span class="line">    [object release];</span><br><span class="line">    <span class="keyword">return</span> quickLookObject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>另一个是如果该类的父类是 Objective-C 的类，字段的偏移值需要在 Objective-C 运行时获得：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">uintptr_t</span> fieldOffset;</span><br><span class="line">  <span class="keyword">if</span> (usesNativeSwiftReferenceCounting(Clas)) &#123;</span><br><span class="line">    fieldOffset = Clas-&gt;getFieldOffsets()[i];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#<span class="keyword">if</span> SWIFT_OBJC_INTEROP</span><br><span class="line">    Ivar *ivars = class_copyIvarList((Class)Clas, <span class="literal">nullptr</span>);</span><br><span class="line">    fieldOffset = ivar_getOffset(ivars[i]);</span><br><span class="line">    <span class="built_in">free</span>(ivars);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    swift::crash(<span class="string">"Object appears to be Objective-C, but no runtime."</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="枚举的反射"><a href="#枚举的反射" class="headerlink" title="枚举的反射"></a>枚举的反射</h2><p>枚举有一些不同之处。<code>Mirror</code> 会考虑一个枚举实例最多只包含一个元素，枚举 case 名字作为标签，它的关联值作为值。没有关联值的 case 没有包含的元素。 举个例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> bar</span><br><span class="line">  <span class="keyword">case</span> baz(<span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> quux(<span class="type">String</span>, <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>Foo</code> 类型的值使用 mirror 时，mirror 会显示 <code>Foo.bar</code> 没有子元素，<code>Foo.baz</code> 有一个 <code>Int</code> 类型的元素，<code>Foo.quux</code> 有一个 <code>(String, String)</code> 类型的元素。相同的子标签和类型的类和结构体的值有着相同字段，但同一个类型的不同的枚举 case 不是这样的。关联的值也可能是间接的，所以需要一些特殊处理。</p><p><code>enum</code> 的反射需要四部分核心的信息：case 的名字，tag（表示该值储存的枚举 case 的数字），payload 的类型，是否是间接的 payload。<code>getInfo</code> 方法获取这些值：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getInfo</span><span class="params">(<span class="keyword">unsigned</span> *tagPtr = <span class="literal">nullptr</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> Metadata **payloadTypePtr = <span class="literal">nullptr</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">bool</span> *indirectPtr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>tag 从请求元数据直接检索而来：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> tag = type-&gt;vw_getEnumTag(value);</span><br></pre></td></tr></table></figure><p>其它信息用 <code>_swift_getFieldAt</code> 检索而来。将 tag 作为字段索引来调用，就会提供合适的信息：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Metadata *payloadType = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">bool</span> indirect = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *caseName = <span class="literal">nullptr</span>;</span><br><span class="line">_swift_getFieldAt(type, tag, [&amp;](llvm::StringRef name, FieldType info) &#123;</span><br><span class="line">  caseName = name.data();</span><br><span class="line">  payloadType = info.getType();</span><br><span class="line">  indirect = info.isIndirect();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所有的值会返回给调用者：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (tagPtr)</span><br><span class="line">    *tagPtr = tag;</span><br><span class="line">  <span class="keyword">if</span> (payloadTypePtr)</span><br><span class="line">    *payloadTypePtr = payloadType;</span><br><span class="line">  <span class="keyword">if</span> (indirectPtr)</span><br><span class="line">    *indirectPtr = indirect;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> caseName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（你可能会好奇：为什么只有 case 的名字是直接返回的，而其它的三个信息用指针返回？为什么不返回 tag 或者 payload 的类型？答案是：我真的不知道，可能在那个时机看起来是个好主意）</p><p><code>count</code> 方法可以用 <code>getInfo</code> 方法去检索 payload 的类型，并返回 0 或 1 表示 payload 类型是否为 null：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> count() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isReflectable()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Metadata *payloadType;</span><br><span class="line">  getInfo(<span class="literal">nullptr</span>, &amp;payloadType, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">return</span> (payloadType != <span class="literal">nullptr</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>subscript</code>方法开始会获取所有有关这个值的信息：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AnyReturn <span class="title">subscript</span><span class="params">(<span class="keyword">intptr_t</span> i, <span class="keyword">const</span> <span class="keyword">char</span> **outName,</span></span></span><br><span class="line">                    void (**outFreeFunc)(const char *)) &#123;</span><br><span class="line">  <span class="keyword">unsigned</span> tag;</span><br><span class="line">  <span class="keyword">const</span> Metadata *payloadType;</span><br><span class="line">  <span class="keyword">bool</span> indirect;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> *caseName = getInfo(&amp;tag, &amp;payloadType, &amp;indirect);</span><br></pre></td></tr></table></figure><p>实际的复制值需要更多的工作。为了处理间接的值，整个过程在一个额外的 box 中进行：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Metadata *boxType = (indirect ? &amp;METADATA_SYM(Bo).base : payloadType);</span><br><span class="line">BoxPair pair = swift_allocBox(boxType);</span><br></pre></td></tr></table></figure><p>间接的情况下，真实值要在 box 中取出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (indirect) &#123;</span><br><span class="line">  <span class="keyword">const</span> HeapObject *owner = *<span class="keyword">reinterpret_cast</span>&lt;HeapObject * <span class="keyword">const</span> *&gt;(value);</span><br><span class="line">  value = swift_projectBox(<span class="keyword">const_cast</span>&lt;HeapObject *&gt;(owner));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在一切都准备好了。给 case 名字设置子标签：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*outName = caseName;</span><br><span class="line">*outFreeFunc = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>似曾相识的方式被用在将 payload 返回为 <code>Any</code> 类型的对象：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  Any result;</span><br><span class="line"></span><br><span class="line">  result.Type = payloadType;</span><br><span class="line">  <span class="keyword">auto</span> *opaqueValueAddr = result.Type-&gt;allocateBoxForExistentialIn(&amp;result.Buffer);</span><br><span class="line">  result.Type-&gt;vw_initializeWithCopy(opaqueValueAddr,</span><br><span class="line">                                     <span class="keyword">const_cast</span>&lt;OpaqueValue *&gt;(value));</span><br><span class="line"></span><br><span class="line">  swift_release(pair.object);</span><br><span class="line">  <span class="keyword">return</span> AnyReturn(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其余种类"><a href="#其余种类" class="headerlink" title="其余种类"></a>其余种类</h2><p>文件中还有三种其他的实现，每种几乎都没做什么事情。<code>ObjCClassImpl</code> 处理 Objective-C 的类。它甚至不去尝试返回任何子元素，因为 Objective-C 在 ivars 的内容上允许太多种补救方案了。Objective-C 的类允许保持野指针一直存在，并需要单独的逻辑让实现不要去碰那个值。因为这样的值尝试作为 <code>Mirror</code> 子元素返回，会违反 Swift 的安全性保证。因为没有办法可靠地去告知应该如何处理如果值出了问题，所以代码避开处理整个这种情况。</p><p><code>MetatypeImpl</code> 处理元类型。如果将 <code>Mirror</code> 用在实际的类型，比如这样用 <code>Mirror(reflecting:String.self)</code>，这时就会用到它。第一反应是，它会在这时提供一些有用的信息。但实际上它仅仅返回空，甚至没有去尝试获取任何东西。同样的，<code>OpaqueImpl</code> 处理不透明的类型并返回空。</p><h2 id="Swift-侧接口"><a href="#Swift-侧接口" class="headerlink" title="Swift 侧接口"></a>Swift 侧接口</h2><p>在 Swift 侧，<code>Mirror</code> 调用在 C++ 侧实现的接口函数，去检索需要的信息，然后以更友好的方式去展现。这些会在 <code>Mirror</code> 的初始化器中完成：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">init</span>(internalReflecting subject: <span class="type">Any</span>,</span><br><span class="line">            subjectType: <span class="type">Any</span>.<span class="type">Type</span>? = <span class="literal">nil</span>,</span><br><span class="line">            customAncestor: <span class="type">Mirror</span>? = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p><code>subjectType</code> 是将要被反射 <code>subject</code> 的值的类型。这通常是值的运行时类型，但如果调用者用 <code>superclassMirror</code> 去找到上面的类的层级，它可以是父类。如果调用者不传 入<code>subjectType</code>，代码会问 C++ 侧的代码要 <code>subject</code> 的类型：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> subjectType = subjectType ?? _getNormalizedType(subject, type: type(of: subject))</span><br></pre></td></tr></table></figure><p>然后它就会获取子元素的数量，创建一个稍后获取每个子元素个体的集合来构建构建 <code>children</code> 对象：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> childCount = _getChildCount(subject, type: subjectType)</span><br><span class="line"><span class="keyword">let</span> children = (<span class="number">0</span> ..&lt; childCount).<span class="built_in">lazy</span>.<span class="built_in">map</span>(&#123;</span><br><span class="line">  getChild(of: subject, type: subjectType, index: $<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">self</span>.children = <span class="type">Children</span>(children)</span><br></pre></td></tr></table></figure><p><code>getChild</code> 函数是 C++ 的 <code>_getChild</code> 函数的简单封装，将标签名字中包含的 C 字符串转换成 Swift 字符串。</p><p><code>Mirror</code> 有一个 <code>superclassMirror</code> 属性，会返回检查过类的层级结构里上一层的类的属性的 <code>Mirror</code> 对象。在内部，它有一个 <code>_makeSuperclassMirror</code> 属性保存着一个按需求构建父类的 <code>Mirror</code> 的闭包。闭包一开始会获取 <code>subjectType</code> 的父类。非类的类型和没有父类的类没有父类的 Mirror，所以他们会获取到 <code>nil</code>:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>._makeSuperclassMirror = &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> subjectClass = subjectType <span class="keyword">as</span>? <span class="type">AnyClass</span>,</span><br><span class="line">        <span class="keyword">let</span> superclass = _getSuperclass(subjectClass) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调用者可以用一个可作为父类 Mirror 直接返回的 <code>Mirror</code> 实例来指定自定义的祖先的表现：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> customAncestor = customAncestor &#123;</span><br><span class="line">  <span class="keyword">if</span> superclass == customAncestor.subjectType &#123;</span><br><span class="line">    <span class="keyword">return</span> customAncestor</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> customAncestor._defaultDescendantRepresentation == .suppressed &#123;</span><br><span class="line">    <span class="keyword">return</span> customAncestor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，给相同值返回一个将 <code>superclass</code> 作为 <code>subjectType</code> 的新 <code>Mirror</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="type">Mirror</span>(internalReflecting: subject,</span><br><span class="line">                subjectType: superclass,</span><br><span class="line">                customAncestor: customAncestor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，它获取并解析显示的样式，并设置 <code>Mirror</code> 的剩下的属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> rawDisplayStyle = _getDisplayStyle(subject)</span><br><span class="line">  <span class="keyword">switch</span> <span class="type">UnicodeScalar</span>(<span class="type">Int</span>(rawDisplayStyle)) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"c"</span>: <span class="keyword">self</span>.displayStyle = .<span class="keyword">class</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"e"</span>: <span class="keyword">self</span>.displayStyle = .<span class="keyword">enum</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"s"</span>: <span class="keyword">self</span>.displayStyle = .<span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"t"</span>: <span class="keyword">self</span>.displayStyle = .tuple</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"\0"</span>: <span class="keyword">self</span>.displayStyle = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">default</span>: <span class="built_in">preconditionFailure</span>(<span class="string">"Unknown raw display style '<span class="subst">\(rawDisplayStyle)</span>'"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.subjectType = subjectType</span><br><span class="line">  <span class="keyword">self</span>._defaultDescendantRepresentation = .generated</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Swift 丰富的元数据类型大多数在幕后存在，为像协议一致性检查和泛型类型解决这样的事提供支持。其中某些通过 <code>Mirror</code> 类 型暴露给用户，从而允许在运行时检查任意值。对于静态类型的 Swift 生态来说，这种方式一开始看起来有点奇怪和神秘，但根据已经存在的信息来看，它其实是个简单直接的应用。这个实现的探索旅程应该会帮助大家了解神秘之处，并在使用 <code>Mirror</code> 时可以意识到背后正在进行着什么。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://swift.org/blog/how-mirror-works/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-09-26&lt;br&gt;译者：&lt;a href=&quot;https://nemocdz.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nemocdz&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;http://linusling.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小铁匠Linus&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;尽管 Swift 重心在强调静态类型上，但它同时支持丰富的元数据类型。元数据类型允许代码在运行时检查和操作任意值。这个功能通过 &lt;code&gt;Mirror&lt;/code&gt; API 暴露给 Swift 开发者。大家可能会感到困惑，在 Swift 这种如此强调静态类型的语言里，&lt;code&gt;Mirror&lt;/code&gt; 这样的特性是怎么工作的？让我们一起来通过这篇文章了解一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
      <category term="Swift" scheme="https://swift.gg/categories/Mike-Ash/Swift/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>NSDataAsset</title>
    <link href="https://swift.gg/2018/11/12/nshipster-nsdataasset/"/>
    <id>https://swift.gg/2018/11/12/nshipster-nsdataasset/</id>
    <published>2018-11-12T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/nsdataasset/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-08-26<br>译者：<a href="https://github.com/mobilefellow" target="_blank" rel="noopener">雨谨</a>；校对：<a href="https://github.com/wongzigii" target="_blank" rel="noopener">wongzigii</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>在 Web 的世界里，速度不是一种奢求；它事关生死。</p><p>近年来的用户研究表明，页面加载中 _任何_ 可以察觉到的延迟 —— 即大于 400 毫秒（字面意义上的“一眨眼的功夫”） —— 都会对转化率和参与率产生负面影响。网页加载时每多花一秒，就会多 10% 的用户返回或者关闭这个页面。</p><p>对于谷歌、亚马逊和 Netflix 这样的大型的互联网公司而言，这里和那里额外的一秒钟可能意味着年收入里的 <em>数十亿</em> 美金。所以那些公司投入如此多的工程努力来让网页更快，也没有什么奇怪的了。</p><p>有很多加速网络请求的技术：压缩和流技术、缓存和预加载、连接池和多路复用、延迟和后台运行。然而，还有一种比它们优先级更高，效果更好的优化策略：<em>不要在刚开始的地方发送请求</em>。</p><p>在这个方面，App 凭借先下载后使用的特点，拥有传统网页所不具备的独特优势。在这一周的 NSHipster 里，我们将展示如何以一种非传统的方式使用 Asset Catalog 来改善你的 App 的首次启动体验。</p><a id="more"></a><p>Asset Catalog 允许你根据当前设备的特点来组织资源文件。对于一个给定的图片，你可以根据设备（iPhone、iPad、Apple Watch、Apple TV、Mac）、屏幕分辨率（<code>@2x</code> / <code>@3x</code>）或者色域（sRGB / P3），提供不同的文件。对于其他类型的 asset，你可能根据可用内存或者 Metal 版本的不同而提供不同的文件。请求 asset 时仅需提供名字，最合适的那个资源就会自动返回。</p><p>除了提供更简便的 API，Asset Catalog 还允许 App 使用 <a href="https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f" target="_blank" rel="noopener">App 瘦身</a> 为每个用户设备提供一个经过优化的更小的安装包。</p><p>图片是最常见的 Asset 类型，但是从 iOS 9 和 macOS El Capitan 开始，JSON、XML 和其他数据文件之类的资源也可以通过 <a href="https://developer.apple.com/documentation/uikit/nsdataasset" target="_blank" rel="noopener"><code>NSDataAsset</code></a> 加入到这种乐趣中。</p><h2 id="如何使用-Asset-Catalog-存储和获取数据"><a href="#如何使用-Asset-Catalog-存储和获取数据" class="headerlink" title="如何使用 Asset Catalog 存储和获取数据"></a>如何使用 Asset Catalog 存储和获取数据</h2><p>举个例子，让我们想象一个用于创建数字调色板的 iOS App。</p><p>为了区分不同深浅的灰色，我们可能会加载一个颜色和对应名字的列表。通常情况下，我们可能会在第一次启动时从服务器下载这个列表，但是如果恶劣的网络环境限制了 App 的功能，就会导致很差的用户体验。既然它是一个相对静态的数据集，为什么不以一种 Asset Catalog 形式将它添加到 app bundle 中？</p><h3 id="步骤-1：向-Asset-Catalog-中添加-New-Data-Set"><a href="#步骤-1：向-Asset-Catalog-中添加-New-Data-Set" class="headerlink" title="步骤 1：向 Asset Catalog 中添加 New Data Set"></a>步骤 1：向 Asset Catalog 中添加 New Data Set</h3><p>当你在 Xcode 中新建一个 app 项目时，它会自动生成一个 Asset Catalog。在项目导航（Project navigator）中选中 <code>Assets.xcassets</code>，打开 Asset Catalog 编辑器。点击左下方的 <kbd>+</kbd> 图标，然后选择 “New Data Set”。</p><p><img src="https://nshipster.com/assets/add-new-data-set-b6d8b1604dd12f49f1e034c0a36a42aa9fc6efc3f42d7320d9b489b6cec5fde0.png" alt=""></p><p>这样会在 <code>Assets.xcassets</code> 下新建一个后缀名为 <code>.dataset</code> 的子目录。</p><blockquote><p>默认情况下，Finder （访达）把这两种 bundle 都当做目录，以便在需要时查看和修改它们的内容。</p></blockquote><h3 id="步骤2：添加数据文件"><a href="#步骤2：添加数据文件" class="headerlink" title="步骤2：添加数据文件"></a>步骤2：添加数据文件</h3><p>打开 Finder，找到数据文件，把它拖拽到 Xcode 中 data set asset 的空白处。</p><p><img src="https://nshipster.com/assets/asset-catalog-any-any-universal-f634190ce57540a9fa1406ded75e13936c390fb0552b374d584510896db186bc.png" alt=""></p><p>当你这么做时，Xcode 会把那个文件复制到 <code>.dataset</code> 子目录，并将它的文件名和 <a href="https://en.wikipedia.org/wiki/Uniform_Type_Identifier" target="_blank" rel="noopener">通用类型标识符（Universal Type Identifier）</a> 更新到 <code>contents.json</code> 元数据文件。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"info"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"author"</span>: <span class="string">"xcode"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"idiom"</span>: <span class="string">"universal"</span>,</span><br><span class="line">      <span class="attr">"filename"</span>: <span class="string">"colors.json"</span>,</span><br><span class="line">      <span class="attr">"universal-type-identifier"</span>: <span class="string">"public.json"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤3：使用-NSDataAsset-访问数据"><a href="#步骤3：使用-NSDataAsset-访问数据" class="headerlink" title="步骤3：使用 NSDataAsset 访问数据"></a>步骤3：使用 NSDataAsset 访问数据</h3><p>现在你可以使用如下代码访问文件的数据：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> asset = <span class="type">NSDataAsset</span>(name: <span class="string">"NamedColors"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Missing data asset: NamedColors"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = asset.data</span><br></pre></td></tr></table></figure><p>对于我们颜色 App，我们可能在一个 view controller 的 <code>viewDidLoad()</code> 方法中调用上面的代码，然后解码返回的数据，获取 model 对象的数组，并展示在一个 table view 上。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">self</span>.colors = <span class="keyword">try</span>! decoder.decode([<span class="type">NamedColor</span>].<span class="keyword">self</span>, from: asset.data)</span><br></pre></td></tr></table></figure><h2 id="混合一下"><a href="#混合一下" class="headerlink" title="混合一下"></a>混合一下</h2><p>Data set 通常无法从 Asset Catalog 的 App 瘦身特性中获益（例如，大部分的 JSON 文件都不太关心设备所支持的 Metal 版本）。</p><p>但是对于我们的调色板 App，我们可能为支持广色域显示的设备提供不同的颜色列表。</p><p>为了做到这一点，在 Asset Catalog 编辑器的侧边栏选中刚才的 asset，然后点击 Attributes Inspector 下名为 Gamut 的下拉控件。</p><p><img src="https://nshipster.com/assets/select-color-gamut-02114afe2b744c228c2b29b7277abb9ec7e2bcb9afa683cc80115792849988c4.png" alt=""></p><p>为每个色域提供定制的数据文件后，<code>contents.json</code> 元数据文件应该看起来像这样：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"info"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"author"</span>: <span class="string">"xcode"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"idiom"</span>: <span class="string">"universal"</span>,</span><br><span class="line">      <span class="attr">"filename"</span>: <span class="string">"colors-srgb.json"</span>,</span><br><span class="line">      <span class="attr">"universal-type-identifier"</span>: <span class="string">"public.json"</span>,</span><br><span class="line">      <span class="attr">"display-gamut"</span>: <span class="string">"sRGB"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"idiom"</span>: <span class="string">"universal"</span>,</span><br><span class="line">      <span class="attr">"filename"</span>: <span class="string">"colors-p3.json"</span>,</span><br><span class="line">      <span class="attr">"universal-type-identifier"</span>: <span class="string">"public.json"</span>,</span><br><span class="line">      <span class="attr">"display-gamut"</span>: <span class="string">"display-P3"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保鲜一下"><a href="#保鲜一下" class="headerlink" title="保鲜一下"></a>保鲜一下</h2><p>使用 Asset Catalog 存储和获取数据是非常简单的。真正困难 —— 并最终更重要 —— 的是保持数据的更新。</p><p>使用 <code>curl</code>、<code>rsync</code>、<code>sftp</code>、Dropbox、BitTorrent 或 Filecoin 刷新数据。从一个 shell 脚本开始（如果你喜欢，可以在 Xcode Build Phase 中调用它）。将它添加到你的 <code>Makefile</code>、<code>Rakefile</code>、<code>Fastfile</code>，或者你的编译系统所要求的任何地方。将这个任务分配给 Jenkins、Travis 或者某个烦人的实习生。使用定制的 Slack integration 或者 Siri Shortcuts 触发它，这样你就可以用随意的一句 <em>“Hey Siri，在数据变得太旧之前更新一下”</em>，让你的同事大吃一惊。</p><p><strong>注意，当你决定同步你的数据时，一定要确保它是自动化的，而且是你发布过程的一部分。</strong></p><p>下面是一个 shell 脚本示例，你可以运行它来使用 <code>curl</code> 下载最新的数据文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">CURL='/usr/bin/curl'</span><br><span class="line">URL='https://example.com/path/to/data.json'</span><br><span class="line">OUTPUT='./Assets.xcassets/Colors.dataset/data.json'</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">CURL -fsSL -o <span class="variable">$OUTPUT</span> <span class="variable">$URL</span></span></span><br></pre></td></tr></table></figure><h2 id="封装一下"><a href="#封装一下" class="headerlink" title="封装一下"></a>封装一下</h2><p>虽然 Assets Catalog 会对 image asset 执行的无损压缩，但没有任何文档、Xcode 帮助或 WWDC 会议指出 data asset 上也存在这种优化（至少目前没有）。</p><p>当 data asset 的文件大小大于，比如说几百 KB 时，你就要考虑使用压缩了。JSON、CSV 和 XML 之类的文本文件尤其如此，它们通常可以被压缩到原始大小的 60% - 80%。</p><p>我们可以将 <code>curl</code> 的输出发送给 <code>gzip</code>，然后再写到我们的文件，从而为我们之前的 shell 脚本添加压缩功能。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">CURL='/usr/bin/curl'</span><br><span class="line">GZIP='/usr/bin/gzip'</span><br><span class="line">URL='https://example.com/path/to/data.json'</span><br><span class="line">OUTPUT='./Assets.xcassets/Colors.dataset/data.json.gz'</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">CURL -fsSL <span class="variable">$URL</span> | <span class="variable">$GZIP</span> -c &gt; <span class="variable">$OUTPUT</span></span></span><br></pre></td></tr></table></figure><p>如果你使用了压缩，请确保 <code>&quot;universal-type-identifier&quot;</code> 字段体现了这一点：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"info"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"author"</span>: <span class="string">"xcode"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"idiom"</span>: <span class="string">"universal"</span>,</span><br><span class="line">      <span class="attr">"filename"</span>: <span class="string">"colors.json.gz"</span>,</span><br><span class="line">      <span class="attr">"universal-type-identifier"</span>: <span class="string">"org.gnu.gnu-zip-archive"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端上，你使用 asset catalog 之前需要先解压数据。如果有 <code>Gzip</code> 模块，你可能会做以下事情：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">Gzip</span>.decompress(data: asset.data)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，如果你会在 App 中反复地这么做，那么可以在 <code>NSDataAsset</code> 的扩展中创建一个便利方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSDataAsset</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">decompressedData</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">Gzip</span>.decompress(data: <span class="keyword">self</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>你还可以考虑使用 <a href="https://git-lfs.github.com" target="_blank" rel="noopener">Git Large File Storage (LFS)</a> 实现大型 data asset 文件的版本控制。</p></blockquote><p>尽管你倾向于认为你的所有用户都享受着快速的、无处不在的 WiFi 和 LTE 网络，但这并不适用于所有人，也不适用于所有时段。</p><p>花点时间看看你的 App 在启动时发出的网络请求，然后考虑哪些可能从预加载中受益。给人留下好的第一印象可能意味着你的 App 是被长期地积极地使用着，而不是几秒钟之后就被删除。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mattt，&lt;a href=&quot;https://nshipster.com/nsdataasset/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-08-26&lt;br&gt;译者：&lt;a href=&quot;https://github.com/mobilefellow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;雨谨&lt;/a&gt;；校对：&lt;a href=&quot;https://github.com/wongzigii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wongzigii&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在 Web 的世界里，速度不是一种奢求；它事关生死。&lt;/p&gt;
&lt;p&gt;近年来的用户研究表明，页面加载中 _任何_ 可以察觉到的延迟 —— 即大于 400 毫秒（字面意义上的“一眨眼的功夫”） —— 都会对转化率和参与率产生负面影响。网页加载时每多花一秒，就会多 10% 的用户返回或者关闭这个页面。&lt;/p&gt;
&lt;p&gt;对于谷歌、亚马逊和 Netflix 这样的大型的互联网公司而言，这里和那里额外的一秒钟可能意味着年收入里的 &lt;em&gt;数十亿&lt;/em&gt; 美金。所以那些公司投入如此多的工程努力来让网页更快，也没有什么奇怪的了。&lt;/p&gt;
&lt;p&gt;有很多加速网络请求的技术：压缩和流技术、缓存和预加载、连接池和多路复用、延迟和后台运行。然而，还有一种比它们优先级更高，效果更好的优化策略：&lt;em&gt;不要在刚开始的地方发送请求&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;在这个方面，App 凭借先下载后使用的特点，拥有传统网页所不具备的独特优势。在这一周的 NSHipster 里，我们将展示如何以一种非传统的方式使用 Asset Catalog 来改善你的 App 的首次启动体验。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>使用 YOLO 进行实时目标检测</title>
    <link href="https://swift.gg/2018/10/29/object-detection-with-yolo/"/>
    <id>https://swift.gg/2018/10/29/object-detection-with-yolo/</id>
    <published>2018-10-29T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Matthijs Hollemans，<a href="http://machinethink.net/blog/object-detection-with-yolo/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018/03/28<br>译者：<a href="https://github.com/YangGao1991" target="_blank" rel="noopener">阳仔</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://linusling.com" target="_blank" rel="noopener">小铁匠Linus</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote> <!--此处开始正文--><p>目标检测是计算机视觉中的经典问题之一：</p><p>识别一幅图像中有哪些目标，以及它们在图像中的位置。</p><p>检测是一个比分类更复杂的问题，因为分类也可以识别目标，但不能准确判断目标在图像中的位置——并且分类不能适用于包含多个目标的图像。</p><p><img src="http://machinethink.net/images/yolo/ClassificationVsDetection.png" alt=""></p><p><a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">YOLO</a> 是一个实时有效的目标检测神经网络。</p><p>在这篇文章中，我将阐述如何使用 Metal Performance Shaders 来将“简化版” YOLOv2 运行在 iOS 设备上。</p><a id="more"></a><p>在继续阅读之前，请先 <a href="https://www.youtube.com/watch?v=VOC3huqHrss" target="_blank" rel="noopener">观看这个令人惊叹的 YOLOv2 介绍视频</a>。</p><h2 id="YOLO-的工作原理"><a href="#YOLO-的工作原理" class="headerlink" title="YOLO 的工作原理"></a>YOLO 的工作原理</h2><p>你可以使用 <a href="http://machinethink.net/blog/convolutional-neural-networks-on-the-iphone-with-vggnet/" target="_blank" rel="noopener">VGGNet</a> 或 <a href="https://github.com/hollance/Forge/tree/master/Examples/Inception" target="_blank" rel="noopener">Inception</a> 这样的分类器，通过一个小的滑动窗口对图像进行遍历，从而形成一个目标检测器。每一步遍历运行一次分类器，来对当前窗口中的目标进行分类。使用这样的滑动窗口，会对一幅图像输出成百上千的检测结果，但你只需要保留分类器最确定的那些结果。</p><p>这种方法是可行的，但很显然会很慢，因为需要运行很多遍分类器。一种效率稍微高一点的方法是，首先判断图像的哪一部分包含了有效的信息——也就是候选区域 (region proposals)——然后仅仅在这些区域中运行分类器。这种方法比滑动窗口的方法能减少分类器的运行次数，但仍然很多。</p><p>YOLO 采用了一种完全不同的方法。它并不是将传统的分类器改造成检测器。YOLO 实际上只对图像进行一次操作（也就是它名字的由来：You Only Look Once），但是是以一种聪明的方式。</p><p>YOLO 将图像分成 13×13 的网格单元：</p><p><img src="http://machinethink.net/images/yolo/Grid.png" alt=""></p><p>每一个网格单元负责预测 5 个检测框。一个检测框是包含一个目标的矩形区域。</p><p>YOLO 同时会给出一个置信度，描述了某个检测框确实包含了某目标的确定程度。这个值和检测框中是什么目标毫无关系，只和检测框的形状大小匹配程度有关。</p><p>预测出的检测框看起来和下图类似（置信度越高，框越粗）：</p><p><img src="http://machinethink.net/images/yolo/Boxes.png" alt=""></p><p>对每个检测框，对应的网格单元还给出了一个分类的预测。这和分类器的工作相似：它给出一个全部可能的类别的概率分布。我们使用的这个版本的 YOLO 是用 <a href="http://host.robots.ox.ac.uk/pascal/VOC/" target="_blank" rel="noopener">PASCAL VOC dataset</a> 训练的，可以检测 20 种不同的类别，比如：</p><ul><li>自行车</li><li>船</li><li>汽车</li><li>猫</li><li>狗</li><li>人</li><li>等等</li></ul><p>检测框的置信度和分类预测最终被整合成一个最终得分，来告诉我们该检测框内包含一个特定类型的目标的概率。例如，左边这个又大又粗的黄色框告诉我们，85% 的概率这里面包含一只狗：</p><p><img src="http://machinethink.net/images/yolo/Scores.png" alt=""></p><p>因为整幅图像包含 13×13 = 169 个网格单元，且每个网格单元预测 5 个检测框，我们最后总计能得到 845 个检测框。实际上，这其中大多数的检测框的置信度都很低，所以，我们只需要保留最终得分大于等于 30% 的检测框就行了（你也可以根据需要的检测准确度改变这个阈值）。</p><p>最终的检测结果：</p><p><img src="http://machinethink.net/images/yolo/Prediction.png" alt=""></p><p>从 845 个检测框中，我们只保留了这三个，因为它们给出的结果最好。尽管我们有 845 个检测框，但它们都是同时得到的——神经网络只需要运行一次。这也是 YOLO 强大而快速的原因。</p><p>（以上图片来自 <a href="https://pjreddie.com/" target="_blank" rel="noopener">pjreddie.com</a>）</p><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>YOLO 的结构只是一个简单的卷积神经网络：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Layer         kernel  stride  output shape</span><br><span class="line">---------------------------------------------</span><br><span class="line">Input                          (416, 416, 3)</span><br><span class="line">Convolution    3×3      1      (416, 416, 16)</span><br><span class="line">MaxPooling     2×2      2      (208, 208, 16)</span><br><span class="line">Convolution    3×3      1      (208, 208, 32)</span><br><span class="line">MaxPooling     2×2      2      (104, 104, 32)</span><br><span class="line">Convolution    3×3      1      (104, 104, 64)</span><br><span class="line">MaxPooling     2×2      2      (52, 52, 64)</span><br><span class="line">Convolution    3×3      1      (52, 52, 128)</span><br><span class="line">MaxPooling     2×2      2      (26, 26, 128)</span><br><span class="line">Convolution    3×3      1      (26, 26, 256)</span><br><span class="line">MaxPooling     2×2      2      (13, 13, 256)</span><br><span class="line">Convolution    3×3      1      (13, 13, 512)</span><br><span class="line">MaxPooling     2×2      1      (13, 13, 512)</span><br><span class="line">Convolution    3×3      1      (13, 13, 1024)</span><br><span class="line">Convolution    3×3      1      (13, 13, 1024)</span><br><span class="line">Convolution    1×1      1      (13, 13, 125)</span><br><span class="line">---------------------------------------------</span><br></pre></td></tr></table></figure><p>该神经网络具有典型的结构：一个 3×3 卷积核的卷积层，采样窗口 2×2 的池化层。没有花哨的东西。YOLO 中没有全连接层。</p><blockquote><p>注意：我们使用的“简化版” YOLO 只有 9 个卷积层和 6 个池化层。完全版 YOLOv2 模型分层数是这个的三倍，并且会更复杂一些，但仍然是一个常规的卷积神经网络。</p></blockquote><p>最后一个卷积层的卷积核为 1×1，是为了将参数降维至 13×13×125。其中的 13×13 看起来很熟悉：这就是图像被划分成的网格单元的数量。</p><p>因此，每个网格单元有 125 个通道。这 125 个通道包含了检测框的数据，以及分类预测的数据。为什么是 125 呢？因为每个网格单元预测 5 个检测框的结果，每个检测框由 25 个数据元素来描述：</p><ul><li>检测框矩形的 x，y，宽，高</li><li>置信度</li><li>在 20 个分类上的概率分布</li></ul><p>YOLO 的使用很简单：输入一幅图像（大小为 416×416 像素），它运行一次卷积网络，输出一个 13×13×125 的张量，描述网格单元以及检测框。你需要做的只是计算每个检测框的最终得分，并抛弃低于 30% 的那些。</p><blockquote><p>小提示：要了解更多有关 YOLO 的工作原理，以及 YOLO 是如何训练的，请 <a href="https://www.youtube.com/watch?v=NM6lrxy0bxs" target="_blank" rel="noopener">观看对它的发明者之一的访谈</a>。这个视频介绍的是 YOLOv1，由于是老版本，结构稍有不同，但主体思想是相同的。很值得观看！</p></blockquote><h2 id="转换成-Metal"><a href="#转换成-Metal" class="headerlink" title="转换成 Metal"></a>转换成 Metal</h2><p>上文描述的是简化版的 YOLO，也是我们将在 iOS 应用中使用的版本。完全版 YOLOv2 的神经网络有三倍的分层数，因为太大，所以在当前的 iPhone 设备上不能快速运行。简化版的 YOLO 使用更少的分层数，因此运行会更快，但准确度也稍差。</p><p><img src="http://machinethink.net/images/yolo/CatOrDog.png" alt=""></p><p>YOLO 使用 Darknet 编写，这是 YOLO 作者自己编写的深度学习框架。能下载到的都是 Darknet 格式。尽管 <a href="https://github.com/pjreddie/darknet" target="_blank" rel="noopener">Darknet 是开源的</a>，我也不想花很多时间去弄清它的工作原理。</p><p>幸运的是，<a href="https://github.com/allanzelener/YAD2K/" target="_blank" rel="noopener">有人</a> 已经做了这件事，将 Darknet 模型转换成了我所使用的深度学习工具 Keras。我所要做的，就是运行这个“YAD2K”脚本，将 Darknet 转换成 Keras 格式，然后用我自己写的脚本将 Keras 转换成 Metal。</p><p>但是，有一点小麻烦。YOLO 在它的卷积层后，使用了一种叫做”批标准化“的规整化方法。</p><p>“批标准化”的思想是，当数据是干净的时候，神经网络能够达到最好的工作效果。理想情况下，一个层级的输入数据的平均值为 0，且方差较小。每个做过机器学习的人都应比较熟悉这一思想，因为我们经常使用一种称为“特征缩放”或“白化”的技术来处理我们的输入数据，以达到这一目的。</p><p>批标准化对层间数据做了类似特征缩放的处理。这种处理能防止数据在神经网络中传递时退化，从而有效提升神经网络的性能。</p><p>为了让你直观感受到批标准化的作用，以下是第一个卷积层分别在应用和未应用批标准化的情况下的输出直方图：</p><p><img src="http://machinethink.net/images/yolo/BatchNorm.png" alt=""></p><p>批标准化在训练一个深度网络时很重要，但事实上，我们在进行推断的时候可以不需要这一处理。不需要进行批标准化的计算，有助于使我们的应用运行更快。在任何时候，Metal 都没有一个 <code>MPSCNNBatchNormalization</code> 层。</p><p>批标准化通常发生在卷积层之后，激活函数（YOLO 中的 ReLU 函数）之前。卷积操作和批标准化操作都是对数据进行线性变换，所以我们可以将批标准化层的参数和卷积权重相结合。这称为将批标准化层“折叠”到卷积层。</p><p>长话短说，使用一些数学方法，我们可以省略批标准化层，但需要改变前序卷积层的权重。</p><p>快速阐述一下卷积层的计算过程：设 <code>x</code> 是输入图像中的像素，<code>w</code> 是卷积层权重，那么，经过卷积层计算，输出的每个像素的值为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">out[j] = x[i]*w[0] + x[i+1]*w[1] + x[i+2]*w[2] + ... + x[i+k]*w[k] + b</span><br></pre></td></tr></table></figure><p>即输入像素矩阵和卷积核权重的点积，再加上偏差项 <code>b</code>。</p><p>以下是对卷积层输出进行批标准化处理的计算过程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        gamma * (out[j] - mean)</span><br><span class="line">bn[j] = ---------------------- + beta</span><br><span class="line">            sqrt(variance)</span><br></pre></td></tr></table></figure><p>批标准化首先对每个像素的输出值减去平均值 <code>mean</code>，再除以标准差，乘以一个缩放系数 <code>gamma</code>，再加上一个偏移值 <code>beta</code>。这四个参数 —— <code>mean</code>，<code>variance</code>，<code>gamma</code>，<code>beta</code> —— 是在网络训练过程中，批标准化层学习得到的。</p><p>为了省略批标准化，我们可以将这两个公式进行稍微的整合，来为卷积层计算新的权重和偏差项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">           gamma * w</span><br><span class="line">w_new = --------------</span><br><span class="line">        sqrt(variance)</span><br><span class="line"></span><br><span class="line">        gamma*(b - mean)</span><br><span class="line">b_new = ---------------- + beta</span><br><span class="line">         sqrt(variance)</span><br></pre></td></tr></table></figure><p>利用这些新的权重和偏差项对输入 <code>x</code> 进行卷积操作，能够得到与原来卷积层加上批标准化处理后同样的结果。</p><p>现在，我们可以去掉批标准化层，只使用卷积层，但参数是经过调节的权重和偏差项 <code>w_new</code> 和 <code>b_new</code>。我们对网络中所有的卷积层都重复这一过程。</p><blockquote><p>注意：事实上，YOLO 中的卷积层没有使用偏差项，因此上述公式中 b 为 0。但请注意，经过整合批标准化的参数后，卷积层就有了偏差项。</p></blockquote><p>一旦我们将所有的批标准化层整合到了它们的前序卷积层，我们就可以将权重转换到 Metal 了。简单地将该数组（Keras 中存储的顺序和 Metal 不同）进行转置，再将其写进 32 位浮点数的二进制文件。</p><p>如果你对这些操作感到好奇，你可以查看转换脚本 <a href="https://github.com/hollance/Forge/blob/master/Examples/YOLO/yolo2metal.py" target="_blank" rel="noopener">yolo2metal.py</a> 来获得详细信息。为了验证整合批标准化的效果，脚本创建了一个不包含批标准化层，但使用了调节后的权重的模型，并将其与原始模型的预测结果进行比对。</p><h2 id="iOS-应用"><a href="#iOS-应用" class="headerlink" title="iOS 应用"></a>iOS 应用</h2><p>我理所当然地使用 <a href="https://github.com/hollance/Forge" target="_blank" rel="noopener">Forge</a> 来编写我的 iOS 应用。😂你可以在 <a href="https://github.com/hollance/Forge/tree/master/Examples/YOLO" target="_blank" rel="noopener">YOLO</a> 文件夹中找到源代码。如果想尝试一下的话，可以下载或者 clone Forge，在 Xcode 8.3 以上版本中打开 <strong>Forge.xcworkspace</strong>，在 iPhone 6 以上设备上运行 <strong>YOLO</strong>。</p><p>最简单的测试方法是将你的 iPhone 对准某个 <a href="https://www.youtube.com/watch?v=e_WBuBqS9h8" target="_blank" rel="noopener">YouTube 视频</a>：</p><p><img src="http://machinethink.net/images/yolo/App.png" alt=""></p><p><strong>YOLO.swift</strong> 中有一些有趣的代码。首先，这里创建了卷积网络：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let leaky = MPSCNNNeuronReLU(device: device, a: 0.1)</span><br><span class="line"></span><br><span class="line">let input = Input()</span><br><span class="line"></span><br><span class="line">let output = input</span><br><span class="line">         --&gt; Resize(width: 416, height: 416)</span><br><span class="line">         --&gt; Convolution(kernel: (3, 3), channels: 16, padding: true, activation: leaky, name: &quot;conv1&quot;)</span><br><span class="line">         --&gt; MaxPooling(kernel: (2, 2), stride: (2, 2))</span><br><span class="line">         --&gt; Convolution(kernel: (3, 3), channels: 32, padding: true, activation: leaky, name: &quot;conv2&quot;)</span><br><span class="line">         --&gt; MaxPooling(kernel: (2, 2), stride: (2, 2))</span><br><span class="line">         --&gt; ...and so on...</span><br></pre></td></tr></table></figure><p>摄像头的输入图像被调整为 416×416 像素大小，接着被输入到卷积层和池化层。这和其他卷积神经网络的操作是非常类似的。</p><p>真正有意思的是对输出的操作。回想一下，我们的输出是一个 13×13×125 的张量：图像中每个网格单元有 125 个通道。这 125 个数字包含了检测框的数据，以及分类预测的数据。我们需要将这些数据通过某些方法进行整理。这些是通过 <code>fetchResult()</code> 实现的。</p><blockquote><p>注意：fetchResult() 函数在 CPU 中运行，而非 GPU。这种实现方式比较简单。有人说 GPU 的并行性会对嵌套循环的运行比较有利。也许我在将来会重新写一个 GPU 的版本。</p></blockquote><p>以下是 <code>fetchResult()</code> 的工作原理：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func fetchResult(inflightIndex: Int) -&gt; NeuralNetworkResult&lt;Prediction&gt; &#123;</span><br><span class="line">  let featuresImage = model.outputImage(inflightIndex: inflightIndex)</span><br><span class="line">  let features = featuresImage.toFloatArray()</span><br></pre></td></tr></table></figure><p>卷积网络的输出是一个 <code>MPSImage</code> 格式的数据。我们首先将其转换成一个 <code>Float</code> 的数组，即 <code>features</code>，以便处理。</p><p><code>fetchResult()</code> 的主体部分是一个大的嵌套循环。它对所有的网格单元以及每个网格单元的 5 个预测结果进行遍历：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for cy in 0..&lt;13 &#123;</span><br><span class="line">  for cx in 0..&lt;13 &#123;</span><br><span class="line">    for b in 0..&lt;5 &#123;</span><br><span class="line">       . . .</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每个循环中我们对网格单元 <code>(cy, cx)</code> 计算出其检测框 <code>b</code>。</p><p>首先，我们从 <code>features</code> 数组中读取出检测框的 x，y，宽，高，以及置信度：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let channel = b*(numClasses + 5)</span><br><span class="line">let tx = features[offset(channel, cx, cy)]</span><br><span class="line">let ty = features[offset(channel + 1, cx, cy)]</span><br><span class="line">let tw = features[offset(channel + 2, cx, cy)]</span><br><span class="line">let th = features[offset(channel + 3, cx, cy)]</span><br><span class="line">let tc = features[offset(channel + 4, cx, cy)]</span><br></pre></td></tr></table></figure><p><code>offset()</code> 函数的作用是帮助在数组中寻找读取数据的合适位置。Metal 将其数据以每 4 个通道为一组进行存储，这意味着这 125 个通道的数据并不是连续存储的，而是分散的。（请查阅代码以获得更详尽的解释）</p><p>我们仍然需要对这 5 个数据 <code>tx</code>，<code>ty</code>，<code>tw</code>，<code>th</code>，<code>tc</code> 进行处理，因为它们的格式有一点奇怪。如果你好奇这些公式是从哪里来的，它们是在 <a href="https://arxiv.org/abs/1612.08242" target="_blank" rel="noopener">这篇文章</a> 中提出的（这是网络训练的副产物）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let x = (Float(cx) + Math.sigmoid(tx)) * 32</span><br><span class="line">let y = (Float(cy) + Math.sigmoid(ty)) * 32</span><br><span class="line"></span><br><span class="line">let w = exp(tw) * anchors[2*b    ] * 32</span><br><span class="line">let h = exp(th) * anchors[2*b + 1] * 32</span><br><span class="line"></span><br><span class="line">let confidence = Math.sigmoid(tc)</span><br></pre></td></tr></table></figure><p>现在，<code>x</code> 和 <code>y</code> 代表在 416×416 大小的输入图像中，检测框的中心点的坐标。<code>w</code> 和 <code>h</code> 是检测框的宽和高。<code>tc</code> 是检测框的置信度，我们用 logistic sigmoid 函数将其转换成百分制的形式。</p><p>我们现在有了检测框，并且我们知道 YOLO 有多确信其中包含了某个目标。下一步，让我们看一下分类预测的结果，看看 YOLO 认为检测框中的目标是什么物体：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var classes = [Float](repeating: 0, count: numClasses)</span><br><span class="line">for c in 0..&lt;numClasses &#123;</span><br><span class="line">  classes[c] = features[offset(channel + 5 + c, cx, cy)]</span><br><span class="line">&#125;</span><br><span class="line">classes = Math.softmax(classes)</span><br><span class="line"></span><br><span class="line">let (detectedClass, bestClassScore) = classes.argmax()</span><br></pre></td></tr></table></figure><p>回想一下，<code>features</code> 数组中的 20 个通道的数据包含了该检测框的分类检测结果。我们将这些读取到一个新的 <code>classes</code> 数组中。像分类器的一般做法一样，我们采用 softmax 函数来将数组转换成一个概率分布。然后，我们挑选分数最高的分类作为结果。</p><p>现在，我们可以对检测框计算最终得分了 —— 例如，“我有 85% 的确信度相信这个检测框包含了一只狗”。一共会有 845 个检测框，而我们只想保留最终得分超过某一阈值的那些。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let confidenceInClass = bestClassScore * confidence</span><br><span class="line">if confidenceInClass &gt; 0.3 &#123;</span><br><span class="line">  let rect = CGRect(x: CGFloat(x - w/2), y: CGFloat(y - h/2),</span><br><span class="line">                    width: CGFloat(w), height: CGFloat(h))</span><br><span class="line"></span><br><span class="line">  let prediction = Prediction(classIndex: detectedClass,</span><br><span class="line">                              score: confidenceInClass,</span><br><span class="line">                              rect: rect)</span><br><span class="line">  predictions.append(prediction)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对所有网格单元重复上述代码。当循环结束后，我们就有了一个 <code>predictions</code> 数组，一般来说，其中会包含 10 到 20 个预测结果。</p><p>我们已经过滤掉了那些最终得分非常低的检测框，但剩下的检测框中，仍然可能会存在相互重叠特别严重的情况。因此，我们在 <code>fetchResult()</code> 中做的最后一件事就是用一种称为<em>非极大值抑制</em>的方法来减少这种重复的检测框。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  var result = NeuralNetworkResult&lt;Prediction&gt;()</span><br><span class="line">  result.predictions = nonMaxSuppression(boxes: predictions,</span><br><span class="line">                                         limit: 10, threshold: 0.5)</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nonMaxSuppression()</code> 函数所使用的算法很简单：</p><ol><li>从最终得分最高的那个检测框开始。</li><li>将其他与该检测框重叠率超过一定阈值（比如超过 50%）的检测框移除。</li><li>返回第一步，重复直到遍历完所有的检测框。</li></ol><p>该算法移除了与更高得分的检测框有太多重叠的其他检测框，只保留了最好的那些。</p><p>以上就是所有的过程了：一个常规的卷积网络，以及后续对结果的一些处理。</p><h2 id="运行效果如何？"><a href="#运行效果如何？" class="headerlink" title="运行效果如何？"></a>运行效果如何？</h2><p><a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">YOLO 官方网站</a> 宣称精简版 YOLO 最快每秒可处理 200 帧图像。但那是在性能优秀的笔记本上的运行结果，而不是在移动设备上。那么，它在 iPhone 上能够运行多快呢？</p><p>在我的 iPhone 6s 上，它处理一幅图像大约需要 0.15 秒。那也只有 6 FPS，几乎不能称之为实时。如果你将手机对准一辆开过的汽车，你会看到一个检测框拖在汽车后面一些。尽管如此，它能够生效已经使我印象深刻了。😁</p><blockquote><p>注意：正如上文解释，检测框的处理是在 CPU 上进行，而不是 GPU。如果 YOLO 完全运行在 GPU 上，会变得更快吗？也许会，但 CPU 代码运行时间只有 0.03 秒，占 20% 的运行时间。将其中一部分工作交给 GPU 做当然是可行的，但考虑到卷积层的计算仍然占据了 80% 的时间，我不确定是否值得这样做。</p></blockquote><p>我认为导致变慢的主要原因在于输出通道为 512 和 1024 卷积层。经过实验，<code>MPSCNNConvolution</code> 在通道较多的小图片上的表现比在通道较少的大图片上会更差。</p><p>另一件我比较感兴趣的事情是采用另一种不同的网络结构，例如 SqueezeNet，对其重新进行训练，以在最后一层进行检测框的预测。换句话说，采用 YOLO 的思想，并将其应用在一个更小更快的网络上。这样以精确度的损失换来速度上的提升是否值得呢？</p><blockquote><p>注意：顺便说一句，最近的 <a href="http://caffe2.ai/" target="_blank" rel="noopener">Caffe2</a> 框架也是通过 Metal 的支持，运行在 iOS 设备上。<a href="https://github.com/KleinYuan/Caffe2-iOS" target="_blank" rel="noopener">Caffe2-iOS project</a> 是一个针对 YOLO 的精简版本。看起来它运行得会比纯 Metal 版稍慢，大约 0.17 秒/帧。</p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>想要了解更多 YOLO 相关的知识，可以查看 YOLO 作者的以下论文：</p><ul><li><a href="https://arxiv.org/abs/1506.02640" target="_blank" rel="noopener">You Only Look Once: Unified, Real-Time Object Detection</a> by Joseph Redmon, Santosh Divvala, Ross Girshick, Ali Farhadi (2015)</li><li><a href="https://arxiv.org/abs/1612.08242" target="_blank" rel="noopener">YOLO9000: Better, Faster, Stronger</a> by Joseph Redmon and Ali Farhadi (2016)</li></ul><p>我的实现一部分基于 TensorFlow Android demo <a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/android" target="_blank" rel="noopener">TF Detect</a>，Allan Zelener 的 <a href="https://github.com/allanzelener/YAD2K/" target="_blank" rel="noopener">YAD2K</a>，以及 <a href="https://github.com/pjreddie/darknet" target="_blank" rel="noopener">Darknet 源代码</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文详细介绍了使用 YOLO 进行实时目标检测的原理，以及在 iOS 上的应用。
    
    </summary>
    
      <category term="machinethink" scheme="https://swift.gg/categories/machinethink/"/>
    
    
      <category term="机器学习" scheme="https://swift.gg/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>macOS Dynamic Desktop</title>
    <link href="https://swift.gg/2018/10/25/macos-dynamic-desktop/"/>
    <id>https://swift.gg/2018/10/25/macos-dynamic-desktop/</id>
    <published>2018-10-25T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/macos-dynamic-desktop/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-10-01<br>译者：<a href="http://www.saitjr.com" target="_blank" rel="noopener">saitjr</a>；校对：<a href="http://www.desgard.com/" target="_blank" rel="noopener">冬瓜</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>Dark Mode（深色模式）可谓是 macOS 最受欢迎的特性之一了 —— 尤其是对于你我这样的开发者来说。我们不仅喜欢文本编辑器是暗色的主题，还很看中整个系统色调的一致性。</p><p>过去几年，和这个特性旗鼓相当的要数 Night Shift（夜览），它主要是在日夜更替的时候减少对眼睛的劳损。</p><p>纵观这两个功能，Dynamic Desktop（动态桌面）也就呼之欲出了，当然这也是 Mojave 的新特性之一。进入“系统偏好设置 &gt; 桌面与屏幕保护程序” 并且选择“动态”，就能得到一个基于地理位置且全天候动态变化的壁纸。</p><a id="more"></a><p><img src="https://nshipster.com/assets/desktop-and-screen-saver-preference-pane-b457c3a4bc26017c8d555506333d5b73244adaf8b7060f0cadd450f39b279c88.png" alt=""></p><p>效果不仅微妙，而且让人愉悦。桌面仿佛被赋予了生命，能随着时间的推移而变化；符合自然规律。（不出意外的话，结合 dark mode 的切换，还会有讨喜的特效）</p><p><em>这到底是如何实现的呢？</em><br><br>这便是本周 NSHipster 讨论的问题。</p><p>答案会深入探究图片格式，同时涉及一些逆向工程以及球面三角学相关的内容。</p><p><br></p><hr><p><br></p><p>理解 Dynamic Desktop 第一步，就是要找到这些动态图片。</p><p>在 macOS Mojave 系统下，打开访达，选择“前往 &gt; 前往文件夹…” （⇧⌘G），输入“/Library/Desktop Pictures/”。</p><p><img src="https://nshipster.com/assets/go-to-library-desktop-pictures-3992f8efa1d14dd3bf092ec7eb298c6c1855dcc8e0cf57c0e494a840a8cb4713.png" alt=""></p><p>在这个目录下，可以找到名为“Mojave.heic”的文件。双击通过预览打开。</p><p><img src="https://nshipster.com/assets/mojave-heic-abd6b67d8941ad50a9bcd7dd6657994174d4be713bb3c2cfbc9e24ffff7ad129.png" alt=""></p><p>在预览中，左边栏会显示从 1~16 的缩略图，每张都是不同状态的沙漠图。</p><p><img src="https://nshipster.com/assets/mojave-dynamic-desktop-images-c8bc3aab78c049d74abd46240445f82c3d0cf0ad043bcc9da6f3fda066776034.png" alt=""></p><p>如果选择“工具 &gt; 显示检查器”（⌘I），可以看到更为详细的信息，如下图所示：</p><p><img src="https://nshipster.com/assets/mojave-heic-preview-info-b71c5e4084bd43f1e6b34852c4c757493627eb8b66ee44b282e2f53d274dda02.png" alt=""></p><p>不幸的是，这些就是预览所展示的全部信息了（截至发稿前）。即使点击旁边的“更多信息检查器”，我们也只是能得到下面这个表格，其余的无从得知：</p><table><thead><tr><th>Color Model</th><th>RGB</th></tr></thead><tbody><tr><td>Depth:</td><td>8</td></tr><tr><td>Pixel Height</td><td>2,880</td></tr><tr><td>Pixel Width</td><td>5,120</td></tr><tr><td>Profile Name</td><td>Display P3</td></tr></tbody></table><blockquote><p>后缀 <code>.heic</code> 表示图片容器采用 HFIF（High-Efficiency Image File Format）编码，即高效率图档格式（这种格式基于 <strong>HEVC</strong>（High-Efficiency Video Compression），即高效率视频压缩，也就是 H.265）。更多信息，可以参考 <a href="https://developer.apple.com/videos/play/wwdc2017/503/" target="_blank" rel="noopener">WWDC 2017 Session 503 “Introducing HEIF and HEVC”</a></p></blockquote><p>想要获得更多的数据，我们还需要脚踏实地，真真切切的深入底层 API。</p><h2 id="利用-CoreGraphics-一探究竟"><a href="#利用-CoreGraphics-一探究竟" class="headerlink" title="利用 CoreGraphics 一探究竟"></a>利用 CoreGraphics 一探究竟</h2><p>第一步先创建 Xcode Playground。简单起见，我们将“Mojave.heic”文件路径硬编码到代码中。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CoreGraphics</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统版本要求 macOS 10.14 Mojave</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(fileURLWithPath: <span class="string">"/Library/Desktop Pictures/Mojave.heic"</span>)</span><br></pre></td></tr></table></figure><p>然后，创建 <code>CGImageSource</code>，拷贝元数据并遍历全部标签：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> source = <span class="type">CGImageSourceCreateWithURL</span>(url <span class="keyword">as</span> <span class="type">CFURL</span>, <span class="literal">nil</span>)!</span><br><span class="line"><span class="keyword">let</span> metadata = <span class="type">CGImageSourceCopyMetadataAtIndex</span>(source, <span class="number">0</span>, <span class="literal">nil</span>)!</span><br><span class="line"><span class="keyword">let</span> tags = <span class="type">CGImageMetadataCopyTags</span>(metadata) <span class="keyword">as</span>! [<span class="type">CGImageMetadataTag</span>]</span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> tags &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name = <span class="type">CGImageMetadataTagCopyName</span>(tag),</span><br><span class="line">        <span class="keyword">let</span> value = <span class="type">CGImageMetadataTagCopyValue</span>(tag)</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(name, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码，会得到两个值：一个是 <code>hasXMP</code>，值为 <code>&quot;True&quot;</code>，另一个是 <code>solar</code>，它的值是一串看不大懂的数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YnBsaXN0MDDRAQJSc2mvEBADDBAUGBwgJCgsMDQ4PEFF1AQFBgcICQoLUWlRelFh</span><br><span class="line">UW8QACNAcO7vOubr3yO/1e+pmkOtXBAB1AQFBgcNDg8LEAEjQFRxqCKOFiAjwCR6</span><br><span class="line">waUkDgHUBAUGBxESEwsQAiNAVZV4BI4c+CPAEP2uFrMcrdQEBQYHFRYXCxADI0BW</span><br><span class="line">tALKmrjwIz/2ObLnx6l21AQFBgcZGhsLEAQjQFfTrJlEjnwjQByrLle1Q0rUBAUG</span><br><span class="line">Bx0eHwsQBSNAWPrrmI0ISCNAKiwhpSRpc9QEBQYHISIjCxAGI0BgJff9KDpyI0BE</span><br><span class="line">NTOsilht1AQFBgclJicLEAcjQGbHdYIVQKojQEq3fAg86lXUBAUGBykqKwsQCCNA</span><br><span class="line">bTGmpC2YRiNAQ2WFOZGjntQEBQYHLS4vCxAJI0BwXfII2B+SI0AmLcjfuC7g1AQF</span><br><span class="line">BgcxMjMLEAojQHCnF6YrsxcjQBS9AVBLTq3UBAUGBzU2NwsQCyNAcTcSnimmjCPA</span><br><span class="line">GP5E0ASXJtQEBQYHOTo7CxAMI0BxgSADjxK2I8AoalieOTyE1AQFBgc9Pj9AEA0j</span><br><span class="line">QHNWsnnMcWIjwEO+oq1pXr8QANQEBQYHQkNEQBAOI0ABZpkFpAcAI8BKYGg/VvMf</span><br><span class="line">1AQFBgdGR0hAEA8jQErBKblRzPgjwEMGElBIUO0ACAALAA4AIQAqACwALgAwADIA</span><br><span class="line">NAA9AEYASABRAFMAXABlAG4AcAB5AIIAiwCNAJYAnwCoAKoAswC8AMUAxwDQANkA</span><br><span class="line">4gDkAO0A9gD/AQEBCgETARwBHgEnATABOQE7AUQBTQFWAVgBYQFqAXMBdQF+AYcB</span><br><span class="line">kAGSAZsBpAGtAa8BuAHBAcMBzAHOAdcB4AHpAesB9AAAAAAAAAIBAAAAAAAAAEkA</span><br><span class="line">AAAAAAAAAAAAAAAAAAH9</span><br></pre></td></tr></table></figure><h3 id="太阳之光"><a href="#太阳之光" class="headerlink" title="太阳之光"></a>太阳之光</h3><p>大多数人看到这串文字，就会默默合上 MacBook Pro，大呼告辞。但一定有人发现，这串文字非常像 <a href="https://en.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">Base64 编码</a> 的杰作。</p><p>让我们来验证一下这个假设：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">"solar"</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="type">Data</span>(base64Encoded: value)!</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">String</span>(data: data, encoding: .ascii))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><samp>              bplist00Ò\u{01}\u{02}\u{03}…</samp><br><br><br>这又是什么？<code>bplist</code> 后面接了一串乱码？</p><p>天哪，原来这是 <a href="https://en.wikipedia.org/wiki/Property_list" target="_blank" rel="noopener">二进制属性列表</a> 的 <a href="https://en.wikipedia.org/wiki/File_format#Magic_number" target="_blank" rel="noopener">文件签名</a>。</p><p>利用 <code>PropertyListSerialization</code> 来看看呢…</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">"solar"</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="type">Data</span>(base64Encoded: value)!</span><br><span class="line">    <span class="keyword">let</span> propertyList = <span class="keyword">try</span> <span class="type">PropertyListSerialization</span></span><br><span class="line">                            .propertyList(from: data,</span><br><span class="line">                                          options: [],</span><br><span class="line">                                          format: <span class="literal">nil</span>)</span><br><span class="line">    <span class="built_in">print</span>(propertyList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(</span><br><span class="line">    ap = &#123;</span><br><span class="line">        d = <span class="number">15</span>;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    si = (</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="string">"-0.3427528387535028"</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            z = <span class="string">"270.9334057827345"</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="string">"-38.04743388682423"</span>;</span><br><span class="line">            i = <span class="number">15</span>;</span><br><span class="line">            z = <span class="string">"53.50908581251309"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><em>清晰多了！</em></p><p>首先有两个一级键：</p><p><code>ap</code> 键对应的值是包含 <code>d</code> 和 <code>l</code> 两个键的字典，它们的值都是整型。</p><p><code>si</code> 键对应的值是包含多个字典的数组，字典中有整型，也有浮点型的值。在嵌套的字典中，<code>i</code> 最容易理解：它从 0 一直递增到 15，这表示的是图片序列的下标。在没有更多信息的情况下，很难猜测 <code>a</code> 与 <code>z</code> 的含义，其实它们表示相应图片中太阳的高度（<code>a</code>）和方位角（<code>z</code>）。</p><h3 id="计算太阳的位置"><a href="#计算太阳的位置" class="headerlink" title="计算太阳的位置"></a>计算太阳的位置</h3><p>就在我落笔之时，身处北半球的人正在进入秋季，白昼变短，气温变低，而南半球的人却经历着白昼变长，气温变高。季节的变化告诉我们，日照的时长取决于你在星球上的位置，以及星球绕太阳的轨道。</p><p>可喜的是，天文学家能告诉你 —— 而且相当准确 —— 太阳在天空中的位置或时间。不可贺的是，这其中的计算十分 <a href="https://en.wikipedia.org/wiki/Position_of_the_Sun" target="_blank" rel="noopener">复杂</a>。</p><p>但老实讲，我们并不用过分深究它，在网上能找到相关的代码。经过不断的试错，<a href="https://github.com/NSHipster/DynamicDesktop/blob/master/SolarPosition.playground" target="_blank" rel="noopener">它们就能为我所用</a>（欢迎 PR！）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CoreLocation</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于加州库比蒂诺的 Apple Park</span></span><br><span class="line"><span class="keyword">let</span> location = <span class="type">CLLocation</span>(latitude: <span class="number">37.3327</span>, longitude: -<span class="number">122.0053</span>)</span><br><span class="line"><span class="keyword">let</span> time = <span class="type">Date</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> position = solarPosition(<span class="keyword">for</span>: location, at: time)</span><br><span class="line"><span class="keyword">let</span> formattedDate = <span class="type">DateFormatter</span>.localizedString(from: time,</span><br><span class="line">                                                    dateStyle: .medium,</span><br><span class="line">                                                    timeStyle: .short)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Solar Position on <span class="subst">\(formattedDate)</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(position.azimuth)</span>° Az / <span class="subst">\(position.elevation)</span>° El"</span>)</span><br></pre></td></tr></table></figure><p><samp>Solar Position on Oct 1, 2018 at 12:00 180.73470025840783° Az / 49.27482549913847° El</samp></p><p>2018 年 10 月 1 日中午，太阳从南面照射在 Apple Park，大约处于地平线中间，直射头顶。</p><p>如果绘制出太阳一天的位置，我们可以得到一个正弦曲线，这不禁让人联想到 Apple Watch 的“太阳表盘”。</p><p><img src="https://nshipster.com/assets/solar-position-watch-faces-1815d6d3c84f42ff4588fa47cd59841f4de15be2b219f6f4ec9a83e13ea0f08b.jpg" alt=""></p><h3 id="扩展对-XMP-的理解"><a href="#扩展对-XMP-的理解" class="headerlink" title="扩展对 XMP 的理解"></a>扩展对 XMP 的理解</h3><p>好吧，天文学到此结束。接下来是一个乏味的过程：<em>摆在眼前</em>的 XML 元数据。</p><p>还记得之前的元数据键 <code>hasXMP</code> 吗？对，就是它没错。</p><p>XMP（Extensible Metadata Platform），即可扩展元数据平台，是一种使用元数据标记文件的标准格式。XMP 长什么样呢？请打起精神来：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xmpData = <span class="type">CGImageMetadataCreateXMPData</span>(metadata, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> xmp = <span class="type">String</span>(data: xmpData <span class="keyword">as</span>! <span class="type">Data</span>, encoding: .utf8)!</span><br><span class="line"><span class="built_in">print</span>(xmp)</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x:xmpmeta</span> <span class="attr">xmlns:x</span>=<span class="string">"adobe:ns:meta/"</span> <span class="attr">x:xmptk</span>=<span class="string">"XMP Core 5.4.0"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rdf:RDF</span> <span class="attr">xmlns:rdf</span>=<span class="string">"http://www.w3.org/1999/02/22-rdf-syntax-ns#"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rdf:Description</span> <span class="attr">rdf:about</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:apple_desktop</span>=<span class="string">"http://ns.apple.com/namespace/1.0/"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">apple_desktop:solar</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- (Base64-Encoded Metadata) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">apple_desktop:solar</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">rdf:Description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">rdf:RDF</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x:xmpmeta</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>呕。</em></p><p>不过也幸好我们检查了一下。之后想要成功自定义 Dynamic Desktop，还得仰仗 <code>apple_desktop</code> 命名空间。</p><p>既然如此，就开始吧。</p><h2 id="创建自定义-Dynamic-Desktop"><a href="#创建自定义-Dynamic-Desktop" class="headerlink" title="创建自定义 Dynamic Desktop"></a>创建自定义 Dynamic Desktop</h2><p>首先，创建一个数据模型来表示 Dynamic Desktop：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DynamicDesktop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> images: [<span class="type">Image</span>]</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cgImage: <span class="type">CGImage</span></span><br><span class="line">        <span class="keyword">let</span> metadata: <span class="type">Metadata</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Metadata</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> index: <span class="type">Int</span></span><br><span class="line">            <span class="keyword">let</span> altitude: <span class="type">Double</span></span><br><span class="line">            <span class="keyword">let</span> azimuth: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">                <span class="keyword">case</span> index = <span class="string">"i"</span></span><br><span class="line">                <span class="keyword">case</span> altitude = <span class="string">"a"</span></span><br><span class="line">                <span class="keyword">case</span> azimuth = <span class="string">"z"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如前文所述，每个 Dynamic Desktop 都由一个有序的图片序列构成，每个图片又包含存储在 <code>CGImage</code> 对象中的图片数据和元数据。<code>Metadata</code> 采用 <code>Codable</code> 类型，是为了编译器自动合成相关函数。我们能在生成 Base64 编码的二进制属性列表时感受到它的优势。</p><h3 id="写入图片目标"><a href="#写入图片目标" class="headerlink" title="写入图片目标"></a>写入图片目标</h3><p>首先，创建一个指定输出 URL 的 <code>CGImageDestination</code>。文件类型为 <code>heic</code>，资源数量即需要包含的图片张数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> imageDestination = <span class="type">CGImageDestinationCreateWithURL</span>(</span><br><span class="line">                                outputURL <span class="keyword">as</span> <span class="type">CFURL</span>,</span><br><span class="line">                                <span class="type">AVFileType</span>.heic <span class="keyword">as</span> <span class="type">CFString</span>,</span><br><span class="line">                                dynamicDesktop.images.<span class="built_in">count</span>,</span><br><span class="line">                                <span class="literal">nil</span></span><br><span class="line">                             )</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Error creating image destination"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，遍历动态桌面对象中的全部图片。通过 <code>enumerated()</code> 方法，我们还能获取到当前 <code>index</code>，这样就可以在第一张图片上设置图片元数据：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, image) <span class="keyword">in</span> dynamicDesktop.images.enumerated() &#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> imageMetadata = <span class="type">CGImageMetadataCreateMutable</span>()</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> tag = <span class="type">CGImageMetadataTagCreate</span>(</span><br><span class="line">                            <span class="string">"http://ns.apple.com/namespace/1.0/"</span> <span class="keyword">as</span> <span class="type">CFString</span>,</span><br><span class="line">                            <span class="string">"apple_desktop"</span> <span class="keyword">as</span> <span class="type">CFString</span>,</span><br><span class="line">                            <span class="string">"solar"</span> <span class="keyword">as</span> <span class="type">CFString</span>,</span><br><span class="line">                            .string,</span><br><span class="line">                            <span class="keyword">try</span>! dynamicDesktop.base64EncodedMetadata() <span class="keyword">as</span> <span class="type">CFString</span></span><br><span class="line">                        ),</span><br><span class="line">            <span class="type">CGImageMetadataSetTagWithPath</span>(</span><br><span class="line">                imageMetadata, <span class="literal">nil</span>, <span class="string">"xmp:solar"</span> <span class="keyword">as</span> <span class="type">CFString</span>, tag</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Error creating image metadata"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">CGImageDestinationAddImageAndMetadata</span>(imageDestination,</span><br><span class="line">                                              image.cgImage,</span><br><span class="line">                                              imageMetadata,</span><br><span class="line">                                              <span class="literal">nil</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">CGImageDestinationAddImage</span>(imageDestination,</span><br><span class="line">                                   image.cgImage,</span><br><span class="line">                                   <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了较为繁杂的 Core Graphics API 以外，代码可以说非常直观了。唯一需要进一步解释的只有 <code>CGImageMetadataTagCreate(_:_:_:_:_:)</code>。</p><p>由于图片与元数据容器的结构、代码的表现形式均不同，所以我们不得不为 <code>DynamicDesktop</code> 实现 <code>Encodable</code> 协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DynamicDesktop</span>: <span class="title">Encodable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> ap, si</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">NestedCodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> d, l</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> keyedContainer =</span><br><span class="line">            encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> nestedKeyedContainer =</span><br><span class="line">            keyedContainer.nestedContainer(keyedBy: <span class="type">NestedCodingKeys</span>.<span class="keyword">self</span>,</span><br><span class="line">                                           forKey: .ap)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// FIXME：不确定此处 `l` 与 `d` 的含义</span></span><br><span class="line">        <span class="keyword">try</span> nestedKeyedContainer.encode(<span class="number">0</span>, forKey: .l)</span><br><span class="line">        <span class="keyword">try</span> nestedKeyedContainer.encode(<span class="keyword">self</span>.images.<span class="built_in">count</span>, forKey: .d)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> unkeyedContainer =</span><br><span class="line">            keyedContainer.nestedUnkeyedContainer(forKey: .si)</span><br><span class="line">        <span class="keyword">for</span> image <span class="keyword">in</span> <span class="keyword">self</span>.images &#123;</span><br><span class="line">            <span class="keyword">try</span> unkeyedContainer.encode(image.metadata)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个，就可以实现之前代码中提到的 <code>base64EncodedMetadata()</code> 方法了：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DynamicDesktop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">base64EncodedMetadata</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> encoder = <span class="type">PropertyListEncoder</span>()</span><br><span class="line">        encoder.outputFormat = .binary</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> binaryPropertyListData = <span class="keyword">try</span> encoder.encode(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">return</span> binaryPropertyListData.base64EncodedString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 for-in 循环执行完，也就表明所有图片和元数据均被写入，我们可以调用 <code>CGImageDestinationFinalize(_:)</code> 方法终止图片源，并将图片写入磁盘。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="type">CGImageDestinationFinalize</span>(imageDestination) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Error finalizing image"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一切顺利，就可以为重新定义 Dynamic Desktop 的自己而感到骄傲了。棒！</p><p><br></p><hr><p><br></p><p>我们非常喜欢 Mojave 的 Dynamic Desktop 特性，并且也很欣慰看到它仿佛重现了 Windows 95 壁纸进入主流市场时的辉煌。</p><p>如果你也这样想，下面还有些想法可供参考：</p><h3 id="照片自动生成-Dynamic-Desktop"><a href="#照片自动生成-Dynamic-Desktop" class="headerlink" title="照片自动生成 Dynamic Desktop"></a>照片自动生成 Dynamic Desktop</h3><p>让人振奋的是，天体运动这样高不可攀的研究，竟然可以简化用二元方程来表达：时间与位置。</p><p>在之前的例子中，这部分信息都是硬编码的，但其实它们可以通过读取图片数据来自动获取。</p><p>默认情况下，绝大部分手机的相机都会捕获拍摄时的 <a href="https://en.wikipedia.org/wiki/Exif" target="_blank" rel="noopener">Exif 元数据</a>。元数据包含了照片拍摄的时间，以及当时设备的 GPS 坐标。</p><p>通过读取元数据中的时间与位置信息，能自动获取太阳的位置，那么从一系列图片中生成 Dynamic Desktop 也就顺理成章了。</p><h3 id="iPhone-上的延时摄影"><a href="#iPhone-上的延时摄影" class="headerlink" title="iPhone 上的延时摄影"></a>iPhone 上的延时摄影</h3><p>想要好好利用手上全新的 iPhone Xs 吗？（更确切的说，“在纠结卖不卖旧 iPhone 的时候，可以先用它来做些有创意的事？”）</p><p>将手机充上电，摆在窗前，打开相机的延时摄影模式，点击“拍摄”按钮。从最后的视频中选出一些关键帧，就可以制作专属 Dynamic Desktop 了。</p><p>当然，你可以看看 <a href="https://itunes.apple.com/us/app/skyflow-time-lapse-shooting/id937208291?mt=8" target="_blank" rel="noopener">Skyflow</a> 这类应用，它能设置时间间隔来拍摄静态图片。</p><h3 id="通过-GIS-数据打造风景"><a href="#通过-GIS-数据打造风景" class="headerlink" title="通过 GIS 数据打造风景"></a>通过 GIS 数据打造风景</h3><p>如果你无法忍受手机一整天不在身边（伤心），又或者没什么标志性景象值得拍摄（依然伤心），你还可以创造一个属于自己的世界（这比现实本身还要令人伤心）。</p><p>可以选择用 <a href="https://planetside.co.uk/" target="_blank" rel="noopener">Terragen</a> 这类应用，它打造了一个逼真的 3D 世界，还能对太阳、地球、天空进行微调。</p><p>想要更加简化，还可以从美国地质调查局的 <a href="https://viewer.nationalmap.gov/basic/" target="_blank" rel="noopener">国家地图网站</a> 上下载高程地图，以用于 3D 渲染的模板。</p><h3 id="下载预制的-Dynamic-Desktops"><a href="#下载预制的-Dynamic-Desktops" class="headerlink" title="下载预制的 Dynamic Desktops"></a>下载预制的 Dynamic Desktops</h3><p>再或者，你每天都非常多的工作要做，抽不出时间捣腾好看的图片，也可以选择付费从别人那里购买。</p><p>我个人是 <a href="https://www.jetsoncreative.com/24hourwallpaper" target="_blank" rel="noopener">24 Hour Wallpaper</a> 这款应用的粉丝。如果你有别的推荐，欢迎 <a href="https://twitter.com/NSHipster/" target="_blank" rel="noopener">联系我们</a>。</p><p><br></p><hr><h3 id="NSMUTABLEHIPSTER"><a href="#NSMUTABLEHIPSTER" class="headerlink" title="NSMUTABLEHIPSTER"></a>NSMUTABLEHIPSTER</h3><p>疑问？纠错？欢迎提 <a href="https://github.com/NSHipster/articles/issues" target="_blank" rel="noopener">issues</a> 和 <a href="https://github.com/NSHipster/articles/blob/master/2018-10-01-macos-dynamic-desktop.md" target="_blank" rel="noopener">pull requests</a> —— NSHipster 因你而变得更好。</p><p><em>本文用的是 Swift 4.2</em>。关于站内文章的状态信息，可以查看 <a href="https://nshipster.com/status/" target="_blank" rel="noopener">状态汇总页面</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Mojave 中 Dynamic Desktop 的奥义
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>编译开源 Swift Foundation 库</title>
    <link href="https://swift.gg/2018/10/22/compiling-open-source-swift-foundation/"/>
    <id>https://swift.gg/2018/10/22/compiling-open-source-swift-foundation/</id>
    <published>2018-10-22T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：iAchieved.it，<a href="http://dev.iachieved.it/iachievedit/compiling-open-source-swift-foundation/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016-06-30<br>译者：<a href="https://github.com/rsenjoyer" target="_blank" rel="noopener">rsenjoyer</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://hulizhen.me" target="_blank" rel="noopener">智多芯</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fuksdkfewij306o06omx6.jpg" alt=""></p><p>我最近在开源的 <a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="noopener">Swift Foundation</a> 中遇到了 <code>NSThread</code> 实现的问题。如果不是尝试在树莓派 3 上运行代码，我也许就发现不了这个问题：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> Glibc</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">  sleep(<span class="number">2</span>)</span><br><span class="line">  counter = counter + <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> t = <span class="type">Thread</span>()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"STARTED:<span class="subst">\(counter)</span>"</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"EXIT:<span class="subst">\(counter)</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"START:<span class="subst">\(counter)</span>"</span>)</span><br><span class="line">  t.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我所期望的是每 2 秒都会创建并销毁一个线程。不幸的是在大约启动 230 个线程之后，系统资源已经耗尽，不再有新的线程被创建。解决的方式正如 <a href="https://bugs.swift.org/browse/SR-1908" target="_blank" rel="noopener">SR-1908</a> 所提到的，初始化具有系统范围的分离状态的线程</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> main: (<span class="type">Void</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  _main = main</span><br><span class="line">  <span class="keyword">let</span> <span class="number">_</span> = <span class="built_in">withUnsafeMutablePointer</span>(&amp;_attr) &#123; attr <span class="keyword">in</span></span><br><span class="line">    pthread_attr_init(attr)</span><br><span class="line">    pthread_attr_setscope(attr，<span class="type">Int32</span>(<span class="type">PTHREAD_SCOPE_SYSTEM</span>))</span><br><span class="line">    pthread_attr_setdetachstate(attr，<span class="type">Int32</span>(<span class="type">PTHREAD_CREATE_DETACHED</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/phausler" target="_blank" rel="noopener">Philippe Hausler</a> 在 SR-1908 中提出了解决方案。正巧我有个树莓派 3 可以实现和测试该方案。</p><h2 id="针对-Foundation-的构建"><a href="#针对-Foundation-的构建" class="headerlink" title="针对 Foundation 的构建"></a>针对 Foundation 的构建</h2><p>如果你阅读了 <a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="noopener">开源库 Foundation</a> 的 <a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Docs/GettingStarted.md" target="_blank" rel="noopener">新手入门文档</a>，你就会知道，它建议在构建 Foundation 之前，首先需要构建 Swift，clang 和 llvm。如果可以在一个有大量的 CPU 和快速磁盘的服务器上工作，我丝毫不介意按照文档一步步构建。然而树莓派 3 与其他老式的设备一样，性能提升有点慢。我也可以考虑交叉编译 Swift，但我还没有足够时间来解决交叉编译带来的问题（如果你曾经使用过交叉编译环境，你一定知道它需要很长时间来做相关的配置）。</p><p>我们所需要的是充分利用已有的构建环境并自行编译 Foundation。事实证明是可以做到的，不然的话，我们也不会有这篇博客了。</p><p>下面是你所需要的准备操作（无论你是在 x86 服务器上还是在像 BeagleBone 或树莓派的 ARM 的计算机上）：</p><ul><li>全量构建 <code>swiftc</code>，通常位于 <code>build/buildbot_linux/swift-linux-armv7/bin</code> 目录</li><li>全量构建 <code>swift</code>，同样位于 <code>build/buildbot_linux/swift-linux-armv7/bin</code> 目录</li><li>全量构建 <code>clang</code>(从开源库中构建)，位于 <code>build/buildbot_linux/llvm-linux-armv7/bin</code> 目录中</li></ul><p>我希望提供各种已经编译过的“工具链”，但是现在你必须首先构建自己的工具链。然后你就可以自己构建 Foundation 了。</p><p>现在，让我们来看看如何使用它来测试 Foundation 上的内容。请注意，我们克隆的是我们自己 fork 的 swift-corelibs-foundation 的分支。如果你打算给上游开源库（即 Apple 开源库）提交 PR，这一点非常的重要。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/iachievedit/swift-corelibs-foundation</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> PREBUILT_ROOT=/root/workspace/Swift-3.0-Pi3-ARM-Incremental/build/buildbot_linux/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SWIFTC=<span class="variable">$PREBUILT_ROOT</span>/swift-linux-armv7/bin/swiftc \</span></span><br><span class="line">CLANG=$PREBUILT_ROOT/llvm-linux-armv7/bin/clang      \</span><br><span class="line">SWIFT=$PREBUILT_ROOT/swift-linux-armv7/bin/swift     \</span><br><span class="line">SDKROOT=$PREBUILT_ROOT/swift-linux-armv7             \</span><br><span class="line">BUILD_DIR=build ./configure Debug</span><br><span class="line"><span class="meta">#</span><span class="bash"> /usr/bin/ninja</span></span><br><span class="line">...</span><br><span class="line">[290/290] Link: build/Foundation/libFoundation.so</span><br></pre></td></tr></table></figure><p>首先，我们将环境变量 <code>PREBUILT_ROOT</code> 设置到预构建 Swift 及相关工具所在的位置，还可以在下一步操作前配置 <code>./configure</code> 为 <code>Debug</code> 模式（你也可以配置为 <code>Release</code>）。我们还需要将环境变量 <code>SWIFTC</code>，<code>CLANG</code>，<code>SWIFT</code> 和 <code>SDKROOT</code> 配置脚本指向我们的“工具链”。最后，环境变量 <code>BUILD_DIR</code> 设置为所有中间件和最终输出（libFoundation.so）的放置位置。</p><p>注意：也许有时你会惊讶于评论中的某些内容。你的 <code>PREBUILT_ROOT</code> 是你工具链的位置。不要期望在 <code>/root/workspace/Swift-3.0-Pi3-ARM-Incremental</code> 上找到你系统上的任何内容！</p><p>最后，执行 <code>/usr/bin/ninja</code> 来运行我们的构建。一旦构建结束后，在 <code>build/Foundation/</code> 目录中会有一个 <code>libFoundation.so</code> 共享库。<br>要使用已安装的 Swift 来测试它，只需将 <code>libFoundation.so</code> 复制到 <code>$YOUR_SWIFT_ROOT/usr/lib/swift/linux/ libFoundation.so</code>。</p><h2 id="运行测试用例"><a href="#运行测试用例" class="headerlink" title="运行测试用例"></a>运行测试用例</h2><p>你可以通过向 <code>./configure</code> 添加 <code>-DXCTEST_BUILD_DIR</code> 参数来运行 Foundation 测试套件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> PREBUILT_ROOT=/root/workspace/Swift-3.0-Pi3-ARM-Incremental/build/buildbot_linux/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SWIFTC=<span class="variable">$PREBUILT_ROOT</span>/swift-linux-armv7/bin/swiftc \</span></span><br><span class="line">CLANG=$PREBUILT_ROOT/llvm-linux-armv7/bin/clang      \</span><br><span class="line">SWIFT=$PREBUILT_ROOT/swift-linux-armv7/bin/swift     \</span><br><span class="line">SDKROOT=$PREBUILT_ROOT/swift-linux-armv7             \</span><br><span class="line">BUILD_DIR=build ./configure Debug                    \</span><br><span class="line">-DXCTEST_BUILD_DIR=$PREBUILT_ROOT/xctest-linux-armv7</span><br><span class="line"><span class="meta">#</span><span class="bash"> /usr/bin/ninja <span class="built_in">test</span></span></span><br><span class="line">[4/4] Building Tests</span><br><span class="line">**** RUNNING TESTS ****</span><br><span class="line">execute:</span><br><span class="line">LD_LIBRARY_PATH= build/TestFoundation/TestFoundation</span><br><span class="line">**** DEBUGGING TESTS ****</span><br><span class="line">execute:</span><br><span class="line">LD_LIBRARY_PATH= lldb build/TestFoundation/TestFoundation</span><br></pre></td></tr></table></figure><p>运行测试需要为 <code>LD_LIBRARY_PATH</code> 提供两个路径：<code>libXCTest.so</code> 共享库和“library under test”的路径。<br>如果我们按照上述步骤操作，<code>libFoundation.so</code> 就一定位于 <code>./build/Foundation</code> 目录中。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> LD_LIBRARY_PATH=./build/Foundation:<span class="variable">$PREBUILT_ROOT</span>/xctest-linux-armv7 ./build/TestFoundation/TestFoundation</span></span><br><span class="line">...</span><br><span class="line">Test Suite 'All tests' passed at 03:16:45.315</span><br><span class="line">     Executed 483 tests, with 0 failures (0 unexpected) in 37.621 (37.621) seconds</span><br></pre></td></tr></table></figure><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>需要强调的是使用这种技术，你需要一个“构建工具链”，它包含 Swift，clang 和 llvm。此外，您的工具链最后一次构建到您尝试自行构建 Foundation 的时间间隔越长，Foundation 所依赖的语言特性在构建工具链时不存在的风险就越高。但如果您决定开始使用 Foundation，请首先构建完整的 Swift 工具链并保存构建目录以使用上述技术。</p><p>祝你好运！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      这是一篇关于编译 Swift 开源的 Foundation 库的文章
    
    </summary>
    
      <category term="iAchieved.it" scheme="https://swift.gg/categories/iAchieved-it/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="iOS" scheme="https://swift.gg/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>在你的 Swift 应用中创建或修改 URL</title>
    <link href="https://swift.gg/2018/10/15/creating-and-modifying-nsurl-in-swift-4/"/>
    <id>https://swift.gg/2018/10/15/creating-and-modifying-nsurl-in-swift-4/</id>
    <published>2018-10-15T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：codingexplorer，<a href="http://www.codingexplorer.com/creating-and-modifying-nsurl-in-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-07-18<br>译者：<a href="https://github.com/Damonvvong" target="_blank" rel="noopener">Damonwong</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://bignerdcoding.com/" target="_blank" rel="noopener">BigNerdCoding</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><blockquote><p>译者注：<br>此篇文章以前我们曾经<a href="https://swift.gg/2017/02/22/creating-and-modifying-nsurl-in-swift/">翻译过</a>，原文作者在今年对这篇文章进行了更新，我们也对更新后的文章进行了翻译并再次发布。</p></blockquote><p>对于大部分应用来说，都需要访问一些文件资源。这些文件资源可能在你的应用安装包中，或者在文件系统内，亦或者在某个网站服务器上。你需要用某种方法将它们体现在代码中。对于苹果平台而言，你主要有两种选择，用字符串或者 <code>URL</code>。</p><a id="more"></a><p>如果你使用过浏览器的地址栏或者在终端中输入过地址，你可能会选择使用字符串，毕竟，在这些地方你只能输入字符串。虽然在 <code>Cocoa</code> 和 <code>Cocoa Touch</code> SDKs 中许多旧的 API 同时采用 <code>URL</code> 和字符串 (对于这些 API 来说，这些字符串通常被称为 “path”) 作为参数，但是越来越多的 API 倾向于只能用 <code>URL</code> 对象。相比较于字符串路径来说，<code>URL</code> 对象有更多的优势，最明显的优势就是你可以直接通过属性访问 <code>URL</code> 的不同的部分，而不需要自己编写一个解析组件来解析路径字符串的不同部分。</p><p>紧跟我的步伐，接下来我们学习如何在 Swift 应用中创建和使用 <code>URL</code> 对象。</p><h2 id="在-Swift-中创建一个-URL-对象"><a href="#在-Swift-中创建一个-URL-对象" class="headerlink" title="在 Swift 中创建一个 URL 对象"></a>在 Swift 中创建一个 <code>URL</code> 对象</h2><p>在 Swift 中有好几个构造器和工厂方法可用于创建 <code>URL</code> 对象，下面我要讲一些更有用的初始化方法。</p><h3 id="init-string-URLString-String"><a href="#init-string-URLString-String" class="headerlink" title="init?(string URLString: String)"></a>init?(string URLString: String)</h3><p>这个是普通的，也是最常用的初始化方法。将一个用于表示 <code>URL</code> 的 Swift 字符串转变成一个 <code>URL</code> 对象。但并不是所有的字符串都可以有效的表示一个 <code>URL</code>，所以这是一个可失败构造器。由于有些字符不能在 <code>URL</code> 中使用，因此需要进行 URL 编码，将这些不能使用的字符转化为可以在 <code>URL</code> 中发送的编码。我个人见过最多的是 <code>%20</code>，也就是“空格”字符。这个构造器需要有效的字符，它不会为你进行 URL 编码转化。如果字符串中包含无法转换为有效 <code>URL</code> 的字符或者内容，构造器将会返回 <code>nil</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">NSHipster</span> = <span class="type">URL</span>(string: <span class="string">"http://nshipster.com/"</span>) <span class="comment">//返回一个有效的 URL</span></span><br><span class="line"><span class="keyword">let</span> invalidURL = <span class="type">URL</span>(string: <span class="string">"www.example.com/This is a sentence"</span>) <span class="comment">//返回 nil</span></span><br></pre></td></tr></table></figure><p>这个构造器其实是下面这个构造器的一个便利构造器。</p><h3 id="init-string-String-relativeTo-URL"><a href="#init-string-String-relativeTo-URL" class="headerlink" title="init?(string: String, relativeTo: URL?)"></a>init?(string: String, relativeTo: URL?)</h3><p>这是一个指定构造器。和上面的构造器一样，也是一个可失败的构造器，而且需要一个类似 <code>URL</code> 的 Swift 字符串和一个可选的 <code>baseURL</code> 对象，这个 <code>baseURL</code> 本身也是一个 <code>URL</code> 对象。如果 <code>baseURL</code> 为 <code>nil</code>，那么内部会像第一个构造器一样，根据提供的 <code>URL</code> 字符串生成一个 <code>URL</code> 对象。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">NSHipsterTwo</span> = <span class="type">URL</span>(string: <span class="string">"http://nshipster.com/"</span>, relativeTo: <span class="literal">nil</span>) <span class="comment">//返回一个有效的 NSHipster URL</span></span><br><span class="line"><span class="keyword">let</span> article = <span class="type">URL</span>(string: <span class="string">"ios9/"</span>, relativeTo: <span class="type">NSHipster</span>) <span class="comment">//返回 "http://nshipster.com/ios9/" URL</span></span><br></pre></td></tr></table></figure><h3 id="init-fileURLWithPath-String-isDirectory-Bool"><a href="#init-fileURLWithPath-String-isDirectory-Bool" class="headerlink" title="init(fileURLWithPath: String, isDirectory: Bool)"></a>init(fileURLWithPath: String, isDirectory: Bool)</h3><p>该构造方法与上一个构造方法类似，但是他的字符串参数指向的是本地文件或者目录。我不太确定为什么会有一个本地文件的特殊版本，我猜有可能是做了一些优化（至少需要是文件 <code>scheme</code> 开头，而不应该是 <code>http</code> 之类的）。虽然有一个不需要传 <code>isDirectory</code> 参数的构造器，但如果你知道它是否是一个目录时，苹果建议你使用这个这个方法。在我看来，有可能另外一个构造器在内部自己判断了输入参数是否是一个目录，而这个方法通过传入参数避免了检查。</p><h3 id="init-fileURLWithPath-String-isDirectory-Bool-relativeTo-URL"><a href="#init-fileURLWithPath-String-isDirectory-Bool-relativeTo-URL" class="headerlink" title="init(fileURLWithPath: String, isDirectory: Bool, relativeTo: URL?)"></a>init(fileURLWithPath: String, isDirectory: Bool, relativeTo: URL?)</h3><p>这是在 iOS 9 中新加入的方法，这与前一个类似，但新增了 <code>relativeToURL</code> 参数。和之前的构造器一样，它将返回一个将路径附加到 <code>baseURL</code> 的 <code>URL</code> 对象。当你需要为了某个事情重复访问某个目录下的不同文件时，可以使用这个初始化方法。你可以将文件所在的目录作为 <code>baseURL</code>，然后只需要一个文件名作为 Swift 字符串路径来创建 <code>URL</code> 对象。</p><h2 id="将-URL-转回-Swift-字符串"><a href="#将-URL-转回-Swift-字符串" class="headerlink" title="将 URL 转回 Swift 字符串"></a>将 URL 转回 Swift 字符串</h2><p>有时你需要将 <code>URL</code> 对象转回 Swift 字符串，特别是在处理旧的 API 或者向用户展示情形下。值得庆幸的是，<code>URL</code> 提供了一个简单的只读属性来解决这个问题: <code>absoluteString</code>。只需要在你的 <code>URL</code> 对象调用该属性即可：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> articleString = article?.absoluteString</span><br><span class="line"><span class="comment">// articleString 现在包含 = 的值是 "http://nshipster.com/ios9/"</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了 <code>relativeToURL</code> 版本的构造器定义了一个 <code>article</code> 常量，将其解析为从 <code>scheme</code> 开始的完整 <code>URL</code> (在这种情况下是一个路径)。如果这个 <code>URL</code> 上有文件拓展名，query 或者 fragment，它依旧可以被解析。原来的 <code>article</code> 对象是由一个可失败构造器返回的，这就是为什么那儿有一个 Swift 可选访问。</p><h2 id="修改一个-URL-对象"><a href="#修改一个-URL-对象" class="headerlink" title="修改一个 URL 对象"></a>修改一个 URL 对象</h2><p>我们接下来所说的这些方法，每一个都会在请求修改完成时根据调用的 <code>URL</code> 对象返回一个新的 <code>URL</code> 对象。它们不会更改调用它们的 <code>URL</code> 对象。</p><h3 id="func-appendingPathComponent-String-isDirectory-Bool-gt-URL"><a href="#func-appendingPathComponent-String-isDirectory-Bool-gt-URL" class="headerlink" title="func appendingPathComponent(String, isDirectory: Bool) -&gt; URL"></a>func appendingPathComponent(String, isDirectory: Bool) -&gt; URL</h3><p>这个方法可以为你的 <code>URL</code> 添加更多的路径组件，比如当你要添加一个文件到你所在的目录(存储在这个方法调用返回的 <code>URL</code>)时，这个方法就可以派上用处。像我们前面提到的那个初始化方法一样，这个方法也有一个没有 <code>isDirectory</code> 参数的版本，但是无论你是否知道它是不是一个目录，都更推荐你使用这个方法来确保元数据可以存储在正确的目录下。</p><h3 id="func-deletingLastPathComponent-gt-URL"><a href="#func-deletingLastPathComponent-gt-URL" class="headerlink" title="func deletingLastPathComponent() -&gt; URL"></a>func deletingLastPathComponent() -&gt; URL</h3><p>这个方法将会返回删除了最后一个路径组件的新 <code>URL</code> 对象。这方法适用于 <code>URL</code> 的路径部分，<code>URL</code> 的其他部分不受影响，比如域名。所以我们可以这样子做:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> articleTwo = <span class="type">NSHipster</span>?.appendingPathComponent(<span class="string">"ios9"</span>, isDirectory: <span class="literal">true</span>)</span><br><span class="line"><span class="comment">//articleTwo 现在包含的 URL 字符是 "http://nshipster.com/ios9/"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> deletePathComp = articleTwo?.deletingLastPathComponent</span><br><span class="line"><span class="comment">//deletePathComp 现在包含的 URL 字符是 "http://nshipster.com/"</span></span><br></pre></td></tr></table></figure><blockquote><p>译者注：<br>在 Swift 4.2 之前，deletingLastPathComponent 是一个属性，因此在调用时不用加括号。在 4.2 版本中，deletingLastPathComponent 变成了方法<br>因此如果你在 4.2 上运行上面一段代码，需要在 articleTwo?.deletingLastPathComponent 最后加一个括号才能正确运行</p></blockquote><p>如果没有路径信息，可能有点儿奇怪。为了好玩，我链式调用了几次 <code>URLByDeletingLastPathComponent</code>，最后只是添加了 “../”，类似于在命令行（cd ..）中上一个目录。</p><p>当然还有几种修改方法和属性，但这些可能是最常用的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你对 URL 格式规范感兴趣的话，可以去查看苹果的 URL 参考文档中，关于如何处理 <code>URL</code> 这部分提及到的 <code>RFC</code> 文档。用于初始化的字符串必须符合 <a href="https://tools.ietf.org/html/rfc2396" target="_blank" rel="noopener">RFC 2396</a>，并且 <code>URL</code> 将会根据 <a href="https://tools.ietf.org/html/rfc1738" target="_blank" rel="noopener">RFC 1738</a> 和 <a href="https://tools.ietf.org/html/rfc1808" target="_blank" rel="noopener">RFC 1808</a> 被解析。这些规范内容很多，但你能找到所有可能关于 URL，URI 等的信息。</p><p>如果你完整查阅 <code>URL</code> 的文档的话，还可以看到它拥有 <code>baseURL</code>，<code>host</code>，<code>query</code>，<code>fragment</code> 等等非常多的属性，所有这些属性都能在 Apple 文档中查询到。不过对我来说，日常使用最多的还是 <code>absoluteString</code>，偶尔也会用到 <code>pathExtension</code></p><p>我希望你能觉得这篇文章对你有所帮助。如果你觉得有用，请不要犹豫，在 Twitter 或者其他社交媒体上分享这篇文章。当然，如果你有任何疑问，请随时通过 <a href="http://www.codingexplorer.com/contact/" target="_blank" rel="noopener">联系页面</a> 或者 <a href="https://twitter.com/CodingExplorer" target="_blank" rel="noopener">Twitter@CodingExplorer</a> 与我联系。我会尽可能的帮助你。谢谢。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/documentation/foundation/url" target="_blank" rel="noopener">URL Class Reference – Apple Inc.</a></p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了基于 Swift 4.1.2 和 Xcode 9.2 如何创建或者修改一个 URL 的常用 API 的描述。
    
    </summary>
    
      <category term="codingexplorer" scheme="https://swift.gg/categories/codingexplorer/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 类型擦除</title>
    <link href="https://swift.gg/2018/10/11/friday-qa-2017-12-08-type-erasure-in-swift/"/>
    <id>https://swift.gg/2018/10/11/friday-qa-2017-12-08-type-erasure-in-swift/</id>
    <published>2018-10-11T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：<a href="https://www.mikeash.com" target="_blank" rel="noopener">Mike Ash</a>，<a href="https://www.mikeash.com/pyblog/friday-qa-2017-12-08-type-erasure-in-swift.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-12-18<br>译者：<a href="https://github.com/rsenjoyer" target="_blank" rel="noopener">rsenjoyer</a>；校对：<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>你也许曾听过<strong>类型擦除</strong>，甚至也使用过标准库提供的类型擦除类型如 <code>AnySequence</code>。但到底什么是类型擦除? 如何自定义类型擦除? 在这篇文章中，我将讨论如何使用类型擦除以及如何自定义。在此感谢 Lorenzo Boaro 提出这个主题。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时你想对外部调用者隐藏某个类的具体类型，或是一些实现细节。在一些情况下，这样做能防止静态类型在项目中滥用，或者保证了类型间的交互。类型擦除就是移除某个类的具体类型使其变得更通用的过程。</p><p>协议或抽象父类可作为类型擦除简单的实现方式之一。例如 <code>NSString</code> 就是一个例子，每次创建一个 <code>NSString</code> 实例时，这个对象并不是一个普通的 <code>NSString</code> 对象，它通常是某个具体的子类的实例，这个子类一般是私有的，同时这些细节通常是被隐藏起来的。你可以使用子类提供的功能而不用知道它具体的类型，你也没必要将你的代码与它们的具体类型联系起来。</p><p>在处理 Swift 泛型以及关联类型协议的时候，可能需要使用一些高级的内容。Swift 不允许把协议当做具体的类型来使用。例如，如果你想编写一个方法，它的参数是一个包含了 <code>Int</code> 的序列，那么下面这种做法是不正确的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(seq: Sequence&lt;Int&gt;)</span></span> &#123; ...</span><br></pre></td></tr></table></figure><p>你不能这样使用协议类型，这样会在编译时报错。但你可以使用泛型来替代协议，解决这个问题：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>&lt;S: Sequence&gt;<span class="params">(seq: S)</span></span> <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> == <span class="type">Int</span> &#123; ...</span><br></pre></td></tr></table></figure><p>有时候这样写完全可以，但有些地方还存在一些比较麻烦的情况，通常你不可能只在一个地方添加泛型: 一个泛型函数对其他泛型要求更多… 更糟糕的是，你不能将泛型作为返回值或者属性。这就跟我们想的有点不一样了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span>&lt;S: Sequence&gt;<span class="params">()</span></span> -&gt; <span class="type">S</span> <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> == <span class="type">Int</span> &#123; ...</span><br></pre></td></tr></table></figure><p>我们希望函数 <code>g</code> 能返回任何符合的类型，但上面这个不同，它允许调用者选择他所需要的类型，然后函数 <code>g</code> 来提供一个合适的值。</p><p>Swift 标准库中提供了 <code>AnySequence</code> 来帮助我们解决这个问题。<code>AnySequence</code> 包装了一个任意类型的序列，并擦除了它的类型。使用 <code>AnySequence</code> 来访问这个序列，我们来重写一下函数 <code>f</code> 与 函数 <code>g</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(seq: AnySequence&lt;Int&gt;)</span></span> &#123; ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> -&gt; <span class="type">AnySequence</span>&lt;<span class="type">Int</span>&gt; &#123; ...</span><br></pre></td></tr></table></figure><p>泛型部分不见了，同时具体的类型也被隐藏起来了。由于使用了 <code>AnySequence</code> 包装具体的值，它带来了一定的代码复杂性以及运行时间成本。但是代码却更简洁了。</p><p>Swift 标准库中提供了很多这样的类型，如 <code>AnyCollection</code>、<code>AnyHashable</code> 及 <code>AnyIndex</code>。这些类型在你自定义泛型或协议的时候非常的管用，你也可以直接使用这些类型来简化你的代码。接下来让我们探索实现类型擦除的多种方式吧。</p><h2 id="基于类的类型擦除"><a href="#基于类的类型擦除" class="headerlink" title="基于类的类型擦除"></a>基于类的类型擦除</h2><p>有时我们需要在不暴露类型信息的情况下从多个类型中包装一些公共的功能，这听起来就像是父类-子类的关系。事实上我们的确可以使用抽象父类来实现类型擦除。父类提供 API 接口，不用去管谁来实现。而子类根据具体的类型信息实现相应的功能。</p><p>接下来我们将使用这种方式来自定义 <code>AnySequence</code>，我们将其命名为 <code>MAnySequence</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MAnySequence</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Sequence</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>这个类需要一个 <code>iterator</code> 类型作为 <code>makeIterator</code> 返回类型。我们必须要做两次类型擦除来隐藏底层的序列类型以及迭代器的类型。我们在 <code>MAnySequence</code> 内部定义了一个 <code>Iterator</code> 类，该类遵循着 <code>IteratorProtocol</code> 协议，并在  <code>next()</code> 方法中使用 <code>fatalError</code> 抛出异常。Swift 本身不支持抽象类型，但这样也够了:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Must override next()"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MAnySequence</code> 对 <code>makeIterator</code> 方法实现也差不多。直接调用将抛出异常，这用来提示子类需要重写这个方法:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Iterator</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Must override makeIterator()"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就定义了一个基于类的类型擦除的API，私有的子类将来实现这些API。公共类通过元素类型参数化，但私有实现类由它包装的序列类型进行参数化:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MAnySequenceImpl</span>&lt;<span class="title">Seq</span>: <span class="title">Sequence</span>&gt;: <span class="title">MAnySequence</span>&lt;<span class="title">Seq</span>.<span class="title">Element</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure><p><code>MAnySequenceImpl</code> 需要一个继承于 <code>Iterator</code> 的子类:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorImpl</span>: <span class="title">Iterator</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><code>IteratorImpl</code> 包装了序列的迭代器:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wrapped: <span class="type">Seq</span>.<span class="type">Iterator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(<span class="number">_</span> wrapped: <span class="type">Seq</span>.<span class="type">Iterator</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.wrapped = wrapped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>next</code> 方法中调用被包装的序列迭代器：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Seq</span>.<span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> wrapped.next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相似地，<code>MAnySequenceImpl</code> 包装一个序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> seq: <span class="type">Seq</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(<span class="number">_</span> seq: <span class="type">Seq</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.seq = seq</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从序列中获取迭代器，然后将迭代器包装成 <code>IteratorImpl</code> 对象返回，这样就实现了 <code>makeIterator</code> 的功能。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">IteratorImpl</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">IteratorImpl</span>(seq.makeIterator())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要一种方法来实际创建这些东西：对 <code>MAnySequence</code> 添加一个静态方法，该方法创建一个 <code>MAnySequenceImpl</code> 实例，并将其作为 <code>MAnySequence</code> 类型返回给调用者。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MAnySequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">make</span>&lt;Seq: Sequence&gt;<span class="params">(<span class="number">_</span> seq: Seq)</span></span> -&gt; <span class="type">MAnySequence</span>&lt;<span class="type">Element</span>&gt; <span class="keyword">where</span> <span class="type">Seq</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MAnySequenceImpl</span>&lt;<span class="type">Seq</span>&gt;(seq)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际开发中，我们可能会做一些额外的操作来让 <code>MAnySequence</code> 提供一个初始化方法。</p><p>我们来试试 <code>MAnySequence</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInts</span><span class="params">(<span class="number">_</span> seq: MAnySequence&lt;Int&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> elt <span class="keyword">in</span> seq &#123;</span><br><span class="line">        <span class="built_in">print</span>(elt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">printInts(<span class="type">MAnySequence</span>.make(array))</span><br><span class="line">printInts(<span class="type">MAnySequence</span>.make(array[<span class="number">1</span> ..&lt; <span class="number">4</span>]))</span><br></pre></td></tr></table></figure><p>完美!</p><h2 id="基于函数的类型擦除"><a href="#基于函数的类型擦除" class="headerlink" title="基于函数的类型擦除"></a>基于函数的类型擦除</h2><p>有时我们希望对外暴露支持多种类型的方法，但又不想指定具体的类型。一个简单的办法就是，存储那些签名仅涉及到我们想公开的类型的函数，函数主体在底层已知具体实现类型的上下文中创建。</p><p>我们一起看看如何运用这种方法来设计 <code>MAnySequence</code>，与前面的实现很类似。它是一个结构体而非类，这是因为它仅仅作为容器使用，不需要有任何的继承关系。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAnySequence</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Sequence</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>跟之前一样，<code>MAnySequence</code> 也需要一个可返回的迭代器（Iterator）。迭代器同样被设计为结构体，并持有一个参数为空并返回 <code>Element?</code> 的存储型属性，实际上这个属性是一个函数，被用于 <code>IteratorProtocol</code> 协议的 <code>next</code> 方法中。接下来 <code>Iterator</code> 遵循 <code>IteratorProtocol</code> 协议，并在 <code>next</code> 方法中调用函数:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Iterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _next: () -&gt; <span class="type">Element</span>?</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> _next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MAnySequence</code> 与 <code>Iterator</code> 很相似：持有一个参数为空返回 <code>Iterator</code> 类型的存储型属性。遵循 <code>Sequence</code> 协议并在 <code>makeIterator</code> 方法中调用这个属性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _makeIterator: () -&gt; <span class="type">Iterator</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _makeIterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MAnySequence</code> 的构造函数正是魔法起作用的地方，它接收任意序列作为参数: </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>&lt;<span class="type">Seq</span>: <span class="type">Sequence</span>&gt;(<span class="number">_</span> seq: <span class="type">Seq</span>) <span class="keyword">where</span> <span class="type">Seq</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br></pre></td></tr></table></figure><p>接下来需要在构造函数中包装此序列的功能:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">_makeIterator = &#123;</span><br></pre></td></tr></table></figure><p>如何生成迭代器？请求 <code>Seq</code> 序列生成：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iterator = seq.makeIterator()</span><br></pre></td></tr></table></figure><p>接下来我们利用自定义的迭代结构体包装序列生成的迭代器，包装后的 <code>_next</code> 属性将会在迭代器协议的 <code>next()</code> 方法中被调用:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="type">Iterator</span>(_next: &#123; iterator.next() &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来展示如何使用 <code>MAnySequence</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInts</span><span class="params">(<span class="number">_</span> seq: MAnySequence&lt;Int&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> elt <span class="keyword">in</span> seq &#123;</span><br><span class="line">        <span class="built_in">print</span>(elt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">printInts(<span class="type">MAnySequence</span>(array))</span><br><span class="line">printInts(<span class="type">MAnySequence</span>(array[<span class="number">1</span> ..&lt; <span class="number">4</span>]))</span><br></pre></td></tr></table></figure><p>正确运行，太棒了！</p><p>当需要将小部分功能包装为更大类型的一部分时，这种基于函数的类型擦除方法特别实用，这样做就不需要有单独的类来实现被擦除类型的这部分功能了。</p><p>比方说你现在想要编写一些适用于各种集合类型的代码，但它真正需要能够对这些集合执行的操作是获取计数并执行从零开始的整数下标。如访问 <code>tableView</code> 数据源。它可能看起来像这样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericDataSource</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">count</span>: () -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> getElement: (<span class="type">Int</span>) -&gt; <span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">C</span>: <span class="type">Collection</span>&gt;(<span class="number">_</span> <span class="built_in">c</span>: <span class="type">C</span>) <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Element</span> == <span class="type">Element</span>，<span class="type">C</span>.<span class="type">Index</span> == <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="built_in">count</span> = &#123; <span class="built_in">c</span>.<span class="built_in">count</span> &#125;</span><br><span class="line">        getElement = &#123; <span class="built_in">c</span>[$<span class="number">0</span> - <span class="built_in">c</span>.startIndex] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GenericDataSource</code> 其他代码可通过调用 <code>count()</code> 或 <code>getElement()</code> 来操作传入的集合。且不会让集合类型破坏 <code>GenericDataSource</code> 泛型参数。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>类型擦除是一种非常有用的技术，它可用来阻止泛型对代码的侵入，也可用来保证接口简单明了。通过将底层类型包装起来，将API与具体的功能进行拆分。这可以通过使用抽象的公共超类和私有子类或将 API 包装在函数中来实现。对于只需要一些功能的简单情况，基于函数类型擦除极其有效。</p><p>Swift 标准库提供了几种可直接利用的类型擦除类型。如 <code>AnySequence</code> 包装一个 <code>Sequence</code>，正如其名，<code>AnySequence</code> 允许你对序列迭代而无需知道序列具体的类型。<code>AnyIterator</code> 也是类型擦除的类型，它提供一个类型擦除的迭代器。<code>AnyHashable</code> 也同样是类型擦除的类型，它提供了对Hashable类型访问功能。Swift 还有很多基于集合的擦除类型，你可以通过搜索 <code>Any</code> 来查阅。标准库中也为 <code>Codable</code> API 设计了类型擦除类型: <code>KeyedEncodingContainer</code> 和 <code>KeyedDecodingContainer</code>。它们都是容器协议类型包装器，可用来在不知道底层具体类型信息的情况下实现 <code>Encode</code> 和 <code>Decode</code>。</p><p>这就是今天全部的内容了，下次再见。你们的建议对 Friday Q&amp;A 是最好的鼓励，所以如果你关于这个主题有什么好的想法，请 <a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发邮件到这里</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      详细说明 Swift 类型擦除
    
    </summary>
    
      <category term="iOS" scheme="https://swift.gg/categories/iOS/"/>
    
      <category term="iOS 开发" scheme="https://swift.gg/categories/iOS/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="教程" scheme="https://swift.gg/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Tagged Pointer 字符串</title>
    <link href="https://swift.gg/2018/10/08/tagged-pointer-strings/"/>
    <id>https://swift.gg/2018/10/08/tagged-pointer-strings/</id>
    <published>2018-10-08T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-07-31-tagged-pointer-strings.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-07-31<br>译者：<a href="https://dingtz.com/" target="_blank" rel="noopener">jojotov</a>；校对：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>，<a href="http://www.desgard.com/" target="_blank" rel="noopener">冬瓜</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>Tagged pointer 是一项用于提高性能并减少内存使用的有趣技术。在 OS X 10.10 中，<code>NSString</code> 也开始使用了 tagged pointer 技术，今天我会在 Ken Ferry 的提议下，窥探其工作原理。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对象存储在内存中的时候是内存对齐的，因此他们的地址总是单个指针大小的倍数，在实际中通常是 16 的倍数。对象的指针通常是以一个完整的 64 位整型的结构进行存储，不过由于内存对齐的，指针中一些位总会为零。</p><p>Tagged pointer 技术受益于此，通过让这些位不再为 0，赋予了对象指针一些特殊意义。在苹果的 64 位 Objective-C 实现当中，对象指针的最低有效位设置为 1 的时候 (也就是说，它是一个奇数) ，此指针被认为是 tagged pointer。此时，最低有效位前面的 3 位不再被当作 isa 指针的地址，而是用于表示一个特殊的 tagged class 表的索引值。这个索引值可以用来查找 tagged pointer 所对应的类。剩余的 60 位则会被直接使用。</p><p>来看一个对上述理论的简单应用：当我们创建一个 <code>NSNumber</code> 对象时，如果它适合于 tagged pointer 技术，那么这个对象将不再是一个真正的 <code>NSNumber</code> 对象——它的指针会自动转换为 tagged pointer 指针，并且最低位会被设置为 1；接下来的 3 位会设为 <code>NSNumber</code> 所对应的 tagged class 在一个全局表中的索引；而剩余的 60 位会用作保存其数值 —— 比如一个能用 60 位表示的整型值。</p><p>对于外部而言，这样的一个指针与其他任何对象的指针看起来都是一样的。它能像其他对象一样响应消息，因为 <code>objc_msgSend</code> 知道它是一个 tagged pointer 类型的指针。假如你要向它发送 <code>integerValue</code> 的消息，OC 运行时会帮助我们从它存储数据的 60 位中拿出数据并返回。</p><p>尽管为了对外统一，运行时做了很多额外工作，但最终你节省了一次内存的初始化，一次指针的间接访问，并且也不会有任何关于引用计数的操作 —— 因为没有内存需要被释放。对于一些经常使用的类来说，这能带来显著的性能提升。</p><p><code>NSString</code> 看起来不太适用于 tagged pointer 技术，因为它的长度是可变的，而且可能会远远超出 tagged pointer 所能存储的范围。但话虽如此，一个 tagged pointer 的类是可以和普通的类共存的 —— 某些值使用 tagged pointer，另外一些值使用普通指针。例如，对于 <code>NSNumber</code> 来说，一个大于 2^60 - 1 的整型超出了 tagged pointer 所能存储的范围，那么它就需要存储为一个在内存中初始化的普通 <code>NSNumber</code> 对象。</p><p><code>NSString</code> 亦是如此。假如某些字符串可以保存为 60 位以内的二进制数据，它会创建为 tagged pointer，而其他字符串会保存为普通的对象。据此我们可以假设，如果小的字符串经常被使用且达到一定的使用量时，它会获得可观的性能。在真实的代码中会有如此效果吗？显然苹果给出了肯定的答案 —— 如果没有实际效果，他们不会尝试去实现它。</p><h2 id="可能的实现"><a href="#可能的实现" class="headerlink" title="可能的实现"></a>可能的实现</h2><p>在窥探苹果的实现之前，我们先花点时间思考一下可能的实现方案。基本准则很简单：把最低位设为 1，然后把后面的几位设为合适的 tagged class 索引，最后把剩下的位设为任意值。此时最大的问题是如何利用剩余的 60 位 —— 我们要尽可能最大化这 60 位的价值。</p><p>Cocoa 框架中的字符串在某种概念上其实是一个 Unicode 码位的序列。Unicode 包含了 1,112,064 个有效码位，所以一个码位需要用 21 位来表示。也就是说，我们可以在 60 位的长度中放入两个 Unicode 码位，这样还剩下 18 位没有使用。我们可以利用这 18 位中其中几位来表示字符串的长度。因此，这样的一个 tagged pointer  字符串可能会包含零个、一个或者两个 Unicode 码位。但问题是，最多只能包含两个码位好像并不太实用。</p><p>实际上，<code>NSString</code> API 使用了 UTF-16 实现，并非原始的 Unicode 码位。UTF-16 把 Unicode 表示为一个包含多个 16 位数值的序列。在基本多语言平面（Basic Multilingual Plane，BMP）中的字符，也就是那些最常用的字符，会使用一个 16 位的值表示。同时，那些超过 65,535 的码位会使用两个 16 位 (也就是 32 位) 的值来表示。因此，我们可以在 60 位的长度中放入三个 16 位的值，剩余的 12 位同样用于表示长度。也就是说，我们可以放入 0 至 3 个 UTF-16 编码的字符 —— 严格来说是最多三个 BMP 中的字符，或者最多一个 BMP 之上平面的字符加一个 BMP 平面之下的字符。不过最多三个字符，我们还是会很受限。</p><p>在应用中的大多数字符串都是 ASCII。即使这个应用本地化为一种非 ASCII 的语言，字符串也不只是单纯地在 UI 层用作展示 —— 字符串会用于 URL 的组成、文件扩展名、对象的键、属性列表的值等等。UTF-8 是一种兼容 ASCII 的编码，它会把每个 ASCII 字符编码为单个字节，并且对其他 Unicode 码位使用最多四个字节进行编码。这样，我们能在 60 位中放入最多 7 个字节，剩下 4 位表示长度。因此，根据不同的字符格式，我们的 tagged pointer 字符串可以包含最多 7 个 ASCII 字符，或者更少量的非 ASCII 字符。</p><p>如果我们针对 ASCII 优化一下，或许我们能完全抛弃对所有 Unicode 都支持的想法 —— 那些非 ASCII 的字符都使用真正的字符串对象来保存。ASCII 是一种 7 位的编码方式。因此，假设我们只给每个字符分配 7 位的空间呢？那么我们能在可利用的 60 位空间中保存最多 8 个 ASCII 字符，剩余 4 位表示长度。现在，我们的方案听上去开始具有一定的可行性了 —— 在应用中应该有不少字符串是纯正的 ASCII 并且仅包含 8 个或更少的字符。</p><p>让我们的思维放飞一点，完整的 ASCII 范围中包含了许多并不常用的东西。比如其中有一大堆控制字符和非常用符号。而字母和数字才是我们最常用的。我们能把它压缩成只有 6 位吗？</p><p>6 位可以表示 64 个可能的值。ASCII 字母表中有 26 个英文字母。如果把大写字母也算上的话一共有 52 个字母。再加上 0-9 的数字，一共有 62 个。现在还有两个空余的位置，我们可以把它们留给空格和句号。这样应该会有很多的字符串只包含上述的字符。如果一个字符只需要 6 位，那么我们可以在 60 位空间中保存最多 10 个字符！不过别高兴太早，我们现在没有多余的位置来表示长度了！因此，我们可以选择这 60 位保存 9 个字符和 1 个长度，或者我们去掉上面的 64 个值之一 (我投票给空格)，然后用一个 6 位的 <code>0</code> 表示少于 10 个字符的字符串的结束位。(译者注：去掉 64 个字符集合中的一个，然后加入一个结束符，当遇到结束符的时候就表示字符串结束，长度为结束符的位置，否则长度刚好为 10。)</p><p>如果只使用 5 位呢？这好像有点天方夜谭。但实际上，应该有很大一部分的字符串只包含小写字母。5 位可以表示 32 个可能的值。如果我们把整个小写字母表考虑进来，那么还剩下 6 个位置，可以分配给一些常用的大写字母、符号和数字。如果你觉得这些除小写字母外的情况更为常见，你甚至可以去掉一些不常用的小写字母，比如字母 <code>q</code>。每个字符只使用 5 位的话，那么我们可以存放 11 个字符并且还能有存放长度的空间，或者我们保存 12 个字符，并采用结束符的方案表示长度。</p><p>让我们的思维再飞远一点。每个字符只使用 5 位似乎已经是在字母表长度固定的前提下的最优解了。不过你可以使用一些变长的编码，例如 Huffman 编码。这样的话，对于一个常见的字母 <code>e</code>，可以使用比字母 <code>q</code> 更少的位表示。也就是说，假设你的字符串全都是 <code>e</code>，那字符串的每个字符最少可以只用 1 位表示。但这样的代价是你的代码会变得更加复杂，且性能或许较差。</p><p>苹果到底是采用哪种方案的呢？我们现在来一探究竟。</p><h2 id="Tagged-Pointer-字符串实践"><a href="#Tagged-Pointer-字符串实践" class="headerlink" title="Tagged Pointer 字符串实践"></a>Tagged Pointer 字符串实践</h2><p>下面的代码创建了一个 tagged pointer 字符串并打印了它的指针：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *a = <span class="string">@"a"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *b = [[a mutableCopy] <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p %p %@"</span>, a, b, object_getClass(b));</span><br></pre></td></tr></table></figure><p>这里 <code>mutableCopy</code> 和 <code>copy</code> 的操作可能会让人费解，但它却是必须的。其中有两个原因：首先，尽管一个像 <code>@&quot;a&quot;</code> 这样的字符串可以被存储为 tagged pointer 字符串，但如果是常量字符串的话，那么它永远不会存储为 tagged pointer 字符串。常量字符串必须保证能够兼容不同的操作系统版本，但 tagged pointer 字符串的内部细节却不保证能兼容。如果只是苹果的运行时代码所生成的 tagged pointer，它不会有任何问题。但如果像常量字符串一样，编译器把它们嵌入在二进制文件中时，就可能会发生崩溃的问题。因此，我们需要对常量字符串进行 <code>copy</code> 操作来拿到一个 tagged pointer。</p><p>必须进行 <code>mutableCopy</code> 操作的原因是，<code>NSString</code> 对我们来说十分的 “聪明” ，它能知道一个对不可变字符串的 <code>copy</code> 其实是一个毫无意义的操作，并返回原来的字符串作为 <code>copy</code> 操作后的值。因为常量字符串是不可变的，所以 <code>[a copy]</code> 的返回值其实与 <code>a</code> 是一样的。不过，<code>mutableCopy</code> 会强制进行真正的拷贝操作（深拷贝），然后对这样一个深拷贝后的结果再进行一次不可变拷贝操作后，足以让系统返回给我们一个 tagger pointer 字符串。</p><blockquote><p>译者注：<code>[a mutableCopy]</code> 会在运行时创建一个可变字符串（深拷贝），因此避免了上面原因一中关于常量字符串的情况。但由于 <code>mutableCopy</code> 后的对象是一个可变对象，不可能为 tagged pointer，因此需要再对此可变副本进行一次 <code>copy</code> 操作。这次 <code>copy</code> 会在运行时返回一个新的不可变副本（深拷贝），避免了上面原因二中对常量字符串拷贝返回原值的情况（浅拷贝），进而保证了最后返回的对象是经过运行时创建出来的（tagged pointer 对象只会在运行时创建）。</p></blockquote><p>注意，你一定不可以在自己的代码中依赖这些细节！<code>NSString</code> 的代码返回一个 tagged pointer 给你的情况并不是一成不变的，如果你编写的代码不知怎么地依赖于此，那它最终可能会导致崩溃。幸好，正常且合理的代码不会有任何问题 —— 让你可以幸福地忽略所有 tagged 相关的东西。</p><p>上面的代码在我的电脑上打印如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x10ba41038 0x6115 NSTaggedPointerString</span><br></pre></td></tr></table></figure><p>首先，你可以看到原始的指针 —— 一个用来表示对象指针的整数。第二个值为 <code>copy</code> 后的指针，它非常清晰地表示出 tagged pointer 的特性：首先，它是一个奇数，也就是说它不会是一个有效的对象指针（内存对齐的关系）。同时，它是一个很小的数。在 64 位 Mac 系统的地址空间中，一开始的 4GB 是没有任何映射且不能建立映射的空页。因此，这个属于空页的地址也很好地证明了它不可能是一个对象指针。</p><p>我们可以从 <code>0x6115</code> 这个值推断出什么呢？首先我们可以知道最低的 4 位是 tagged pointer 机制本身的一部分。最低的十六进制数字 <code>5</code> 在二进制中为 <code>0101</code>。最低位的 <code>1</code> 表明了它是一个 tagged pointer。剩下的 3 位表明了它的 tagged class —— 在这个例子中是 <code>010</code>，表明了 tagged pointer 字符串类的索引值为 <code>2</code>。不过这些信息并不能提供给我们什么有用的东西。</p><p>而上面例子中十六进制地址的 <code>61</code> 则很值得我们探讨一番。在十六进制中，<code>61</code> 刚好为字母 a 的 ASCII 编码。还记得这个指针所指向的值吗 —— 正好就是字母 a！看起来这里直接使用了 ASCII 编码的值，真是个方便而又合适的选择！</p><p>接下来打印出的类名明显地表明了它的类是什么，并且也提供了一个非常不错的切入点，来让我们深入其真实源码一探此特性的本质实现。我们很快会进入这一阶段，不过在此之前先做点额外的检查。</p><p>这里通过一个循环构造出 <code>abcdef...</code> 的字符串，同时把属于 tagged pointer 的字符串指针一个接一个地打印出来。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> *<span class="keyword">mutable</span> = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line"><span class="built_in">NSString</span> *immutable;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    [<span class="keyword">mutable</span> appendFormat: <span class="string">@"%c"</span>, c++];</span><br><span class="line">    immutable = [<span class="keyword">mutable</span> <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"0x%016lx %@ %@"</span>, immutable, immutable, object_getClass(immutable));</span><br><span class="line">&#125; <span class="keyword">while</span>(((uintptr_t)immutable &amp; <span class="number">1</span>) == <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>第一次迭代的打印结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000000000006115 a NSTaggedPointerString</span><br></pre></td></tr></table></figure><p>这验证了上文的所写的。需要注意的是，现在我们把包含空位 0 的指针完整地打印出来，可以让每次迭代的打印结果对比更加清晰。</p><p>现在对比一下第二次迭代的打印结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000000000626125 ab NSTaggedPointerString</span><br></pre></td></tr></table></figure><p>可以看到最低 4 位没有发生任何变化，这也在我们意料之中。这个十六进制的数字 <code>5</code> 会一直保持不变，总是表明它是一个 <code>NSTaggedPointerString</code> 类型的 tagged pointer。</p><p>而原来的 <code>61</code> 也保持原来的位置，不过现在它前面出现了 <code>62</code>。显而易见，<code>62</code> 是字母 b 的 ASCII 编码，因此我们可以知道当前的编码方式是使用 ASCII 的 8 位编码。而在最低位之前的 4 位由 <code>1</code> 变成了 <code>2</code>，由此我们可以想到它或许表示了字符串的长度。接下来的迭代确认了这个猜想：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000000063626135 abc NSTaggedPointerString</span><br><span class="line">0x0000006463626145 abcd NSTaggedPointerString</span><br><span class="line">0x0000656463626155 abcde NSTaggedPointerString</span><br><span class="line">0x0066656463626165 abcdef NSTaggedPointerString</span><br><span class="line">0x6766656463626175 abcdefg NSTaggedPointerString</span><br></pre></td></tr></table></figure><p>按理来说，由于 tagged pointer 的空位已经填满了，迭代应该也到此为止。可事实的确如此吗？并不是！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0022038a01169585 abcdefgh NSTaggedPointerString</span><br><span class="line">0x0880e28045a54195 abcdefghi NSTaggedPointerString</span><br><span class="line">0x00007fd275800030 abcdefghij __NSCFString</span><br></pre></td></tr></table></figure><p>循环中的代码继续执行下去，直到两次迭代后才终止。表示长度的区间继续保持增长，但指针剩余的部分却显得杂乱无章。到底是发生了什么呢？让我们深入其实现代码来一探究竟。</p><h2 id="刨根问底"><a href="#刨根问底" class="headerlink" title="刨根问底"></a>刨根问底</h2><p><code>NSTaggedPointer</code> 类存在于 CoreFoundation 库中。似乎把它放在 Foundation 中会更加合理一点，但实际上现在苹果许多核心的 Objective-C 类都被移到了 CoreFoundation 当中，因为苹果慢慢地放弃了把  CoreFoundation 变成一个独立实体的想法。</p><p>先来看看 <code>-[NSTaggedPointerString length]</code> 的实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push       rbp</span><br><span class="line">mov        rbp, rsp</span><br><span class="line">shr        rdi, 0x4</span><br><span class="line">and        rdi, 0xf</span><br><span class="line">mov        rax, rdi</span><br><span class="line">pop        rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>Hopper 工具为我们提供了这个简易的反编译版本：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> -[<span class="built_in">NSTaggedPointerString</span> length](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd) &#123;</span><br><span class="line">    rax = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，提取出 4 至 7 位的值并返回它们便可以得到字符串的长度。这证实了我们上文中所观察到的 —— 在最低位的十六进制 <code>5</code> 前面的 4 位表示了字符串的长度。 </p><p><code>NSString</code> 子类中另一个原始方法是 <code>characterAtIndex:</code>。由于其汇编代码太长，我会直接跳过并给出 Hopper 反编译出的可读性较高的版本：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> -[<span class="built_in">NSTaggedPointerString</span> characterAtIndex:](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> arg2) &#123;</span><br><span class="line">     rsi = _cmd;</span><br><span class="line">     rdi = <span class="keyword">self</span>;</span><br><span class="line">     r13 = arg2</span><br><span class="line">     r8 = ___stack_chk_guard;</span><br><span class="line">     var_30 = *r8;</span><br><span class="line">     r12 = rdi &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">     <span class="keyword">if</span> (r12 &gt;= <span class="number">0x8</span>) &#123;</span><br><span class="line">             rbx = rdi &gt;&gt; <span class="number">0x8</span>;</span><br><span class="line">             rcx = <span class="string">"eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX"</span>;</span><br><span class="line">             rdx = r12;</span><br><span class="line">             <span class="keyword">if</span> (r12 &lt; <span class="number">0xa</span>) &#123;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                             *(int8_t *)(rbp + rdx + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((rbx &amp; <span class="number">0x3f</span>) + rcx);</span><br><span class="line">                             rdx = rdx - <span class="number">0x1</span>;</span><br><span class="line">                             rbx = rbx &gt;&gt; <span class="number">0x6</span>;</span><br><span class="line">                     &#125; <span class="keyword">while</span> (rdx != <span class="number">0x0</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                             *(int8_t *)(rbp + rdx + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((rbx &amp; <span class="number">0x1f</span>) + rcx);</span><br><span class="line">                             rdx = rdx - <span class="number">0x1</span>;</span><br><span class="line">                             rbx = rbx &gt;&gt; <span class="number">0x5</span>;</span><br><span class="line">                     &#125; <span class="keyword">while</span> (rdx != <span class="number">0x0</span>);</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (r12 &lt;= r13) &#123;</span><br><span class="line">             rbx = r8;</span><br><span class="line">             ___CFExceptionProem(rdi, rsi);</span><br><span class="line">             [<span class="built_in">NSException</span> raise:<span class="string">@"NSRangeException"</span> format:<span class="string">@"%@: Index %lu out of bounds; string length %lu"</span>];</span><br><span class="line">             r8 = rbx;</span><br><span class="line">     &#125;</span><br><span class="line">     rax = *(int8_t *)(rbp + r13 + <span class="number">0xffffffffffffffc0</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">     <span class="keyword">if</span> (*r8 != var_30) &#123;</span><br><span class="line">             rax = __stack_chk_fail();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> rax;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们稍微整理一下：前三行中，Hopper 让我们知道了寄存器分别存放了哪些参数。我们马上着手把 <code>rsi</code> 替换成 <code>_cmd</code>，然后把 <code>rdi</code> 替换成 <code>self</code>。<code>arg2</code> 实际上是 <code>index</code> 参数，因此我们把所有 <code>r13</code> 的调用替换成 <code>index</code>。接下来，由于 <code>__stack_chk</code> 其实是一个用来加强防御性的东西，且它与函数的实际作用没有多大关联，我们可以暂时忽略掉它。现在整理过后的代码看起来大概是这个样子的：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> -[<span class="built_in">NSTaggedPointerString</span> characterAtIndex:](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> index) &#123;</span><br><span class="line">    r12 = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">if</span> (r12 &gt;= <span class="number">0x8</span>) &#123;</span><br><span class="line">            rbx = <span class="keyword">self</span> &gt;&gt; <span class="number">0x8</span>;</span><br><span class="line">            rcx = <span class="string">"eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX"</span>;</span><br><span class="line">            rdx = r12;</span><br><span class="line">            <span class="keyword">if</span> (r12 &lt; <span class="number">0xa</span>) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(rbp + rdx + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((rbx &amp; <span class="number">0x3f</span>) + rcx);</span><br><span class="line">                            rdx = rdx - <span class="number">0x1</span>;</span><br><span class="line">                            rbx = rbx &gt;&gt; <span class="number">0x6</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (rdx != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(rbp + rdx + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((rbx &amp; <span class="number">0x1f</span>) + rcx);</span><br><span class="line">                            rdx = rdx - <span class="number">0x1</span>;</span><br><span class="line">                            rbx = rbx &gt;&gt; <span class="number">0x5</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (rdx != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r12 &lt;= index) &#123;</span><br><span class="line">            rbx = r8;</span><br><span class="line">            ___CFExceptionProem(<span class="keyword">self</span>, _cmd);</span><br><span class="line">            [<span class="built_in">NSException</span> raise:<span class="string">@"NSRangeException"</span> format:<span class="string">@"%@: Index %lu out of bounds; string length %lu"</span>];</span><br><span class="line">            r8 = rbx;</span><br><span class="line">    &#125;</span><br><span class="line">    rax = *(int8_t *)(rbp + index + <span class="number">0xffffffffffffffc0</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意第一个 <code>if</code> 语句之前的这行代码：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">r12 = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span></span><br></pre></td></tr></table></figure><p>我们可以发现，这正是我们前面所看到的 <code>-length</code> 实现代码。既然如此，那我们就把 <code>r12</code> 全部替换成 <code>length</code>：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> -[<span class="built_in">NSTaggedPointerString</span> characterAtIndex:](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> index) &#123;</span><br><span class="line">    length = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= <span class="number">0x8</span>) &#123;</span><br><span class="line">            rbx = <span class="keyword">self</span> &gt;&gt; <span class="number">0x8</span>;</span><br><span class="line">            rcx = <span class="string">"eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX"</span>;</span><br><span class="line">            rdx = length;</span><br><span class="line">            <span class="keyword">if</span> (length &lt; <span class="number">0xa</span>) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(rbp + rdx + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((rbx &amp; <span class="number">0x3f</span>) + rcx);</span><br><span class="line">                            rdx = rdx - <span class="number">0x1</span>;</span><br><span class="line">                            rbx = rbx &gt;&gt; <span class="number">0x6</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (rdx != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(rbp + rdx + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((rbx &amp; <span class="number">0x1f</span>) + rcx);</span><br><span class="line">                            rdx = rdx - <span class="number">0x1</span>;</span><br><span class="line">                            rbx = rbx &gt;&gt; <span class="number">0x5</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (rdx != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= index) &#123;</span><br><span class="line">            rbx = r8;</span><br><span class="line">            ___CFExceptionProem(<span class="keyword">self</span>, _cmd);</span><br><span class="line">            [<span class="built_in">NSException</span> raise:<span class="string">@"NSRangeException"</span> format:<span class="string">@"%@: Index %lu out of bounds; string length %lu"</span>];</span><br><span class="line">            r8 = rbx;</span><br><span class="line">    &#125;</span><br><span class="line">    rax = *(int8_t *)(rbp + index + <span class="number">0xffffffffffffffc0</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看 <code>if</code> 语句内部的代码，第一行把 <code>self</code> 右移了 8 位。这 8 位是保存了 tagged pointer 的指示符以及字符串长度。而右移操作后得到的值，我们可以推测它就是其真正的数据。因此我们把 <code>rbx</code> 替换为 <code>stringData</code> 来让代码更加清晰可读一点。下一行把一个类似查找表的东西赋值给 <code>rcx</code>，因此我们也把 <code>rcx</code> 替换成 <code>table</code>。最后，<code>rdx</code> 拿到了值的长度的一份拷贝。看起来它后面会作为光标来使用，因此我们再把 <code>rdx</code> 替换为 <code>cursor</code>。现在我们的代码是这样的：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> -[<span class="built_in">NSTaggedPointerString</span> characterAtIndex:](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> index) &#123;</span><br><span class="line">    length = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= <span class="number">0x8</span>) &#123;</span><br><span class="line">            stringData = <span class="keyword">self</span> &gt;&gt; <span class="number">0x8</span>;</span><br><span class="line">            table = <span class="string">"eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX"</span>;</span><br><span class="line">            cursor = length;</span><br><span class="line">            <span class="keyword">if</span> (length &lt; <span class="number">0xa</span>) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(rbp + cursor + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((stringData &amp; <span class="number">0x3f</span>) + table);</span><br><span class="line">                            cursor = cursor - <span class="number">0x1</span>;</span><br><span class="line">                            stringData = stringData &gt;&gt; <span class="number">0x6</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (cursor != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(rbp + cursor + <span class="number">0xffffffffffffffbf</span>) = *(int8_t *)((stringData &amp; <span class="number">0x1f</span>) + table);</span><br><span class="line">                            cursor = cursor - <span class="number">0x1</span>;</span><br><span class="line">                            stringData = stringData &gt;&gt; <span class="number">0x5</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (cursor != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= index) &#123;</span><br><span class="line">            rbx = r8;</span><br><span class="line">            ___CFExceptionProem(<span class="keyword">self</span>, _cmd);</span><br><span class="line">            [<span class="built_in">NSException</span> raise:<span class="string">@"NSRangeException"</span> format:<span class="string">@"%@: Index %lu out of bounds; string length %lu"</span>];</span><br><span class="line">            r8 = rbx;</span><br><span class="line">    &#125;</span><br><span class="line">    rax = *(int8_t *)(rbp + index + <span class="number">0xffffffffffffffc0</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，代码基本上已经完全符号化了，不过还有一个寄存器名称仍然存在：<code>rbp</code>。它实际上是帧指针。因此，编译器其实做了一些很 tricky 的事情 —— 直接通过帧指针进行了索引操作。二进制补码中有一条原理： “所有东西最终都是无符号整型” ，因此为了让变量减去 65，我们可以将其与 <code>0xffffffffffffffbf</code> 常量相加。接下来，它又减去了 64（倒数第二行代码）。这两个值大概都是分配在栈上的局部变量。仔细看的话，你会发现这段代码非常奇怪 —— 有一条路径是只进行了读操作而没有进行任何的写操作。这到底是怎么回事呢？</p><p>原因其实是 Hopper 忘记了对另一个 if 条件判断的 <code>else</code> 分支进行反编译。相对应的汇编代码看起来是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov        rax, rdi</span><br><span class="line">shr        rax, 0x8</span><br><span class="line">mov        qword [ss:rbp+var_40], rax</span><br></pre></td></tr></table></figure><p><code>var_40</code> 便是在 Hopper 反编译版本中的偏移量 <code>64</code>（<code>40</code> 刚好是 <code>64</code> 的十六进制表示）。我们暂且把这个位置的指针称为 <code>buffer</code>。这样一来，上面代码中遗漏分支的 C 语言代码看起来是这样的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="keyword">uint64_t</span> *)buffer = self &gt;&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><p>现在把这段代码插入原本的代码中，并替换掉其他位置的 <code>rbp</code> 为 <code>buffer</code>。最后，为了能提醒自己，我们在函数开始的位置再补上一行 <code>buffer</code> 的声明语句：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> -[<span class="built_in">NSTaggedPointerString</span> characterAtIndex:](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> index) &#123;</span><br><span class="line">    int8_t buffer[<span class="number">11</span>];</span><br><span class="line">    length = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= <span class="number">0x8</span>) &#123;</span><br><span class="line">            stringData = <span class="keyword">self</span> &gt;&gt; <span class="number">0x8</span>;</span><br><span class="line">            table = <span class="string">"eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX"</span>;</span><br><span class="line">            cursor = length;</span><br><span class="line">            <span class="keyword">if</span> (length &lt; <span class="number">0xa</span>) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(buffer + cursor - <span class="number">1</span>) = *(int8_t *)((stringData &amp; <span class="number">0x3f</span>) + table);</span><br><span class="line">                            cursor = cursor - <span class="number">0x1</span>;</span><br><span class="line">                            stringData = stringData &gt;&gt; <span class="number">0x6</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (cursor != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                            *(int8_t *)(buffer + cursor - <span class="number">1</span>) = *(int8_t *)((stringData &amp; <span class="number">0x1f</span>) + table);</span><br><span class="line">                            cursor = cursor - <span class="number">0x1</span>;</span><br><span class="line">                            stringData = stringData &gt;&gt; <span class="number">0x5</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (cursor != <span class="number">0x0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *(uint64_t *)buffer = <span class="keyword">self</span> &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= index) &#123;</span><br><span class="line">            rbx = r8;</span><br><span class="line">            ___CFExceptionProem(<span class="keyword">self</span>, _cmd);</span><br><span class="line">            [<span class="built_in">NSException</span> raise:<span class="string">@"NSRangeException"</span> format:<span class="string">@"%@: Index %lu out of bounds; string length %lu"</span>];</span><br><span class="line">            r8 = rbx;</span><br><span class="line">    &#125;</span><br><span class="line">    rax = *(int8_t *)(buffer + index) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在代码看起来好了很多。不过那些疯狂的指针操作语句实在是太难看懂了，而它们仅仅是一些数组的索引操作。我们来简化一下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> -[<span class="built_in">NSTaggedPointerString</span> characterAtIndex:](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> index) &#123;</span><br><span class="line">     int8_t buffer[<span class="number">11</span>];</span><br><span class="line">     length = <span class="keyword">self</span> &gt;&gt; <span class="number">0x4</span> &amp; <span class="number">0xf</span>;</span><br><span class="line">     <span class="keyword">if</span> (length &gt;= <span class="number">0x8</span>) &#123;</span><br><span class="line">             stringData = <span class="keyword">self</span> &gt;&gt; <span class="number">0x8</span>;</span><br><span class="line">             table = <span class="string">"eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX"</span>;</span><br><span class="line">             cursor = length;</span><br><span class="line">             <span class="keyword">if</span> (length &lt; <span class="number">0xa</span>) &#123;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                             buffer[cursor - <span class="number">1</span>] = table[stringData &amp; <span class="number">0x3f</span>];</span><br><span class="line">                             cursor = cursor - <span class="number">0x1</span>;</span><br><span class="line">                             stringData = stringData &gt;&gt; <span class="number">0x6</span>;</span><br><span class="line">                     &#125; <span class="keyword">while</span> (cursor != <span class="number">0x0</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                             buffer[cursor - <span class="number">1</span>] = table[stringData &amp; <span class="number">0x1f</span>];</span><br><span class="line">                             cursor = cursor - <span class="number">0x1</span>;</span><br><span class="line">                             stringData = stringData &gt;&gt; <span class="number">0x5</span>;</span><br><span class="line">                     &#125; <span class="keyword">while</span> (cursor != <span class="number">0x0</span>);</span><br><span class="line">             &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         *(uint64_t *)buffer = <span class="keyword">self</span> &gt;&gt; <span class="number">8</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (length &lt;= index) &#123;</span><br><span class="line">             rbx = r8;</span><br><span class="line">             ___CFExceptionProem(<span class="keyword">self</span>, _cmd);</span><br><span class="line">             [<span class="built_in">NSException</span> raise:<span class="string">@"NSRangeException"</span> format:<span class="string">@"%@: Index %lu out of bounds; string length %lu"</span>];</span><br><span class="line">             r8 = rbx;</span><br><span class="line">     &#125;</span><br><span class="line">     rax = buffer[index];</span><br><span class="line">     <span class="keyword">return</span> rax;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>现在，我们能看出些端倪了。</p><p>首先可以看到基于长度的不同，会有三种不同的情况。长度小于 8 的情况下，会执行到刚刚我们补充的遗漏分支 —— 单纯地把 <code>self</code> 的值按位移动后赋给 <code>buffer</code>。这是简单 ASCII 的情况。在此情况下，<code>index</code> 只作为 <code>self</code> 的索引值来取出给定字节，并随后返回给调用方。由于 ASCII 字符的值在指定范围内可以匹配 Unicode 码位。因此不需要额外的操作便可以返回正确结果。我们在上文曾猜测这种情况下（长度小于 8）会直接存放 ASCII 码，这也验证了我们的猜想。</p><p>那么在长度大于或等于 8 的情况下会怎么样呢？如果字符串长度等于 8 或大于 8 且小于 10，那么会执行一段循环代码：首先取出 <code>stringData</code> 的最低 6 位，然后作为 <code>table</code> 的索引并取出相应的值，再拷贝到 <code>buffer</code> 中。接下来，会把 <code>stringData</code> 右移 6 位然后重复上面的操作直到遍历完整个字符串。这段代码其实是一种 6 位编码方式 —— 通过原始 6 位数据在 <code>table</code> 中的索引进行编码。<code>buffer</code> 中会构建出一个临时的字符串，然后最后的索引操作（上面函数中倒数第二行）会取出其需要的字符。</p><p>当如果长度大于 10 呢？可以看到其代码和长度在 8 到 10 的情况下基本一致，除了现在一次只处理 5 位而不是 6 位数据。这是一种更加紧凑的编码方式，可以让 tagged pointer 字符串最多能够保存 11 个字符，不过它使用的字母表仅包含 32 个值（仅使用了 <code>table</code> 的前半部分）。</p><p>因此，我们可以得到 tagged pointer 字符串的结构大致为：</p><ol><li>长度在 0 到 7 范围内时，直接保存原始的 8 位字符。</li><li>长度为 8 或者 9时， 保存 6 位编码后的字符，编码使用的字母表为 <code>&quot;eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX&quot;</code>。 </li><li>长度大于 10 时，保存 5 位编码后的字符，编码使用的字母表为 <code>&quot;eilotrm.apdnsIc ufkMShjTRxgC4013&quot;</code>。 </li></ol><p>现在我们来对比一下前面生成的数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000000000006115 a NSTaggedPointerString</span><br><span class="line">0x0000000000626125 ab NSTaggedPointerString</span><br><span class="line">0x0000000063626135 abc NSTaggedPointerString</span><br><span class="line">0x0000006463626145 abcd NSTaggedPointerString</span><br><span class="line">0x0000656463626155 abcde NSTaggedPointerString</span><br><span class="line">0x0066656463626165 abcdef NSTaggedPointerString</span><br><span class="line">0x6766656463626175 abcdefg NSTaggedPointerString</span><br><span class="line">0x0022038a01169585 abcdefgh NSTaggedPointerString</span><br><span class="line">0x0880e28045a54195 abcdefghi NSTaggedPointerString</span><br><span class="line">0x00007fbad9512010 abcdefghij __NSCFString</span><br></pre></td></tr></table></figure><p><code>0x0022038a01169585</code> 的二进制表达式去掉了字符串后面的 8 位，并把剩余的位分成了 6 位为单位的块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">001000 100000 001110 001010 000000 010001 011010 010101</span><br></pre></td></tr></table></figure><p>以这些数值作为 <code>table</code> 的索引，我们的确可以拼出 <code>&quot;abcdefgh&quot;</code>。同样的，<code>0x0880e28045a54195</code> 的二进制表达式也有类似的规则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">001000 100000 001110 001010 000000 010001 011010 010101 000001</span><br></pre></td></tr></table></figure><p>可以看到它与上面的字符串基本一致，只是在最后多出了字符 <code>i</code>。</p><p>但是后面的字符串却不符合我们的预测。在这之后，按理来说本应会切换为 5 位编码方式进行存储，且在两个字符串之后才会终止。但事实却是，在长度等于 10 的时候 tagged pointer 字符串就已经停止了工作，并转为创建真正的字符串对象，为什么会这样？</p><p>原因是 5 位编码方式中使用的字母表过于受限，因此没有包含字母 <code>b</code>！相对于 5 位编码方式使用的字母表中 32 个 “神圣” 的字符而言，<code>b</code> 这个字母的普遍程度肯定还不够，以至于未能取得其中的一席之地。既然如此，我们换成从 <code>c</code> 开始的字符串再尝试一次，打印结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000000000006315 c NSTaggedPointerString</span><br><span class="line">0x0000000000646325 cd NSTaggedPointerString</span><br><span class="line">0x0000000065646335 cde NSTaggedPointerString</span><br><span class="line">0x0000006665646345 cdef NSTaggedPointerString</span><br><span class="line">0x0000676665646355 cdefg NSTaggedPointerString</span><br><span class="line">0x0068676665646365 cdefgh NSTaggedPointerString</span><br><span class="line">0x6968676665646375 cdefghi NSTaggedPointerString</span><br><span class="line">0x0038a01169505685 cdefghij NSTaggedPointerString</span><br><span class="line">0x0e28045a54159295 cdefghijk NSTaggedPointerString</span><br><span class="line">0x01ca047550da42a5 cdefghijkl NSTaggedPointerString</span><br><span class="line">0x39408eaa1b4846b5 cdefghijklm NSTaggedPointerString</span><br><span class="line">0x00007fbd6a511760 cdefghijklmn __NSCFString</span><br></pre></td></tr></table></figure><p>现在，我们获得了一直到长度为 11 的所有 tagged pointer 字符串。最后两个 tagged pointer 字符串的二进制表示如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01110 01010 00000 10001 11010 10101 00001 10110 10010 00010</span><br><span class="line">01110 01010 00000 10001 11010 10101 00001 10110 10010 00010 00110</span><br></pre></td></tr></table></figure><p>正是我们预期的 5 位编码。</p><h2 id="构造-Tagged-Pointer-字符串"><a href="#构造-Tagged-Pointer-字符串" class="headerlink" title="构造 Tagged Pointer 字符串"></a>构造 Tagged Pointer 字符串</h2><p>既然我们现在知道了 tagged pointer 字符串是如何编码的，那么我就不再深入地探究其构造方法的实现了。构造的代码在一个名为 <code>__CFStringCreateImmutableFunnel3</code> 的私有函数内。这个巨大的函数包含了所有可能的情况。你可以在 <a href="https://opensource.apple.com" target="_blank" rel="noopener">opensource.apple.com</a> 中提供的 CoreFoundation 开源版本中找到此函数，不过别高兴太早：开源版本并没有包含关于 tagged pointer 字符串的代码实现。</p><p>构造 tagged pointer 字符串的代码实际上是我们上面看到的代码的相反版本。如果 tagged pointer 字符串能够容下原始字符串的长度和内容，那么就会开始一点一点地构造 —— 包含 ASCII 字符、6 位或者 5 位编码的字符。其中会有一个相反的查找表。上文代码中看到的字符常量的查找表是一个名为 <code>sixBitToCharLookup</code> 的全局变量，在 <code>Funnel3</code> 函数中有一个与之相对应的 <code>sixBitToCharLookup</code> 变量。</p><h2 id="奇怪的查找表"><a href="#奇怪的查找表" class="headerlink" title="奇怪的查找表"></a>奇怪的查找表</h2><p>完整的 6 位编码查找表如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX</span><br></pre></td></tr></table></figure><p>可能大家都会很自然地问一个问题：为什么它的顺序如此奇怪？</p><p>因为这个表同时提供给 6 位编码和 5 位编码使用，这就是为什么它和普通的英语字母表有同样的顺序。那些使用频率非常高的字符位于表的前半段，而那些使用频率没那么高的字符串就会放在后半段。这在最大程度上保证了稍长的字符串能够使用 5 位编码。</p><p>虽然如此，假如我们把查找表对半分，每一半中的顺序仿佛显得无关紧要。对半分后的表按理来说可以按照英语字母表的顺序进行排序，但事实却并非如此。</p><p>查找表开头位置的几个字母似乎是按照其在英语中出现的频率排序的。英语中最常见的字母是 E，其实是 T，接下来依次为 A、O、I、N 和 S。E 确实位于表的开头，且剩下的几个字母也的确都位于靠近开头的位置。看起来这张查找表的确是按照使用频率进行排序的。至于其为什么体现出和英语的差异性，大概是因为在 Cocoa 应用中的短字符串并不是随机选自英文散文，而是一些较为特别的语言。</p><p>我猜测苹果原本打算使用一种更为巧妙的变长编码方式，或许会基于一种 <a href="https://en.wikipedia.org/wiki/Huffman_coding" target="_blank" rel="noopener">Huffman 编码</a>。但最后发现其实现难度太大，或者性价比并没有想象中高，甚至是因为时间不允许的原因。因此他们决定退而求其次，使用一种更容易实现的版本，也就是我们上文中所看到的编码方式 —— 针对不同长度的字符串使用不同的定长编码方式（每个字符 8 位、6 位或 5 位）。这个奇怪的查找表也许是基于被遗弃的变长编码方式而构建的，同时也便于日后决定再次启用变长编码方式。虽然这些纯属猜测，但至少我感觉事实便是如此。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Tagged pointer 是一种非常酷的技术。虽然应用到字符串上面并不常见，但很清楚的是，苹果肯定从中受益良多，不然也不会对它倾注如此多精力和想法。能够看到这两种技术融合在一起的效果，以及它们如何对有限的存储空间物尽其用，实在是有趣至极。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Tagged pointer 是一项用于提高性能并减少内存使用的有趣技术，本文探讨了 NSString 中应用 tagged pointer 的实现原理。
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
      <category term="Objective-C" scheme="https://swift.gg/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>拓展 Swift 应用领域</title>
    <link href="https://swift.gg/2018/10/04/expanding-swifts-reach/"/>
    <id>https://swift.gg/2018/10/04/expanding-swifts-reach/</id>
    <published>2018-10-04T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：terhechte，<a href="http://appventure.me/2018/05/03/expanding-swifts-reach/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-05-03<br>译者：<a href="https://github.com/Adolf-L" target="_blank" rel="noopener">BigLuo</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>我想大家应该都会同意 Swift 是一门优秀的语言，很好的处理了那些简单与复杂的问题。理论上讲，它将会成为重要的编程语言之一。目前，Swift 的使用仅限于苹果开发领域（外加少量服务端 Swift 以及近期宣布的 <a href="https://www.tensorflow.org/community/swift" target="_blank" rel="noopener">Swift 版本的 Tensorflow</a>）。</p><blockquote><p>“My goal for Swift has always been and still is total world domination. It’s a modest goal”</p><p>“我一直期待着 Swift 统治世界，这是一个谦虚的目标。”</p><ul><li>Chris Lattner</li></ul></blockquote><p>随着新的泛型特性在 Swift 4.1 中推出以及 <a href="https://swift.org/abi-stability/" target="_blank" rel="noopener">ABI 在 Swift 5 中逐渐稳定</a>，Swift 似乎逐渐具备了跳出苹果开发领域的条件。本文我会讨论一个我知道的问题，它阻碍着 Swift 广泛的应用，准确的讲，与其它问题一样，该问题也正在被开发社区着手解决。</p><a id="more"></a><p>我会简单介绍 Swift 在这个领域的<strong>竞争力</strong>。就像 C++ 一样，其它编程语言也渴望成为一个跨平台的通用的语言。通过比较 Swift 和其他语言处理相同问题上的方式，可以让我们该如何改进 Swift。</p><h2 id="系统包管理"><a href="#系统包管理" class="headerlink" title="系统包管理"></a>系统包管理</h2><p>Swift 拥有一个非常健康的开源社区，拥有大量杰出、精心编写且实用的开发框架。但是，这些开发框架多为 iOS（macOS 相对少很多）UI 库，这让 Swift 受限在这个开发领域。这里有很多 UI 动画库、UI 布局库、含有 UI 元素的框架、UI 协作库和 JSON 解析库。因为缺少 UIKit/AppKit，它们中的大部分无法在 Linux 上运行。当然，这里也有一些类似于 <a href="https://vapor.codes/" target="_blank" rel="noopener">Vapor</a> 或 <a href="http://kitura.io/" target="_blank" rel="noopener">Kitura</a> 的 Web 框架，致力于在 Web 开发领域推广使用 Swift 语言。</p><p>然而，与大众观点不同，在 Linux 平台上，很多公司不仅在 Web 服务端，也在 Linux 的其它方面做了大量的工作。先简单举个例子，有些编程语言可以管理系统，掌控系统权限，并且提供相应的开发工具和库。这些内容虽然和 iOS 或者 macOS 应用开发没有相关联，但是对于系统或者 Web 开发来说极其重要。比如，数据库权限、系统文件管理、进程管理、日志分析与收集、容器管理、部署工具、甚至区块链工具。</p><p>随着 Swift 4.1 的发布，在 <a href="https://news.ycombinator.com/item?id=16710895" target="_blank" rel="noopener">Hacker News 上有一个讨论这门语言的帖子</a>。我完整通读多次后，觉得回复很有趣。让我感触最深的是下面的评论：</p><blockquote><p>“相比 Go 和 Rust 在系统支持和库的量级方面，Swift 的系列库只有一小点儿……如果我们列出其它编程语言在已发布的应用、数据库后端方面库的贡献，Swift 的数量基本可以忽略不计”</p></blockquote><p>让我们来看看这些竞争对手。</p><h2 id="竞争者"><a href="#竞争者" class="headerlink" title="竞争者"></a>竞争者</h2><p>在最近几年，编程语言领域出现了几个新的有力的竞争者。当然，你也许并不同意这些语言是 Swift 的合格竞争者。这里仅根据我个人的感觉列举出几个编程语言，排名不分先后。</p><p>这些看法可能并不准确。请不要因为你是某个语言的粉丝，并认为我的说法存在错误，就把他们分享到 Twitter。我只是一个有着某些观点的普通人，而这些观点确实含有一些错误。相反，我们可以利用这些精力来追问问题原由，并改善或解决问题本身。</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Go 的发布时间比 Swift 早很多，它多用于开发系统工具，却很少在图形界面中使用。Go 不支持现代语言特性，如标签联合、泛型，或函数式编程。但它易上手，速度快，并使用了垃圾回收器，生成的二进制文件使得其内存消耗非常低。当然，垃圾回收器也使得 Go 在嵌入式开发和使用 Webassembly 变得有点棘手。</p><p>Go 良好的性能，语言的简单性和低内存占用率催生出了大量的系统工具和库。如：Grafana、Kubernetes、CoreOS-etcd、Go-Ethereum、CockroachDB、Hub、Terraform 等等。<a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">通过这个列表，我们可以看到一个问题的多种解法</a>。</p><p>简言之，如果你想做基于系统层面的开发，你能找到几乎所有你想要的依赖包。</p><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>Kotlin 像是 Android 版本下的 Swift，但其底层却完全不同。基于 JVM 的 Kotlin 使得它必须大量使用引用类型，就像 Go 的垃圾回收器使其在嵌入式系统的开发成为一个挑战。然而，<a href="https://kotlinlang.org/docs/reference/native-overview.html" target="_blank" rel="noopener">Kotlin-Native 的出现让它在未来有了更多的可能性</a>。Kotlin-Native 是基于 LLVM 构建的，支持嵌入式平台开发、Webassembly 等。Kotlin 也能被编译成 Javascript，Kotlin-Native 甚至可用于构建 iOS 应用的框架。</p><p>Kotlin 也可能会成为未来的一个主流语言，但和有着相同问题的 Swift 一样，其发展遇到了类似的阻碍。几乎所有可用的开源库集中在 Android 开发领域。而 Kotlin-Native 解决的是一个纯粹 JVM 语言所面临的问题。我不知道一个易于执行且轻量级的 Kotlin-Native 要如何实现（相比于 C++ 或 Swift，尤其是在嵌入式开发、复杂系统开发、或 Webassembly）。</p><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><p>Rust 是一个有趣的语言。事实上它是如此的有趣，我花了几个月的时间慢慢的学习它。这门语言的很多方面与 Swift 相似，但比 Swift 更难（这里我们暂不做讨论，该部分内容将以主题的形式发布在博客）。似乎这两种语言一开始就是采用完全相反的设计思路；Swift 作为一个易学的语言起初是一些容易上手的特性，慢慢的添加复杂的特性。Rust 起初作为一门复杂的语言，它正在慢慢的增添一些更简单的抽象对象或更好的错误调试信息来让初学者容易上手。两种语言语法类似，这点我并不惊讶，直到未来的突然某天，我意识到两门语言在某些简单和复杂特性上有着高度的相似性。然而，目前而言，在你经历一段复杂学习体验的后，便会发现 Rust 背后有提供了一些非常诱人的特性。</p><p>相对于 Swift，Rust 提供了更好的跨平台特性和一个虽难于处理但更高效的内存管理策略（比如在对象的生命周期和所有权方面），<a href="https://github.com/apple/swift/blob/master/docs/OwnershipManifesto.md" target="_blank" rel="noopener">幸运的是，Rust 的一部分内存管理的优点未来也会在 Swift 上出现</a>，同时它也支持 <a href="https://rust-lang-nursery.github.io/rust-wasm/" target="_blank" rel="noopener">Webassembly</a>（你可以用 Rust 写一个前端 App），也提供了很好的基础库让开发者能够快速的构建新项目，虽然它没有提供像 Go 一样数量级的高质量项目，但它也提供了一些有潜力的项目（CoreUtils，RedoxOS，TikV，Vagga，Servo，Parity）。但更重要的，现在已经有大量的 Rust 第三方库供你选择。<a href="https://github.com/rust-unofficial/awesome-rust" target="_blank" rel="noopener">你可以来看看看下这个列表。</a></p><h3 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h3><p>这里还有像 D，Nim、Chrystal、Elixir、TypeScript 等语言，当然也包括 C++ 自身。</p><h2 id="我们看到了什么"><a href="#我们看到了什么" class="headerlink" title="我们看到了什么"></a>我们看到了什么</h2><p>目前 Swift 在系统包管理领域有短板，这也是一个先有鸡还有先有蛋的问题。</p><blockquote><p>“因为没有足够多的系统包，导致那些对 Swift 感兴趣的开发者在开发简单 Demo 应用时数据库处理不方便，从而对 Swift 失去兴趣，对 Swift 失去兴趣的开发者更不愿意去改善包管理了。”</p></blockquote><p>对我而言，我们需要改进我们的系统包/库。如果我们能用 Swift 写出 Kubernets 之类的东西，那一定很棒。为了实现这个项目，我们需要一套好的基础库用于一般性的系统开发。下面我列出了基础的功能库和相关三方服务（此外，下面列出的功能，已经存在部分，不需要我们重复造轮子）。</p><ul><li>认证</li><li>缓存</li><li>并发</li><li>云服务</li><li>命令行参数解析</li><li>命令行 UI</li><li>命令行编辑器</li><li>压缩</li><li>计算（例如：BLAS）</li><li>加密</li><li>数据库</li><li>数据处理</li><li>数据结构</li><li>数据可视化</li><li>日期和时间</li><li>分布式系统</li><li>电子邮件</li><li>编码和解码</li><li>文件系统</li><li>图像处理</li><li>机器学习</li><li>解析</li><li>文本处理</li><li>虚拟化</li></ul><p>我认为，让 Swift 成为一门通用的语言，能够在非苹果操作系统上运行，Swift 需要提供一个健壮的、跨平台的包管理系统。</p><h2 id="你能做些什么？"><a href="#你能做些什么？" class="headerlink" title="你能做些什么？"></a>你能做些什么？</h2><h3 id="写库"><a href="#写库" class="headerlink" title="写库"></a>写库</h3><p>在你决定写 JSON 解析器，动画库、自定义的开关按钮，或者抽象的集合视图/表格视图的代码之前，考虑写一个跨平台的系统库。如果你不知道怎么做，你可以去看看 Go 和 Rust 提供的那些已有的库。</p><h3 id="重写现有-C-库"><a href="#重写现有-C-库" class="headerlink" title="重写现有 C 库"></a>重写现有 C 库</h3><p>对于某些场景，Swift 的确提供了库，但那些库底层仍然是 C 的实现。虽然那样也搞定了问题，但在混合的过程中引入了 C 这门不安全的语言，在那些要求绝对安全的执行案例中，我们必须要为此做特别处理。当然，如果你想不到你想要写什么，可以用纯 Swift 实现一个你使用过的东西。这也是一个好机会，学习更多的 C 的同时进而爱上 Swift。</p><h3 id="关心-Linux"><a href="#关心-Linux" class="headerlink" title="关心 Linux"></a>关心 Linux</h3><p>我最近用 Vapor 写了一个小应用，需要为它添加几个依赖库（比如：时间计数器）但大部分的现有的库只支持 iOS/macOS。 假如你有处理跨平台（由于没有 UIKit/AppKit 的依赖）的经验，可以尝试在 Linux 上测试编译 Swift。</p><p>这比听上去更简单。这里有一个可用的 <a href="https://hub.docker.com/r/ibmcom/swift-ubuntu/tags/" target="_blank" rel="noopener">Swift 4.1 版本的 docker 镜像</a>，你可以直接运行它来测试你的代码，或者选择通过 <a href="https://www.virtualbox.org/" target="_blank" rel="noopener">Virtualbox</a> 虚拟机来运行它。</p><h3 id="Swift-包管理的支持"><a href="#Swift-包管理的支持" class="headerlink" title="Swift 包管理的支持"></a>Swift 包管理的支持</h3><p>如果你已经有了一个库，除了支持 CocoaPods 和 Carthage 外，请尝试支持 Swift Package Manager。</p><h3 id="运行在-Foundation-库上"><a href="#运行在-Foundation-库上" class="headerlink" title="运行在 Foundation 库上"></a>运行在 Foundation 库上</h3><p>另一件依旧困难的事情是 Swift 在 Linux 的 <a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="noopener">Foundation 库</a> 是基于 iOS/macOS Foundation 库的二次实现，因此依旧存在些没有实现的特性和（特别棘手）bugs。这意味着也许你写在 Mac 上面的代码在 Xcode 中跑的很好，但由于 Linux Foundation 库的 bug，它运行在 Linux 上时可能会崩溃。为了拓展 Swift 的应用领域，让 Linux 上面的 Fundation 库代码变得更加健壮是一个很好的目标。</p><p>最简单的开始方式是去 <a href="https://bugs.swift.org/secure/Dashboard.jspa" target="_blank" rel="noopener">Swift Jira</a> 的首页搜索 Foundation bugs。</p><h3 id="帮助改进-Foundation-库"><a href="#帮助改进-Foundation-库" class="headerlink" title="帮助改进 Foundation 库"></a>帮助改进 Foundation 库</h3><p>如果你没有时间或者对在 Swift Foundation 上的工作内容不感兴趣。你也可以在 Linux 上使用或者测试 Foundation 库，并且提交 bug 报告。只要有越来越多的人使用它，它也将变得更加稳定。</p><h3 id="帮助改善-Linux-编辑体验"><a href="#帮助改善-Linux-编辑体验" class="headerlink" title="帮助改善 Linux 编辑体验"></a>帮助改善 Linux 编辑体验</h3><p>Linux 用户没有 Xcode，所以他们使用 Atom、Emacs、Vim 或 VSCode。这里已经有多个项目来让这些编辑器支持 Swift 语言编辑。但我们也许能够改进它们。如果你有空闲时间，用你喜欢的编辑器参与到这些项目中来，进行测试提交问题或解决这些问题。</p><h3 id="参加在-San-Jose-举办的-Try-Swift-大会"><a href="#参加在-San-Jose-举办的-Try-Swift-大会" class="headerlink" title="参加在 San Jose 举办的 Try Swift 大会"></a>参加在 San Jose 举办的 Try Swift 大会</h3><p>如果你恰好在 San Jose 参加今年的 WWDC。这是一个很好的学习机会。 你会遇见一些有趣的人，<a href="https://www.tryswift.co/events/2018/sanjose/" target="_blank" rel="noopener">尝试参加在 San Jose 举办的 Try Swift 大会</a>。 </p><blockquote><p>“你有机会为 Swift 做出贡献。加入一个 Swift 开源贡献者小组，讨论有关 Swift 开源项目的最新消息，然后在社区导师的帮助下为 Swift Evolution 做出自己贡献！”</p></blockquote><p><a href="https://www.tryswift.co/events/2018/sanjose/" target="_blank" rel="noopener">你可以查阅这个链接</a></p><h3 id="举手之劳"><a href="#举手之劳" class="headerlink" title="举手之劳"></a>举手之劳</h3><p>在过去的一年半里，我没有太多时间做任何关于开源的工作，因为我一直忙于自己的（闭源）项目，但我真想再次为 Swift 开源代码贡献。我真的很喜欢 Swift，这是一个很棒的语言，帮助它成功的那些日子，是我曾感到最美妙的时光，如果你有同样的感觉，请分享这篇文章。</p><p><a href="https://twitter.com/terhechte" target="_blank" rel="noopener">如果对文章内容有想法的话，欢迎来 Twitter 上一起讨论</a></p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：terhechte，&lt;a href=&quot;http://appventure.me/2018/05/03/expanding-swifts-reach/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-05-03&lt;br&gt;译者：&lt;a href=&quot;https://github.com/Adolf-L&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigLuo&lt;/a&gt;；校对：&lt;a href=&quot;https://github.com/Cee&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cee&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;我想大家应该都会同意 Swift 是一门优秀的语言，很好的处理了那些简单与复杂的问题。理论上讲，它将会成为重要的编程语言之一。目前，Swift 的使用仅限于苹果开发领域（外加少量服务端 Swift 以及近期宣布的 &lt;a href=&quot;https://www.tensorflow.org/community/swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift 版本的 Tensorflow&lt;/a&gt;）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“My goal for Swift has always been and still is total world domination. It’s a modest goal”&lt;/p&gt;
&lt;p&gt;“我一直期待着 Swift 统治世界，这是一个谦虚的目标。”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Chris Lattner&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着新的泛型特性在 Swift 4.1 中推出以及 &lt;a href=&quot;https://swift.org/abi-stability/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ABI 在 Swift 5 中逐渐稳定&lt;/a&gt;，Swift 似乎逐渐具备了跳出苹果开发领域的条件。本文我会讨论一个我知道的问题，它阻碍着 Swift 广泛的应用，准确的讲，与其它问题一样，该问题也正在被开发社区着手解决。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Hashable / Hasher</title>
    <link href="https://swift.gg/2018/10/01/hashable_hahser/"/>
    <id>https://swift.gg/2018/10/01/hashable_hahser/</id>
    <published>2018-10-01T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/hashable/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-08-13<br>译者：<a href="https://github.com/Damonvvong" target="_blank" rel="noopener">Damonwong</a>；校对：<a href="https://lision.me/" target="_blank" rel="noopener">Lision</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>当你在苹果商店预约天才吧服务后，相关工作人员会帮你登记并且安排特定的服务时间，在被带到座位上之后，工作人员会记录你的身份信息并添加到服务队列当中。</p><p>根据一份来自零售店某位前员工的报告表示，对于顾客的描述有着严格的指导方针。他们的外貌特征如：年龄、性别、种族、身高都没有被使用 —— 甚至连头发的颜色都没有被使用。而是通过顾客的着装来描述，例如“黑色的高领毛衣，牛仔裤和眼镜”。</p><p>这种描述顾客的方式和编程中的哈希函数有很多共同之处。同许多优秀的哈希函数一样，它是连续和易计算的，可用于快速找到你正在寻找的内容（或者人）。我想你肯定也觉得这样比队列要好用多了。</p><p>这周我们的主题是 <code>Hashable</code> 和相关的新类型 <code>Hasher</code>。它们共同组成了 Swift 最受喜爱的两个集合类 <code>Dictionary</code> 和 <code>Set</code> 的基础功能。</p><a id="more"></a><p>假设你有一个可以比较相等性的对象<strong><a href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E5%88%97_(%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5" target="_blank" rel="noopener">列表</a>)</strong>。要在这个列表中找到一个特定的对象，你需要遍历这个列表的元素，直到找到匹配项为止。随着你向列表中添加更多的元素时，需要找到其中任何一个元素所需的平均时间是线性级的(<code>O(n)</code>)。</p><p>如果将这些对象存储在一个<strong><a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">集合</a>)</strong>中，理论上可以在常量级时间(<code>O(1)</code>)内找到它们中的任何一个 - 也就是说，在一个包含 10 个元素的集合中查找或在一个包含 10000<sup>*</sup> 个元素的集合中查找所需的时间是一样的。这是怎么回事呢？因为集合不是按顺序存储对象的，而是将对象内容计算的<dfn>哈希值</dfn>作为索引存储。当在集合中查找对象时，可以使用相同的哈希函数计算新的哈希值然后查找对象存储位置。</p><p><sup>*</sup> 如果两个不同的对象具有相同的哈希值时，会产生<dfn>哈希冲突</dfn>。当发生哈希冲突时，它们将存储在该地址对应的列表中。对象之间发生冲突的概率越高，哈希集合的性能就会更加线性增长。</p><h2 id="Hashable"><a href="#Hashable" class="headerlink" title="Hashable"></a>Hashable</h2><p>在 Swift 中，<code>Array</code> 为列表提供了标准的接⼝，<code>Set</code> 为集合提供了标准的接⼝。如果要将对象存储到 <code>Set</code> 中，就要遵循 <code>Hashable</code> 协议及其扩展协议 <code>Equatable</code>。Swift 的标准映射接口 <code>Dictionary</code> 对它的关联类型 <code>Key</code> 也需要遵循 <code>Hashable</code> 协议及其扩展协议。</p><p>在 Swift 之前的版本中，为了让自定义类型能支持 <code>Set</code> 或 <code>Dictionary</code> 存储需要写⼤量的 <a href="https://nshipster.cn/swift-gyb/" target="_blank" rel="noopener">样板代码</a>。</p><p>以下面的 <code>Color</code> 类型为例，<code>Color</code> 使⽤了 8 位整型值来表示红，绿，蓝色值:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> red: <span class="type">UInt8</span></span><br><span class="line">    <span class="keyword">let</span> green: <span class="type">UInt8</span></span><br><span class="line">    <span class="keyword">let</span> blue: <span class="type">UInt8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要符合 <code>Equatable</code> 的要求，你需要提供一个 == 操作符的实现。要符合 <code>Hashable</code> 的要求，你需要提供⼀个名为 <code>hashValue</code> 的计算属性:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &lt; 4.1</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Color</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Color, rhs: Color)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.red == rhs.red &amp;&amp;</span><br><span class="line">               lhs.green == rhs.green &amp;&amp;</span><br><span class="line">               lhs.blue == rhs.blue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Color</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.red.hashValue ^</span><br><span class="line">               <span class="keyword">self</span>.green.hashValue ^</span><br><span class="line">               <span class="keyword">self</span>.blue.hashValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于大多数开发者⽽⾔，实现 <code>Hashable</code> 只是为了能尽快让要做的事情步入正轨，因此他们会对所有的存储属性使⽤<a href="https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96" target="_blank" rel="noopener">逻辑异或</a>操作，并在某一天调用它。</p><p>然⽽这种实现的一个缺陷是高哈希冲突率。由于逻辑异或满⾜<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E6%8F%9B%E5%BE%8B" target="_blank" rel="noopener">交换率</a>，像⻘色和⻩色这样不同的颜色也会发⽣哈希冲突:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &lt; 4.2</span></span><br><span class="line"><span class="keyword">let</span> cyan = <span class="type">Color</span>(red: <span class="number">0x00</span>, green: <span class="number">0xFF</span>, blue: <span class="number">0xFF</span>)</span><br><span class="line"><span class="keyword">let</span> yellow = <span class="type">Color</span>(red: <span class="number">0xFF</span>, green: <span class="number">0xFF</span>, blue: <span class="number">0x00</span>)</span><br><span class="line"></span><br><span class="line">cyan.hashValue == yellow.hashValue <span class="comment">// true, collision</span></span><br></pre></td></tr></table></figure><p>大多数时候这样做不会出问题；现代计算机已经足够强大以至于你很难意识到性能的衰减，除⾮你的实现细节存在⼤量问题。</p><p>但这并不是说这些细节⽆关紧要 —— 它们往往极其重要。稍后会详细介绍。</p><h2 id="自动合成-Hashable-实现"><a href="#自动合成-Hashable-实现" class="headerlink" title="自动合成 Hashable 实现"></a>自动合成 Hashable 实现</h2><p>从 Swift 4.1 开始，如果某个类型在声明时遵循了 <code>Equatable</code> 和 <code>Hashable</code> 协议并且它的成员变量同时也满足了这些协议，编译器会为其自动合成 <code>Equatable</code> 和 <code>Hashable</code> 的实现。</p><p>除了大大的提高了开发人员的开发效率以外，还可以大幅减少代码的数量。比如，我们之前 <code>Color</code> 的例子 —— 现在是最开始代码量的 1/3 :</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &gt;= 4.1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> red: <span class="type">UInt8</span></span><br><span class="line">    <span class="keyword">let</span> green: <span class="type">UInt8</span></span><br><span class="line">    <span class="keyword">let</span> blue: <span class="type">UInt8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管对语言进行了明显的改进，但还是有一些实现细节有着无法忽视的问题。</p><p>在 Swift Evolution 提案 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0185-synthesize-equatable-hashable.md" target="_blank" rel="noopener">SE-0185: 合成 <code>Equatable</code> 和 <code>Hashable</code> 的实现</a> 中， <a href="https://github.com/allevato" target="_blank" rel="noopener">Tony Allevato</a> 给哈希函数提供了这个注释: </p><blockquote><p>哈希函数的选择应该作为实现细节，而不是设计中的固定部分；因此，使用者不应该依赖于编译器自动生成的 Hashable 函数的具体特征。最可能的实现是在每个成员的哈希值上调用标准库中的 <code>_mixInt</code> 函数，然后将他们逻辑异或（^），如同目前 <code>Collection</code> 类型的哈希方式一样。</p></blockquote><p>幸运的是，Swift 不需要多久就能解决这个问题。我们将在下一个版本得到答案:</p><h2 id="Hasher"><a href="#Hasher" class="headerlink" title="Hasher"></a>Hasher</h2><p>Swift 4.2 通过引入 <code>Hasher</code> 类型并采用新的通用哈希函数进一步优化 <code>Hashable</code></p><p>在 Swift Evolution 提案 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0206-hashable-enhancements.md" target="_blank" rel="noopener">SE-0206: Hashable 增强</a> 中：</p><blockquote><p>使用一个好的哈希函数时，简单的查找，插入，删除操作都只需要常量级时间即可完成。然而，如果没有为当前数据选择一个合适的哈希函数，这些操作的预期时间就会和哈希表中存储的数据数量成正比。</p></blockquote><p>正如 <a href="https://github.com/lorentey" target="_blank" rel="noopener">Karoy Lorentey</a> 和 <a href="https://github.com/regexident" target="_blank" rel="noopener">Vincent Esche</a> 所指出的那样，<code>Set</code> 和 <code>Dictionary</code> 等基于哈希的集合主要特点是它们能够在常量级时间内查找值。如果哈希函数不能产生一个均匀的值分布，这些集合实际上就变成了链表。</p><p>Swift 4.2 中的哈希函数是基于伪随机函数族 <a href="https://en.wikipedia.org/wiki/SipHash" target="_blank" rel="noopener">SipHash</a> 实现的，比如 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/SipHash.swift" target="_blank" rel="noopener">SipHash-1-3 and SipHash-2-4</a>，分别在每个消息块异或哈希之后执行一次 round + 三次 final round，或两次 round + 四次 final round。(译者注：这里的 round 指的是伪随机数变化。具体实现看 <a href="https://github.com/apple/swift/blob/4967393618f89370269518cf3b5ad5247cb0a2c0/stdlib/public/core/SipHash.swift#L47" target="_blank" rel="noopener"><code>_round</code></a>)</p><p>现在，如果你要自定义类型实现 <code>Hashable</code> 的方式，可以重写 <code>hash(into:)</code> 方法而不是 <code>hashValue</code>。<code>hash(into:)</code> 通过传递了一个 <code>Hasher</code> 引用对象，然后通过这个对象调用 <code>combine(_:)</code> 来添加类型的必要状态信息。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &gt;= 4.2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> red: <span class="type">UInt8</span></span><br><span class="line">    <span class="keyword">let</span> green: <span class="type">UInt8</span></span><br><span class="line">    <span class="keyword">let</span> blue: <span class="type">UInt8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Synthesized by compiler</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">hash</span><span class="params">(into hasher: <span class="keyword">inout</span> Hasher)</span></span> &#123;</span><br><span class="line">        hasher.combine(<span class="keyword">self</span>.red)</span><br><span class="line">        hasher.combine(<span class="keyword">self</span>.green)</span><br><span class="line">        hasher.combine(<span class="keyword">self</span>.blue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default implementation from protocol extension</span></span><br><span class="line">    <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> hasher = <span class="type">Hasher</span>()</span><br><span class="line">        <span class="keyword">self</span>.hash(into: &amp;hasher)</span><br><span class="line">        <span class="keyword">return</span> hasher.finalize()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过抽象隔离底层的位操作细节，开发人员可以利用 Swift 内置的哈希函数，这样可以避免再现我们原有的基于逻辑异或实现的冲突：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &gt;= 4.2</span></span><br><span class="line"><span class="keyword">let</span> cyan = <span class="type">Color</span>(red: <span class="number">0x00</span>, green: <span class="number">0xFF</span>, blue: <span class="number">0xFF</span>)</span><br><span class="line"><span class="keyword">let</span> yellow = <span class="type">Color</span>(red: <span class="number">0xFF</span>, green: <span class="number">0xFF</span>, blue: <span class="number">0x00</span>)</span><br><span class="line"></span><br><span class="line">cyan.hashValue == yellow.hashValue <span class="comment">// false, no collision</span></span><br></pre></td></tr></table></figure><h3 id="自定义哈希函数"><a href="#自定义哈希函数" class="headerlink" title="自定义哈希函数"></a>自定义哈希函数</h3><p>默认情况下，Swift 使用通用的哈希函数将字节序列缩减为一个整数。</p><p>但是，你可以使用你项目中自定义的哈希函数来改进这个缩减的问题。比如，如果你正在编写一个程序来玩国际象棋或者棋盘游戏，你可以使用 <a href="https://en.wikipedia.org/wiki/Zobrist_hashing" target="_blank" rel="noopener">Zobrist hashing</a> 来快速的存储游戏的状态。</p><h3 id="避免哈希泛滥-Hash-Flooding"><a href="#避免哈希泛滥-Hash-Flooding" class="headerlink" title="避免哈希泛滥(Hash-Flooding)"></a>避免哈希泛滥(Hash-Flooding)</h3><p>选择像 SipHash 这样的加密算法有助于防止哈希泛滥的 DoS 攻击，这种攻击会尝试生成哈希冲突，并试图强制实施哈希数据结构最坏的情况，最终导致程序慢下来。<a href="https://arstechnica.com/information-technology/2011/12/huge-portions-of-web-vulnerable-to-hashing-denial-of-service-attack/" target="_blank" rel="noopener">这在 2010 年初引发了一系列的网络问题</a>。</p><p>为了使事情变的更加安全，<code>Hasher</code> 会在每次启动应用程序时生成一个随机种子值，使得哈希值更难以预测。</p><blockquote><p>你不应该依赖特定的哈希值，也不应该在程序执行中保存特定的哈希值。在极少数情况下，你确定要这么做的话，可以设置 SWIFT_DETERMINISTIC_HASHING 标识符来禁用随机哈希种子。</p></blockquote><p>编程类比的挑战在于它们通过边界情况规范反社会行为。</p><p>当我们能够考虑到攻击者所有可能利用来达到某种险恶目的的情况时，这时能体现出我们优秀工程师的品质 —— 比如哈希泛滥的 DoS 攻击。在现实生活中，这么做我们需要冒着失败的风险去应用这些 AFK（Away From Keyboard）知识。</p><p>也就是说…亲爱的读者，我不希望你和你的朋友下次穿一样的衣服去当地苹果商店的天才吧中制造混乱和不和谐。</p><p>请不要这么做。</p><p>相反的，希望你有下面的收获：</p><p>当你在天才吧等候的时候，和穿同样颜色衣服的人站得远一点。这会让每个人做事都变得容易得多。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了 Hashable 和相关的新类型 Hasher
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/Swift/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
      <category term="NSHipster" scheme="https://swift.gg/tags/NSHipster/"/>
    
  </entry>
  
  <entry>
    <title>使用 C-Reduce 进行调试</title>
    <link href="https://swift.gg/2018/09/27/debugging-with-c-reduce/"/>
    <id>https://swift.gg/2018/09/27/debugging-with-c-reduce/</id>
    <published>2018-09-27T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2018-06-29-debugging-with-c-reduce.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-06-29<br>译者：<a href="https://bignerdcoding.com/" target="_blank" rel="noopener">BigNerdCoding</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>调试复杂问题本身就并不轻松，如果还没有足够的上下文和大致方向的话那就是一件非常困难的事。所以对代码进行精简缩小调试范围也就变成了一种常见的行为。不过与繁杂的手动简化相比，执行自动化处理程序明显更容易发挥计算机自身的优势。C-Reduce 正是为此而生，它能自动对原始代码进行简化操作输出一个简化的调试友好版本。下面我们看看如何使用该自动化程序。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>C-Reduce 代码基于两个主要思想。</p><p>首先，C-Reduce 通过删除相关代码行或者将 token 重命名为更短的版本等手段，将某些原始代码转化为一个简化版本。</p><p>其次，对简化结果进行检验测试。上面的代码简化操作是盲目的，因此经常产生不含待跟踪错误甚至是根本无法编译的简化版本。所以在使用 C-Reduce 时，除原始代码外还需要一个用来测试简化操作是否符合特定“预期”的脚本程序。而“预期”的标准则由我们根据实际情况进行设定。例如，如果你想定位到某个 bug 那么“预期”就意味着简化版本包含与原始代码一致的错误。你可以利用脚本程序写出任何你想要的“预期”标准，C-Reduce 会依据该脚本程序确保简化版本符合预先定义的行为。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>C-Reduce 程序的依赖项非常多，安装也很复杂。好在有 Homebrew 的加持，我们只需输入以下命令即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install creduce</span><br></pre></td></tr></table></figure><p>如果你想手动安装的话，可以参照该安装 <a href="https://github.com/csmith-project/creduce/blob/master/INSTALL" target="_blank" rel="noopener">指南</a>。</p><h2 id="简易示例"><a href="#简易示例" class="headerlink" title="简易示例"></a>简易示例</h2><p>想出一个小的示例代码解释 C-Reduce 是很困难的，因为它的主要目的是从一个大的程序简化出一个小型示例。下面是我竭尽全力想出来的一个简单 C 程序代码，它会产生一些难以理解的编译警告。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat test.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">struct Stuff &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(int argc, char **argv) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ clang test.c</span><br><span class="line">test.c:3:1: warning: <span class="built_in">return</span> <span class="built_in">type</span> of <span class="string">'main'</span> is not <span class="string">'int'</span> [-Wmain-return-type]</span><br><span class="line">struct Stuff &#123;</span><br><span class="line">^</span><br><span class="line">test.c:3:1: note: change <span class="built_in">return</span> <span class="built_in">type</span> to <span class="string">'int'</span></span><br><span class="line">struct Stuff &#123;</span><br><span class="line">^~~~~~~~~~~~</span><br><span class="line">int</span><br><span class="line">test.c:10:1: warning: control reaches end of non-void <span class="keyword">function</span> [-Wreturn-type]</span><br><span class="line">&#125;</span><br><span class="line">^</span><br><span class="line">2 warnings generated.</span><br></pre></td></tr></table></figure><p>从警告中我们知道 <code>struct</code> 和 <code>main</code> 代码存在某种问题！至于具体问题是什么，我们可以在简化版本中仔细分析。</p><p>C-Reduce 能轻松的将程序精简到远超我们想象的程度。所以为了控制 C-Reduce 的精简行为确保简化操作符合特定预期，我们将编写一个小的 shell 脚本，编译该段代码并检查警告信息。在该脚本中我们需要匹配编译警告并拒绝任何形式编译错误，同时我们还需要确保输出文件包含 <code>struct Stuff</code>，详细脚本代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">clang test.c &amp;&gt; output.txt</span><br><span class="line">grep error output.txt &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line">grep <span class="string">"warning: return type of 'main' is not 'int'"</span> output.txt &amp;&amp;</span><br><span class="line">grep <span class="string">"struct Stuff"</span> output.txt</span><br></pre></td></tr></table></figure><p>首先，我们对简化代码进行编译并将输出重定向到 <code>output.txt</code>。如果输出文件包含任何 “error” 字眼则立即退出并返回状态码 1。否则脚本将会继续检查输出文本是否包含特定警告信息和文本 <code>struct Stuff</code>。当 <code>grep</code> 同时成功匹配上述两个条件时，会返回状态码 0；否则就退出并返回状态码 1。状态码 0 表示符合预期而状态码 1 则表示简化的代码不符合预期需要重新简化。</p><p>接下来我们运行 C-Reduce 看看效果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ creduce interestingness.sh test.c </span><br><span class="line">===&lt; 4907 &gt;===</span><br><span class="line">running 3 interestingness tests <span class="keyword">in</span> parallel</span><br><span class="line">===&lt; pass_includes :: 0 &gt;===</span><br><span class="line">(14.6 %, 111 bytes)</span><br><span class="line"></span><br><span class="line">...lots of output...</span><br><span class="line"></span><br><span class="line">===&lt; pass_clex :: rename-toks &gt;===</span><br><span class="line">===&lt; pass_clex :: delete-string &gt;===</span><br><span class="line">===&lt; pass_indent :: final &gt;===</span><br><span class="line">(78.5 %, 28 bytes)</span><br><span class="line">===================== <span class="keyword">done</span> ====================</span><br><span class="line"></span><br><span class="line">pass statistics:</span><br><span class="line">  method pass_balanced :: parens-inside worked 1 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_includes :: 0 worked 1 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_blank :: 0 worked 1 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_indent :: final worked 1 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_indent :: regular worked 2 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 3 worked 3 <span class="built_in">times</span> and failed 30 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 8 worked 3 <span class="built_in">times</span> and failed 30 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 10 worked 3 <span class="built_in">times</span> and failed 30 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 6 worked 3 <span class="built_in">times</span> and failed 30 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 2 worked 3 <span class="built_in">times</span> and failed 30 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 4 worked 3 <span class="built_in">times</span> and failed 30 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 0 worked 4 <span class="built_in">times</span> and failed 20 <span class="built_in">times</span></span><br><span class="line">  method pass_balanced :: curly-inside worked 4 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 1 worked 6 <span class="built_in">times</span> and failed 33 <span class="built_in">times</span></span><br><span class="line"></span><br><span class="line"> ******** .../test.c ********</span><br><span class="line"></span><br><span class="line">struct Stuff &#123;</span><br><span class="line">&#125; <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们得到一个符合预期的简化版本，并且会覆盖原始代码文件。所以在使用 C-Reduce 时需要注意这一点！一定要在代码的副本中运行 C-Reduce 进行简化操作，否则可能对原始代码造成不可逆更改。</p><p>该简化版本使代码问题成功暴露了出来：在 <code>struct Stuff</code> 类型声明末尾忘记加分号，另外 <code>main</code> 函数没有明确返回类型。这导致编译器将 <code>struct Stuff</code> 错误的当作了返回类型。而 <code>main</code> 函数必须返回 <code>int</code> 类型，所以编译器发出了警告。</p><h2 id="Xcode-工程"><a href="#Xcode-工程" class="headerlink" title="Xcode 工程"></a>Xcode 工程</h2><p>对于单个文件的简化来说 C-Reduce 非常棒，但是更复杂场景下效果如何呢？我们大多数人都有多个 Xcode 工程，那么如何简化某个 Xcode 工程呢？</p><p>考虑到 C-Reduce 的工作方式，简化 Xcode 工程并不简单。它会将需要简化的文件拷贝到一个目录中，然后运行脚本。这样虽然能够同时运行多个简化任务，但如果需要其他依赖才能让它工作，那么就可能无法简化。好在可以在脚本中运行各种命令，所以可以将项目的其余部分复制到临时目录来解决这个问题。</p><p>我使用 Xcode 创建了一个标准的 Objective-C 语言的 Cocoa 应用，然后对 <code>AppDelegate.m</code> 进行如下修改：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> () </span>&#123;</span><br><span class="line">    <span class="built_in">NSWindow</span> *win;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">NSWindow</span> *window;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidFinishLaunching: (<span class="built_in">NSRect</span>)visibleRect &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Starting up"</span>);</span><br><span class="line">    visibleRect = <span class="built_in">NSInsetRect</span>(visibleRect, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    visibleRect.size.height *= <span class="number">2.0</span>/<span class="number">3.0</span>;</span><br><span class="line">    win = [[<span class="built_in">NSWindow</span> alloc] initWithContentRect: <span class="built_in">NSMakeRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>) styleMask:<span class="built_in">NSWindowStyleMaskTitled</span> backing:<span class="built_in">NSBackingStoreBuffered</span> defer:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line">    [win makeKeyAndOrderFront: <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Off we go"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这段代码会让应用在启动时崩溃：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = EXC_BAD_ACCESS (code=EXC_I386_GPFLT)</span><br><span class="line">  * frame #0: 0x00007fff3ab3bf2d CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 13</span><br></pre></td></tr></table></figure><p>上面的内容并不是一个非常有用的调用栈信息。虽然我们可以通过调试追溯问题，但是这里我们尝试使用 C-Reduce 来进行问题定位。</p><p>这里的 C-Reduce 预期定义将包含更多的内容。首先我们需要给应用设置运行的超时时间。我们会在运行时进行崩溃捕获操作，如果没有发生崩溃则保持应用正常运行直到触发超时处理而退出。下面是一段网上随处可见的 <code>perl</code> 脚本代码：</p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">function timeout() &#123; perl -e <span class="string">'alarm shift; exec @ARGV'</span> <span class="string">"$@"</span>; &#125;</span><br></pre></td></tr></table></figure><p>紧接着我们需要拷贝该工程文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -a ~/Development/creduce-examples/Crasher .</span><br></pre></td></tr></table></figure><p>然后将修改后的 <code>AppDelegate.m</code> 文件拷贝到合适的路径下。（注意：如果文件发现合适简化版本，C-Reduce 会将文件复制回来，所以一定要在这里使用 <code>cp</code> 而不是 <code>mv</code>。使用 <code>mv</code> 会导致一个奇怪的致命错误。）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp AppDelegate.m Crasher/Crasher</span><br></pre></td></tr></table></figure><p>接下来我们切换到 <code>Crasher</code> 目录执行编译命令，并在发生错误时退出。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Crasher</span><br><span class="line">xcodebuild || <span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p>如果编译成功，则运行应用并且设置超时时间。我的系统对编译项进行了设置，所以 <code>xcodebuild</code> 命令会将编译结果存放着本地 <code>build</code> 目录下。因为配置可能存在差异，所以你首先需要自行检查。如果你将配置设为共享构建目录的话，那么需要在命令行中增加 <code>—n 1</code> 来禁用 C-Reduce 的并发构建操作。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timeout 5 ./build/Release/Crasher.app/Contents/MacOS/Crasher</span><br></pre></td></tr></table></figure><p>如果应用发生崩溃的话，那么会返回特定状态码 139 。此时我们需要将其转化为状态码 0 ，其它情形统统返回状态码 1。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ $? -eq 139 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>紧接着，我们运行 C-Reduce：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ creduce interestingness.sh Crasher/AppDelegate.m</span><br><span class="line">...</span><br><span class="line">(78.1 %, 151 bytes)</span><br><span class="line">===================== <span class="keyword">done</span> ====================</span><br><span class="line"></span><br><span class="line">pass statistics:</span><br><span class="line">  method pass_ints :: a worked 1 <span class="built_in">times</span> and failed 2 <span class="built_in">times</span></span><br><span class="line">  method pass_balanced :: curly worked 1 <span class="built_in">times</span> and failed 3 <span class="built_in">times</span></span><br><span class="line">  method pass_clex :: rm-toks-7 worked 1 <span class="built_in">times</span> and failed 74 <span class="built_in">times</span></span><br><span class="line">  method pass_clex :: rename-toks worked 1 <span class="built_in">times</span> and failed 24 <span class="built_in">times</span></span><br><span class="line">  method pass_clex :: delete-string worked 1 <span class="built_in">times</span> and failed 3 <span class="built_in">times</span></span><br><span class="line">  method pass_blank :: 0 worked 1 <span class="built_in">times</span> and failed 1 <span class="built_in">times</span></span><br><span class="line">  method pass_comments :: 0 worked 1 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_indent :: final worked 1 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_indent :: regular worked 2 <span class="built_in">times</span> and failed 0 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 8 worked 3 <span class="built_in">times</span> and failed 43 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 2 worked 3 <span class="built_in">times</span> and failed 43 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 6 worked 3 <span class="built_in">times</span> and failed 43 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 10 worked 3 <span class="built_in">times</span> and failed 43 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 4 worked 3 <span class="built_in">times</span> and failed 43 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 3 worked 3 <span class="built_in">times</span> and failed 43 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 0 worked 4 <span class="built_in">times</span> and failed 23 <span class="built_in">times</span></span><br><span class="line">  method pass_lines :: 1 worked 6 <span class="built_in">times</span> and failed 45 <span class="built_in">times</span></span><br><span class="line"></span><br><span class="line">******** /Users/mikeash/Development/creduce-examples/Crasher/Crasher/AppDelegate.m ********</span><br><span class="line"></span><br><span class="line"><span class="comment">#import "AppDelegate.h"</span></span><br><span class="line">@implementation AppDelegate</span><br><span class="line">- (void)applicationDidFinishLaunching:(NSRect)a &#123;</span><br><span class="line">    a = NSInsetRect(a, 0, 10);</span><br><span class="line">    NSLog(@<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>我们得到一个极其精简的代码。虽然 C-Reduce 没有移除 <code>NSLog</code> 那行代码，但是崩溃看起来并不是它引起的。所以此处导致崩溃的代码只能是 <code>a = NSInsetRect(a, 0, 10);</code> 这行代码。通过检查该行代码的功能和使用到的变量，我们能发现它使用了一个 <code>NSRect</code> 类型的变量而 <code>applicationDidFinishLaunching</code> 函数的入参实际上并不是该类型。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationDidFinishLaunching:(<span class="built_in">NSNotification</span> *)notification;</span><br></pre></td></tr></table></figure><p>因此该崩溃应该是由于类型不匹配导致的错误引起的。</p><p>因为编译工程的耗时远超过单文件而且很多测试示例都会触发超时处理，所以此例中的 C-Reduce 运行时间会比较长。C-Reduce 会在每次运行成功后将精简的文件写回原始文件，所以你可以使用文本编辑器保持文件的打开状态并查看更改结果。另外你可以在合适时时机运行 <code>^C</code> 命令结束 C-Reduce 执行，此时会得到部分精简过的文件。如果有必要你后续可以在此基础上继续进行精简工作。</p><h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><p>如果您使用 Swift 并且也有精简需求时该怎么办呢？从名字上来看，我原本以为 C-Reduce 只适用于 C（也许还包括 C++，因为很多工具都是如此）。</p><p>不过好在，这次我的直觉错了。C-Reduce 确实有一些与 C 相关的特定验证测试，但大部分还是和语言无关的。无论你使用何种语言只要你能写出相关的验证测试，C-Reduce 都能派上用场，虽然效率可能不是很理想。</p><p>下面我们就来试一试。我在 bugs.swift.org 上面找到了一个很好的测试 <a href="https://bugs.swift.org/browse/SR-7354" target="_blank" rel="noopener">用例</a>。不过该崩溃只出现在 Xcode9.3 版本上，而我正好就安装了该版本。下面是该 bug 示例的简易修改版：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crash</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> blah = <span class="type">ProblematicEnum</span>.problematicCase.problematicMethod()</span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"<span class="subst">\(blah)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ProblematicEnum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> first, second, problematicCase</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">problematicMethod</span><span class="params">()</span></span> -&gt; <span class="type">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> someVariable: <span class="type">SomeClass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .first:</span><br><span class="line">        someVariable = <span class="type">SomeClass</span>()</span><br><span class="line">    <span class="keyword">case</span> .second:</span><br><span class="line">        someVariable = <span class="type">SomeClass</span>()</span><br><span class="line">    <span class="keyword">case</span> .problematicCase:</span><br><span class="line">        someVariable = <span class="type">SomeClass</span>(someParameter: <span class="type">NSObject</span>())</span><br><span class="line">        <span class="number">_</span> = <span class="type">NSObject</span>().description</span><br><span class="line">        <span class="keyword">return</span> someVariable <span class="comment">// EXC_BAD_ACCESS (simulator: EXC_I386_GPFLT, device: code=1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="number">_</span> = [someVariable]</span><br><span class="line">    <span class="keyword">return</span> <span class="type">SomeClass</span>(someParameter: <span class="type">NSObject</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">init</span>(someParameter: <span class="type">NSObject</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">crash()</span><br></pre></td></tr></table></figure><p>当我们尝试在启用优化的情况下运行代码时，会出现如下结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swift -O test.swift </span><br><span class="line">&lt;unknown&gt;:0: error: fatal error encountered during compilation; please file a bug report with your project and the crash <span class="built_in">log</span></span><br><span class="line">&lt;unknown&gt;:0: note: Program used external <span class="keyword">function</span> <span class="string">'__T04test15ProblematicEnumON'</span> <span class="built_in">which</span> could not be resolved!</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>与之对应的验证脚本为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swift -O test.swift</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 134 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>运行 C-Reduce 程序我们可以达到如下的简化版本：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">a</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> b, <span class="built_in">c</span>, d</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">e</span><span class="params">()</span></span> -&gt; f &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .b:</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> .<span class="built_in">c</span>:</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> .d:</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">f</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>深入解析该编译错误超出了本文的范围，但如果我们需要对其进行修复时，该简化版本显然更方便。我们得到了一个相当简单的测试用例。 我们还可以推断出 Swift 语句和类的实例化之间存在一些交互，否则 C-Reduce 可能会删除其中一个。这为编译器导致该崩溃的原因提供了一些非常好的提示。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>测试示例的盲约精简并不是一种多复杂的调试技术，但是自动化让其变的更为有用高效。C-Reduce 可以作为你调试工具箱的一个很好补充。它并不适用所有场景，但是它在面对有些问题时能够带来不小的帮助。虽然在需要与多文件测试用例一起工作时可能存在一些困难，但检验脚本能够解决了该问题。另外，对于 Swift 这类其他语言来说 C-Reduce 也是开箱即用的，而不仅仅只能在 C 语言中发挥功效，所以不要因为你使用的语言不是 C 而放弃它。</p><p>今天内容到此为止。下次我还会带来与编程和代码相关的新内容。当然你也可以将你感兴趣的话题 <a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发送给我</a>。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2018-06-29-debugging-with-c-reduce.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-06-29&lt;br&gt;译者：&lt;a href=&quot;https://bignerdcoding.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigNerdCoding&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;调试复杂问题本身就并不轻松，如果还没有足够的上下文和大致方向的话那就是一件非常困难的事。所以对代码进行精简缩小调试范围也就变成了一种常见的行为。不过与繁杂的手动简化相比，执行自动化处理程序明显更容易发挥计算机自身的优势。C-Reduce 正是为此而生，它能自动对原始代码进行简化操作输出一个简化的调试友好版本。下面我们看看如何使用该自动化程序。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="Debug" scheme="https://swift.gg/tags/Debug/"/>
    
      <category term="C-Reduce" scheme="https://swift.gg/tags/C-Reduce/"/>
    
  </entry>
  
  <entry>
    <title>iOS 12 中的 Siri Shortcuts 简介</title>
    <link href="https://swift.gg/2018/09/20/siri-shortcuts/"/>
    <id>https://swift.gg/2018/09/20/siri-shortcuts/</id>
    <published>2018-09-20T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：AppCoda，<a href="https://appcoda.com/siri-shortcuts/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-07-11<br>译者：<a href="http://wuqiuhao.github.io" target="_blank" rel="noopener">Hale</a>；校对：<a href="http://xiaolu520.com/" target="_blank" rel="noopener">liberalisman</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="http://blog.yousanflics.com.cn" target="_blank" rel="noopener">Yousanflics</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>在美国圣何塞举办的 2018 开发者大会上，苹果公布了 Siri Shortcuts，这是一个令人期待已久的功能，开发人员能够在自己的应用程序中扩展和增强 Siri 的功能。在这之前，SiriKit SDK 的功能非常有限。随着 Siri Shortcuts 的出现，开发人员可以扩展 Siri 的功能并通过构建自定义语音操作来唤起应用程序。</p><a id="more"></a><h2 id="Siri-Shortcuts-简史"><a href="#Siri-Shortcuts-简史" class="headerlink" title="Siri Shortcuts 简史"></a>Siri Shortcuts 简史</h2><p>Siri Shortcuts 的核心是自动化。Siri Shortcuts 是由前 WWDC 奖学金获得者开发的 iOS 自动化应用程序 Workflow 演变而来的。苹果在2017年收购了 Workflow，但出乎意料的是，即便在收购之后，该应用依然独立的在 App Store 上线。</p><p><img src="https://appcoda.com/wp-content/uploads/2018/07/workflow-app.jpg" alt=""></p><blockquote><p>Shortcuts 让你可以将应用程序的功能暴露给 Siri。</p></blockquote><p>Apple 全新的 Siri Shortcuts 大量借鉴了 Workflow。但是区分语音 Shortcuts 短句与 Shortcuts 应用本身还是很重要的。Shortcuts 应用允许用户基于语音短句创建常见的日常任务，Siri Shortcuts 使开发人员能够在自己的原生应用程序中扩展 Siri 的功能。</p><p>在撰写本文时，Shortcuts 应用程序 无法在 iOS 12 Beta 2 Build 中进行测试。那么，我们将在自己构建的自定义应用程序中探索 Siri Shortcuts 的实用功能。</p><h2 id="我们的示例工程"><a href="#我们的示例工程" class="headerlink" title="我们的示例工程"></a>我们的示例工程</h2><blockquote><p>注意：本教程假定你基本熟悉 NSUserActivity API。如果你不熟悉，请参阅我们关于此主题的 <a href="https://www.appcoda.com/core-spotlight-framework/" target="_blank" rel="noopener">优秀教程</a>。</p></blockquote><p>在本教程中，我们将探究如何在一个简单的项目中利用 Siri Shortcuts，在用户说出 “Say Hi” 之类的短语时启动我们的应用程序并展示出一个 UIAlertView。</p><p>此应用程序简单概述了如何在一个大型项目中不增加复杂代码的前提下集成 Siri Shortcuts。在本教程结束时，你应该扎实掌握 Siri Shortcuts 背后的用例和技术，并了解如何将它们与你的应用程序集成！</p><h2 id="在新项目中定义你的-Shortcuts"><a href="#在新项目中定义你的-Shortcuts" class="headerlink" title="在新项目中定义你的 Shortcuts"></a>在新项目中定义你的 Shortcuts</h2><p>当我们在创建任意新项目时，花一些时间来建立基本的项目结构是很重要的。首先我们需要有 iOS 12，macOS Mojave 和 Xcode 10 的最新开发人员预览版。如果你还没有安装这些，你可以从 <a href="https://developer.apple.com/" target="_blank" rel="noopener">开发者网站</a> 下载安装。</p><p>在 Xcode 创建一个名为 <em>SiriShortcuts</em> 的应用程序。将组织 ID 设置为 <code>com.appcoda</code>，这些后期可以按需修改。</p><p><img src="https://appcoda.com/wp-content/uploads/2018/07/2-1240x793.png" alt=""></p><p>如下所示，在项目的 <em>Project Settings</em> 中选择 <em>Capabilities</em>，启用 Siri。接下来我们就可以在应用程序中使用 Siri SDK，并将 .entitlements 文件添加到项目中。</p><p><img src="https://appcoda.com/wp-content/uploads/2018/07/4-1240x793.png" alt=""></p><p>启用 S​​iri 后，Xcode 会将 <code>.entitlements</code> 文件添加到项目里。然后将 <code>Intents.framework</code> 这个全新的框架加入到项目中。</p><p><img src="https://appcoda.com/wp-content/uploads/2018/07/7-1240x793.png" alt=""></p><p>最后，在 <code>Info.plist</code> 中添加 <code>NSUserActivityTypes</code>。该项的值应该包含你的 Bundle ID 以及唤醒 Siri 的行为 ，例如 “sayHi”。</p><p><img src="https://appcoda.com/wp-content/uploads/2018/07/8-1240x775.png" alt=""></p><h2 id="集成-Shortcut"><a href="#集成-Shortcut" class="headerlink" title="集成 Shortcut"></a>集成 Shortcut</h2><blockquote><p>要创建一个 Shortcut 应用，我们首先配置 Shortcut，然后将 Shortcut 集成到项目中</p></blockquote><p>现在我们的项目已经完成了所有 Shortcut 的配置工作，是时候将 Shortcut 集成到项目中了。</p><p>根据 Apple 开发者文档，</p><blockquote><p>每次用户在你的应用中执行操作时，你都应该进行一次 Shortcut 集成。例如，用户可以使用你的应用从餐厅订购汤，请在用户下订单后为支付操作进行 Shortcut 集成。如果用户未在你的应用中执行操作，则不需要进行集成操作。</p></blockquote><p>显然，只有在提供有意义的用例时我们才需要集成 Shortcut，从而增强应用程序的整体功能。</p><p>回到代码中，首先我们前往 <code>ViewController.swift</code> 文件。在 <code>viewDidLoad</code> 方法之后，创建一个名为 <code>setupIntents</code> 的新方法。在此方法中，实现我们的 Siri Shortcuts 代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupIntents</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> activity = <span class="type">NSUserActivity</span>(activityType: <span class="string">"com.AppCoda.SiriSortcuts.sayHi"</span>) <span class="comment">// 1</span></span><br><span class="line">        activity.title = <span class="string">"Say Hi"</span> <span class="comment">// 2</span></span><br><span class="line">        activity.userInfo = [<span class="string">"speech"</span> : <span class="string">"hi"</span>] <span class="comment">// 3</span></span><br><span class="line">        activity.isEligibleForSearch = <span class="literal">true</span> <span class="comment">// 4</span></span><br><span class="line">        activity.isEligibleForPrediction = <span class="literal">true</span> <span class="comment">// 5</span></span><br><span class="line">        activity.persistentIdentifier = <span class="type">NSUserActivityPersistentIdentifier</span>(rawValue: <span class="string">"com.AppCoda.SiriSortcuts.sayHi"</span>) <span class="comment">// 6</span></span><br><span class="line">        view.userActivity = activity <span class="comment">// 7</span></span><br><span class="line">        activity.becomeCurrent() <span class="comment">// 8</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>让我们来看看这段代码做了什么。</p><ul><li><p>第一行，我们创建了 NSUserActivity 实例并将我们在 <code>Info.plist</code> 文件中定义的标识符赋值给 activityType。</p></li><li><p>第二行，我们定义了 Activity 的标题。（会应用在设置中心和 Spotlight 的搜索中。如果你对 NSUserActivity 以及 spotlight 搜索索引的工作方式不是很熟悉，我建议你阅读我们关于这个主题的其他教程。）</p></li><li><p>第三行，我们添加了一个 <code>userInfo</code> 字典。根据 Apple 的说法， userInfo 字典包含了在另一台设备上继续活动所需的与应用程序相关的状态信息。</p></li><li><p>下一步，我们设置 <code>.isEligibleForSearch</code> 参数为 <code>true</code> 然后在下一行启用 <code>isEligibleForPrediction</code>。这两个属性允许 iOS 在设备上为我们的 NSUserActivity 提供搜索和建议。</p></li><li><p>接下来，我们将 <code>persistentIdentifier</code> 属性设置为 NSUserActivityPersistentIdentifier 的实例，此实例用与第一行相同的标识符进行构造。</p></li><li><p>最后，我们将上面创建的 activity 实例赋值给视图的 <code>userActivity</code> 属性，并调用 <code>becomeCurrent()</code> 方法来激活我们的 Activity。</p></li></ul><p>我们再创建另一个名为 <code>sayHi()</code> 的方法并粘贴以下代码。此代码创建一个 UIAlertController 以显示消息。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"Hi There!"</span>, message: <span class="string">"Hey there! Glad to see you got this working!"</span>, preferredStyle: <span class="type">UIAlertController</span>.<span class="type">Style</span>.alert)</span><br><span class="line">        alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertAction</span>.<span class="type">Style</span>.<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">        <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述方法很简单，主要用于说明 Siri Shortcuts 是如何工作的。另外需要注意这是一个 <strong>public</strong> 函数，因为我们需要在视图控制器的作用域之外使用它。</p><h2 id="公开-Activity"><a href="#公开-Activity" class="headerlink" title="公开 Activity"></a>公开 Activity</h2><p>现在，你已经在 <code>ViewController.swift</code> 设置了基本功能，切换到 <code>AppDelegate.swift</code> 文件并添加 <code>application(_:continueUserActivity:restorationHandler)</code> 方法，如下所示。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, <span class="keyword">continue</span> userActivity: NSUserActivity, restorationHandler: @escaping <span class="params">([UIUserActivityRestoring]?)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> viewController = window?.rootViewController <span class="keyword">as</span>! <span class="type">ViewController</span></span><br><span class="line">  viewController.sayHi()</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码将我们新创建的 Activity 公开在应用委托方法中并允许 Siri 对此 Activity 进行操作唤起应用。</p><p>现在让我们试试看！导航到“设置”应用并选择 Siri。你应该看到一个名为 ”Say Hi” 的新快捷方式。单击 <code>+</code> 按钮添加它，然后按照屏幕上的提示创建自定义语音短语以创建此快捷方式。</p><p>现在你可以唤起 Siri 并说出你的短语，体验 Shortcut！</p><p><img src="/img/articles/siri-shortcuts/006tNbRwgy1fvfvhpdhd4j31kw0jr1kx.jpg1537423351.9367192" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正如你所见，在项目中使用 NSUserActivity 可以很容易地实现 Siri Shortcuts 的强大功能。在本教程中,我创建了一个基础的应用，同样的你也可以将这些技术应用到你自己的应用中。Siri Shortcuts 的使用场景还有很多，相信开发者们会以更创新和独特的方式来使用这项新技术。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了基于 iOS12 和 XCode10 创建 NSUserActivity 将示例应用支持 Siri Shortcuts，并在设置中自定义 Siri 短语以唤起应用触发事件。
    
    </summary>
    
      <category term="AppCoda" scheme="https://swift.gg/categories/AppCoda/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的属性</title>
    <link href="https://swift.gg/2018/09/18/properties-in-swift/"/>
    <id>https://swift.gg/2018/09/18/properties-in-swift/</id>
    <published>2018-09-18T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/properties-in-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-03-15<br>译者：<a href="https://www.sunnyyoung.net/" target="_blank" rel="noopener">Sunnyyoung</a>；校对：<a href="http://linusling.com" target="_blank" rel="noopener">小铁匠Linus</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>Swift 中有两种类型的属性：存储属性与计算属性。存储属性将值（常量或者变量）保存为实例或类型的一部分，而计算属性没有存储值。</p><p>提示：这篇文章已经更新至 Swift 4。</p><a id="more"></a><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p>让我们从存储属性开始看起。想象一下你有一个名为 Circle 的类：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line">circle.radius = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"radius: <span class="subst">\(circle.radius)</span>"</span>) <span class="comment">//radius: 10.0</span></span><br></pre></td></tr></table></figure><p>Circle 拥有名为 <code>radius</code> 的实例变量，默认值为 0。在 Swift 中，每个实例变量都为一个属性。因此你可以添加所谓的属性观察者。在 Swift 中有两种类型的属性观察者：一种在赋值之前调用，另一种在赋值之后调用。</p><p>在赋值后调用的属性观察者采用 <code>didSet</code> 关键字标记。在我们的示例中，你可以使用它来监测新设置的值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">                radius = oldValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line"> </span><br><span class="line">circle.radius = -<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"radius: <span class="subst">\(circle.radius)</span>"</span>) <span class="comment">//radius: 0.0</span></span><br><span class="line"> </span><br><span class="line">circle.radius = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"radius: <span class="subst">\(circle.radius)</span>"</span>) <span class="comment">//radius: 10.0</span></span><br></pre></td></tr></table></figure><p>在属性观察者中你可以通过变量 <code>oldValue</code> 来访问属性的旧值。</p><p>你还可以使用 <code>willSet</code> 属性观察者，它在赋值之前会被调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"About to assign the new value <span class="subst">\(newValue)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">                radius = oldValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line"> </span><br><span class="line">circle.radius = <span class="number">10</span> <span class="comment">//设置新值 10.0</span></span><br></pre></td></tr></table></figure><p>在 <code>willSet</code> 中，你可以通过变量 <code>newValue</code> 来访问属性的新值。</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>与存储属性不同的是，计算属性并不会存储属性的值。因此在每次调用计算属性时，都要计算该值。在 <code>Circle</code> 类中，你可以将属性 <code>area</code> 定义为计算属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">                radius = oldValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> radius * radius * <span class="type">Double</span>.pi</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line">circle.radius = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"area: <span class="subst">\(circle.area)</span>"</span>) <span class="comment">//area: 78.5398163397448</span></span><br></pre></td></tr></table></figure><p>计算属性总是需要一个 <code>getter</code>。如果缺少 <code>setter</code>，则该属性被称为只读属性。下面这个例子很好地说明了 <code>setter</code> 的作用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">                radius = oldValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> radius * radius * <span class="type">Double</span>.pi</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newArea) &#123;</span><br><span class="line">            radius = sqrt(newArea / <span class="type">Double</span>.pi)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>()</span><br><span class="line"></span><br><span class="line">circle.area = <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"radius: <span class="subst">\(circle.radius)</span>"</span>) <span class="comment">//radius: 2.82094791773878</span></span><br></pre></td></tr></table></figure><p>至此，每次对 area 设置了新的值之后，radius 都会被重新计算。</p><h2 id="存储属性的初始化"><a href="#存储属性的初始化" class="headerlink" title="存储属性的初始化"></a>存储属性的初始化</h2><p>每个存储属性在它的对象实例化之后都必须有值。属性初始化有两种方法：</p><ul><li>在 <code>init</code> 方法中初始化值</li><li>给属性设置默认的值</li></ul><p>下面的例子同时使用了这两种方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> identifier: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(radius: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.radius = radius</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> circle = <span class="type">Circle</span>(radius: <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>如果存储属性在对象实例化之后没有值，代码无法通过编译。</p><h2 id="懒加载属性"><a href="#懒加载属性" class="headerlink" title="懒加载属性"></a>懒加载属性</h2><p>如果具有默认值的存储属性使用了关键字 <code>lazy</code> 标记，则其默认值不会立即初始化，而是在第一次访问该属性时初始化。</p><p>因此，如果该属性从未被访问，它将永远不会被初始化。你可以将这种特性应用于一些特别耗费 CPU 或内存的初始化上。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> testString: <span class="type">String</span> = <span class="string">"TestString"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> testClass = <span class="type">TestClass</span>()</span><br><span class="line"><span class="built_in">print</span>(testClass.testString) <span class="comment">//TestString</span></span><br></pre></td></tr></table></figure><p>该属性在被访问之前不会进行初始化。在这个例子中并不容易看出来。但由于初始化也可以在 block 里面实现，我们可以使它更明显一些：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> testString: <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"about to initialize the property"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TestString"</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testClass = <span class="type">TestClass</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"before first call"</span>)</span><br><span class="line"><span class="built_in">print</span>(testClass.testString)</span><br><span class="line"><span class="built_in">print</span>(testClass.testString)</span><br></pre></td></tr></table></figure><p>这个例子的输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">before first call</span><br><span class="line">about to initialize the property</span><br><span class="line">TestString</span><br><span class="line">TestString</span><br></pre></td></tr></table></figure><p>这意味着该 block 仅被调用一次 - 第一次访问该属性的时候。由于存储属性是可变的，因此可以更改初始值。</p><h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><p>类型属性是类的一部分，但不是实例的一部分，类型属性也被称为静态属性。存储属性和计算属性都可以是类型属性。类型属性的关键字是 <code>static</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> testString: <span class="type">String</span> = <span class="string">"TestString"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(TestClass.testString)</span>"</span>) <span class="comment">//TestString</span></span><br></pre></td></tr></table></figure><p>如你所见，它们使用类名而不是实例对象来访问它们。此外，由于类型属性没有初始化方法，它总是需要一个默认值。</p><h2 id="拥有私有-Setter-的公共属性"><a href="#拥有私有-Setter-的公共属性" class="headerlink" title="拥有私有 Setter 的公共属性"></a>拥有私有 Setter 的公共属性</h2><p>正如我在 <a href="http://www.thomashanning.com/public-properties-with-private-setters/" target="_blank" rel="noopener">另一篇文章</a> 中介绍的那样，这是一种常见的情况，你不想提供一个公共的 setter，而是提供一个私有的 setter。这是封装的基本原则。这样只有类本身可以操作该属性，但仍可从类外部访问读取它。</p><p>来看下面的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> area: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> diameter: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> radius: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            calculateFigures()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(radius:<span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.radius = radius</span><br><span class="line">        calculateFigures()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">calculateFigures</span><span class="params">()</span></span> &#123;</span><br><span class="line">        area = <span class="type">Double</span>.pi * radius * radius</span><br><span class="line">        diameter = <span class="number">2</span> * <span class="type">Double</span>.pi * radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>(radius: <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"area: <span class="subst">\(circle.area)</span>"</span>) <span class="comment">//area: 78.5398163397448</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"diameter: <span class="subst">\(circle.diameter)</span>"</span>) <span class="comment">//diameter: 31.4159265358979</span></span><br><span class="line"></span><br><span class="line">circle.area = <span class="number">10</span> <span class="comment">//编译错误：无法对 'area' 属性进行赋值，因为 setter 方法不可访问</span></span><br></pre></td></tr></table></figure><p>这里的属性 <code>area</code> 和 <code>diameter</code> 可以从类的外部访问，但只能在类内部赋值。为此你必须使用 <code>public private(set)</code> 的组合。根据本人的经验，这个特性在 iOS 开发中很少使用，但它对写出更少 bug 的代码很有帮助。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文简单介绍了 Swift 中的属性
    
    </summary>
    
      <category term="Thomas Hanning" scheme="https://swift.gg/categories/Thomas-Hanning/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>在序列的链式操作中注入副作用</title>
    <link href="https://swift.gg/2018/09/13/chained-foreach/"/>
    <id>https://swift.gg/2018/09/13/chained-foreach/</id>
    <published>2018-09-13T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://oleb.net/blog/2017/10/chained-foreach/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017/10/30<br>译者：<a href="https://dingtz.com/" target="_blank" rel="noopener">jojotov</a>；校对：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>，<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>几周前，一位读者指出了 <a href="https://oleb.net/advanced-swift/" target="_blank" rel="noopener"><em>Advanced Swift</em></a> 中的<a href="https://twitter.com/jasonalexzurita/status/915972380685516800" target="_blank" rel="noopener">一处错误</a>。我们当时这样描述 Swift 中的 <code>forEach</code> 方法：</p><blockquote><p><code>forEach</code> 作为一系列链式调用中的一部分时确实可以大放异彩。举个例子，试想一下你在一个语句中通过链式调用的方式调用了几次 <code>map</code> 和 <code>filter</code> 方法。在调试这段代码时，你希望能够打印出某几步操作中间的值。要达成这一目的，在你期望的位置插入一个 <code>forEach</code> 或许是最快速的解决方式。</p></blockquote><p>当我写下这段描述时，众多美妙的想法涌现在我脑中，因为这听起来是个非常实用的特性<a href="#foot1" id="1"><sup>[1]</sup></a>（你并不能通过 <code>for-in</code> 循环达到这种效果）。可事实却如此的残酷 —— 你不能在一系列链式调用中间插入 <code>forEach</code>！</p><a id="more"></a><h2 id="理想中的形式"><a href="#理想中的形式" class="headerlink" title="理想中的形式"></a>理想中的形式</h2><p>为了以代码的形式更好地阐述我的想法，先让我们设想有如下一系列的链式调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = <span class="number">1</span>...<span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> sumOfSquaredEvenNumbers = numbers</span><br><span class="line">    .<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line">    .<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line"><span class="comment">// → 220</span></span><br></pre></td></tr></table></figure><p>现在假设我们希望确认一下每个链式操作是否达到了预期的效果 —— 例如 <code>filter</code> 和（或） <code>map</code> 操作后的返回值是否正确，最简洁的方式当然是在两个操作中间插入类似 <code>.forEach { print($0) }</code> 的调用。</p><p>但为什么 <code>forEach</code> 并不支持类似这样的使用方式呢？原因在于，在一系列链式调用中间的任何操作，都必须返回一个遵循 <a href="https://developer.apple.com/documentation/swift/sequence" target="_blank" rel="noopener"><code>Sequence</code></a> 协议的对象，这样下一个链式操作才能正常执行。而 <code>forEach</code> 的返回值为 <code>()</code>，因此它只能在一系列链式操作的结尾处调用。</p><h2 id="实现一个返回-Self-的-forEach"><a href="#实现一个返回-Self-的-forEach" class="headerlink" title="实现一个返回 Self 的 forEach"></a>实现一个返回 <code>Self</code> 的 <code>forEach</code></h2><p>值得庆幸的一点是，实现这个功能并不困难。我们所需要做的事情只是实现一个方法 —— 它能够遍历序列，并对每个元素执行一次传入的函数（就像 <code>forEach</code> 一样），最后返回自己（这样链式操作就能够无感知地继续进行）。换句话来说，这个方法的返回值类型应为 <code>Self</code>。为了避免在类型检查的时候这个方法与原生的 <code>forEach</code> 发生混淆，我把它命名为 <code>forEachPerform</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Perform a side effect for each element in `self`.</span></span><br><span class="line">    @discardableResult</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">forEachPerform</span><span class="params">(<span class="number">_</span> body: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; ())</span><br><span class="line">        <span class="keyword">rethrows</span> -&gt; <span class="type">Self</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> forEach(body)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>forEach</code> 不同，我们可以插入这个方法到一系列链式操作中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sumOfSquaredEvenNumbers = numbers</span><br><span class="line">    .<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">    .forEachPerform &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line">    .<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line"><span class="comment">/* Prints:</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>除此之外，我还添加了另一个非常有用的方法。这个方法只会对整个序列调用传入参数中的函数一次，而不会遍历序列并对每一个元素都调用一次。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Perform a side effect.</span></span><br><span class="line">    @discardableResult</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(<span class="number">_</span> body: <span class="params">(<span class="keyword">Self</span>)</span></span></span> <span class="keyword">throws</span> -&gt; ())</span><br><span class="line">        <span class="keyword">rethrows</span> -&gt; <span class="type">Self</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> body(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个方法可以完美地打印每一步链式操作的中间值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sumOfSquaredEvenNumbers = numbers</span><br><span class="line">    .<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">    .perform &#123; <span class="built_in">print</span>(<span class="string">"After filter: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line">    .perform &#123; <span class="built_in">print</span>(<span class="string">"After map: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</span><br><span class="line">    .<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line"><span class="comment">/* Prints:</span></span><br><span class="line"><span class="comment">After filter: [2, 4, 6, 8, 10]</span></span><br><span class="line"><span class="comment">After map: [4, 16, 36, 64, 100]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="自毁序列"><a href="#自毁序列" class="headerlink" title="自毁序列"></a>自毁序列</h2><p>我们新添加的方法返回了一个未修改过的 <code>self</code>，因此把它插入一系列链式调用中是完全没有影响的。但我们需要注意， <code>Sequence</code> 协议目前的代码实现中并没有保证多次的迭代返回完全相同的序列。</p><blockquote><p>译者注:</p><p>苹果官方 <code>Sequence</code> 的文档中有一段关与 <a href="https://developer.apple.com/documentation/swift/sequence#Repeated%20Access" target="_blank" rel="noopener">Repeated Access</a> 的描述：</p><p>The <code>Sequence</code> protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration. As a consequence, don’t assume that multiple <code>for</code>-<code>in</code> loops on a sequence will either resume iteration or restart from the beginning:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> element <span class="keyword">in</span> sequence &#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> ... some condition &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">for</span> element <span class="keyword">in</span> sequence &#123;</span><br><span class="line">&gt;     <span class="comment">// No defined behavior</span></span><br><span class="line">&gt; &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>大多数遵循 <code>Sequence</code> 的类型会确保上面的这种情况不会发生（例如 <a href="https://developer.apple.com/documentation/swift/array" target="_blank" rel="noopener"><code>Array</code></a>），但假设你有一个可以用于接收来自网络 socket 的字节流的 <code>Sequence</code> 类型——调用 <code>forEachPerform</code> 或者 <code>perform</code> 会打乱其顺序，导致随后操作中的数据不能被正确处理。</p><p>如果你的代码中存在上述问题，你可以选择让 <code>forEachPerform</code> 和 <code>perform</code> 方法返回一个 <code>Array&lt;Element&gt;</code> 类型（这样可以把可破坏的序列隐式转换为可重复的序列），或者可以把这些方法加到  <a href="https://developer.apple.com/documentation/swift/collection" target="_blank" rel="noopener"><code>Collection</code></a> 中（<code>Collection</code> 类型保证了迭代不会破坏顺序）。</p><h2 id="让它变“懒”"><a href="#让它变“懒”" class="headerlink" title="让它变“懒”"></a>让它变“懒”</h2><p><code>forEachPerform</code> 有个不太容易发现的问题：如果我们把它放在 <strong><em>惰性队列 (lazy sequences)</em></strong> 的链式调用之间，惰性队列会失去其原本的惰性。</p><p>惰性队列的设计初衷是为了把所有需要对下一个元素所做的工作都尽可能地延迟进行 —— 也就是说，当一个惰性序列的链式调用的最终返回值需要被获取时，那些被 ”延迟“ 的工作才会真正执行。由于 <code>forEachPerform</code> 的实现中遍历了序列的每个元素，我们让这个队列的任何惰性都被破坏了。</p><p>为了保证序列的惰性，我们可以定义一个自己的惰性迭代器以及序列类型，分别命名为 <code>LazyForEachIterator</code> 和 <code>LazyForEachSequence</code>。它们的工作与标准库中类似的类型相差无几：它们会把传入的函数以及序列 <em>保存</em> 起来，而不是立即执行传入的函数。<em>直到</em> 某个操作访问到下个元素时，它们才会轮流尝试获取原本序列的下一个元素，并执行相应的操作。</p><p>实现代码大概如此：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LazyForEachIterator</span>&lt;<span class="title">Base</span>: <span class="title">IteratorProtocol</span>&gt;</span></span><br><span class="line"><span class="class">    : <span class="title">IteratorProtocol</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Base</span>.<span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> nextElement = base.next() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        perform(nextElement)</span><br><span class="line">        <span class="keyword">return</span> nextElement</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> base: <span class="type">Base</span></span><br><span class="line">    <span class="keyword">let</span> perform: (<span class="type">Base</span>.<span class="type">Element</span>) -&gt; ()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LazyForEachSequence</span>&lt;<span class="title">Base</span>: <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class">    : <span class="title">LazySequenceProtocol</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span></span><br><span class="line">        -&gt; <span class="type">LazyForEachIterator</span>&lt;<span class="type">Base</span>.<span class="type">Iterator</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">LazyForEachIterator</span>(</span><br><span class="line">            base: base.makeIterator(),</span><br><span class="line">            perform: perform)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> base: <span class="type">Base</span></span><br><span class="line">    <span class="keyword">let</span> perform: (<span class="type">Base</span>.<span class="type">Element</span>) -&gt; ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这个序列遵循 <a href="https://developer.apple.com/documentation/swift/lazysequenceprotocol" target="_blank" rel="noopener"><code>LazySequenceProtocol</code></a> 协议。此协议继承于 <code>Sequence</code>。这个协议的职责是为一些即刻响应的操作（译者注：例如 <code>map</code> 和 <code>filter</code>）提供了惰性实现。</p><blockquote><p>译者注:</p><p>关于“即刻响应的操作”（原文中为 <em>normally-eager operations</em>），<code>LazySequenceProtocol</code> 的<a href="https://developer.apple.com/documentation/swift/lazysequenceprotocol" target="_blank" rel="noopener">官方文档</a>中有这样一段解释：</p><p>Sequence operations taking closure arguments, such as <code>map</code> and <code>filter</code>, are normally eager: they use the closure immediately and return a new array. </p><p>同时，文档紧跟着解释了 <code>lazy</code> 是如何让这种 <em>normally-eager operations</em> 变成惰性操作的：</p><p>Using the <code>lazy</code> property gives the standard library explicit permission to store the closure and the sequence in the result, and defer computation until it is needed.</p></blockquote><p>Swift 的类型推断机制其中一条规则是：在给定的约束的前提下，Swift 编译器会自动选择一个最明确且可工作的重载（译者注：可查看官方文档 <a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID322" target="_blank" rel="noopener">Type Safety and Type Inference</a> ）。因此，当你对一个遵循了 <code>LazySequenceProtocol</code> 协议的值调用诸如 <code>map</code> 的方法时，编译器会倾向于 <code>map</code> 方法的惰性变体而非默认版本实现。</p><p>为了在我们的方法中实现同样的效果，我们可以在 <code>LazySequenceProtocol</code> 的扩展中加入一个 <code>forEachPerform</code> 的变体，同时让它返回一个惰性序列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LazySequenceProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">forEachPerform</span><span class="params">(<span class="number">_</span> body: @escaping <span class="params">(Element)</span></span></span> -&gt; ())</span><br><span class="line">        -&gt; <span class="type">LazyForEachSequence</span>&lt;<span class="type">Self</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">LazyForEachSequence</span>(base: <span class="keyword">self</span>,</span><br><span class="line">            perform: body)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在以下几个方面上与与非惰性版本略有不同：</p><ul><li>因为我们需要把传入的闭包暂存起来，所以它必须是 <code>@escaping</code>，也就是逃逸闭包。</li><li>由于其惰性性质，这个方法并不支持会抛出异常的方法。</li><li>一般来说，一个惰性操作完成后必定会有后续的操作，因此其返回值并没有标记为 <code>descardable</code>。</li></ul><p>但这个方法最重要的特性是我们上面讨论过的：除了把原本的序列和传入的函数进行存储之外，它不会执行任何操作。</p><p>当这一切准备完成后，<code>forEachPerform</code> 便可以成功维持一个序列的惰性性质（注意 <code>.lazy</code> 的调用）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> largeNumbersSquared = numbers</span><br><span class="line">    .<span class="built_in">lazy</span></span><br><span class="line">    .<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt;= <span class="number">5</span> &#125;</span><br><span class="line">    .forEachPerform &#123; <span class="built_in">print</span>(<span class="string">"After filter: <span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// Prints nothing</span></span><br></pre></td></tr></table></figure><p><em>注意：其实这段代码在 Swift 4.0 中会编译失败：”ambiguous use of ‘forEachPerform’”。只有当我把 Sequence.forEachPerform 的返回类型由 Self 改为 [Element] 后这段代码才能正常运行。说实话我也不太明白这是为什么。不过你也可以通过修改 LazySequenceProtocol.forEachPerform 方法的命名暂时解决这个问题。</em></p><p>这样一来，只有当我们访问到惰性序列的元素时，这些元素的副作用才会被打印出来：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Access the first two elements</span></span><br><span class="line"><span class="type">Array</span>(largeNumbersSquared.<span class="keyword">prefix</span>(<span class="number">2</span>))</span><br><span class="line"><span class="comment">/* Prints:</span></span><br><span class="line"><span class="comment">After filter: 5</span></span><br><span class="line"><span class="comment">After filter: 6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// → [25, 36]</span></span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我真的很喜欢这种往链式操作中注入副作用的功能，即便我几乎没有在调试之外的时候使用过。插句题外话，虽然基于 <code>print</code> 的调试方法一直在被争论是否已经 “过时” 了，但我还是一直在用。</p><hr><p><a id="foot1" href="#1"><sup>[1]</sup></a>RxSwift 中有一个类似的操作符 <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Debug.swift" target="_blank" rel="noopener">debug</a> </p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      本文介绍了如何在 Swift 的链式调用中通过使用创建的自定义函数来实现调试的目的
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的设计模式 #1 工厂方法与单例方法</title>
    <link href="https://swift.gg/2018/09/10/design-pattern-creational/"/>
    <id>https://swift.gg/2018/09/10/design-pattern-creational/</id>
    <published>2018-09-10T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Andrew Jaffee，<a href="https://www.appcoda.com/design-pattern-creational/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-07-24<br>译者：<a href="https://github.com/Adolf-L" target="_blank" rel="noopener">BigLuo</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>，<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>“Gang of Four” (“GoF”) Erich Gamma，Richard Helm，Ralph Johonson，和 John Vlissides 在他们“<a href="https://smile.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8/" target="_blank" rel="noopener">设计模式：面向对象软件设计复用的基本原理</a>” 的重要著作里整理了大概 23 种经典的设计模式 。本文会介绍 GoF 总结的两种创建型（creational）模式：<em>工厂方法</em>和<em>单例方法</em>。</p><a id="more"></a><p>软件开发一直在努力地模拟真实世界的场景，希望通过创建工具的方式来加强人类的场景体验。财富管理工具，例如：像亚马逊或者 eBay 这样的银行 App 和购物辅助工具，相比十年前确实给消费者带来了更大的生活便利。回顾我们的发展路程。当应用变的更加强大易用时，应用的开发也已变的<a href="http://iosbrain.com/blog/2018/04/29/controlling-chaos-why-you-should-care-about-adding-error-checking-to-your-ios-apps/#chaos" target="_blank" rel="noopener"><strong>更加复杂</strong></a>。</p><p>所以开发者也开创出了一系列最佳实践。一些很流行的名字，像<a href="http://iosbrain.com/blog/2017/02/26/intro-to-object-oriented-principles-in-swift-3-via-a-message-box-class-hierarchy/" target="_blank" rel="noopener"><strong>面向对象编程</strong></a>，<a href="https://www.appcoda.com/pop-vs-oop/" target="_blank" rel="noopener"><strong>面向协议编程</strong></a>，<a href="http://iosbrain.com/blog/2018/03/28/protocol-oriented-programming-in-swift-is-it-better-than-object-oriented-programming/#value_semantics" target="_blank" rel="noopener"><strong>值语义 （value semantics）</strong></a>，<a href="http://iosbrain.com/blog/2018/03/28/protocol-oriented-programming-in-swift-is-it-better-than-object-oriented-programming/#local_reasoning" target="_blank" rel="noopener"><strong>局部推断 （local reasoning）</strong></a>将大块代码分解成具有良好接口定义的小段代码（比如使用 <a href="http://iosbrain.com/blog/2017/01/28/swift-extensions-managing-complexity-improving-readability-extensibility-protocols-delegates-uicollectionview/" target="_blank" rel="noopener"><strong>Swift 的扩展</strong></a>），以及 <a href="http://iosbrain.com/blog/2018/01/27/writing-expressive-meaningful-and-readable-code-in-swift-4/" target="_blank" rel="noopener"><strong>语法糖</strong></a>。还有我没提及，但却是最重要的、值得重视的实践之一，设计模式的使用。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是开发者管理软件复杂性的重要工具。作为常见的模板技术，它很好地对软件中类似的、复现的、容易识别的问题进行了概念化抽象。将它当作一个最佳实践应用到你日常会遇到的那些编程场景中，例如，在不了解类簇实现细节的情况下创建一个类簇相关的对象。设计模式主要是用于经常发生的那些问题场景中。它们频繁被使用是因为这些问题很普遍，让我用一个具体的例子来帮助你们理解吧。</p><p>设计模式讨论的并不是某些具体的问题，比如”如何迭代包含 11 个整数（Int）的 Swift 数组“。针对这类问题，GoF 定义了迭代器模式（Iterator Pattern），这是一个通用的模式，描述如何在不确定数据类型的情况下遍历一个数据列表。设计模式不是语言编码。它是用于解决相同软件场景问题的一套实用的指导规则。</p><p>还记得吗，之前我在 AppCoda 介绍过 <a href="https://www.appcoda.com/mvvm-vs-mvc/" target="_blank" rel="noopener">“Model-View-ViewModel” or “MVVM”</a> 与非常著名的 <a href="https://www.appcoda.com/mvvm-vs-mvc/" target="_blank" rel="noopener">“Model-View-Controller” or “MVC”</a> 设计模式，这两个模式深受 Apple 和 iOS 开发者喜爱。</p><p>这两种模式一般用在<em>整个应用</em>中。MVVM 和 MVC 是<em>架构（architectural）</em>设计模式，用于将 UI 从应用数据代码和展示逻辑中分离出来（如：MVC），以及将应用的数据从核心数据流程或者业务逻辑中分离（如：MVVM）。 而 GoF 设计模式本质上更具体，旨在解决基于程序代码中的具体问题。在一个应用里面你也许会用到 3 种、7 种或者 12 种 GoF 设计模式。除了<em>迭代器</em>例子，代理模式也是设计模式中另一个很好的例子， 尽管它在 GoF 列出的 23 种设计模式中并未被具体介绍。</p><p>当 GoF 的这本书作为大量开发者的圣经而存在时，也不乏有它的诋毁者，我们在文章的结尾处讨论这个话题。</p><h2 id="设计模式的类别"><a href="#设计模式的类别" class="headerlink" title="设计模式的类别"></a>设计模式的类别</h2><p>GoF 将 23 种设计模式整理分为 3 类，“创建型”、“结构型”和“行为型”。本教程讨论创建型模式类别中的两种（工厂模式与单例）。如同实例对象和类的实现，模式的作用是让复杂对象的创建变得简单、易于理解、易于维护，隐藏细节。</p><p><strong>隐藏复杂度（封装）</strong>是聪明的程序员最主要的目标之一。例如，面向对象（OOP）类能提供非常复杂的，强大且成熟的函数而不需要知道任何关于类内部间的工作方式。在创建型模式中，开发者甚至不需要知道类的属性和方法，但如果需要，程序员可以看到其接口 - 在 Swift 中的协议中 - 或对那些感兴趣的类进行扩展。你会在我的第一个“工厂方法”的例子中明白我的意思。</p><h2 id="工厂方法设计模式"><a href="#工厂方法设计模式" class="headerlink" title="工厂方法设计模式"></a>工厂方法设计模式</h2><p>如果你已经探索过 GoF 设计模式或在 OOP 的世界里花费了很多时间，你大概至少听说过“抽象工厂”、“工厂”，或者“工厂方法”模式。“确切”的命名可能有很多争议，不过下面我要介绍的这个例子最接近的命名是工厂模式。</p><p>在这个范例中，你通过工厂方法创建对象，而<em>不需要</em>知道类的构造器和关于类和类层次结构的任何信息。这带来了很大的方便。可以用少量的代码创建 UI 和它的相关功能。我的工厂方法项目案例，在 <a href="https://github.com/appcoda/FactoryMethodInSwift" target="_blank" rel="noopener"><strong>GitHub</strong></a> 可下载，展示了在复杂类层次结构中，如何轻松的使用对象。<br><img src="https://www.appcoda.com/wp-content/uploads/2018/07/Factory_Method.gif" alt=""></p><p>大多数成功的应用都有风格一致的主题 。为保证应用主题风格统一，假设应用中所有的 shapes 有着相同的颜色和尺寸，这样就可以和主题保持一致——也就是塑造品牌。这些图形用在自定义按钮上，或者作为登录流程的界面背景图都是不错的。</p><p>假设设计团队同意使用我的代码作为应用的主题背景图片。下面来看看我的具体代码，包括协议、类结构和（UI 开发人员不需要关心的）工厂方法。</p><p> <code>ShapeFactory.swift</code> 文件是一个用于在视图控制器内绘制形状的协议。因为可用于各种目的，所以它的访问级别是 public：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些值被图形设计团队预先选定</span></span><br><span class="line"><span class="keyword">let</span> defaultHeight = <span class="number">200</span></span><br><span class="line"><span class="keyword">let</span> defaultColor = <span class="type">UIColor</span>.blue</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HelperViewFactoryProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">configure</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">position</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> view: <span class="type">UIView</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> parentView: <span class="type">UIView</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得吗？ <code>UIView</code> 类有一个默认的矩形属性 <code>frame</code>  ，所以我可以轻松的创建出形状基类 <code>Square</code>: </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span>: <span class="title">HelperViewFactoryProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> height: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> parentView: <span class="type">UIView</span></span><br><span class="line">    <span class="keyword">var</span> view: <span class="type">UIView</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(height: <span class="type">Int</span> = defaultHeight, parentView: <span class="type">UIView</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.height = height</span><br><span class="line">        <span class="keyword">self</span>.parentView = parentView</span><br><span class="line">        view = <span class="type">UIView</span>()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">configure</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: height, height: height)</span><br><span class="line">        view.frame = frame</span><br><span class="line">        view.backgroundColor = defaultColor</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">position</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        view.center = parentView.center</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        configure()</span><br><span class="line">        position()</span><br><span class="line">        parentView.addSubview(view)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到我根据 OOP 的设计思想来构建复用代码，这样能让 shape 层级更加简化和可维护。<code>Circle</code> 和 <code>Rectangle</code> 类是 <code>Square</code> 类的特化 （另外你可以看到，从正方形出发绘制圆形是多么简单。）<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Square</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">configure</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">super</span>.configure()</span><br><span class="line">        </span><br><span class="line">        view.layer.cornerRadius = view.frame.width / <span class="number">2</span></span><br><span class="line">        view.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="title">Square</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">configure</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: height + height/<span class="number">2</span>, height: height)</span><br><span class="line">        view.frame = frame</span><br><span class="line">        view.backgroundColor = <span class="type">UIColor</span>.blue</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我使用 <code>fileprivate</code> 来强调工厂方法模式背后的一个目的：<em>封装</em>。你可以看到不用改变下面工厂方法的前提下，对 <code>shape</code> 类的层级结构进行修改和扩展是很容易的。这是工厂方法的代码，它们让对象的创建如此简单且抽象。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> square</span><br><span class="line">    <span class="keyword">case</span> circle</span><br><span class="line">    <span class="keyword">case</span> rectangle</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> parentView: <span class="type">UIView</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(parentView: <span class="type">UIView</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.parentView = parentView</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="keyword">as</span> shape: Shapes)</span></span> -&gt; <span class="type">HelperViewFactoryProtocol</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> shape &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> .square:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> square = <span class="type">Square</span>(parentView: parentView)</span><br><span class="line">            <span class="keyword">return</span> square</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> .circle:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> circle = <span class="type">Circle</span>(parentView: parentView)</span><br><span class="line">            <span class="keyword">return</span> circle</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> .rectangle:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> rectangle = <span class="type">Rectangle</span>(parentView: parentView)</span><br><span class="line">            <span class="keyword">return</span> rectangle</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共的工厂方法来展示形状</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createShape</span><span class="params">(<span class="number">_</span> shape: Shapes, on view: UIView)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> shapeFactory = <span class="type">ShapeFactory</span>(parentView: view)</span><br><span class="line">    shapeFactory.create(<span class="keyword">as</span>: shape).display()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择公共的工厂方法来展示形状</span></span><br><span class="line"><span class="comment">// 严格来说，工厂方法应该返回相关类中的一个。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getShape</span><span class="params">(<span class="number">_</span> shape: Shapes, on view: UIView)</span></span> -&gt; <span class="type">HelperViewFactoryProtocol</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> shapeFactory = <span class="type">ShapeFactory</span>(parentView: view)</span><br><span class="line">    <span class="keyword">return</span> shapeFactory.create(<span class="keyword">as</span>: shape)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意到：我已经写下一个类工厂和两个工厂方法来让你思考。严格说，一个工厂方法应该返回对应类的对象，这些类有着共同的基类或者协议。我的目的是在视图上绘制一个形状，所以我更倾心使用 <code>createShape(_:view:)</code> 这个方法。提供这种可选方式（该方法），在需要时可用于试验和探索新的可能性。</p><p>最后，我展示了两个工厂方法绘制形状的使用方式。UI 开发者不用知道形状类是如何被编码出来的。尤其是他/她不必为形状类如何被初始化而担忧。<code>ViewController.swift</code> 文件中的代码很容易阅读。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">//在加载视图后进行添加设置，一般是从nib</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// 废弃掉那些可以被重新创建的资源</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">drawCircle</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 仅仅用于绘制形状</span></span><br><span class="line">        createShape(.circle, on: view)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">drawSquare</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制图形</span></span><br><span class="line">        createShape(.square, on: view)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">drawRectangle</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从工厂获取一个对象并使用它来绘制一个形状</span></span><br><span class="line">        <span class="keyword">let</span> rectangle = getShape(.rectangle, on: view)</span><br><span class="line">        rectangle.display()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>大部分 iOS 开发者熟悉单例模式。回想一下 <code>UNUserNotificationCenter.current()</code>，<code>UIApplication.shared</code> 或 <code>FileManager.default</code> 如果你想要发送通知，或者在 Safari 里面打开一个 URL，或者操作 iOS 文件，你必须分别使用它们各自的单例。单例可以很好的用于保护共享资源，提供有且仅有一个对象实例进入一些系统，并且支持对象执行一些应用级类型的协作。正如我们将要看到的，单例也可以用来封装 iOS 内建的其它单例，添加一些值操作功能。</p><p>作为一个单例，我们需要确保这个类：</p><ul><li>声明和初始化一个 static 的类的常量属性，然后命名那个属性为 <code>shared</code> 来表明这个类的实例是一个单例（默认是共有的）；</li><li>为我们想要控制和保护的一些资源声明一个<em>私有的</em>属性。且只能通过 <code>shared</code> 共享；</li><li>声明一个私有初始化方法，只有我们的单例类能够初始化它，在 <code>init</code> 的内部，初始化我们想要用于控制的共享资源；</li></ul><p>通过定义一个 <code>shared</code> 静态常量来创建一个类的 <code>private</code> 初始化方法。我们要确保这个类只有一个实例，该类只能初始化一次，并且共享的实例在应用的任何地方都能获取。就这样我们创建了一个<em>单例</em>！</p><p>这个单例项目的代码，在 <a href="https://github.com/appcoda/SingletonInSwift" target="_blank" rel="noopener"><strong>GitHub</strong></a> 可下载，展示了一个开发者如何安全的、高效的存储用户的偏好。这是个简单的 Demo，该 Demo 能够记录用户的密码文本，偏好设置可设置为可见或隐藏。不过事后发现，这个功能并不是个好想法，我只是需要一个例子来向你展示我代码的工作机制。这段代码<em>完全是</em>出于教学的目的。我建议你<strong>永远不要</strong>让你的密码暴露。你可以看到用户可以设置他们的的密码偏好 — 且密码偏好被存储在 <code>UserDefaults</code>:</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/07/Show_Pwd.gif" alt=""></p><p>当用户关闭应用并且再次打开后，注意到他/她的密码偏好被记录了：</p><p><img src="https://www.appcoda.com/wp-content/uploads/2018/07/Remember_Pwd_Setting.gif" alt=""></p><p>让我向你展示 <code>PreferencesSingleton.swift</code> 文件中的代码片段，在行内注释里，你将会看到我想准确表达的意思。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPreferences</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类的初始化方法创建一个静态的，常量实例。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">UserPreferences</span>()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这是一个私有的，收我们保护的资源共享的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> userPreferences: <span class="type">UserDefaults</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 一个私有的初始化方法只能被类本身调用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取 iOS 共享单例。我们在这里包装了它。</span></span><br><span class="line">        userPreferences = <span class="type">UserDefaults</span>.standard</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125; <span class="comment">// end class UserPreferences</span></span><br></pre></td></tr></table></figure><p>应用启动的时候需要初始化静态属性，但是全局变量默认是懒加载。你可能会担心上面这段代码在执行的时候出错，不过就我对 Swift 的了解来说，这段代码完全没问题。</p><p>你也许会问，“为什么要通过包装另一个<code>UserDefaults</code> 单例的方式来创建一个单例？” 首先，我主要目的是要向你展示在 Swift 中创建和使用单例的最佳做法。 用户偏好是一个资源类型，应该有一个单一的入口。所以在这个例子中，很明显我们应该使用 <code>UserDefaults</code>。其次，想一下你曾多少次看到在应用中 <code>UserDefaults</code> 被滥用。</p><p>在一些项目应用代码中，我看到 <code>UserDefaults</code>(或者之前的 <code>NSUserDefaults</code>)的使用缺乏条理和原由。用户偏好属性对应的每个键都是字符串引用。刚才，我在代码中发现了一个 bug。我把“switch”拼写成了“swithc”，由于我对代码进行了复制和粘贴，在发现问题前，我已经创建了不少“swithc”的实例。 如果其他开发者在这个应用开始或者继续使用“switch”作为一个键来存储对应的值呢？应用的当前状态是无法被正确保存的。 我们经常使用 <code>UserDefaults</code> 的 strings 以键值映射的方式保存应用的状态。这是一个好的写法。这可以让值的意思清晰明确、简单易懂，还便于记忆。但也不是说通过 strings 来描述是没有任何风险的。</p><p>在我讨论的“swithc”与“switch”中。大多数人可能已经明白了被称为“stringly-typed”的那些代码, 用 strings 作为唯一的标识符会产生细微的不同，最终会因为拼写错误带来灾难性的错误。Swift 编译器不能帮助我们避免“stringly-typed”这类的错误。</p><p>解决“stringly-typed”错误的方式在于把 Swift <code>enum</code> 设置成 string 类型。这么做不仅可以让我们标准化字符串的使用，而且可让我们对其进行分类管理。让我们再次回到 <code>PreferencesSingleton.swift</code>:<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPreferences</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Preferences</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">UserCredentials</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> passwordVisibile</span><br><span class="line">            <span class="keyword">case</span> password</span><br><span class="line">            <span class="keyword">case</span> username</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">AppState</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> appFirstRun</span><br><span class="line">            <span class="keyword">case</span> dateLastRun</span><br><span class="line">            <span class="keyword">case</span> currentVersion</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="comment">// end enum Preferences</span></span><br></pre></td></tr></table></figure></p><p>我们从单例模式的定义开始，向你介绍清楚在我的应用中，为什么使用一个单例来封装 <code>UserDefaults</code>。我们可以通过添加值的方式来增添新的功能，但通过简单的对 <code>UserDefaults</code> 的包装却能增强代码的健壮性。在获取和设置用户偏好时，你脑中应该要马上想到进行错误校验。在这里，我想实现一个关于用户偏好的功能，设置密码的可见性。看到下面的代码。内容都在 <code>PreferencesSingleton.swift</code> 文件：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPreferences</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Preferences</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">UserCredentials</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> passwordVisibile</span><br><span class="line">            <span class="keyword">case</span> password</span><br><span class="line">            <span class="keyword">case</span> username</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">AppState</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> appFirstRun</span><br><span class="line">            <span class="keyword">case</span> dateLastRun</span><br><span class="line">            <span class="keyword">case</span> currentVersion</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="comment">// end enum Preferences</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个静态、常量实例并初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">UserPreferences</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是一个私有的，被保护的共享资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> userPreferences: <span class="type">UserDefaults</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有类本身能调用的一个私有初始化方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 获取 iOS 共享单例。我们在这里包装它</span></span><br><span class="line">        userPreferences = <span class="type">UserDefaults</span>.standard</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setBooleanForKey</span><span class="params">(<span class="number">_</span> boolean:Bool, key:String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> key != <span class="string">""</span> &#123;</span><br><span class="line">            userPreferences.<span class="keyword">set</span>(boolean, forKey: key)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getBooleanForKey</span><span class="params">(<span class="number">_</span> key:String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> isBooleanValue = userPreferences.value(forKey: key) <span class="keyword">as</span>! <span class="type">Bool</span>? &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Key <span class="subst">\(key)</span> is <span class="subst">\(isBooleanValue)</span>"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Key <span class="subst">\(key)</span> is false"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isPasswordVisible</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> isVisible = userPreferences.bool(forKey: <span class="type">Preferences</span>.<span class="type">UserCredentials</span>.passwordVisibile.rawValue)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> isVisible &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>来到 <code>ViewController.swift</code> 文件，你将看到，访问并使用结构良好的单例是多么的容易：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> passwordTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> passwordVisibleSwitch: <span class="type">UISwitch</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"><span class="comment">// 在加载视图后（一般通过 nib 来进行）进行其它的额外设置。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="type">UserPreferences</span>.shared.isPasswordVisible() &#123;</span><br><span class="line">            passwordVisibleSwitch.isOn = <span class="literal">true</span></span><br><span class="line">            passwordTextField.isSecureTextEntry = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            passwordVisibleSwitch.isOn = <span class="literal">false</span></span><br><span class="line">            passwordTextField.isSecureTextEntry = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line"><span class="comment">// 可以销毁那些能被重新创建的资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">passwordVisibleSwitched</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> pwdSwitch:<span class="type">UISwitch</span> = sender <span class="keyword">as</span>! <span class="type">UISwitch</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> pwdSwitch.isOn &#123;</span><br><span class="line">            passwordTextField.isSecureTextEntry = <span class="literal">false</span></span><br><span class="line">            <span class="type">UserPreferences</span>.shared.setPasswordVisibity(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            passwordTextField.isSecureTextEntry = <span class="literal">true</span></span><br><span class="line">            <span class="type">UserPreferences</span>.shared.setPasswordVisibity(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>有些评论家声称设计模式在一些编程语言中的使用缺乏证明，相同的设计模式在代码中反复出现是很槽糕的一件事情。我并不同意这个说法。期望一个编程语言对<em>每件事情</em>的处理都有其对应的特性是很愚蠢的。这很可能会导致一个臃肿的语言，像 C++ 一样正在变得更大、更复杂，以致很难被学习、使用与维护。认识并解决反复出现的问题是人的一种积极性格并且这确实值得我们强化。有一些事情，人们尝试却失败了很多次，通过学习总结前人经验，对一些相同的问题进行抽象和标准化，让这些好的解决方案散播出去的方面，设计模式成为了一个成功案例。</p><p>像 Swift 这样的简单紧凑的语言和设计模式这样一系列最佳实践的组合是一个理想中的、令人开心的方法。风格统一的代码一般来说都具有较好的可读性和易维护性。不过也要记住，在数以百万的开发者不断地讨论和分享下，设计模式也在不断的发展变化，这些美好事物被万维网联系在一起，这种开发人员的讨论持续的引领着集体智慧的自我调节。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Andrew Jaffee，&lt;a href=&quot;https://www.appcoda.com/design-pattern-creational/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-07-24&lt;br&gt;译者：&lt;a href=&quot;https://github.com/Adolf-L&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BigLuo&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;，&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;“Gang of Four” (“GoF”) Erich Gamma，Richard Helm，Ralph Johonson，和 John Vlissides 在他们“&lt;a href=&quot;https://smile.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式：面向对象软件设计复用的基本原理&lt;/a&gt;” 的重要著作里整理了大概 23 种经典的设计模式 。本文会介绍 GoF 总结的两种创建型（creational）模式：&lt;em&gt;工厂方法&lt;/em&gt;和&lt;em&gt;单例方法&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://swift.gg/categories/Swift/"/>
    
    
      <category term="Design Patterns" scheme="https://swift.gg/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>Never</title>
    <link href="https://swift.gg/2018/08/30/never/"/>
    <id>https://swift.gg/2018/08/30/never/</id>
    <published>2018-08-30T00:00:00.000Z</published>
    <updated>2018-12-03T07:23:57.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mattt，<a href="https://nshipster.com/never/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-07-30<br>译者：<a href="https://github.com/mobilefellow" target="_blank" rel="noopener">雨谨</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>，<a href="https://github.com/wongzigii" target="_blank" rel="noopener">wongzigii</a>，<a href="undefined">Firecrest</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p><code>Never</code> 是一个约定，表示一件事在过去或未来的任何时段都不会发生。它是时间轴上的一种逻辑上的不可能，在任何方向延展开去都没有可能。这就是为什么在代码中看到 <a href="https://github.com/search?q=%22this+will+never+happen%22&amp;type=Code" target="_blank" rel="noopener">这样的注释</a> 会特别让人不安。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个不会发生</span></span><br></pre></td></tr></table></figure><p>所有编译器的教科书都会告诉你，这样一句注释不能也不会对编译出的代码产生任何影响。<a href="https://en.wikipedia.org/wiki/Murphy%27s_law" target="_blank" rel="noopener">墨菲定理</a> 告诉你并非如此，注释以下的代码一定会被触发。</p><p>那 Swift 是如何在这种无法预测的、混乱的开发过程中保证安全呢？答案难以置信：“<strong>什么都不做</strong>”，以及“<strong>崩溃</strong>”。</p><hr><p>使用 <code>Never</code> 替换 <code>@noreturn</code> 修饰符，是由 <a href="https://github.com/jckarter" target="_blank" rel="noopener">Joe Groff</a> 在 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0102-noreturn-bottom-type.md" target="_blank" rel="noopener">SE-0102: “Remove @noreturn attribute and introduce an empty Never type”</a> 中提出的。</p><p>在 Swift 3 之前，那些要中断执行的函数，比如 <code>fatalError(_:file:line:)</code>，<code>abort()</code> 和 <code>exit(_:)</code>，需要使用 <code>@noreturn</code> 修饰符来声明，这会告诉编译器，执行完成后不用返回调用这个函数的位置。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &lt; 3.0</span></span><br><span class="line"><span class="meta">@noreturn</span> <span class="function"><span class="keyword">func</span> <span class="title">fatalError</span><span class="params">(<span class="number">_</span> message: <span class="params">()</span></span></span> -&gt; <span class="type">String</span> = <span class="type">String</span>(),</span><br><span class="line">                               file: <span class="type">StaticString</span> = #file,</span><br><span class="line">                               line: <span class="type">UInt</span> = #line)</span><br></pre></td></tr></table></figure><p>从 Swift 3 开始，<code>fatalError</code> 和它的相关函数都被声明为返回 <code>Never</code> 类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift &gt;= 3.0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fatalError</span><span class="params">(<span class="number">_</span> message: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span> = <span class="type">String</span>(),</span><br><span class="line">                     file: <span class="type">StaticString</span> = #file,</span><br><span class="line">                     line: <span class="type">UInt</span> = #line) -&gt; <span class="type">Never</span></span><br></pre></td></tr></table></figure><p>作为一个注释的替代品，它肯定是很复杂的，对吗？NO！事实上，恰恰相反，<code>Never</code> 可以说是整个 Swift 标准库中最简单的一个类型：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Never</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="无实例类型（Uninhabited-Types）"><a href="#无实例类型（Uninhabited-Types）" class="headerlink" title="无实例类型（Uninhabited Types）"></a>无实例类型（<code>Uninhabited Types</code>）</h2><p><code>Never</code> 是一个<em>无实例</em>（<em>Uninhabited</em>）类型，也就是说它没有任何值。或者换句话说，无实例类型是无法被构建的。</p><p>在 Swift 中，没有定义任何 <code>case</code> 的枚举是最常见的一种无实例类型。跟结构体和类不同，枚举没有初始化方法。跟协议也不同，枚举是一个具体的类型，可以包含属性、方法、泛型约束和嵌套类型。正因如此，Swift 标准库广泛使用无实例的枚举类型来做诸如 <a href="https://github.com/apple/swift/blob/a4230ab2ad37e37edc9ed86cd1510b7c016a769d/stdlib/public/core/Unicode.swift#L918" target="_blank" rel="noopener">定义命名空间</a> 以及 <a href="https://github.com/apple/swift/blob/a6952decab6f918a9df3c6fa342153a9f9204f8e/stdlib/public/core/MemoryLayout.swift#L43" target="_blank" rel="noopener">标识类型的含义</a> 之类的事情。</p><p>但 <code>Never</code> 并不这样。它没有什么花哨的东西，它的特别之处就在于，它就是它自己（或者说，它什么都不是）。</p><p>试想一个返回值为无实例类型的函数：因为无实例类型没有任何值，所以这个函数无法正常的返回。（它要如何生成这个返回值呢？）所以，这个函数要么停止运行，要么无休止的一直运行下去。</p><h2 id="消除泛型中的不可能状态"><a href="#消除泛型中的不可能状态" class="headerlink" title="消除泛型中的不可能状态"></a>消除泛型中的不可能状态</h2><p>从理论角度上说，<code>Never</code> 确实很有意思，但它在实际应用中又能帮我们做什么呢？</p><p>做不了什么，或者说在 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0215-conform-never-to-hashable-and-equatable.md#conform-never-to-equatable-and-hashable" target="_blank" rel="noopener">SE-0215: Conform Never to Equatable and Hashable</a> 推出以前，做不了什么。</p><p><a href="https://github.com/mdiep" target="_blank" rel="noopener">Matt Diephouse</a> 在提案中解释了为什么让这个令人费解的类型去遵守 <code>Equatable</code> 和其他协议：</p><blockquote><p><code>Never</code> 在表示不可能执行的代码方面非常有用。大部分人熟悉它，是因为它是 <code>fatalError</code> 等方法的返回值，但 <code>Never</code> 在泛型方面也非常有用。比如说，一个 <code>Result</code> 类型可能使用 <code>Never</code> 作为它的 <code>Value</code>，表示某种东西一直是错误的，或者使用 <code>Never</code> 作为它的 <code>Error</code>，表示某种东西一直不是错误的。</p></blockquote><p>Swift 没有标准的 <code>Result</code> 类型，大部分情况下它们是这个样子的：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">Value</span>, <span class="title">Error</span>: <span class="title">Swift</span>.<span class="title">Error</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">Value</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Result</code> 类型被用来封装异步操作生成的返回值和异常（同步操作可以使用 <code>throw</code> 来返回异常）。</p><p>比如说，一个发送异步 HTTP 请求的函数可能使用 <code>Result</code> 类型来存储响应或错误：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(<span class="number">_</span> request: Request, completion: <span class="params">(Result&lt;Response, Error&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这个方法后，你可以使用 <code>switch</code> 来分别处理它的 <code>.success</code> 和 <code>.failure</code>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fetch(request) &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Success: <span class="subst">\(value)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Failure: <span class="subst">\(error)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设有一个函数会在它的 <code>completion</code> 中永远返回成功结果：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alwaysSucceeds</span><span class="params">(<span class="number">_</span> completion: <span class="params">(Result&lt;String, Never&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completion(.success(<span class="string">"yes!"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>Result</code> 的 <code>Error</code> 类型指定为 <code>Never</code> 后，我们可以使用类型检测体系来表明失败是永远不可能发生的。这样做的好处在于，你不需要处理 <code>.failure</code>，Swift 可以推断出这个 <code>switch</code> 语句已经处理了所有情况。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">alwaysSucceeds &#123; (result) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> string):</span><br><span class="line">        <span class="built_in">print</span>(string)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个例子是让 <code>Never</code> 遵循 <code>Comparable</code> 协议，这段代码把 <code>Never</code> 用到了极致：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Never</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt; (lhs: Never, rhs: Never) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (lhs, rhs) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>Never</code> 是一个无实例类型，所以它没有任何可能的值。所以当我们使用 <code>switch</code> 遍历它的 <code>lhs</code> 和 <code>rhs</code> 时，Swift 可以确定所有的可能性都遍历了。既然所有的可能性 — 实际上这里不存在任何值 — 都返回了 <code>Bool</code>，那么这个方法就可以正常编译。</p><p><em>工整！</em></p><h2 id="使用-Never-作为兜底类型"><a href="#使用-Never-作为兜底类型" class="headerlink" title="使用 Never 作为兜底类型"></a>使用 <code>Never</code> 作为兜底类型</h2><p><strong>实际上，关于 <code>Never</code> 的 Swift Evolution 提案中已经暗示了这个类型在未来可能有更多用处：</strong></p><blockquote><p>一个无实例类型可以作为其他任意类型的子类型 — 如果某个表达式根本不可能产生任何结果，那么我们就不需要关心这个表达式的类型到底是什么。如果编译器支持这一特性，就可以实现很多有用的功能……</p></blockquote><h3 id="解包或者死亡"><a href="#解包或者死亡" class="headerlink" title="解包或者死亡"></a>解包或者死亡</h3><p>强制解包操作（<code>!</code>）是 Swift 中最具争议的部分之一。（在代码中使用这个操作符）往好了说，是有意为之（在异常时故意让程序崩溃）；往坏了说，可能表示使用者没有认真思考。在缺乏其他信息的情况下，很难看出这两者的区别。</p><p>比如，下面的代码假定数组一定不为空，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array: [<span class="type">Int</span>]</span><br><span class="line"><span class="keyword">let</span> firstIem = array.first!</span><br></pre></td></tr></table></figure><p>为了避免强制解包，你可以使用带条件赋值的 <code>guard</code> 语句：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array: [<span class="type">Int</span>]</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> firstItem = array.first <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"array cannot be empty"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未来，如果 <code>Never</code> 成为兜底类型，它就可以用在 <code>nil-coalescing operator</code> 表达式的右边。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未来的 Swift 写法? 🔮</span></span><br><span class="line"><span class="keyword">let</span> firstItem = array.first ?? <span class="built_in">fatalError</span>(<span class="string">"array cannot be empty"</span>)</span><br></pre></td></tr></table></figure><p>如果你想现在就使用这种模式，可以手动重载 <code>??</code> 运算符（但是……）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> ?? &lt;T&gt;<span class="params">(lhs: T?, rhs: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Never</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> lhs &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> value?:</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        rhs()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在拒绝 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0217-bangbang.md#on-forced-unwraps" target="_blank" rel="noopener">SE-0217: Introducing the !! “Unwrap or Die” operator to the Swift Standard Library</a> 的<a href="https://forums.swift.org/t/se-0217-the-unwrap-or-die-operator/14107/222" target="_blank" rel="noopener">原因说明</a>中, <a href="https://github.com/jckarter" target="_blank" rel="noopener">Joe Groff</a> 提到，“我们发现重载 [?? for Never] 会对类型检测的性能产生难以接受的影响”。所以，不建议你在自己的代码中添加上面的代码。</p></blockquote><h3 id="表达式风格的-Throw"><a href="#表达式风格的-Throw" class="headerlink" title="表达式风格的 Throw"></a>表达式风格的 Throw</h3><p>类似的，如果 <code>throw</code> 可以从语句变成一个返回 <code>Never</code>的表达式，你就可以在 <code>??</code> 右边使用 <code>throw</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未来的 Swift 写法? 🔮</span></span><br><span class="line"><span class="keyword">let</span> firstItem = array.first ?? <span class="keyword">throw</span> <span class="type">Error</span>.empty</span><br></pre></td></tr></table></figure><h3 id="带类型的-Throw"><a href="#带类型的-Throw" class="headerlink" title="带类型的 Throw"></a>带类型的 <code>Throw</code></h3><p>继续研究下去：如果函数声明的 <code>throw</code> 关键字支持类型约束，那么 <code>Never</code> 可以用来表明某个函数绝对不会抛出异常（类似于在上面的 <code>Result</code> 例子）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未来的 Swift 写法? 🔮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">neverThrows</span><span class="params">()</span></span> <span class="keyword">throws</span>&lt;<span class="type">Never</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">neverThrows() <span class="comment">// 无需使用 `try` ，因为编译器保证它一定成功（可能）</span></span><br></pre></td></tr></table></figure><hr><p>声称某个事情永远不可能发生，就像是向整个宇宙发出邀请，来证明它是错的一样。情态逻辑（modal logic）或者信念逻辑（doxastic logic）允许保面子式的妥协（“<em>它当时是对的，或者我是这么认为的！</em>”），但时态逻辑（temporal logic）似乎将这个约定提到了更高的一个标准。</p><p>幸运的是，得益于最不像类型的 <code>Never</code>，Swift 到达了这个高标准。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mattt，&lt;a href=&quot;https://nshipster.com/never/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2018-07-30&lt;br&gt;译者：&lt;a href=&quot;https://github.com/mobilefellow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;雨谨&lt;/a&gt;；校对：&lt;a href=&quot;http://numbbbbb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numbbbbb&lt;/a&gt;，&lt;a href=&quot;https://github.com/wongzigii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wongzigii&lt;/a&gt;，&lt;a href=&quot;undefined&quot;&gt;Firecrest&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;&lt;code&gt;Never&lt;/code&gt; 是一个约定，表示一件事在过去或未来的任何时段都不会发生。它是时间轴上的一种逻辑上的不可能，在任何方向延展开去都没有可能。这就是为什么在代码中看到 &lt;a href=&quot;https://github.com/search?q=%22this+will+never+happen%22&amp;amp;type=Code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这样的注释&lt;/a&gt; 会特别让人不安。&lt;/p&gt;
    
    </summary>
    
      <category term="NSHipster" scheme="https://swift.gg/categories/NSHipster/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
</feed>
