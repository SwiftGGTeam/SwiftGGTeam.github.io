
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="baidu-site-verification" content="vqJV77bZM6">
  
    <title>Swift 中枚举高级用法及实践 | Swift 教程 - Swift 语言学习 - Swift code - SwiftGG 翻译组 - 高质量的 Swift 译文网站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="SwiftGG">
    

    <meta name="keywords" content="swift语言,swift翻译,swift学习">
    <meta name="applicable-device" content="pc,mobile">
    <meta name="description" content="作者：Benedikt Terhechte，原文链接，原文日期：2015-10-17译者：小锅，pmst；校对：shanks；定稿：shanks    译者注：作为一个走心且有逼格的翻译组，我们对本篇文章中的代码都进行了验证，并且写了将代码分为上下两篇做成了 playground，代码中有详尽的注释。可以到这个github地址上进行下载，这个代码由翻译组的另一位小伙伴 ppt 提供。  本文是一">
<meta name="keywords" content="Swift 进阶">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 中枚举高级用法及实践">
<meta property="og:url" content="https://swift.gg/2015/11/20/advanced-practical-enum-examples/index.html">
<meta property="og:site_name" content="SwiftGG">
<meta property="og:description" content="作者：Benedikt Terhechte，原文链接，原文日期：2015-10-17译者：小锅，pmst；校对：shanks；定稿：shanks    译者注：作为一个走心且有逼格的翻译组，我们对本篇文章中的代码都进行了验证，并且写了将代码分为上下两篇做成了 playground，代码中有详尽的注释。可以到这个github地址上进行下载，这个代码由翻译组的另一位小伙伴 ppt 提供。  本文是一">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-07-10T12:01:29.547Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift 中枚举高级用法及实践">
<meta name="twitter:description" content="作者：Benedikt Terhechte，原文链接，原文日期：2015-10-17译者：小锅，pmst；校对：shanks；定稿：shanks    译者注：作为一个走心且有逼格的翻译组，我们对本篇文章中的代码都进行了验证，并且写了将代码分为上下两篇做成了 playground，代码中有详尽的注释。可以到这个github地址上进行下载，这个代码由翻译组的另一位小伙伴 ppt 提供。  本文是一">

    
    <link rel="alternative" href="/atom.xml" title="SwiftGG" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon_new.ico">
    
    
    <link rel="apple-touch-icon" href="/img/logo_new.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/logo_new.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/gitment.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo_new.png" alt="SwiftGG" title="SwiftGG"></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="SwiftGG">SwiftGG</a></h1>
				<h2 class="blog-motto">走心的 Swift 翻译组</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
						<li><a href="/stat">统计</a></li>
					
						<li><a href="https://swiftgg.gitbook.io/swift/">Swift 官方文档翻译</a></li>
					
					<li>
 					
						<form class="search" method="GET" action="http://search.swift.gg/cse/search" target="_blank">
							<label>搜索</label>
						<input name="s" type="hidden" value="4873498141517765035"><input type="search" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		
  <header class="article-info clearfix">
    <h1 itemprop="name">
      
        <a href="/2015/11/20/advanced-practical-enum-examples/" target="_blank" title="Swift 中枚举高级用法及实践" itemprop="url">Swift 中枚举高级用法及实践</a>
    </h1>
    <p class="article-time">
      <time datetime="2015-11-20T00:00:00.000Z" itemprop="datePublished">2015-11-20</time>
      <span style="margin-left: 0.5em;"><i class="icon-eye-open"></i> <span class="viewcount"></span></span>
    </p>
  </header>

	<div class="article-content">
		
		<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/10/17/advanced-practical-enum-examples/" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-10-17<br>译者：<a href="http://www.swiftyper.com" target="_blank" rel="noopener">小锅</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；校对：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>译者注：作为一个走心且有逼格的翻译组，我们对本篇文章中的代码都进行了验证，并且写了将代码分为上下两篇做成了 playground，代码中有详尽的注释。可以到<a href="https://github.com/colourful987/Topic_Demo/tree/master/Advanced%20%26%20Practical%20Enum%20usage%20in%20Swift" target="_blank" rel="noopener">这个github地址上进行下载</a>，这个代码由翻译组的另一位小伙伴 <a href="http://blog.csdn.net/colouful987" target="_blank" rel="noopener">ppt</a> 提供。</p>
</blockquote>
<p>本文是一篇详细且具有实战意义的教程，涵盖几乎所有枚举(<code>Enum</code>)知识点，为你解答<code>Swift</code>中枚举的应用场合以及使用方法。</p>
<a id="more"></a>
<p>和<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="noopener">switch语句</a>类似，<code>Swift</code>中的枚举乍看之下更像是<code>C</code>语言中枚举的进阶版本，即允许你定义一种类型，用于表示普通事情中某种用例。不过深入挖掘之后，凭借<code>Swift</code>背后特别的设计理念，相比较<code>C</code>语言枚举来说其在实际场景中的应用更为广泛。特别是作为强大的工具，<code>Swift</code>中的枚举能够清晰表达代码的意图。</p>
<p>本文中，我们将首先了解基础语法和使用枚举的可能性，接着通过实战教你如何以及何时使用枚举。最后我们还会大致了解下<code>Swift</code>标准库中枚举是如何被使用的。</p>
<p>正式开始学习之前，先给出枚举的定义。之后我们将回过头再来讨论它。</p>
<blockquote>
<p>枚举声明的类型是囊括可能状态的有限集，且可以具有附加值。通过内嵌(<em>nesting</em>),方法(<em>method</em>),关联值(<em>associated values</em>)和模式匹配(<em>pattern matching</em>),枚举可以分层次地定义任何有组织的数据。</p>
</blockquote>
<h2 id="深入理解-Diving-In"><a href="#深入理解-Diving-In" class="headerlink" title="深入理解(Diving In)"></a>深入理解(Diving In)</h2><p>简要概述如何定义和使用枚举。</p>
<h3 id="定义基本的枚举类型-Defining-Basic-Enums"><a href="#定义基本的枚举类型-Defining-Basic-Enums" class="headerlink" title="定义基本的枚举类型(Defining Basic Enums)"></a>定义基本的枚举类型(Defining Basic Enums)</h3><p>试想我们正在开发一款游戏，玩家能够朝四个方向移动。所以喽，玩家的运动轨迹受到了限制。显然，我们能够使用枚举来表述这一情况:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Movement</span></span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Left</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Right</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Top</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Bottom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着，你可以使用<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="noopener">多种模式匹配结构</a>获取到<code>Movement</code>的枚举值，或者按照特定情况执行操作:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aMovement = <span class="type">Movement</span>.<span class="type">Left</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// switch 分情况处理</span></span><br><span class="line"><span class="keyword">switch</span> aMovement&#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Left</span>: <span class="built_in">print</span>(<span class="string">"left"</span>)</span><br><span class="line"><span class="keyword">default</span>:()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 明确的case情况</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> .<span class="type">Left</span> = aMovement&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"left"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> aMovement == .<span class="type">Left</span> &#123; <span class="built_in">print</span>(<span class="string">"left"</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>案例中，我们无须明确指出<code>enum</code>的实际名称(即<code>case Move.Left:print(&quot;Left&quot;)</code>)。因为类型检查器能够自动为此进行类型推算。这对于那些<strong>UIKit</strong>以及<strong>AppKit</strong>中错综复杂的枚举是灰常有用的。</p>
<h3 id="枚举值-Enum-Values"><a href="#枚举值-Enum-Values" class="headerlink" title="枚举值(Enum Values)"></a>枚举值(Enum Values)</h3><p>当然，你可能想要为<code>enum</code>中每个<code>case</code>分配一个值。这相当有用，比如枚举自身实际与某事或某物挂钩时，往往这些东西又需要使用不同类型来表述。在<code>C</code>语言中，你只能为枚举<code>case</code>分配整型值，而<code>Swift</code>则提供了更多的灵活性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 映射到整型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Movement</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Top</span> = <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bottom</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样你可以与字符串一一对应</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">House</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Baratheon</span> = <span class="string">"Ours is the Fury"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Greyjoy</span> = <span class="string">"We Do Not Sow"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Martell</span> = <span class="string">"Unbowed, Unbent, Unbroken"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Stark</span> = <span class="string">"Winter is Coming"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tully</span> = <span class="string">"Family, Duty, Honor"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tyrell</span> = <span class="string">"Growing Strong"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者float double都可以(同时注意枚举中的花式unicode)</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Constants</span>: <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> π = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">case</span> e = <span class="number">2.71828</span></span><br><span class="line">    <span class="keyword">case</span> φ = <span class="number">1.61803398874</span></span><br><span class="line">    <span class="keyword">case</span> λ = <span class="number">1.30357</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>String</code>和<code>Int</code>类型来说，你甚至可以忽略为枚举中的<code>case</code>赋值，<code>Swift</code>编译器也能正常工作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mercury = 1, Venus = 2, ... Neptune = 8</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span> = <span class="number">1</span>, <span class="type">Venus</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Neptune</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// North = "North", ... West = "West"</span></span><br><span class="line"><span class="comment">// 译者注: 这个是swift2.0新增语法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span>, <span class="type">East</span>, <span class="type">West</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Swift</code>枚举中支持以下四种关联值类型:</p>
<ul>
<li>整型(Integer)</li>
<li>浮点数(Float Point)</li>
<li>字符串(String)</li>
<li>布尔类型(Boolean)</li>
</ul>
<p>因此你无法<a href="#c1"><sup>1<sup></sup></sup></a>为枚举分配诸如<code>CGPoint</code>类型的值。</p>
<p>倘若你想要读取枚举的值，可以通过<code>rawValue</code>属性来实现:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bestHouse = <span class="type">House</span>.<span class="type">Stark</span></span><br><span class="line"><span class="built_in">print</span>(bestHouse.rawValue)</span><br><span class="line"><span class="comment">// prints "Winter is coming"</span></span><br></pre></td></tr></table></figure>
<p>不过某种情形下，你可能想要通过一个已有的<code>raw value</code>来创建一个<code>enum case</code>。这种情况下，枚举提供了一个指定构造方法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Movement</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Top</span> = <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bottom</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个movement.Right 用例,其raw value值为1</span></span><br><span class="line"><span class="keyword">let</span> rightMovement = <span class="type">Movement</span>(rawValue: <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>倘若使用<code>rawValue</code>构造器，切记它是一个可失败构造器(<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID376" target="_blank" rel="noopener">failable initializer</a>)。换言之，构造方法返回值为<a href="http://appventure.me/2014/06/13/swift-optionals-made-simple/" target="_blank" rel="noopener">可选类型值</a>,因为有时候传入的值可能与任意一个<code>case</code>都不匹配。比如<code>Movement(rawValue:42)</code>。</p>
<p>如果你想要以底层 C 二进制编码形式呈现某物或某事，使得更具可读性，这是一个非常有用的功能。例如，可以看一下<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man2/kqueue.2.html" target="_blank" rel="noopener">BSD kqeue library</a>中的<strong>VNode Flags</strong>标志位的编码方式:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">VNodeFlags</span> : <span class="title">UInt32</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Delete</span> = <span class="number">0x00000001</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Write</span> = <span class="number">0x00000002</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Extended</span> = <span class="number">0x00000004</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Attrib</span> = <span class="number">0x00000008</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Link</span> = <span class="number">0x00000010</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Rename</span> = <span class="number">0x00000020</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Revoke</span> = <span class="number">0x00000040</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> = <span class="number">0x00000080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此便可以使你的<strong>Delete</strong>或<strong>Write</strong>用例声明一目了然，稍后一旦需要，只需将<strong>raw value</strong>传入 C 函数中即可。</p>
<h3 id="嵌套枚举-Nesting-Enums"><a href="#嵌套枚举-Nesting-Enums" class="headerlink" title="嵌套枚举(Nesting Enums)"></a>嵌套枚举(Nesting Enums)</h3><p>如果你有特定子类型的需求，可以对<code>enum</code>进行嵌套。这样就允许你为实际的<code>enum</code>中包含其他明确信息的<code>enum</code>。以<strong>RPG</strong>游戏中的每个角色为例，每个角色能够拥有武器，因此所有角色都可以获取同一个武器集合。而游戏中的其他实例则无法获取这些武器(比如食人魔,它们仅使用棍棒)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Character</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bow</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sword</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lance</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Dagger</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Helmet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Wooden</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Iron</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Diamond</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Thief</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Warrior</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Knight</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，你可以通过层级结构来描述角色允许访问的项目条。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> character = <span class="type">Character</span>.<span class="type">Thief</span></span><br><span class="line"><span class="keyword">let</span> weapon = <span class="type">Character</span>.<span class="type">Weapon</span>.<span class="type">Bow</span></span><br><span class="line"><span class="keyword">let</span> helmet = <span class="type">Character</span>.<span class="type">Helmet</span>.<span class="type">Iron</span></span><br></pre></td></tr></table></figure>
<h3 id="包含枚举-Containing-Enums"><a href="#包含枚举-Containing-Enums" class="headerlink" title="包含枚举(Containing Enums)"></a>包含枚举(Containing Enums)</h3><p>同样地，你也能够在<code>structs</code>或<code>classes</code>中内嵌枚举。接着上面的例子:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Character</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">CharacterType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Thief</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Warrior</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Knight</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bow</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sword</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lance</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Dagger</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> type: <span class="type">CharacterType</span></span><br><span class="line">  <span class="keyword">let</span> weapon: <span class="type">Weapon</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> warrior = <span class="type">Character</span>(type: .<span class="type">Warrior</span>, weapon: .<span class="type">Sword</span>)</span><br></pre></td></tr></table></figure>
<p>同样地，这也将有助于我们将相关的信息集中在一个位置。</p>
<h3 id="关联值-Associated-Value"><a href="#关联值-Associated-Value" class="headerlink" title="关联值(Associated Value)"></a>关联值(Associated Value)</h3><p>关联值是将额外信息附加到<code>enum case</code>中的一种极好的方式。打个比方，你正在开发一款交易引擎，可能存在<strong>买</strong>和<strong>卖</strong>两种不同的交易类型。除此之外每手交易还要制定明确的股票名称和交易数量:</p>
<h4 id="简单例程-Simple-Example"><a href="#简单例程-Simple-Example" class="headerlink" title="简单例程(Simple Example)"></a>简单例程(Simple Example)</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trade</span><span class="params">(tradeType: Trade, stock: String, amount: Int)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然而股票的价值和数量显然从属于交易，让他们作为独立的参数显得模棱两可。你可能已经想到要往<code>struct</code>中内嵌一个枚举了，不过关联值提供了一种更清爽的解决方案：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trade</span><span class="params">(type: Trade)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模式匹配-Pattern-Mathching"><a href="#模式匹配-Pattern-Mathching" class="headerlink" title="模式匹配(Pattern Mathching)"></a>模式匹配(Pattern Mathching)</h4><p>如果你想要访问这些值，<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="noopener">模式匹配</a>再次救场:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> trade = <span class="type">Trade</span>.<span class="type">Buy</span>(stock: <span class="string">"APPL"</span>, amount: <span class="number">500</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">Trade</span>.<span class="type">Buy</span>(stock, amount) = trade &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"buy \(amount) of \(stock)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标签-Labels"><a href="#标签-Labels" class="headerlink" title="标签(Labels)"></a>标签(Labels)</h4><p>关联值不需要附加标签的声明:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Buy</span>(<span class="type">String</span>, <span class="type">Int</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Sell</span>(<span class="type">String</span>, <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倘若你添加了，那么，每当创建枚举用例时，你都需要将这些标签标示出来。</p>
<h4 id="元组参数-Tuple-as-Arguments"><a href="#元组参数-Tuple-as-Arguments" class="headerlink" title="元组参数(Tuple as Arguments)"></a>元组参数(Tuple as Arguments)</h4><p>更重要的是,<code>Swift</code>内部相关信息其实是一个元组,所以你可以像下面这样做:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tp = (stock: <span class="string">"TSLA"</span>, amount: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> trade = <span class="type">Trade</span>.<span class="type">Sell</span>(tp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">Trade</span>.<span class="type">Sell</span>(stock, amount) = trade &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"buy \(amount) of \(stock)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints: "buy 100 of TSLA"</span></span><br></pre></td></tr></table></figure>
<p>语法允许您将元组当作一个简单的数据结构,稍后元组将自动转换到高级类型，就比如<code>enum case</code>。想象一个应用程序可以让用户来配置电脑:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Config</span> = (<span class="type">RAM</span>: <span class="type">Int</span>, <span class="type">CPU</span>: <span class="type">String</span>, <span class="type">GPU</span>: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each of these takes a config and returns an updated config</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectRAM</span><span class="params">(<span class="number">_</span> config: Config)</span></span> -&gt; <span class="type">Config</span> &#123;<span class="keyword">return</span> (<span class="type">RAM</span>: <span class="number">32</span>, <span class="type">CPU</span>: config.<span class="type">CPU</span>, <span class="type">GPU</span>: config.<span class="type">GPU</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectCPU</span><span class="params">(<span class="number">_</span> config: Config)</span></span> -&gt; <span class="type">Config</span> &#123;<span class="keyword">return</span> (<span class="type">RAM</span>: config.<span class="type">RAM</span>, <span class="type">CPU</span>: <span class="string">"3.2GHZ"</span>, <span class="type">GPU</span>: config.<span class="type">GPU</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectGPU</span><span class="params">(<span class="number">_</span> config: Config)</span></span> -&gt; <span class="type">Config</span> &#123;<span class="keyword">return</span> (<span class="type">RAM</span>: config.<span class="type">RAM</span>, <span class="type">CPU</span>: <span class="string">"3.2GHZ"</span>, <span class="type">GPU</span>: <span class="string">"NVidia"</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Desktop</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Cube</span>(<span class="type">Config</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Tower</span>(<span class="type">Config</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Rack</span>(<span class="type">Config</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aTower = <span class="type">Desktop</span>.<span class="type">Tower</span>(selectGPU(selectCPU(selectRAM((<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>) <span class="keyword">as</span> <span class="type">Config</span>))))</span><br></pre></td></tr></table></figure>
<p>配置的每个步骤均通过递交元组到<code>enum</code>中进行内容更新。倘若我们从<strong>函数式编程</strong><a href="#c2"><sup>2<sup></sup></sup></a>中获得启发，这将变得更好。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;^&gt; &#123; <span class="keyword">associativity</span> <span class="keyword">left</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;^&gt;<span class="params">(a: Config, f: <span class="params">(Config)</span></span></span> -&gt; <span class="type">Config</span>) -&gt; <span class="type">Config</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> f(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们可以将不同配置步骤串联起来。这在配置步骤繁多的情况下相当有用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> config = (<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>) &lt;^&gt; selectRAM  &lt;^&gt; selectCPU &lt;^&gt; selectGPU</span><br><span class="line"><span class="keyword">let</span> aCube = <span class="type">Desktop</span>.<span class="type">Cube</span>(config)</span><br></pre></td></tr></table></figure>
<h4 id="使用案例-Use-Case-Example"><a href="#使用案例-Use-Case-Example" class="headerlink" title="使用案例(Use Case Example)"></a>使用案例(Use Case Example)</h4><p>关联值可以以多种方式使用。常言道：一码胜千言, 下面就上几段简单的示例代码，这几段代码没有特定的顺序。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拥有不同值的用例</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UserAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">OpenURL</span>(url: <span class="type">NSURL</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">SwitchProcess</span>(processId: <span class="type">UInt32</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Restart</span>(time: <span class="type">NSDate?</span>, intoCommandLine: <span class="type">Bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设你在实现一个功能强大的编辑器，这个编辑器允许多重选择，</span></span><br><span class="line"><span class="comment">// 正如 Sublime Text : https://www.youtube.com/watch?v=i2SVJa2EGIw</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Single</span>(<span class="type">Range</span>&lt;<span class="type">Int</span>&gt;)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Multiple</span>([<span class="type">Range</span>&lt;<span class="type">Int</span>&gt;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者映射不同的标识码</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UPCA</span>(numberSystem: <span class="type">Int</span>, manufacturer: <span class="type">Int</span>, product: <span class="type">Int</span>, check: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">QRCode</span>(productCode: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 又或者假设你在封装一个 C 语言库，正如 Kqeue BSD/Darwin 通知系统:</span></span><br><span class="line"><span class="comment">// https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">KqueueEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UserEvent</span>(identifier: <span class="type">UInt</span>, fflags: [<span class="type">UInt32</span>], data: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ReadFD</span>(fd: <span class="type">UInt</span>, data: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">WriteFD</span>(fd: <span class="type">UInt</span>, data: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">VnodeFD</span>(fd: <span class="type">UInt</span>, fflags: [<span class="type">UInt32</span>], data: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ErrorEvent</span>(code: <span class="type">UInt</span>, message: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后, 一个 RPG 游戏中的所有可穿戴装备可以使用一个枚举来进行映射，</span></span><br><span class="line"><span class="comment">// 可以为一个装备增加重量和持久两个属性</span></span><br><span class="line"><span class="comment">// 现在可以仅用一行代码来增加一个"钻石"属性，如此一来我们便可以增加几件新的镶嵌钻石的可穿戴装备</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Wearable</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Weight</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Light</span> = <span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Mid</span> = <span class="number">4</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Heavy</span> = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Armor</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Light</span> = <span class="number">2</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Strong</span> = <span class="number">8</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Heavy</span> = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Helmet</span>(weight: <span class="type">Weight</span>, armor: <span class="type">Armor</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Breastplate</span>(weight: <span class="type">Weight</span>, armor: <span class="type">Armor</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Shield</span>(weight: <span class="type">Weight</span>, armor: <span class="type">Armor</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> woodenHelmet = <span class="type">Wearable</span>.<span class="type">Helmet</span>(weight: .<span class="type">Light</span>, armor: .<span class="type">Light</span>)</span><br></pre></td></tr></table></figure>
<h3 id="方法和属性-Methods-and-properties"><a href="#方法和属性-Methods-and-properties" class="headerlink" title="方法和属性(Methods and properties)"></a>方法和属性(Methods and properties)</h3><p>你也可以在<code>enum</code>中像这样定义方法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Wearable</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Weight</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Light</span> = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Armor</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">case</span> <span class="type">Light</span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Helmet</span>(weight: <span class="type">Weight</span>, armor: <span class="type">Armor</span>)</span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">attributes</span><span class="params">()</span></span> -&gt; (weight: <span class="type">Int</span>, armor: <span class="type">Int</span>) &#123;</span><br><span class="line">       <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	         <span class="keyword">case</span> .<span class="type">Helmet</span>(<span class="keyword">let</span> w, <span class="keyword">let</span> a): <span class="keyword">return</span> (weight: w.rawValue * <span class="number">2</span>, armor: w.rawValue * <span class="number">4</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> woodenHelmetProps = <span class="type">Wearable</span>.<span class="type">Helmet</span>(weight: .<span class="type">Light</span>, armor: .<span class="type">Light</span>).attributes()</span><br><span class="line"><span class="built_in">print</span> (woodenHelmetProps)</span><br><span class="line"><span class="comment">// prints "(2, 4)"</span></span><br></pre></td></tr></table></figure>
<p>枚举中的方法为每一个<code>enum case</code>而“生”。所以倘若想要在特定情况执行特定代码的话，你需要分支处理或采用<code>switch</code>语句来明确正确的代码路径。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> iPad, iPhone, <span class="type">AppleTV</span>, <span class="type">AppleWatch</span> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">introduced</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	     <span class="keyword">case</span> <span class="type">AppleTV</span>: <span class="keyword">return</span> <span class="string">"\(self) was introduced 2006"</span></span><br><span class="line">	     <span class="keyword">case</span> iPhone: <span class="keyword">return</span> <span class="string">"\(self) was introduced 2007"</span></span><br><span class="line">	     <span class="keyword">case</span> iPad: <span class="keyword">return</span> <span class="string">"\(self) was introduced 2010"</span></span><br><span class="line">	     <span class="keyword">case</span> <span class="type">AppleWatch</span>: <span class="keyword">return</span> <span class="string">"\(self) was introduced 2014"</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span> (<span class="type">Device</span>.iPhone.introduced())</span><br><span class="line"><span class="comment">// prints: "iPhone was introduced 2007"</span></span><br></pre></td></tr></table></figure>
<h4 id="属性-Properties"><a href="#属性-Properties" class="headerlink" title="属性(Properties)"></a>属性(Properties)</h4><p>尽管增加一个存储属性到枚举中不被允许，但你依然能够创建计算属性。当然，计算属性的内容都是建立在枚举值下或者枚举关联值得到的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> iPad, iPhone</span><br><span class="line">  <span class="keyword">var</span> year: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	    <span class="keyword">case</span> iPhone: <span class="keyword">return</span> <span class="number">2007</span></span><br><span class="line">	    <span class="keyword">case</span> iPad: <span class="keyword">return</span> <span class="number">2010</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态方法-Static-Methods"><a href="#静态方法-Static-Methods" class="headerlink" title="静态方法(Static Methods)"></a>静态方法(Static Methods)</h4><p>你也能够为枚举创建一些静态方法(<code>static methods</code>)。换言之通过一个非枚举类型来创建一个枚举。在这个示例中,我们需要考虑用户有时将苹果设备叫错的情况(比如AppleWatch叫成iWatch)，需要返回一个合适的名称。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="type">AppleWatch</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">fromSlang</span><span class="params">(term: String)</span></span> -&gt; <span class="type">Device?</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> term == <span class="string">"iWatch"</span> &#123;</span><br><span class="line">	  <span class="keyword">return</span> .<span class="type">AppleWatch</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span> (<span class="type">Device</span>.fromSlang(<span class="string">"iWatch"</span>))</span><br></pre></td></tr></table></figure>
<h4 id="可变方法-Mutating-Methods"><a href="#可变方法-Mutating-Methods" class="headerlink" title="可变方法(Mutating Methods)"></a>可变方法(Mutating Methods)</h4><p>方法可以声明为<code>mutating</code>。这样就允许改变隐藏参数<code>self</code>的<code>case</code>值了<a href="#c3"><sup>3<sup></sup></sup></a>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TriStateSwitch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Off</span>, <span class="type">Low</span>, <span class="type">High</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Off</span>:</span><br><span class="line">	    <span class="keyword">self</span> = <span class="type">Low</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Low</span>:</span><br><span class="line">	    <span class="keyword">self</span> = <span class="type">High</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">High</span>:</span><br><span class="line">	    <span class="keyword">self</span> = <span class="type">Off</span></span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ovenLight = <span class="type">TriStateSwitch</span>.<span class="type">Low</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于.On</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于.Off</span></span><br></pre></td></tr></table></figure>
<h3 id="小结-To-Recap"><a href="#小结-To-Recap" class="headerlink" title="小结(To Recap)"></a>小结(To Recap)</h3><p>至此，我们已经大致了解了Swift中枚举语法的基本用例。在开始迈向进阶之路之前，让我们重新审视文章开篇给出的定义，看看现在是否变得更清晰了。</p>
<blockquote>
<p>枚举声明的类型是囊括可能状态的有限集，且可以具有附加值。通过内嵌(<em>nesting</em>),方法(<em>method</em>),关联值(<em>associated values</em>)和模式匹配(<em>pattern matching</em>),枚举可以分层次地定义任何有组织的数据。</p>
</blockquote>
<p>现在我们已经对这个定义更加清晰了。确实，如果我们添加关联值和嵌套，<code>enum</code>就看起来就像一个封闭的、简化的<code>struct</code>。相比较<code>struct</code>，前者优势体现在能够为分类与层次结构编码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Struct Example</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123; <span class="keyword">let</span> x: <span class="type">Int</span>, <span class="keyword">let</span> y: <span class="type">Int</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123; <span class="keyword">let</span> x: <span class="type">Int</span>, <span class="keyword">let</span> y: <span class="type">Int</span>, <span class="keyword">let</span> width: <span class="type">Int</span>, <span class="keyword">let</span> height: <span class="type">Int</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum Example</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GeometricEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Point</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Rect</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法和静态方法的添加允许我们为<code>enum</code>附加功能，这意味着无须依靠额外函数就能实现<a href="#c4"><sup>4<sup></sup></sup></a>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C-Like example</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Buy</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Sell</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">order</span><span class="params">(trade: Trade)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift Enum example</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Buy</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Sell</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">order</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举进阶-Advanced-Enum-Usage）"><a href="#枚举进阶-Advanced-Enum-Usage）" class="headerlink" title="枚举进阶(Advanced Enum Usage）"></a>枚举进阶(Advanced Enum Usage）</h2><h3 id="协议-Protocols"><a href="#协议-Protocols" class="headerlink" title="协议(Protocols)"></a>协议(Protocols)</h3><p>我已经提及了<code>structs</code>和<code>enums</code>之间的相似性。除了附加方法的能力之外，<code>Swift</code>也允许你在枚举中使用<strong>协议(Protocols)</strong>和<strong>协议扩展(Protocol Extension)</strong>。</p>
<p><code>Swift</code>协议定义一个接口或类型以供其他数据结构来遵循。<code>enum</code>当然也不例外。我们先从<code>Swift</code>标准库中的一个例子开始.</p>
<p><code>CustomStringConvertible</code>是一个以打印为目的的自定义格式化输出的类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该协议只有一个要求，即一个只读(<code>getter</code>)类型的字符串(<code>String</code>类型)。我们可以很容易为<code>enum</code>实现这个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Buy</span>, <span class="type">Sell</span></span><br><span class="line">   <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	   <span class="keyword">case</span> <span class="type">Buy</span>: <span class="keyword">return</span> <span class="string">"We're buying something"</span></span><br><span class="line">	   <span class="keyword">case</span> <span class="type">Sell</span>: <span class="keyword">return</span> <span class="string">"We're selling something"</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> action = <span class="type">Trade</span>.<span class="type">Buy</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"this action is \(action)"</span>)</span><br><span class="line"><span class="comment">// prints: this action is We're buying something</span></span><br></pre></td></tr></table></figure>
<p>一些协议的实现可能需要根据内部状态来相应处理要求。例如定义一个管理银行账号的协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AccountCompatible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> remainingFunds: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addFunds</span><span class="params">(amount: Int)</span></span> <span class="keyword">throws</span></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">removeFunds</span><span class="params">(amount: Int)</span></span> <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也许会简单地拿<code>struct</code>实现这个协议，但是考虑应用的上下文，<code>enum</code>是一个更明智的处理方法。不过你无法添加一个存储属性到<code>enum</code>中，就像<code>var remainingFuns:Int</code>。那么你会如何构造呢？答案灰常简单，你可以使用关联值完美解决:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Empty</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Funds</span>(remaining: <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Error</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Overdraft</span>(amount: <span class="type">Int</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> remainingFunds: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Empty</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Funds</span>(<span class="keyword">let</span> remaining): <span class="keyword">return</span> remaining</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了保持代码清爽，我们可以在<code>enum</code>的协议扩展(<code>protocl extension</code>)中定义必须的协议函数:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Account</span>: <span class="title">AccountCompatible</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addFunds</span><span class="params">(amount: Int)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newAmount = amount</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Funds</span>(remaining) = <span class="keyword">self</span> &#123;</span><br><span class="line">      newAmount += remaining</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> newAmount &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">Error</span>.<span class="type">Overdraft</span>(amount: -newAmount)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> newAmount == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">self</span> = .<span class="type">Empty</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">self</span> = .<span class="type">Funds</span>(remaining: newAmount)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">removeFunds</span><span class="params">(amount: Int)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">self</span>.addFunds(amount * -<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> account = <span class="type">Account</span>.<span class="type">Funds</span>(remaining: <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"add: "</span>, <span class="keyword">try</span>? account.addFunds(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"remove 1: "</span>, <span class="keyword">try</span>? account.removeFunds(<span class="number">15</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"remove 2: "</span>, <span class="keyword">try</span>? account.removeFunds(<span class="number">55</span>))</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// : add:  Optional(())</span></span><br><span class="line"><span class="comment">// : remove 1:  Optional(())</span></span><br><span class="line"><span class="comment">// : remove 2:  nil</span></span><br></pre></td></tr></table></figure>
<p>正如你所看见的，我们通过将值存储到<code>enum cases</code>中实现了协议所有要求项。如此做法还有一个妙不可言的地方:现在整个代码基础上你只需要一个模式匹配就能测试空账号输入的情况。你不需要关心剩余资金是否等于零。</p>
<p>同时，我们也在<strong>账号(Accout)</strong>中内嵌了一个遵循<code>ErrorType</code>协议的枚举，这样我们就可以使用<code>Swift2.0</code>语法来进行错误处理了。这里给出更详细的<a href="http://appventure.me/2015/10/17/advanced-practical-enum-examples/#errortype" target="_blank" rel="noopener">使用案例</a>教程。</p>
<h3 id="扩展-Extensions"><a href="#扩展-Extensions" class="headerlink" title="扩展(Extensions)"></a>扩展(Extensions)</h3><p>正如刚才所见，枚举也可以进行扩展。最明显的用例就是将枚举的<code>case</code>和<code>method</code>分离，这样阅读你的代码能够简单快速地消化掉<code>enum</code>内容，紧接着转移到方法定义:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Entities</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Soldier</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tank</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Player</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们为<code>enum</code>扩展方法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Entities</span> </span>&#123;</span><br><span class="line">   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(dist: CGVector)</span></span> &#123;&#125;</span><br><span class="line">   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">attack</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你同样可以通过写一个扩展来遵循一个特定的协议:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Entities</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Soldier</span>(x, y): <span class="keyword">return</span> <span class="string">"\(x), \(y)"</span></span><br><span class="line">       <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Tank</span>(x, y): <span class="keyword">return</span> <span class="string">"\(x), \(y)"</span></span><br><span class="line">       <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Player</span>(x, y): <span class="keyword">return</span> <span class="string">"\(x), \(y)"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举泛型-Generic-Enums"><a href="#枚举泛型-Generic-Enums" class="headerlink" title="枚举泛型(Generic Enums)"></a>枚举泛型(Generic Enums)</h3><p>枚举也支持泛型参数定义。你可以使用它们以适应枚举中的关联值。就拿直接来自<code>Swift</code>标准库中的简单例子来说，即<code>Optional</code>类型。你主要可能通过以下几种方式使用它:可选链(<code>optional chaining(?)</code>)、<code>if-let</code>可选绑定、<code>guard let</code>、或<code>switch</code>，但是从语法角度来说你也可以这么使用<code>Optional</code>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aValue = <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;.<span class="type">Some</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> noValue = <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;.<span class="type">None</span></span><br><span class="line"><span class="keyword">if</span> noValue == <span class="type">Optional</span>.<span class="type">None</span> &#123; <span class="built_in">print</span>(<span class="string">"No value"</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>这是<code>Optional</code>最直接的用例，并未使用任何语法糖，但是不可否认<code>Swift</code>中语法糖的加入使得你的工作更简单。如果你观察上面的实例代码，你恐怕已经猜到<code>Optional</code>内部实现是这样的<a href="#c5"><sup>5<sup></sup></sup></a>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Simplified implementation of Swift's Optional</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MyOptional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">T</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有啥特别呢？注意枚举的关联值采用泛型参数<code>T</code>作为自身类型，这样可选类型构造任何你想要的返回值。</p>
<p>枚举可以拥有多个泛型参数。就拿熟知的<code>Either</code>类为例，它并非是<code>Swift</code>标准库中的一部分，而是实现于众多开源库以及<br>其他函数式编程语言，比如<strong>Haskell</strong>或<strong>F#</strong>。设计想法是这样的:相比较仅仅返回一个值或没有值(née Optional)，你更期望返回一个成功值或者一些反馈信息(比如错误值)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The well-known either type is, of course, an enum that allows you to return either</span></span><br><span class="line"><span class="comment">// value one (say, a successful value) or value two (say an error) from a function</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Either</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Left</span>(<span class="type">T1</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Right</span>(<span class="type">T2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，<code>Swift</code>中所有在<code>class</code>和<code>struct</code>中奏效的类型约束，在<code>enum</code>中同样适用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Totally nonsensical example. A bag that is either full (has an array with contents)</span></span><br><span class="line"><span class="comment">// or empty.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Bag</span>&lt;<span class="title">T</span>: <span class="title">SequenceType</span> <span class="title">where</span> <span class="title">T</span>.<span class="title">Generator</span>.<span class="title">Element</span>==<span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Empty</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Full</span>(contents: <span class="type">T</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归-间接-Indirect-类型"><a href="#递归-间接-Indirect-类型" class="headerlink" title="递归 / 间接(Indirect)类型"></a>递归 / 间接(Indirect)类型</h3><p>间接类型是 Swift 2.0 新增的一个类型。 它们允许将枚举中一个 case 的关联值再次定义为枚举。举个例子，假设我们想定义一个文件系统，用来表示文件以及包含文件的目录。如果将<em>文件</em>和<em>目录</em>定义为枚举的 case，则<em>目录</em> case 的关联值应该再包含一个<em>文件</em>的数组作为它的关联值。因为这是一个递归的操作，编译器需要对此进行一个特殊的准备。Swift 文档中是这么写的：</p>
<blockquote>
<p>枚举和 case 可以被标记为间接的(indrect)，这意味它们的关联值是被间接保存的，这允许我们定义递归的数据结构。</p>
</blockquote>
<p>所以，如果我们要定义 <code>FileNode</code> 的枚举，它应该会是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FileNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">File</span>(name: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">indirect</span> <span class="keyword">case</span> <span class="type">Folder</span>(name: <span class="type">String</span>, files: [<span class="type">FileNode</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的 <code>indrect</code> 关键字告诉编译器间接地处理这个枚举的 case。也可以对整个枚举类型使用这个关键字。<a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/" target="_blank" rel="noopener">作为例子，我们来定义一个二叉树</a>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">Tree</span>&lt;<span class="title">Element</span>: <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Empty</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Node</span>(<span class="type">Tree</span>&lt;<span class="type">Element</span>&gt;,<span class="type">Element</span>,<span class="type">Tree</span>&lt;<span class="type">Element</span>&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个很强大的特性，可以让我们用非常简洁的方式来定义一个有着复杂关联的数据结构。</p>
<h3 id="使用自定义类型作为枚举的值"><a href="#使用自定义类型作为枚举的值" class="headerlink" title="使用自定义类型作为枚举的值"></a>使用自定义类型作为枚举的值</h3><p>如果我们忽略关联值，则枚举的值就只能是整型，浮点型，字符串和布尔类型。如果想要支持别的类型，则可以通过实现 <code>StringLiteralConvertible</code> 协议来完成，这可以让我们通过对字符串的序列化和反序列化来使枚举支持自定义类型。</p>
<p>作为一个例子，假设我们要定义一个枚举来保存不同的 iOS 设备的屏幕尺寸：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Devices</span>: <span class="title">CGSize</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> iPhone3GS = <span class="type">CGSize</span>(width: <span class="number">320</span>, height: <span class="number">480</span>)</span><br><span class="line">   <span class="keyword">case</span> iPhone5 = <span class="type">CGSize</span>(width: <span class="number">320</span>, height: <span class="number">568</span>)</span><br><span class="line">   <span class="keyword">case</span> iPhone6 = <span class="type">CGSize</span>(width: <span class="number">375</span>, height: <span class="number">667</span>)</span><br><span class="line">   <span class="keyword">case</span> iPhone6Plus = <span class="type">CGSize</span>(width: <span class="number">414</span>, height: <span class="number">736</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，这段代码不能通过编译。因为 CGPoint 并不是一个常量，不能用来定义枚举的值。我们需要为想要支持的自定义类型增加一个扩展，让其实现 <code>StringLiteralConvertible</code> 协议。这个协议要求我们实现三个<em>构造方法</em>，这三个方法都需要使用一个<code>String</code>类型的参数，并且我们需要将这个字符串转换成我们需要的类型(此处是<code>CGSize</code>)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGSize</span>: <span class="title">StringLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(stringLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> size = <span class="type">CGSizeFromString</span>(value)</span><br><span class="line">	<span class="keyword">self</span>.<span class="keyword">init</span>(width: size.width, height: size.height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(extendedGraphemeClusterLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> size = <span class="type">CGSizeFromString</span>(value)</span><br><span class="line">	<span class="keyword">self</span>.<span class="keyword">init</span>(width: size.width, height: size.height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(unicodeScalarLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> size = <span class="type">CGSizeFromString</span>(value)</span><br><span class="line">	<span class="keyword">self</span>.<span class="keyword">init</span>(width: size.width, height: size.height)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在就可以来实现我们需要的枚举了，不过这里有一个缺点：初始化的值必须写成字符串形式，因为这就是我们定义的枚举需要接受的类型(记住，我们实现了 StringLiteralConvertible，因此<strong>String</strong>可以转化成<code>CGSize</code>类型)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Devices</span>: <span class="title">CGSize</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> iPhone3GS = <span class="string">"&#123;320, 480&#125;"</span></span><br><span class="line">   <span class="keyword">case</span> iPhone5 = <span class="string">"&#123;320, 568&#125;"</span></span><br><span class="line">   <span class="keyword">case</span> iPhone6 = <span class="string">"&#123;375, 667&#125;"</span></span><br><span class="line">   <span class="keyword">case</span> iPhone6Plus = <span class="string">"&#123;414, 736&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于，我们可以使用 CGPoint 类型的枚举了。需要注意的是，当要获取真实的 CGPoint 的值的时候，我们需要访问枚举的是 <code>rawValue</code> 属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">Devices</span>.iPhone5</span><br><span class="line"><span class="keyword">let</span> b = a.rawValue</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the phone size string is \(a), width is \(b.width), height is \(b.height)"</span>)</span><br><span class="line"><span class="comment">// prints : the phone size string is iPhone5, width is 320.0, height is 568.0</span></span><br></pre></td></tr></table></figure>
<p>使用字符串序列化的形式，会让使用自定义类型的枚举比较困难，然而在某些特定的情况下，这也会给我们增加不少便利(比较使用<strong>NSColor</strong> / <strong>UIColor</strong>的时候)。不仅如此，我们完全可以对自己定义的类型使用这个方法。</p>
<h3 id="对枚举的关联值进行比较"><a href="#对枚举的关联值进行比较" class="headerlink" title="对枚举的关联值进行比较"></a>对枚举的关联值进行比较</h3><p>在通常情况下，枚举是很容易进行相等性判断的。一个简单的 <code>enum T { case a, b }</code> 实现默认支持相等性判断 <code>T.a == T.b, T.b != T.a</code></p>
<p>然而，一旦我们为枚举增加了关联值，Swift 就没有办法正确地为两个枚举进行相等性判断，需要我们自己实现 <code>==</code> 运行符。这并不是很困难：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Trade, rhs: Trade)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> (lhs, rhs) &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="keyword">let</span> (.<span class="type">Buy</span>(stock1, amount1), .<span class="type">Buy</span>(stock2, amount2))</span><br><span class="line">	   <span class="keyword">where</span> stock1 == stock2 &amp;&amp; amount1 == amount2:</span><br><span class="line">	   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">     <span class="keyword">case</span> <span class="keyword">let</span> (.<span class="type">Sell</span>(stock1, amount1), .<span class="type">Sell</span>(stock2, amount2))</span><br><span class="line">	   <span class="keyword">where</span> stock1 == stock2 &amp;&amp; amount1 == amount2:</span><br><span class="line">	   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">     <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我们所见，我们通过 switch 语句对两个枚举的 case 进行判断，并且只有当它们的 case 是匹配的时候(比如 Buy 和 Buy)才对它们的真实关联值进行判断。</p>
<h3 id="自定义构造方法"><a href="#自定义构造方法" class="headerlink" title="自定义构造方法"></a>自定义构造方法</h3><p>在 <strong>静态方法</strong> 一节当中我们已经提到它们可以作为从不同数据构造枚举的方便形式。在之前的例子里也展示过，对出版社经常误用的苹果设备名返回正确的名字：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="type">AppleWatch</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">fromSlang</span><span class="params">(term: String)</span></span> -&gt; <span class="type">Device?</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> term == <span class="string">"iWatch"</span> &#123;</span><br><span class="line">	  <span class="keyword">return</span> .<span class="type">AppleWatch</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以使用自定义构造方法来替换静态方法。枚举与结构体和类的构造方法最大的不同在于，枚举的构造方法需要将隐式的 <code>self</code>  属性设置为正确的 case。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="type">AppleWatch</span> </span><br><span class="line">    <span class="keyword">init</span>?(term: <span class="type">String</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> term == <span class="string">"iWatch"</span> &#123;</span><br><span class="line">	  <span class="keyword">self</span> = .<span class="type">AppleWatch</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用了可失败(failable)的构造方法。但是，普通的构造方法也可以工作得很好：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NumberCategory</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Small</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Medium</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Big</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Huge</span></span><br><span class="line">   <span class="keyword">init</span>(number n: <span class="type">Int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">10000</span> &#123; <span class="keyword">self</span> = .<span class="type">Small</span> &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> n &lt; <span class="number">1000000</span> &#123; <span class="keyword">self</span> = .<span class="type">Medium</span> &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> n &lt; <span class="number">100000000</span> &#123; <span class="keyword">self</span> = .<span class="type">Big</span> &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="keyword">self</span> = .<span class="type">Huge</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> aNumber = <span class="type">NumberCategory</span>(number: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(aNumber)</span><br><span class="line"><span class="comment">// prints: "Small"</span></span><br></pre></td></tr></table></figure>
<h3 id="对枚举的-case-进行迭代"><a href="#对枚举的-case-进行迭代" class="headerlink" title="对枚举的 case 进行迭代"></a>对枚举的 case 进行迭代</h3><p>一个特别经常被问到的问题就是如何对枚举中的 case 进行迭代。可惜的是，枚举并没有遵守<code>SequenceType</code>协议，因此没有一个官方的做法来对其进行迭代。取决于枚举的类型，对其进行迭代可能也简单，也有可能很困难。在<a href="http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type" target="_blank" rel="noopener">StackOverflow</a>上有一个很好的讨论贴。贴子里面讨论到的不同情况太多了，如果只在这里摘取一些会有片面性，而如果将全部情况都列出来，则会太多。</p>
<h3 id="对-Objective-C-的支持"><a href="#对-Objective-C-的支持" class="headerlink" title="对 Objective-C 的支持"></a>对 Objective-C 的支持</h3><p>基于整型的枚举，如 <code>enum Bit: Int { case Zero = 0; case One = 1 }</code> 可以通过 <code>@objc</code> 标识来将其桥接到 Objective-C 当中。然而，一旦使用整型之外的类型(如 <code>String</code>)或者开始使用<strong>关联值</strong>，我们就无法在 Objective-C 当中使用这些枚举了。</p>
<p>有一个名为<a href="http://nshint.io/blog/2015/10/07/easy-cast-with-_ObjectiveCBridgeable/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_11" target="_blank" rel="noopener">_ObjectiveCBridgeable的隐藏协议</a>，可以让规范我们以定义合适的方法，如此一来，Swift 便可以正确地将枚举转成 Objective-C 类型，但我猜这个协议被隐藏起来一定是有原因的。然而，从理论上来讲，这个协议还是允许我们将枚举(包括其实枚举值)正确地桥接到 Objective-C 当中。</p>
<p>但是，我们并不一定非要使用上面提到的这个方法。为枚举添加两个方法，使用 <code>@objc</code> 定义一个替代类型，如此一来我们便可以自由地将枚举进行转换了，并且这种方式不需要遵守私有协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类型也可以定义在 Objective-C 的代码中</span></span><br><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">OTrade</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> stock: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> amount: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(type: <span class="type">Int</span>, stock: <span class="type">String</span>, amount: <span class="type">Int</span>) &#123;</span><br><span class="line">	<span class="keyword">self</span>.type = type</span><br><span class="line">	<span class="keyword">self</span>.stock = stock</span><br><span class="line">	<span class="keyword">self</span>.amount = amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Trade</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toObjc</span><span class="params">()</span></span> -&gt; <span class="type">OTrade</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Buy</span>(stock, amount):</span><br><span class="line">	    <span class="keyword">return</span> <span class="type">OTrade</span>(type: <span class="number">0</span>, stock: stock, amount: amount)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Sell</span>(stock, amount):</span><br><span class="line">	    <span class="keyword">return</span> <span class="type">OTrade</span>(type: <span class="number">1</span>, stock: stock, amount: amount)</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">fromObjc</span><span class="params">(source: OTrade)</span></span> -&gt; <span class="type">Trade?</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> (source.type) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="type">Trade</span>.<span class="type">Buy</span>(stock: source.stock, amount: source.amount)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="type">Trade</span>.<span class="type">Sell</span>(stock: source.stock, amount: source.amount)</span><br><span class="line">	<span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有一个的缺点，我们需要将枚举映射为 Objective-C 中的 <code>NSObject</code> 基础类型(我们也可以直接使用 <code>NSDictionary</code>)，但是，当我们碰到一些确实<strong>需要</strong>在 Objective-C 当中获取有关联值的枚举时，这是一个可以使用的方法。</p>
<h3 id="枚举底层"><a href="#枚举底层" class="headerlink" title="枚举底层"></a>枚举底层</h3><p>Erica Sadun 写过一篇很流弊的<a href="http://ericasadun.com/2015/07/12/swift-enumerations-or-how-to-annoy-tom/" target="_blank" rel="noopener">关于枚举底层的博客</a>，涉及到枚举底层的方方面面。在生产代码中绝不应该使用到这些东西，但是学习一下还是相当有趣的。在这里，我准备只提到那篇博客中一条，如果想了解更多，请移步到原文：</p>
<blockquote>
<p>枚举通常都是一个字节长度。[…]如果你真的很傻很天真，你当然可以定义一个有成百上千个 case 的枚举，在这种情况下，取决于最少所需要的比特数，枚举可能占据两个字节或者更多。</p>
</blockquote>
<h2 id="Swift-标准库中的枚举"><a href="#Swift-标准库中的枚举" class="headerlink" title="Swift 标准库中的枚举"></a>Swift 标准库中的枚举</h2><p>在我们准备继续探索枚举在项目中的不同用例之前，先看一下在 Swift 标准库当中是如何使用枚举可能会更诱人，所以现在让我们先来看看。</p>
<ul>
<li><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Bit_Enumeration/index.html#//apple_ref/swift/enum/s:OSs3Bit" target="_blank" rel="noopener">Bit</a> 这个枚举有两个值，<strong>One</strong> 和 <strong>Zero</strong>。它被作为 <code>CollectionOfOne&lt;T&gt;</code> 中的 <code>Index</code> 类型。</li>
<li><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_FloatingPointClassification_Enumeration/index.html#//apple_ref/swift/enumelt/FloatingPointClassification/s:FOSs27FloatingPointClassification12SignalingNaNFMS_S_" target="_blank" rel="noopener">FloatingPointClassification</a> 这个枚举定义了一系列 IEEE 754 可能的类别，比如 <code>NegativeInfinity</code>, <code>PositiveZero</code> 或 <code>SignalingNaN</code>。</li>
<li><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-AncestorRepresentation_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror22AncestorRepresentation" target="_blank" rel="noopener">Mirror.AncestorRepresentation</a> 和 <a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-DisplayStyle_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror12DisplayStyle" target="_blank" rel="noopener">Mirror.DisplayStyle</a> 这两个枚举被用在 Swift 反射 API 的上下文当中。</li>
<li><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Optional_Enumeration/index.html#//apple_ref/swift/enum/s:Sq" target="_blank" rel="noopener">Optional</a> 这个就不用多说了</li>
<li><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Process_Enumeration/index.html#//apple_ref/swift/enum/s:OSs7Process" target="_blank" rel="noopener">Process</a> 这个枚举包含了当前进程的命令行参数(<code>Process.argc</code>, <code>Process.arguments</code>)。这是一个相当有趣的枚举类型，因为在 Swift 1.0 当中，它是被作为一个结构体来实现的。</li>
</ul>
<h2 id="实践用例"><a href="#实践用例" class="headerlink" title="实践用例"></a>实践用例</h2><p>我们已经在前面几个小节当中看过了许多有用的枚举类型。包括 <code>Optional</code>，<code>Either</code>, <code>FileNode</code> 还有二叉树。然而，还存在很多场合，使用枚举要胜过使用结构体和类。一般来讲，如果问题可以被分解为有限的不同类别，则使用枚举应该就是正确的选择。即使只有两种 case，这也是一个使用枚举的完美场景，正如 Optional 和 Either 类型所展示的。</p>
<p>以下列举了一些枚举类型在实战中的使用示例，可以用来点燃你的创造力。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>说到枚举的实践使用，当然少不了在 Swift 2.0 当中新推出的错误处理。标记为可抛出的函数可以抛出任何遵守了 <code>ErrorType</code> 空协议的类型。正如 Swift 官方文档中所写的：</p>
<blockquote>
<p>Swift 的枚举特别适用于构建一组相关的错误状态，可以通过关联值来为其增加额外的附加信息。</p>
</blockquote>
<p>作为一个示例，我们来看下流行的<a href="https://github.com/thoughtbot/Argo" target="_blank" rel="noopener">JSON解析框架 Argo</a>。当 JSON 解析失败的时候，它有可能是以下两种主要原因：</p>
<ol>
<li>JSON 数据缺少某些最终模型所需要的键(比如你的模型有一个 <code>username</code> 的属性，但是 JSON 中缺少了)</li>
<li>存在类型不匹配，比如说 <code>username</code> 需要的是 String 类型，而 JSON 中包含的是 <code>NSNull</code><a href="#c6"><sup>6</sup></a>。</li>
</ol>
<p>除此之外，Argo 还为不包含在上述两个类别中的错误提供了自定义错误。它们的 <code>ErrorType</code> 枚举是类似这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DecodeError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">TypeMismatch</span>(expected: <span class="type">String</span>, actual: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">MissingKey</span>(<span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Custom</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的 case 都有一个关联值用来包含关于错误的附加信息。</p>
<p>一个更加通用的用于完整 HTTP / REST API 错误处理的<code>ErrorType</code>应该是类似这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">APIError</span> : <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Can't connect to the server (maybe offline?)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ConnectionError</span>(error: <span class="type">NSError</span>)</span><br><span class="line">    <span class="comment">// The server responded with a non 200 status code</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ServerError</span>(statusCode: <span class="type">Int</span>, error: <span class="type">NSError</span>)</span><br><span class="line">    <span class="comment">// We got no data (0 bytes) back from the server</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">NoDataError</span></span><br><span class="line">    <span class="comment">// The server response can't be converted from JSON to a Dictionary</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONSerializationError</span>(error: <span class="type">ErrorType</span>)</span><br><span class="line">    <span class="comment">// The Argo decoding Failed</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONMappingError</span>(converstionError: <span class="type">DecodeError</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>ErrorType</code> 实现了完整的 REST 程序栈解析有可能出现的错误，包含了所有在解析结构体与类时会出现的错误。</p>
<p>如果你看得够仔细，会发现在<code>JSONMappingError</code>中，我们将<strong>Argo</strong>中的<code>DecodeError</code>封装到了我们的<code>APIError</code>类型当中，因为我们会用 Argo 来作实际的 JSON 解析。</p>
<p>更多关于<code>ErrorType</code>以及此种枚举类型的示例可以参看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html" target="_blank" rel="noopener">官方文档</a>。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>在 Swift 当中，有许多方法来构建观察模式。如果使用 <code>@objc</code> 兼容标记，则我们可以使用 <code>NSNotificationCenter</code> 或者 <strong>KVO</strong>。即使不用这个标记，<code>didSet</code>语法也可以很容易地实现简单的观察模式。在这里可以使用枚举，它可以使被观察者的变化更加清晰明了。设想我们要对一个集合进行观察。如果我们稍微思考一下就会发现这只有几种可能的情况：一个或多个项被插入，一个或多个项被删除，一个或多个项被更新。这听起来就是枚举可以完成的工作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Change</span> </span>&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="type">Insertion</span>(items: [<span class="type">Item</span>])</span><br><span class="line">     <span class="keyword">case</span> <span class="type">Deletion</span>(items: [<span class="type">Item</span>])</span><br><span class="line">     <span class="keyword">case</span> <span class="type">Update</span>(items: [<span class="type">Item</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，观察对象就可以使用一个很简洁的方式来获取已经发生的事情的详细信息。这也可以通过为其增加 <strong>oldValue</strong> 和 <strong>newValue</strong> 的简单方法来扩展它的功能。</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>如果我们正在使用一个外部系统，而这个系统使用了状态码(或者错误码)来传递错误信息，类似 HTTP 状态码，这种情况下枚举就是一种很明显并且很好的方式来对信息进行封装<a href="#c7"><sup>7</sup></a> 。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HttpError</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code400</span> = <span class="string">"Bad Request"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code401</span> = <span class="string">"Unauthorized"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code402</span> = <span class="string">"Payment Required"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code403</span> = <span class="string">"Forbidden"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code404</span> = <span class="string">"Not Found"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果类型映射-Map-Result-Types"><a href="#结果类型映射-Map-Result-Types" class="headerlink" title="结果类型映射(Map Result Types)"></a>结果类型映射(Map Result Types)</h3><p>枚举也经常被用于将 JSON 解析后的结果映射成 Swift 的原生类型。这里有一个简短的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">JSON</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONString</span>(<span class="type">Swift</span>.<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONNumber</span>(<span class="type">Double</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONObject</span>([<span class="type">String</span> : <span class="type">JSONValue</span>])</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONArray</span>([<span class="type">JSONValue</span>])</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONBool</span>(<span class="type">Bool</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONNull</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，如果我们解析了其它的东西，也可以使用这种方式将解析结果转化我们 Swift 的类型。</p>
<h3 id="UIKit-标识"><a href="#UIKit-标识" class="headerlink" title="UIKit 标识"></a>UIKit 标识</h3><p>枚举可以用来将字符串类型的重用标识或者 storyboard 标识映射为类型系统可以进行检查的类型。假设我们有一个拥有很多原型 Cell 的 UITableView：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CellType</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ButtonValueCell</span> = <span class="string">"ButtonValueCell"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">UnitEditCell</span> = <span class="string">"UnitEditCell"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">LabelCell</span> = <span class="string">"LabelCell"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ResultLabelCell</span> = <span class="string">"ResultLabelCell"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><p>单位以及单位转换是另一个使用枚举的绝佳场合。可以将单位及其对应的转换率映射起来，然后添加方法来对单位进行自动的转换。以下是一个相当简单的示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Liquid</span>: <span class="title">Float</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> ml = <span class="number">1.0</span></span><br><span class="line">  <span class="keyword">case</span> l = <span class="number">1000.0</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(amount amount: Float, to: Liquid)</span></span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">self</span>.rawValue &lt; to.rawValue &#123;</span><br><span class="line">	 <span class="keyword">return</span> (<span class="keyword">self</span>.rawValue / to.rawValue) * amount</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 <span class="keyword">return</span> (<span class="keyword">self</span>.rawValue * to.rawValue) * amount</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Convert liters to milliliters</span></span><br><span class="line"><span class="built_in">print</span> (<span class="type">Liquid</span>.l.convert(amount: <span class="number">5</span>, to: <span class="type">Liquid</span>.ml))</span><br></pre></td></tr></table></figure>
<p>另一个示例是货币的转换。以及数学符号(比如角度与弧度)也可以从中受益。</p>
<h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>游戏也是枚举中的另一个相当好的用例，屏幕上的大多数实体都属于一个特定种族的类型(敌人，障碍，纹理，…)。相对于本地的 iOS 或者 Mac 应用，游戏更像是一个白板。即开发游戏我们可以使用全新的对象以及全新的关联创造一个全新的世界，而 iOS 或者 OSX 需要使用预定义的 UIButtons，UITableViews，UITableViewCells 或者 NSStackView.</p>
<p>不仅如此，由于枚举可以遵守协议，我们可以利用协议扩展和基于协议的编程为不同为游戏定义的枚举增加功能。这里是一个用来展示这种层级的的简短示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FlyingBeast</span> </span>&#123; <span class="keyword">case</span> <span class="type">Dragon</span>, <span class="type">Hippogriff</span>, <span class="type">Gargoyle</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Horde</span> </span>&#123; <span class="keyword">case</span> <span class="type">Ork</span>, <span class="type">Troll</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Player</span> </span>&#123; <span class="keyword">case</span> <span class="type">Mage</span>, <span class="type">Warrior</span>, <span class="type">Barbarian</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NPC</span> </span>&#123; <span class="keyword">case</span> <span class="type">Vendor</span>, <span class="type">Blacksmith</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Element</span> </span>&#123; <span class="keyword">case</span> <span class="type">Tree</span>, <span class="type">Fence</span>, <span class="type">Stone</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Hurtable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Killable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Flying</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Attacking</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Obstacle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FlyingBeast</span>: <span class="title">Hurtable</span>, <span class="title">Killable</span>, <span class="title">Flying</span>, <span class="title">Attacking</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Horde</span>: <span class="title">Hurtable</span>, <span class="title">Killable</span>, <span class="title">Attacking</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Player</span>: <span class="title">Hurtable</span>, <span class="title">Obstacle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NPC</span>: <span class="title">Hurtable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Element</span>: <span class="title">Obstacle</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串类型化"><a href="#字符串类型化" class="headerlink" title="字符串类型化"></a>字符串类型化</h3><p>在一个稍微大一点的 Xcode 项目中，我们很快就会有一大堆通过字符串来访问的资源。在前面的小节中，我们已经提过重用标识和 storyboard 的标识，但是除了这两样，还存在很多资源：图像，Segues，Nibs，字体以及其它资源。通常情况下，这些资源都可以分成不同的集合。如果是这样的话，一个类型化的字符串会是一个让编译器帮我们进行类型检查的好方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DetailViewImages</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Background</span> = <span class="string">"bg1.png"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Sidebar</span> = <span class="string">"sbg.png"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">ActionButton1</span> = <span class="string">"btn1_1.png"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">ActionButton2</span> = <span class="string">"btn2_1.png"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 iOS 开发者，<a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener">R.swift</a>这个第三方库可以为以上提到的情况自动生成结构体。但是有些时候你可能需要有更多的控制(或者你可能是一个Mac开发者<a href="#c8"><sup>8</sup></a>)。</p>
<h3 id="API-端点"><a href="#API-端点" class="headerlink" title="API 端点"></a>API 端点</h3><p>Rest API 是枚举的绝佳用例。它们都是分组的，它们都是有限的 API 集合，并且它们也可能会有附加的查询或者命名的参数，而这可以使用关联值来实现。</p>
<p>这里有个 <a href="https://instagram.com/developer/endpoints/media/" target="_blank" rel="noopener">Instagram API</a> 的简化版：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Instagram</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Media</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Popular</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Shortcode</span>(id: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Search</span>(lat: <span class="type">Float</span>, min_timestamp: <span class="type">Int</span>, lng: <span class="type">Float</span>, max_timestamp: <span class="type">Int</span>, <span class="built_in">distance</span>: <span class="type">Int</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Users</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">User</span>(id: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Feed</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Recent</span>(id: <span class="type">String</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Ash Furrow的<strong>Moya</strong>框架</a>就是基本这个思想，使用枚举对 rest 端点进行映射。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>Airspeed Velocity有一篇<a href="http://airspeedvelocity.net/tag/swift/" target="_blank" rel="noopener">极好的文章</a>说明了如何使用枚举来实现一个链表。那篇文章中的大多数代码都超出了枚举的知识，并涉及到了大量其它有趣的主题<a href="#c9"><sup>9</sup></a>，但是，链表最基本的定义是类似这样的(我对其进行了一些简化)：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">End</span></span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> <span class="type">Node</span>(<span class="type">Int</span>, next: <span class="type">List</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个节点(Node) case 都指向了下一个 case， 通过使用枚举而非其它类型，我们可以避免使用一个可选的 next 类型以用来表示链表的结束。</p>
<p>Airspeed Velocity 还写过一篇超赞的博客，关于如何使用 Swift 的间接枚举类型来实现红黑树，所以如果你已经阅读过关于链表的博客，你可能想继续阅读<a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/" target="_blank" rel="noopener">这篇关于红黑树的博客</a>。</p>
<h3 id="设置字典-Setting-Dictionaries"><a href="#设置字典-Setting-Dictionaries" class="headerlink" title="设置字典(Setting Dictionaries)"></a>设置字典(Setting Dictionaries)</h3><p>这是 Erica Sadun 提出的<a href="http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_12" target="_blank" rel="noopener">非常非常机智的解决方案</a>。简单来讲，就是任何我们需要用一个属性的字典来对一个项进行设置的时候，都应该使用一系列有关联值的枚举来替代。使用这方法，类型检查系统可以确保配置的值都是正确的类型。</p>
<p><a href="http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_12" target="_blank" rel="noopener">关于更多的细节，以及合适的例子，可以阅读下她的文章</a>。</p>
<h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><p>与之前类似，我将会用一系列枚举的局限性来结束本篇文章。</p>
<h3 id="提取关联值"><a href="#提取关联值" class="headerlink" title="提取关联值"></a>提取关联值</h3><p>David Owens写过一篇<a href="http://owensd.io/2015/09/15/associated-enum-cases-as-types.html" target="_blank" rel="noopener">文章</a>，他觉得当前的关联值提取方式是很笨重的。我墙裂推荐你去看一下他的原文，在这里我对它的要旨进行下说明：为了从一个枚举中获取关联值，我们必须使用模式匹配。然而，关联值就是关联在特定枚举 case 的高效元组。而元组是可以使用更简单的方式来获取它内部值，即 <code>.keyword 或者 .0</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enums</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ex</span> </span>&#123; <span class="keyword">case</span> <span class="type">Mode</span>(ab: <span class="type">Int</span>, cd: <span class="type">Int</span>) &#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="type">Ex</span>.<span class="type">Mode</span>(<span class="keyword">let</span> ab, <span class="keyword">let</span> cd) = <span class="type">Ex</span>.<span class="type">Mode</span>(ab: <span class="number">4</span>, cd: <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(ab)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vs tuples:</span></span><br><span class="line"><span class="keyword">let</span> tp = (ab: <span class="number">4</span>, cd: <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tp.ab)</span><br></pre></td></tr></table></figure>
<p>如果你也同样觉得我们应该使用相同的方法来对枚举进行解构(deconstruct)，这里有个 rdar: <a href="http://openradar.me/22704262" target="_blank" rel="noopener">rdar://22704262</a> (译者注：一开始我不明白 rdar 是啥意思，后来我 google 了下，如果你也有兴趣，也可以自己去搜索一下)</p>
<h3 id="相等性"><a href="#相等性" class="headerlink" title="相等性"></a>相等性</h3><p>拥有关联值的枚举没有遵守 <code>equatable</code> 协议。这是一个遗憾，因为它为很多事情增加了不必要的复杂和麻烦。深层的原因可能是因为关联值的底层使用是使用了元组，而元组并没有遵守 <code>equatable</code> 协议。然而，对于限定的 case 子集，如果这些关联值的类型都遵守了 <code>equatable</code> 类型，我认为编译器应该默认为其生成 <code>equatable</code> 扩展。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Int 和 String 是可判等的, 所以 Mode 应该也是可判等的</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ex</span> </span>&#123; <span class="keyword">case</span> <span class="type">Mode</span>(ab: <span class="type">Int</span>, cd: <span class="type">String</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift 应该能够自动生成这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Ex.Mode, rhs: Ex.Mode)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (lhs, rhs) &#123;</span><br><span class="line">       <span class="keyword">case</span> (.<span class="type">Mode</span>(<span class="keyword">let</span> a, <span class="keyword">let</span> b), .<span class="type">Mode</span>(<span class="keyword">let</span> <span class="built_in">c</span>, <span class="keyword">let</span> d)):</span><br><span class="line">	   <span class="keyword">return</span> a == <span class="built_in">c</span> &amp;&amp; b == d</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">	   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元组-Tuples"><a href="#元组-Tuples" class="headerlink" title="元组(Tuples)"></a>元组(Tuples)</h3><p>最大的问题就是对<a href="http://appventure.me/2015/07/19/tuples-swift-advanced-usage-best-practices/" target="_blank" rel="noopener">元组的支持</a>。我喜欢使用元组，它们可以使很多事情变得更简单，但是他们目前还处于无文档状态并且在很多场合都无法使用。在枚举当中，我们无法使用元组作为枚举的值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Devices</span>: (<span class="title">intro</span>: <span class="title">Int</span>, <span class="title">name</span>: <span class="title">String</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> iPhone = (intro: <span class="number">2007</span>, name: <span class="string">"iPhone"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">AppleTV</span> = (intro: <span class="number">2006</span>, name: <span class="string">"Apple TV"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">AppleWatch</span> = (intro: <span class="number">2014</span>, name: <span class="string">"Apple Watch"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这似乎看起来并不是一个最好的示例，但是我们一旦开始使用枚举，就会经常陷入到需要用到类似上面这个示例的情形中。</p>
<h3 id="迭代枚举的所有case"><a href="#迭代枚举的所有case" class="headerlink" title="迭代枚举的所有case"></a>迭代枚举的所有case</h3><p>这个我们已经在前面讨论过了。目前还没有一个很好的方法来获得枚举中的所有 case 的集合以使我们可以对其进行迭代。</p>
<h3 id="默认关联值"><a href="#默认关联值" class="headerlink" title="默认关联值"></a>默认关联值</h3><p>另一个会碰到的事是枚举的关联值总是类型，但是我们却无法为这些类型指定默认值。假设有这样一种情况:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Characters</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Mage</span>(health: <span class="type">Int</span> = <span class="number">70</span>, magic: <span class="type">Int</span> = <span class="number">100</span>, strength: <span class="type">Int</span> = <span class="number">30</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Warrior</span>(health: <span class="type">Int</span> = <span class="number">100</span>, magic: <span class="type">Int</span> = <span class="number">0</span>, strength: <span class="type">Int</span> = <span class="number">100</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Neophyte</span>(health: <span class="type">Int</span> = <span class="number">50</span>, magic: <span class="type">Int</span> = <span class="number">20</span>, strength: <span class="type">Int</span> = <span class="number">80</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们依然可以使用不同的值创建新的 case，但是角色的默认设置依然会被映射。</p>
<h2 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h2><h3 id="10-26-2015"><a href="#10-26-2015" class="headerlink" title="10/26/2015"></a>10/26/2015</h3><ul>
<li>增加局限性示例(相等性 &amp; 获取关联值)</li>
<li>增加 Erica Sadun 的关联枚举示例</li>
</ul>
<h3 id="10-22-2015"><a href="#10-22-2015" class="headerlink" title="10/22/2015"></a>10/22/2015</h3><ul>
<li>合并<a href="https://github.com/terhechte/appventure-blog/pull/6" target="_blank" rel="noopener">来自 #6 @mabidakun</a>的PR</li>
<li>增加枚举底层的链接</li>
<li>将帐号示例拆分为两个更容易理解的片段。</li>
</ul>
<h3 id="10-21-2015"><a href="#10-21-2015" class="headerlink" title="10/21/2015"></a>10/21/2015</h3><ul>
<li>合并<a href="https://github.com/terhechte/appventure-blog/pull/4" target="_blank" rel="noopener">来自 #4 @blixt</a>和<a href="https://github.com/terhechte/appventure-blog/pull/2" target="_blank" rel="noopener">#2 @kandelvijayavolare</a>和<a href="https://github.com/terhechte/appventure-blog/pull/3" target="_blank" rel="noopener">#3 @sriniram</a>以及<a href="https://github.com/terhechte/appventure-blog/pull/5" target="_blank" rel="noopener">#5 @SixFiveSoftware</a>的PR</li>
<li>为帐号示例添加调用代码</li>
<li>增加 <code>ErrorType</code> 示例</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p><a name="c1"></a></p>
<ul>
<li><p>1、可以使用一些小技术来达到这个目的，具体的请参照下面的文章内容<br><a name="c2"></a></p>
</li>
<li><p>2、为了演示的缘故，这个示例的实现经过的简化。在真实的开发中，应该使用可选类型以及反向顺序的参数。可以参考一下现在十分流行的函数式编程库，如 <a href="https://github.com/typelift/Swiftz" target="_blank" rel="noopener">Swiftz</a> 和 <a href="https://github.com/ankurp/Dollar.swift" target="_blank" rel="noopener">Dollar</a><br><a name="c3"></a></p>
</li>
<li><p>3、这个示例直接采用了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID234" target="_blank" rel="noopener">Swift 官方文档的示例</a><br><a name="c4"></a></p>
</li>
<li><p>4、经常使得他们定义的位置很难被发现<br><a name="c5"></a></p>
</li>
<li><p>5、这是一个简化版的，当然，Swift 为我们加了很多的语法糖<br><a name="c6"></a></p>
</li>
<li><p>6、如果你在应用中使用过 JSON，应该也曾经碰到过这个问题<br><a name="c6"></a></p>
</li>
<li><p>7、顺便一提，不能直接使用数字做为枚举 case 的名称，因此直接使用 400 是不行的<br><a name="c8"></a></p>
</li>
<li><p>8、虽然如此，不过支持 Mac 版的 R.swift 好像就快推出了<br><a name="c9"></a></p>
</li>
<li><p>9、这句话可以解释为: 打开链接，并开始阅读文章</p>
</li>
</ul>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/APPVENTURE/">APPVENTURE</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Swift-进阶/">Swift 进阶</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://swift.gg/2015/11/20/advanced-practical-enum-examples/" data-title="Swift 中枚举高级用法及实践 | SwiftGG" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/2015/11/23/swift-reflection-api-what-you-can-do/" title="Swift 反射 API 及用法">
  <strong>上一篇</strong><br>
  <span>
  Swift 反射 API 及用法</span>
</a>
</div>


<div class="next">
<a href="/2015/11/19/3d-touch-tutorial/" title="3D Touch介绍：电子秤App与快捷操作">
 <strong>下一篇</strong><br> 
 <span>3D Touch介绍：电子秤App与快捷操作
</span>
</a>
</div>

</nav>

	


<section id="comments" class="comment">
  <div id="gitcomment">
  </div>
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
    var gitment = new Gitment({
      id: "2015/11/20/advanced-practical-enum-examples/",
      owner: "SwiftGGBot",
      repo: "gg-comment",
      oauth: {
        client_id: "8ed6aa0071e9d92f7ffc",
        client_secret: "29cc2c70290fad40a967780e5b49d86501348ddf",
      },
    })
    gitment.render('gitcomment')
    </script>
</section>



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#深入理解-Diving-In"><span class="toc-number">1.</span> <span class="toc-text">深入理解(Diving In)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义基本的枚举类型-Defining-Basic-Enums"><span class="toc-number">1.1.</span> <span class="toc-text">定义基本的枚举类型(Defining Basic Enums)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举值-Enum-Values"><span class="toc-number">1.2.</span> <span class="toc-text">枚举值(Enum Values)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套枚举-Nesting-Enums"><span class="toc-number">1.3.</span> <span class="toc-text">嵌套枚举(Nesting Enums)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包含枚举-Containing-Enums"><span class="toc-number">1.4.</span> <span class="toc-text">包含枚举(Containing Enums)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关联值-Associated-Value"><span class="toc-number">1.5.</span> <span class="toc-text">关联值(Associated Value)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简单例程-Simple-Example"><span class="toc-number">1.5.1.</span> <span class="toc-text">简单例程(Simple Example)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模式匹配-Pattern-Mathching"><span class="toc-number">1.5.2.</span> <span class="toc-text">模式匹配(Pattern Mathching)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标签-Labels"><span class="toc-number">1.5.3.</span> <span class="toc-text">标签(Labels)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#元组参数-Tuple-as-Arguments"><span class="toc-number">1.5.4.</span> <span class="toc-text">元组参数(Tuple as Arguments)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用案例-Use-Case-Example"><span class="toc-number">1.5.5.</span> <span class="toc-text">使用案例(Use Case Example)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法和属性-Methods-and-properties"><span class="toc-number">1.6.</span> <span class="toc-text">方法和属性(Methods and properties)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性-Properties"><span class="toc-number">1.6.1.</span> <span class="toc-text">属性(Properties)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态方法-Static-Methods"><span class="toc-number">1.6.2.</span> <span class="toc-text">静态方法(Static Methods)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可变方法-Mutating-Methods"><span class="toc-number">1.6.3.</span> <span class="toc-text">可变方法(Mutating Methods)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结-To-Recap"><span class="toc-number">1.7.</span> <span class="toc-text">小结(To Recap)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举进阶-Advanced-Enum-Usage）"><span class="toc-number">2.</span> <span class="toc-text">枚举进阶(Advanced Enum Usage）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#协议-Protocols"><span class="toc-number">2.1.</span> <span class="toc-text">协议(Protocols)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展-Extensions"><span class="toc-number">2.2.</span> <span class="toc-text">扩展(Extensions)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举泛型-Generic-Enums"><span class="toc-number">2.3.</span> <span class="toc-text">枚举泛型(Generic Enums)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归-间接-Indirect-类型"><span class="toc-number">2.4.</span> <span class="toc-text">递归 / 间接(Indirect)类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用自定义类型作为枚举的值"><span class="toc-number">2.5.</span> <span class="toc-text">使用自定义类型作为枚举的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对枚举的关联值进行比较"><span class="toc-number">2.6.</span> <span class="toc-text">对枚举的关联值进行比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义构造方法"><span class="toc-number">2.7.</span> <span class="toc-text">自定义构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对枚举的-case-进行迭代"><span class="toc-number">2.8.</span> <span class="toc-text">对枚举的 case 进行迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对-Objective-C-的支持"><span class="toc-number">2.9.</span> <span class="toc-text">对 Objective-C 的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举底层"><span class="toc-number">2.10.</span> <span class="toc-text">枚举底层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Swift-标准库中的枚举"><span class="toc-number">3.</span> <span class="toc-text">Swift 标准库中的枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实践用例"><span class="toc-number">4.</span> <span class="toc-text">实践用例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#错误处理"><span class="toc-number">4.1.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#观察者模式"><span class="toc-number">4.2.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态码"><span class="toc-number">4.3.</span> <span class="toc-text">状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结果类型映射-Map-Result-Types"><span class="toc-number">4.4.</span> <span class="toc-text">结果类型映射(Map Result Types)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UIKit-标识"><span class="toc-number">4.5.</span> <span class="toc-text">UIKit 标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单位"><span class="toc-number">4.6.</span> <span class="toc-text">单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#游戏"><span class="toc-number">4.7.</span> <span class="toc-text">游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串类型化"><span class="toc-number">4.8.</span> <span class="toc-text">字符串类型化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-端点"><span class="toc-number">4.9.</span> <span class="toc-text">API 端点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表"><span class="toc-number">4.10.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置字典-Setting-Dictionaries"><span class="toc-number">4.11.</span> <span class="toc-text">设置字典(Setting Dictionaries)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#局限"><span class="toc-number">5.</span> <span class="toc-text">局限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#提取关联值"><span class="toc-number">5.1.</span> <span class="toc-text">提取关联值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相等性"><span class="toc-number">5.2.</span> <span class="toc-text">相等性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元组-Tuples"><span class="toc-number">5.3.</span> <span class="toc-text">元组(Tuples)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代枚举的所有case"><span class="toc-number">5.4.</span> <span class="toc-text">迭代枚举的所有case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#默认关联值"><span class="toc-number">5.5.</span> <span class="toc-text">默认关联值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变化"><span class="toc-number">6.</span> <span class="toc-text">变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-26-2015"><span class="toc-number">6.1.</span> <span class="toc-text">10/26/2015</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-22-2015"><span class="toc-number">6.2.</span> <span class="toc-text">10/22/2015</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-21-2015"><span class="toc-number">6.3.</span> <span class="toc-text">10/21/2015</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释"><span class="toc-number">7.</span> <span class="toc-text">解释</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/APPVENTURE/" title="APPVENTURE">APPVENTURE<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/Andyy-Hope/" title="Andyy Hope">Andyy Hope<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/AppCoda/" title="AppCoda">AppCoda<sup>44</sup></a></li>
		  
		
		  
			<li><a href="/categories/Arthur-Knopper/" title="Arthur Knopper">Arthur Knopper<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Big-O-Note-Taking/" title="Big O Note-Taking">Big O Note-Taking<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Coding-Explorer-Blog/" title="Coding Explorer Blog">Coding Explorer Blog<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Crunchy-Development/" title="Crunchy Development">Crunchy Development<sup>25</sup></a></li>
		  
		
		  
			<li><a href="/categories/Erica-Sadun/" title="Erica Sadun">Erica Sadun<sup>68</sup></a></li>
		  
		
		  
			<li><a href="/categories/IOSCREATOR/" title="IOSCREATOR">IOSCREATOR<sup>29</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jacob-Bandes-Storch/" title="Jacob Bandes-Storch">Jacob Bandes-Storch<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jameson-Quave/" title="Jameson Quave">Jameson Quave<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/JamesonQuave-com/" title="JamesonQuave.com">JamesonQuave.com<sup>18</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jesse-Squires/" title="Jesse Squires">Jesse Squires<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/KHANLOU/" title="KHANLOU">KHANLOU<sup>22</sup></a></li>
		  
		
		  
			<li><a href="/categories/Khanlou/" title="Khanlou">Khanlou<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mike-Ash/" title="Mike Ash">Mike Ash<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/NSHipster/" title="NSHipster">NSHipster<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift/NSHipster/" title="NSHipster">NSHipster<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Natasha-The-Robot/" title="Natasha The Robot">Natasha The Robot<sup>48</sup></a></li>
		  
		
		  
			<li><a href="/categories/PhotoKit/Ole-Begemann/" title="Ole Begemann">Ole Begemann<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Ole-Begemann/" title="Ole Begemann">Ole Begemann<sup>37</sup></a></li>
		  
		
		  
			<li><a href="/categories/Ole-Begemannh/" title="Ole Begemannh">Ole Begemannh<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Olivier-Halligon/" title="Olivier Halligon">Olivier Halligon<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Open-Source-Swift/" title="Open Source Swift">Open Source Swift<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/PhotoKit/" title="PhotoKit">PhotoKit<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Raj-Kandathi/" title="Raj Kandathi">Raj Kandathi<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Reinder-de-Vries/" title="Reinder de Vries">Reinder de Vries<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Russ-Bishop/" title="Russ Bishop">Russ Bishop<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Soroush-Khanlou/" title="Soroush Khanlou">Soroush Khanlou<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Olivier-Halligon/Swift/" title="Swift">Swift<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift/" title="Swift">Swift<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mike-Ash/Swift/" title="Swift">Swift<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift-and-Painless/" title="Swift and Painless">Swift and Painless<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/Swift-入门/" title="Swift 入门">Swift 入门<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift-进阶/" title="Swift 进阶">Swift 进阶<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Think-and-Build/" title="Think and Build">Think and Build<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Thomas-Hanning/" title="Thomas Hanning">Thomas Hanning<sup>22</sup></a></li>
		  
		
		  
			<li><a href="/categories/Thoughtbot/" title="Thoughtbot">Thoughtbot<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tomasz-Szulc/" title="Tomasz Szulc">Tomasz Szulc<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/Wooji-Juice/" title="Wooji Juice">Wooji Juice<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/alisoftware/" title="alisoftware">alisoftware<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/alloc-init/" title="alloc-init">alloc-init<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/appcoda/" title="appcoda">appcoda<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/codingexplorer/" title="codingexplorer">codingexplorer<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iAchieved-it/" title="iAchieved.it">iAchieved.it<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/AppCoda/iOS/" title="iOS">iOS<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开发/" title="iOS 开发">iOS 开发<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/iOS-开发/" title="iOS 开发">iOS 开发<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/khanlou-com/" title="khanlou.com">khanlou.com<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/machinethink/" title="machinethink">machinethink<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/medium-com/" title="medium.com">medium.com<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/mikeash-com/" title="mikeash.com">mikeash.com<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/radex-io/" title="radex.io">radex.io<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/swift-org/" title="swift.org">swift.org<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/swiftandpainless/" title="swiftandpainless">swiftandpainless<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/thomashanning/" title="thomashanning">thomashanning<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/uraimo/" title="uraimo">uraimo<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/原创文章/" title="原创文章">原创文章<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/投稿/" title="投稿">投稿<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播资源/" title="直播资源">直播资源<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/社区问答/" title="社区问答">社区问答<sup>19</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Swift-进阶/" title="Swift 进阶">Swift 进阶<sup>170</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-入门/" title="Swift 入门">Swift 入门<sup>130</sup></a></li>
			
		
			
				<li><a href="/tags/Swift/" title="Swift">Swift<sup>103</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-开发/" title="iOS 开发">iOS 开发<sup>85</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-跨平台/" title="Swift 跨平台">Swift 跨平台<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-开源信息/" title="Swift 开源信息">Swift 开源信息<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/NSHipster/" title="NSHipster">NSHipster<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-3/" title="Swift 3">Swift 3<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/WatchOS-2/" title="WatchOS 2">WatchOS 2<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-入门/" title="iOS 入门">iOS 入门<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/教程/" title="教程">教程<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Xcode/" title="Xcode">Xcode<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Apple-TV-开发/" title="Apple TV 开发">Apple TV 开发<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-9/" title="iOS 9">iOS 9<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/IOSCREATOR/" title="IOSCREATOR">IOSCREATOR<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-2/" title="Swift 2">Swift 2<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/社区问答/" title="社区问答">社区问答<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Jesse-Squires/" title="Jesse Squires">Jesse Squires<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Design-Patterns/" title="Design Patterns">Design Patterns<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C/" title="Objective-C">Objective-C<sup>3</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://c4ios.swift.gg" target="_blank" title="C4iOS 教程">C4iOS 教程</a>
            
          </li>
        
          <li>
            
            	<a href="http://swift.gg/2016/03/14/live-video/" target="_blank" title="SwiftGG直播">SwiftGG直播</a>
            
          </li>
        
          <li>
            
            	<a href="http://t.swift.gg/" target="_blank" title="T 沙龙">T 沙龙</a>
            
          </li>
        
          <li>
            
            	<a href="http://codebuild.me" target="_blank" title="Code Build Me">Code Build Me</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.saitjr.com" target="_blank" title="//TODO:">//TODO:</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.5isjyx.com/" target="_blank" title="chiba">chiba</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.cee.moe" target="_blank" title="Perfect Freeze">Perfect Freeze</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftyper.com" target="_blank" title="小锅的 swift 之路">小锅的 swift 之路</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.futantan.com/" target="_blank" title="Prayer 的博客">Prayer 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.csdn.net/mmoaay" target="_blank" title="画渣程序猿 mmoaay">画渣程序猿 mmoaay</a>
            
          </li>
        
          <li>
            
            	<a href="http://linusling.com" target="_blank" title="小铁匠的 swift 之路">小铁匠的 swift 之路</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" title="ppppppmst 的简书博客">ppppppmst 的简书博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://chenmingbiao.github.io/" target="_blank" title="CMB 的博客">CMB 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://wxgbridgeq.github.io/" target="_blank" title="BridgeQ">BridgeQ</a>
            
          </li>
        
          <li>
            
            	<a href="http://chengway.in" target="_blank" title="walkingway 的博客">walkingway 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.dianqk.org" target="_blank" title="靛青K">靛青K</a>
            
          </li>
        
          <li>
            
            	<a href="http://alanmelody.com/" target="_blank" title="JackAlan">JackAlan</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftconchina.com" target="_blank" title="SwiftConChina">SwiftConChina</a>
            
          </li>
        
          <li>
            
            	<a href="http://swiftcn.io" target="_blank" title="Swift 中国">Swift 中国</a>
            
          </li>
        
          <li>
            
            	<a href="https://boxueio.com/" target="_blank" title="泊学">泊学</a>
            
          </li>
        
          <li>
            
            	<a href="https://bearychat.com/" target="_blank" title="BearyChat">BearyChat</a>
            
          </li>
        
          <li>
            
            	<a href="http://bbs.php-z.com" target="_blank" title="PHP-Z 论坛">PHP-Z 论坛</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftguide.cn" target="_blank" title="官方文档">官方文档</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.upyun.com/" target="_blank" title="又拍云赞助图床">又拍云赞助图床</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="wechatpart">
	<p class="asidetitle">微信公众号</p>
	<img src="/img/wechat.jpg">
</div>

</aside>
</div>
    </div>
    <footer>


<div id="footer">
	
	<div class="social-font">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="SwiftGG">SwiftGG</a>
		
		 | 
		<a href="http://www.miitbeian.gov.cn" target="_blank">浙ICP备14022870号-3</a>
		</p>
</div>
<img src="/img/logo_new.jpg" style="position: fixed; top: -9999px;height: 500px;width: 500px;">
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script src="/js/mm.js"></script>
<script src="/js/subscribe.js"></script>

<div id="swiftweekly" style="display:none;">
  <img id="closeme" src="/img/close.png">
  <span id="sw_slogan">SwiftUI 重磅教程专属优惠：<b><a style="color: white;text-decoration:underline;" target="_blank" href="https://j.youzan.com/H9aEpi">使用 SwiftGG 优惠码，半价基础上再减 20 元！</a></b>&nbsp;</span>
  <!-- <form id="content"> -->
    <!-- <input name="email" id="sw_email" placeholder="输入邮箱地址" type="email" /><a class="sw_sub">订阅</a> -->
  <!-- </form> -->
</div>

<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<script type="text/javascript">
$(document).ready(function(){

  

  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66150920-1', 'auto');
  ga('send', 'pageview');

</script>





<!-- Analytics End -->

<!-- Totop Begin -->
<!--
	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>
-->
<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
