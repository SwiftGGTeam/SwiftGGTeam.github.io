
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="baidu-site-verification" content="vqJV77bZM6">
  
    <title>使用 Swift 从头构建 LISP 解释器 | Swift 教程 - Swift 语言学习 - Swift code - SwiftGG 翻译组 - 高质量的 Swift 译文网站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="SwiftGG">
    

    <meta name="keywords" content="swift语言,swift翻译,swift学习">
    <meta name="applicable-device" content="pc,mobile">
    <meta name="description" content="作者：uraimo，原文链接，原文日期：2017-02-05译者：pmst；校对：Yake；定稿：CMB   有人建议我写一个小型语言解释器，如果是 LISP 那就更完美了。作为一名程序员，这是你职业生涯必须经历的事情之一，也是一次让你大开眼界的经历：你会对日常工作中的工具产生新的见解，那些令人望而生畏的概念也会被慢慢掀开神秘的面纱。 本文中，我们基于 1978 年 John McCarthy">
<meta name="keywords" content="Swift 进阶">
<meta property="og:type" content="article">
<meta property="og:title" content="使用 Swift 从头构建 LISP 解释器">
<meta property="og:url" content="https://swift.gg/2017/03/08/building-a-lisp-from-scratch-with-swift/index.html">
<meta property="og:site_name" content="SwiftGG">
<meta property="og:description" content="作者：uraimo，原文链接，原文日期：2017-02-05译者：pmst；校对：Yake；定稿：CMB   有人建议我写一个小型语言解释器，如果是 LISP 那就更完美了。作为一名程序员，这是你职业生涯必须经历的事情之一，也是一次让你大开眼界的经历：你会对日常工作中的工具产生新的见解，那些令人望而生畏的概念也会被慢慢掀开神秘的面纱。 本文中，我们基于 1978 年 John McCarthy">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://www.uraimo.com/imgs/lisp.png">
<meta property="og:image" content="https://www.uraimo.com/imgs/lisp.png">
<meta property="og:updated_time" content="2019-08-18T15:28:48.234Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用 Swift 从头构建 LISP 解释器">
<meta name="twitter:description" content="作者：uraimo，原文链接，原文日期：2017-02-05译者：pmst；校对：Yake；定稿：CMB   有人建议我写一个小型语言解释器，如果是 LISP 那就更完美了。作为一名程序员，这是你职业生涯必须经历的事情之一，也是一次让你大开眼界的经历：你会对日常工作中的工具产生新的见解，那些令人望而生畏的概念也会被慢慢掀开神秘的面纱。 本文中，我们基于 1978 年 John McCarthy">
<meta name="twitter:image" content="https://www.uraimo.com/imgs/lisp.png">

    
    <link rel="alternative" href="/atom.xml" title="SwiftGG" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon_new.ico">
    
    
    <link rel="apple-touch-icon" href="/img/logo_new.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/logo_new.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/gitment.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo_new.png" alt="SwiftGG" title="SwiftGG"></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="SwiftGG">SwiftGG</a></h1>
				<h2 class="blog-motto">走心的 Swift 翻译组</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
						<li><a href="/stat">统计</a></li>
					
						<li><a href="https://swiftgg.gitbook.io/swift/">Swift 官方文档翻译</a></li>
					
					<li>
 					
						<form class="search" method="GET" action="http://search.swift.gg/cse/search" target="_blank">
							<label>搜索</label>
						<input name="s" type="hidden" value="4873498141517765035"><input type="search" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		
  <header class="article-info clearfix">
    <h1 itemprop="name">
      
        <a href="/2017/03/08/building-a-lisp-from-scratch-with-swift/" target="_blank" title="使用 Swift 从头构建 LISP 解释器" itemprop="url">使用 Swift 从头构建 LISP 解释器</a>
    </h1>
    <p class="article-time">
      <time datetime="2017-03-08T00:00:00.000Z" itemprop="datePublished">2017-03-08</time>
      <span style="margin-left: 0.5em;"><i class="icon-eye-open"></i> <span class="viewcount"></span></span>
    </p>
  </header>

	<div class="article-content">
		
		<blockquote>
<p>作者：uraimo，<a href="https://www.uraimo.com/2017/02/05/building-a-lisp-from-scratch-with-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-02-05<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；校对：<a href="http://blog.csdn.net/yake_099" target="_blank" rel="noopener">Yake</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>有人建议我写一个小型语言解释器，如果是 LISP 那就更完美了。作为一名程序员，这是你职业生涯必须经历的事情之一，也是一次让你大开眼界的经历：你会对日常工作中的工具产生新的见解，那些令人望而生畏的概念也会被慢慢掀开神秘的面纱。</p>
<p>本文中，我们基于 1978 年 John McCarthy 发表的 <a href="https://www.uraimo.com/files/MicroManual-LISP.pdf" target="_blank" rel="noopener">A Micro-Manual For Lisp - Not The Whole Thruth</a>  文章，实现一个小型 LISP 解释器，麻雀虽小但五脏俱全，这里主要利用 Swift 框架来对一些包含 LISP 符号表达式的字符串解释。</p>
<p>我们最终会使用解释器来构建一个简单的 REPL (Read-Eval-Print-Loop) 程序，它将交互地执行语句并打印出求值结果。我们还实现了探究解释器的一个 Playground 。</p>
<p>本文将手把手教你直至完成属于你的 LISP 解释器，这将是一次难忘的周末计划。选择跟着一起实现或只是阅读介绍取决于你的心情，当然你也可以参考本文的实现，构建你独有的解释器。</p>
<p>下图显示了我们将要建造的总体设计：<br><img src="https://www.uraimo.com/imgs/lisp.png" alt></p>
<a id="more"></a>
<p>第一个功能块( 读取阶段 Read Phase)的作用是读取一些包含代码的文本，并在后续两个阶段过程中通过输入程序的内部表示将文本生成一个语法树。</p>
<p>第一阶段，词法分析程序（Lexer）将输入文本分离成词法单元 Token（从文本的角度来说，就是程序的构建块），接着语法剖析程式（Parser）接受这些词法单元生成一个<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">抽象语法树(Abstract Syntax Tree AST)</a>，也就是源代码的分层表示。</p>
<p>一旦有了抽象语法树，我们就能够对表达式求值，然后打印输出到用户的屏幕上。</p>
<blockquote>
<p>文本介绍的解释器封装库和 playground 测试代码已经上传到 <a href="https://github.com/uraimo/SwiftyLISP" target="_blank" rel="noopener">GitHub</a>。</p>
</blockquote>
<p><strong>目录：</strong></p>
<ul>
<li><a href="https://www.uraimo.com/2017/02/05/building-a-lisp-from-scratch-with-swift/#lisp-basics" target="_blank" rel="noopener">LISP Basics</a></li>
<li><a href="https://www.uraimo.com/2017/02/05/building-a-lisp-from-scratch-with-swift/#building-the-interpreter" target="_blank" rel="noopener">Building the interpreter</a></li>
<li><a href="https://www.uraimo.com/2017/02/05/building-a-lisp-from-scratch-with-swift/#lexer-and-parser" target="_blank" rel="noopener">Lexer and Parser</a></li>
<li><a href="https://www.uraimo.com/2017/02/05/building-a-lisp-from-scratch-with-swift/#evaluation-and-default-global-environment" target="_blank" rel="noopener">Evaluation and Default Global Environment</a></li>
<li><a href="https://www.uraimo.com/2017/02/05/building-a-lisp-from-scratch-with-swift/#swiftylisp-repl" target="_blank" rel="noopener">SwiftyLisp REPL</a></li>
<li><a href="https://www.uraimo.com/2017/02/05/building-a-lisp-from-scratch-with-swift/#conclusion" target="_blank" rel="noopener">Conclusion</a></li>
</ul>
<h2 id="LISP-基础知识"><a href="#LISP-基础知识" class="headerlink" title="LISP 基础知识"></a>LISP 基础知识</h2><p>让我们简要回顾下将要实现的 LISP 解释器基础知识，McCarthy 的<a href="https://www.uraimo.com/files/MicroManual-LISP.pdf" target="_blank" rel="noopener">文章</a>基本涵盖了该语言所有的定义。</p>
<p>首先，如果你不熟悉 LISP，首字母缩略词源自 LISt 处理程序，这是描述 LISP 家族语言一个很好的方式。它们的基本数据结构是列表，之后你的程序也将基于列表执行操作。</p>
<p>你应该已经猜到我为何使用”家族”这一术语，McCarthy 定义的 LISP 当前存在很多变种或方言，从传统语言如 Racket 到 Clojure 之类的语言，它们建立在不同技术之上（Java虚拟机以及 Java 的 runtime)，并且能够通过其不同的范例使用 LISP 提供的功能来扩展底层平台。</p>
<p>这里我们要实现的是一个最小的 LISP 解释器，它包含了一些有用的基本元素。</p>
<p>LISP 解释器其实就是对那些以<a href="https://en.wikipedia.org/wiki/S-expression" target="_blank" rel="noopener">符号表达式</a>递归数据结构的一个评估程序，呈现形式有原子和列表(Atom &amp; List)。原子是一些简单的字母数字字符，具有不同的含义，而列表（也称为复合形式）是其他符号表达式的序列，以括号形式表示一个值序列。</p>
<p>LISP 中还有另外一种形式存在，这种特殊的形式有别于其他的符号表达式，区别在于对子表达式的求值规则不同。</p>
<p>为了表示程序将要处理的数据，我们将再次使用相同的符号表达式数据类型，最后使用相同的数据结构来表示源代码和所使用的数据。</p>
<p>但是什么是抽象语法树呢？语法上有效的程序包括一系列的符号表达式，即一系列嵌套列表，所以当源代码转换为抽象语法树，我们将再次使用一个能够存储列表的数据结构来建模我们的程序。</p>
<p>像 LISP 这样的语言，文本表示（通常指源代码）与其抽象语法树具有相同的结构，称之为<a href="https://zh.wikipedia.org/wiki/同像性" target="_blank" rel="noopener">同像性</a>(homoiconic)，它是元编程的基本特性之一，程序具有以相同语言修改本身或其他程序的能力，较之非同像性语言(大多数你知道，包括 Swift )要简单的多。你可以在运行时将代码当作数据来修改或者变换，而不使用复杂的机制。</p>
<p>如果你整篇阅读了 McCarthy 的文章，会发现可以让 LISP 自解释构建一个 LISP 解释器，称之为“Meta Circular Evaluator”，就只是几行代码而已。我们即将建立的 Swift 解释器将完成同样的事情，递归地评估这些符号表达式，并产生另一个符号表达式作为结果。</p>
<p>让我们看一个使用符号表达式表达的 LISP 例程：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(<span class="type">COUNT</span> (<span class="type">QUOTE</span> (<span class="type">A</span> <span class="type">B</span> <span class="type">C</span>) ) <span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<p>上述例程中，<code>COUNT</code>，<code>QUOTE</code>，<code>A</code>，<code>B</code>，<code>C</code>，<code>42</code> 都是原子（暂时忽略它们的意义），每个括号中的序列是一个列表。注意列表如何包含任何类型的符号表达式，甚至包括子列表。</p>
<p>我们的解释器如何对这些表达式求值呢？</p>
<p>评估这个表达式将使用称之为 <a href="https://en.wikipedia.org/wiki/Polish_notation" target="_blank" rel="noopener">polish notation</a> 的表达式，其中每个列表将被视为一个操作，随后是其需要应用的操作数，例如对两个数求和可以用 <code>(+ 1 2)</code> 表示。</p>
<p>上面例程中，操作者/函数 <code>COUNT</code> 将被应用到操作数/参数 <code>(QUOTE (A B C))</code> 和 <code>42</code>。</p>
<p>你一定注意到在我们的语言定义中，原子是没有类型的，我们只有单一类型的原子，而常见类型如整数、布尔值和字符串是不可用的。LISP 没有 Swift 语言中复杂的类型系统。</p>
<p>手册定义了一系列执行基本操作的原子，并描述了一旦包含它们的列表所产生的值。在下表中，e 将表示通用的符号表达式，而 L 表示列表。</p>
<table>
<thead>
<tr>
<th><strong>原子</strong></th>
<th><strong>使用形式</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Quote</td>
<td>(quote e1)</td>
<td>返回子表达式，例如(quote A) = A</td>
</tr>
<tr>
<td>Car</td>
<td>(car l)</td>
<td>返回第一个非空自列表，例如 (car (quote (A B C))) = A</td>
</tr>
<tr>
<td>Cdr</td>
<td>(cdr l)</td>
<td>返回除去第一个元素后，所有剩余元素构成的子列表，例如(cdr (quote (A B C))) = (B C)</td>
</tr>
<tr>
<td>Cons</td>
<td>(cons e l)</td>
<td>组合第一个元素和子列表中的元素成一个新列表，例如 (cons (quote A) (quote (B C))) = (A B C)</td>
</tr>
<tr>
<td>Equal</td>
<td>(equal e1 e2)</td>
<td>如果两个符号表达式递归相等，则返回一个名为 true 的原子，如果它们不为空，则返回空的 list()（同时用作 nil 和 false 值）。例如： (equal (car (quote (A B))) = (quote A))</td>
</tr>
<tr>
<td>Atom</td>
<td>(atom e)</td>
<td>如果符号表达式是原子或空列表（如果它是一个列表），则返回 true。(atom A)= true</td>
</tr>
<tr>
<td>Cond</td>
<td>(cond (p1 e1) (p2 e2) … (pn en))</td>
<td>p 条件表达式不等于空列表则返回其第一个 e 表达式。 <code>cond</code> 可以构造一些语法稍微复杂的条件表达式。 例如  (cond ((atom (quote A)) (quote B)) ((quote true) (quote C) = B</td>
</tr>
<tr>
<td>List</td>
<td>(list e1 e2 … en)</td>
<td>返回所有给定表达式的列表，与将递归应用于表达式序列相同。</td>
</tr>
</tbody>
</table>
<p>上述包含了评估这些表达式的规则集。</p>
<p>如果仔细观察，你会注意到 <code>cond</code>与其他的有些不同，因为它根据它包含的子列表有条件地评估它的主体。 这是我们第一个特殊形式的例子，我们将在实现评估器时特别注意这个细节。</p>
<p>现在让我们看看这些操作符的另一类，即能够定义函数的操作符:</p>
<table>
<thead>
<tr>
<th><strong>原子</strong></th>
<th><strong>使用形式</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Lambda</td>
<td>( (lambda (v1 … vn) e) p1 … pn)</td>
<td>定义具有主体e的lambda表达式，描述使用一系列环境变量的匿名函数v。将使用提供的参数作为变量的值来评估此函数。 例如  <code>(cond ((atom (quote A)) (quote B)) ((quote true) (quote C) = B</code></td>
</tr>
<tr>
<td>Defun</td>
<td>(defun (v1 … vn) e)</td>
<td>定义 lambda 表达式并将其注册在当前上下文中，以便在需要时使用。 我们可以像这样 <code>(defun cadr (X) (car (cdr x)))</code>定义一个函数，然后在另一个表达式中调用它：<code>(cadr (quote (A B C D)))</code>.</td>
</tr>
</tbody>
</table>
<p>McCarthy 的论文描述了一个额外的操作，可以用来定义局部标记 lambda 表达式，但我们不会实现它，当我们需要类似的东西，会使用 <em>defun</em> 替代。</p>
<h2 id="构建解释器"><a href="#构建解释器" class="headerlink" title="构建解释器"></a>构建解释器</h2><p>现在我们简单过完一遍论文的内容了，是时候开始讨论解释器的实现了。</p>
<p>在本节中，我们会对组成解释器的每个功能模块进行详细的分析，完整代码请前往 <a href="https://github.com/uraimo/SwiftyLISP" target="_blank" rel="noopener">Gitbub</a> 仓库地址下载。</p>
<p>第一个需要思考的问题是：符号表达式是如何在内部解释中呈现的，又是如何定义结构化的抽象语法树。这是一个重要的方面，因为良好的结构简化了计算过程。</p>
<h3 id="为符号表达式创建模型"><a href="#为符号表达式创建模型" class="headerlink" title="为符号表达式创建模型"></a>为符号表达式创建模型</h3><p>最显而易见的方式是使用递归枚举为符号表达式创建模型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SExpr</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Atom</span>(<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>([<span class="type">SExpr</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下声明递归的枚举需要加上 <code>indirect</code> 关键字，但是在本例中， <code>List</code> 的关联值(数组类型)扮演着一个容器角色，因此无须添加该关键字。这个枚举定义已经能满足我们对符号表达式定义的要求。</p>
<p>现在让我们为这个枚举添加一些其他的东西，我们需要理解两个表达式怎么算相等，以及一个打印方法。为了达到这两个目的，我们需要实现 <code>Equatable</code> 和 <code>CustomStringConvertible</code>两个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SExpr</span> : <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: SExpr, rhs: SExpr)</span></span> -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(lhs,rhs)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> (.<span class="type">Atom</span>(l),.<span class="type">Atom</span>(r)):</span><br><span class="line">            <span class="keyword">return</span> l==r</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> (.<span class="type">List</span>(l),.<span class="type">List</span>(r)):</span><br><span class="line">            <span class="keyword">guard</span> l.<span class="built_in">count</span> == r.<span class="built_in">count</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line">            <span class="keyword">for</span> (idx,el) <span class="keyword">in</span> l.enumerated() &#123;</span><br><span class="line">                <span class="keyword">if</span> el != r[idx] &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SExpr</span> : <span class="title">CustomStringConvertible</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Atom</span>(value):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"\(value) "</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">List</span>(subxexprs):</span><br><span class="line">            <span class="keyword">var</span> res = <span class="string">"("</span></span><br><span class="line">            <span class="keyword">for</span> expr <span class="keyword">in</span> subxexprs&#123;</span><br><span class="line">                res += <span class="string">"\(expr) "</span></span><br><span class="line">            &#125;</span><br><span class="line">            res += <span class="string">")"</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数递归遍历符号表达式结构，触发对自己的调用（使用等式运算符或将 <code>SExpr</code> 转换为字符串）来发挥他们的作用。</p>
<p>现在请回忆下之前定义的数据结构，然后思考 RERL 图中的每个组件应该如何实现。</p>
<p><img src="https://www.uraimo.com/imgs/lisp.png" alt></p>
<h3 id="词法分析器和语法分析器"><a href="#词法分析器和语法分析器" class="headerlink" title="词法分析器和语法分析器"></a>词法分析器和语法分析器</h3><p>在 <em>Read</em> 阶段，将源代码翻译为抽象语法树过程可分为两个阶段，每个过程由专门的组件负责：词法分析器 <em>Lexer</em> 和语法分析器 <em>Parser</em>。</p>
<p>词法分析器或分词器的主要职责是对包含源代码的文本输入块进行<a href="https://en.wikipedia.org/wiki/Lexical_analysis" target="_blank" rel="noopener">词法分析</a>。</p>
<p>词法分析器能够考虑上下文，将一系列字符分解成具有意义的 <em>lexeme</em> 或 <em>token</em> 。Token 可以是语言关键字，如<code>if</code>，运算符 <code>=</code> 或各种标识符（例如变量名）和字面量。</p>
<p>由于我们的语言的<a href="https://en.wikipedia.org/wiki/Lexical_grammar" target="_blank" rel="noopener">词法语法</a>，有效标记的定义是非常简单的，词法分析器/分词器也是如此。 Lexer 将只识别由空格或括号分隔的字符串标记。</p>
<p>让我们向 SExpr 添加一个 <code>read()</code> 方法来将字符串转换为我们的枚举表达式，并开始讨论分词阶段的处理方式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SExpr</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     读取 LISP 字符串表达式并将其转换为具有层级结构的 S-Expression</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(<span class="number">_</span> sexpr:String)</span></span> -&gt; <span class="type">SExpr</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">Token</span></span>&#123;</span><br><span class="line">            <span class="keyword">case</span> pOpen,pClose,textBlock(<span class="type">String</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         将字符串分解为一系列词法单元</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         - Parameter sexpr: 字符串类型的表达式</span></span><br><span class="line"><span class="comment">         - Returns: 词法单元数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">tokenize</span><span class="params">(<span class="number">_</span> sexpr:String)</span></span> -&gt; [<span class="type">Token</span>] &#123;</span><br><span class="line">            <span class="keyword">var</span> res = [<span class="type">Token</span>]()</span><br><span class="line">            <span class="keyword">var</span> tmpText = <span class="string">""</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> sexpr.characters &#123;</span><br><span class="line">                <span class="keyword">switch</span> <span class="built_in">c</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"("</span>:</span><br><span class="line">                    <span class="keyword">if</span> tmpText != <span class="string">""</span> &#123;</span><br><span class="line">                        res.append(.textBlock(tmpText))</span><br><span class="line">                        tmpText = <span class="string">""</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    res.append(.pOpen)</span><br><span class="line">                <span class="keyword">case</span> <span class="string">")"</span>:</span><br><span class="line">                    <span class="keyword">if</span> tmpText != <span class="string">""</span> &#123;</span><br><span class="line">                        res.append(.textBlock(tmpText))</span><br><span class="line">                        tmpText = <span class="string">""</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    res.append(.pClose)</span><br><span class="line">                <span class="keyword">case</span> <span class="string">" "</span>:</span><br><span class="line">                    <span class="keyword">if</span> tmpText != <span class="string">""</span> &#123;</span><br><span class="line">                        res.append(.textBlock(tmpText))</span><br><span class="line">                        tmpText = <span class="string">""</span></span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    tmpText.append(<span class="built_in">c</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;      </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 语法解析代码预留</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取阶段: tokenize -&gt; parse -&gt; result</span></span><br><span class="line">        <span class="keyword">let</span> tokens = tokenize(sexpr)</span><br><span class="line">        <span class="keyword">let</span> res = parse(tokens)</span><br><span class="line">        <span class="keyword">return</span> res.subexpr ?? .<span class="type">List</span>([])  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tokenize</code> 方法将遍历输入字符串的所有字符，将不透明（从语法的角度）字符串转换为 <code>Token</code> 枚举中定义的一系列值。 可能的值是：<em>pOpen</em>（用于开括号），<em>pClose</em>（用于右括号）和 <em>textBlock</em>（用于每个其他字符串，表示一个原子）。 一切都很直接，因为没有特殊的规则能够造成内容读取无效。</p>
<p>下一阶段依靠<a href="https://en.wikipedia.org/wiki/Parsing#Computer_languages" target="_blank" rel="noopener">语法分析器</a>执行。</p>
<p>语法分析器的目的是将一系列 <code>token</code> 转换为抽象语法树形式表示我们的源代码，有利于检查语法错误，并且易于评估（如果我们正在构建一个编译器而不是解释器，则可以加入优化和编译模块）。</p>
<p>我们将实现一个非常简单的<a href="https://en.wikipedia.org/wiki/Top-down_parsing" target="_blank" rel="noopener"> Top-down 语法解析器</a>，它将提取 <code>token</code> 数组按照自然语序构建抽象语法树。如果你计划构建一个语法更复杂的分析器，可能需要参考一些更复杂的，如<a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" target="_blank" rel="noopener">向下递归解析器(易上手)</a> 或 <a href="https://en.wikipedia.org/wiki/LL_parser" target="_blank" rel="noopener">LL Parser</a>。</p>
<p>但是对于具有复杂语法的语言，语法分析器通常使用解析器生成器（例如 ANTLR，最近引入了对 Swift 的支持）生成，因此你必须在 DSL 中描述语法，而不是手动编写解析器。</p>
<p>语法分析器肯定会比词法分析器更复杂，但是，由于这种语言很简单，它将是一个非常小而简单的分析器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SExpr</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     Read a LISP string and convert it to a hierarchical S-Expression</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(<span class="number">_</span> sexpr:String)</span></span> -&gt; <span class="type">SExpr</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Tokenizer</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">appendTo</span><span class="params">(list: SExpr?, node:SExpr)</span></span> -&gt; <span class="type">SExpr</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> list = list</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> list != <span class="literal">nil</span>, <span class="keyword">case</span> <span class="keyword">var</span> .<span class="type">List</span>(elements) = list! &#123;</span><br><span class="line">                elements.append(node)</span><br><span class="line">                list = .<span class="type">List</span>(elements)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                list = node</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list!</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         Parses a series of tokens to obtain a hierachical S-Expression</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         - Parameter tokens: Tokens to parse</span></span><br><span class="line"><span class="comment">         - Parameter node: Parent S-Expression if available</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         - Returns: Tuple with remaning tokens and resulting S-Expression</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(<span class="number">_</span> tokens: [Token], node: SExpr? = <span class="literal">nil</span>)</span></span> -&gt; (remaining:[<span class="type">Token</span>], subexpr:<span class="type">SExpr?</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> tokens = tokens</span><br><span class="line">            <span class="keyword">var</span> node = node</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">repeat</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> t = tokens[i]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">switch</span> t &#123;</span><br><span class="line">                <span class="keyword">case</span> .pOpen:</span><br><span class="line">                    <span class="comment">//new sexpr</span></span><br><span class="line">                    <span class="keyword">let</span> (tr,n) = parse( <span class="type">Array</span>(tokens[(i+<span class="number">1</span>)..&lt;tokens.<span class="built_in">count</span>]), node: .<span class="type">List</span>([]))</span><br><span class="line">                    <span class="built_in">assert</span>(n != <span class="literal">nil</span>) <span class="comment">//Cannot be nil</span></span><br><span class="line">                    </span><br><span class="line">                    (tokens, i) = (tr, <span class="number">0</span>)</span><br><span class="line">                    node = appendTo(list: node, node: n!)</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> tokens.<span class="built_in">count</span> != <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> .pClose:</span><br><span class="line">                    <span class="comment">//close sexpr</span></span><br><span class="line">                    <span class="keyword">return</span> (<span class="type">Array</span>(tokens[(i+<span class="number">1</span>)..&lt;tokens.<span class="built_in">count</span>]), node)</span><br><span class="line">                <span class="keyword">case</span> <span class="keyword">let</span> .textBlock(value):</span><br><span class="line">                    node = appendTo(list: node, node: .<span class="type">Atom</span>(value))</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">while</span>(tokens.<span class="built_in">count</span> &gt; <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> ([],node)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> tokens = tokenize(sexpr)</span><br><span class="line">        <span class="keyword">let</span> res = parse(tokens)</span><br><span class="line">        <span class="keyword">return</span> res.subexpr ?? .<span class="type">List</span>([])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>词法分析器使用 <code>.pOpen</code> 和 <code>.pClose</code> 将列表分割成 <code>token</code> 元素,<code>parse(tokens：node :)</code> 方法进行遍历并将每个其他 <code>token</code> 转换为原子。</p>
<p>注意，递归地执行解析，每个嵌套调用接收 <code>token</code> 数组等待解析，并且父列表将包含在下一递归步骤期间解析的值（从根表达式的 <em>nil</em> 开始）。 当执行到右括号时，列表被认为是完整的，并且将解析的剩余 <code>token</code> 一起返回给调用者。</p>
<p>在这些函数之后，你可以看到 <code>read()</code> 方法的实际主体，它执行这一系列中的每个步骤并返回顶层形式或在错误情况下返回一个空列表（我们在上一节中看到的两者都返回 false）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">let</span> tokens = tokenize(sexpr)</span><br><span class="line">        <span class="keyword">let</span> res = parse(tokens)</span><br><span class="line">        <span class="keyword">return</span> res.subexpr ?? .<span class="type">List</span>([])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们有一个可用的 Read 模块，让我们添加一些东西到 <code>SExpr</code> 枚举中，这将允许我们直接从字符串字面量获得一个表达式，而不通过实现 <code>ExpressibleByStringLiteral</code> 协议手动调用 <code>read（）</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SExpr</span> : <span class="title">ExpressibleByStringLiteral</span>,</span></span><br><span class="line"><span class="class">                  <span class="title">ExpressibleByUnicodeScalarLiteral</span>,</span></span><br><span class="line"><span class="class">                  <span class="title">ExpressibleByExtendedGraphemeClusterLiteral</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(stringLiteral value: <span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="type">SExpr</span>.read(value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(extendedGraphemeClusterLiteral value: <span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(stringLiteral: value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(unicodeScalarLiteral value: <span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(stringLiteral: value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以直接从字符串中读取程序：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> expr: <span class="type">SExpr</span> = <span class="string">"(cond ((atom (quote A)) (quote B)) ((quote true) (quote C)))"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(expr)</span><br><span class="line"><span class="built_in">print</span>(expr.eval()!)  <span class="comment">//B</span></span><br></pre></td></tr></table></figure>
<h3 id="评估和默认全局环境"><a href="#评估和默认全局环境" class="headerlink" title="评估和默认全局环境"></a>评估和默认全局环境</h3><p>评估阶段将比我们目前所看到的更复杂，<code>eval()</code> 函数将递归地评估抽象语法树，并返回符号表达式求值结果。</p>
<p>首先，让我们总结下所有这门语言所定义的基本操作符，它们被定义在一个名为 <code>defaultEnvironment</code> 的私有字典中，它将关联到每个操作符原子，由 <code>(SExpr, [SExpr]?, [SExpr]?)-&gt;SExpr</code> 类型的函数来实现它。</p>
<p>这些函数将使用包含原始列表（函数名和参数）的 <code>SExpr</code> 参数，计算并返回一个 <code>SExpr</code> 作为结果。 这两个可选数组作为第二和第三个参数将包含一个变量列表及其值，并将用于通过 <code>defun</code> 和 <code>lamdba</code> 定义用户定义的函数，在所有其他情况下，它们将只是 <code>nil</code>。 当我们看到这些操作符时我们再回头看。</p>
<p>为了跟踪基本内置操作符，<code>Builtin</code> 枚举已经用一个函数声明，该函数标识哪些操作符不需要子表达式求值。像 <code>quote</code>（存在唯一的目的是禁用子表达式求值）这种操作符属于特殊形式，其他还有 <code>cond</code> 或 <code>lambda</code> 定义运算符，将在内部处理子表达式的求值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Basic builtins</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">enum</span> <span class="title">Builtins</span>:<span class="title">String</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> quote,car,cdr,cons,<span class="built_in">equal</span>,atom,cond,lambda,defun,list,</span><br><span class="line">         <span class="built_in">println</span>,eval</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     True if the given parameter stop evaluation of sub-expressions.</span></span><br><span class="line"><span class="comment">     Sub expressions will be evaluated lazily by the operator.</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     - Parameter atom: Stringified atom</span></span><br><span class="line"><span class="comment">     - Returns: True if the atom is the quote operator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">mustSkip</span><span class="params">(<span class="number">_</span> atom: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  (atom == <span class="type">Builtins</span>.quote.rawValue) ||</span><br><span class="line">                (atom == <span class="type">Builtins</span>.cond.rawValue) ||</span><br><span class="line">                (atom == <span class="type">Builtins</span>.defun.rawValue) ||</span><br><span class="line">                (atom == <span class="type">Builtins</span>.lambda.rawValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有 <code>defaultEnvironment</code> 函数都以简单的检查开始，以验证是否已提供最小数量的参数，然后继续构建返回结果。</p>
<p>让我们来看看其中的一些，完整项目的工程你可以看<a href="https://github.com/uraimo/SwiftyLISP" target="_blank" rel="noopener">这里</a>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Global default builtin functions environment</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Contains definitions for: quote,car,cdr,cons,equal,atom,cond,lambda,label,defun.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> defaultEnvironment: [<span class="type">String</span>: (<span class="type">SExpr</span>, [<span class="type">SExpr</span>]?, [<span class="type">SExpr</span>]?)-&gt;<span class="type">SExpr</span>] = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> env = [<span class="type">String</span>: (<span class="type">SExpr</span>, [<span class="type">SExpr</span>]?, [<span class="type">SExpr</span>]?)-&gt;<span class="type">SExpr</span>]()</span><br><span class="line"></span><br><span class="line">    env[<span class="type">Builtins</span>.quote.rawValue] = &#123; params,locals,values <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">List</span>(parameters) = params, parameters.<span class="built_in">count</span> == <span class="number">2</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span> .<span class="type">List</span>([])&#125;</span><br><span class="line">        <span class="keyword">return</span> parameters[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    env[<span class="type">Builtins</span>.cdr.rawValue] = &#123; params,locals,values <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">List</span>(parameters) = params, parameters.<span class="built_in">count</span> == <span class="number">2</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span> .<span class="type">List</span>([])&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">List</span>(elements) = parameters[<span class="number">1</span>], elements.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span> .<span class="type">List</span>([])&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> .<span class="type">List</span>(<span class="type">Array</span>(elements.<span class="built_in">dropFirst</span>(<span class="number">1</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    env[<span class="type">Builtins</span>.<span class="built_in">equal</span>.rawValue] = &#123;params,locals,values <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">List</span>(elements) = params, elements.<span class="built_in">count</span> == <span class="number">3</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span> .<span class="type">List</span>([])&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> me = env[<span class="type">Builtins</span>.<span class="built_in">equal</span>.rawValue]!</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> (elements[<span class="number">1</span>].eval(with: locals,<span class="keyword">for</span>: values)!,elements[<span class="number">2</span>].eval(with: locals,<span class="keyword">for</span>: values)!) &#123;</span><br><span class="line">        <span class="keyword">case</span> (.<span class="type">Atom</span>(<span class="keyword">let</span> elLeft),.<span class="type">Atom</span>(<span class="keyword">let</span> elRight)):</span><br><span class="line">            <span class="keyword">return</span> elLeft == elRight ? .<span class="type">Atom</span>(<span class="string">"true"</span>) : .<span class="type">List</span>([])</span><br><span class="line">        <span class="keyword">case</span> (.<span class="type">List</span>(<span class="keyword">let</span> elLeft),.<span class="type">List</span>(<span class="keyword">let</span> elRight)):</span><br><span class="line">            <span class="keyword">guard</span> elLeft.<span class="built_in">count</span> == elRight.<span class="built_in">count</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span> .<span class="type">List</span>([])&#125;</span><br><span class="line">            <span class="keyword">for</span> (idx,el) <span class="keyword">in</span> elLeft.enumerated() &#123;</span><br><span class="line">                <span class="keyword">let</span> testeq:[<span class="type">SExpr</span>] = [.<span class="type">Atom</span>(<span class="string">"Equal"</span>),el,elRight[idx]]</span><br><span class="line">                <span class="keyword">if</span> me(.<span class="type">List</span>(testeq),locals,values) != <span class="type">SExpr</span>.<span class="type">Atom</span>(<span class="string">"true"</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> .<span class="type">List</span>([])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Atom</span>(<span class="string">"true"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">List</span>([])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    env[<span class="type">Builtins</span>.atom.rawValue] = &#123; params,locals,values <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">List</span>(parameters) = params, parameters.<span class="built_in">count</span> == <span class="number">2</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span> .<span class="type">List</span>([])&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> parameters[<span class="number">1</span>].eval(with: locals,<span class="keyword">for</span>: values)! &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Atom</span>:</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Atom</span>(<span class="string">"true"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">List</span>([])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> env</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>虽然像 <code>quote</code> 或 <code>cdr</code> 这样的函数只是操作参数列表来构建输出列表，但是其他的函数像 <code>equals</code> 实现了一个更复杂的逻辑（在这种情况下，它执行递归等式检查）。 为了保持源代码可读的教学目的，错误检查被保持到最小，额外的参数被忽略，当出现错误时，返回空列表。</p>
<p>对于像条件 <code>cond</code> 这样的特殊形式，需要对评估进行不同的处理。</p>
<p>条件运算符对于实现递归是至关重要的，因为只有这种语句，我们才能决定是否停止递归或继续进行另一次迭代。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">env[<span class="type">Builtins</span>.cond.rawValue] = &#123; params,locals,values <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">List</span>(parameters) = params, parameters.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span> .<span class="type">List</span>([])&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> el <span class="keyword">in</span> parameters.<span class="built_in">dropFirst</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">List</span>(<span class="built_in">c</span>) = el, <span class="built_in">c</span>.<span class="built_in">count</span> == <span class="number">2</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span> .<span class="type">List</span>([])&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">c</span>[<span class="number">0</span>].eval(with: locals,<span class="keyword">for</span>: values) != .<span class="type">List</span>([]) &#123;</span><br><span class="line">            <span class="keyword">let</span> res = <span class="built_in">c</span>[<span class="number">1</span>].eval(with: locals,<span class="keyword">for</span>: values)</span><br><span class="line">            <span class="keyword">return</span> res!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> .<span class="type">List</span>([])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cond</code> 的实现方式：一旦列表第一个包含 <code>cond</code> 原子的元素被删除了，遍历列表直至找到一个子列表，其中第一个成员是一个值不同于空列表的表单（这意味着 <code>false</code>，前面我们已经看到了），一旦找到它，评估子列表的第二个成员并返回它。 使用这种评估，我们只评估我们实际需要什么，当评估递归函数时，我们不遵循这些函数的主体包含的无限序列的嵌套递归调用。</p>
<p>在这些默认函数中，<code>defun</code> 和 <code>lambda</code> 操作符允许创建用户定义的函数，然后在一个名为 <code>localContext</code> 的全局访问字典中注册：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Local environment for locally defined functions</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> localContext = [<span class="type">String</span>: (<span class="type">SExpr</span>, [<span class="type">SExpr</span>]?, [<span class="type">SExpr</span>]?)-&gt;<span class="type">SExpr</span>]()</span><br></pre></td></tr></table></figure>
<p>让我们看看 <code>defun</code>（ <code>lambda</code> 的实现基本和它一致）是如何实现的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">env[<span class="type">Builtins</span>.defun.rawValue] =  &#123; params,locals,values <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">List</span>(parameters) = params, parameters.<span class="built_in">count</span> == <span class="number">4</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span> .<span class="type">List</span>([])&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Atom</span>(lname) = parameters[<span class="number">1</span>] <span class="keyword">else</span> &#123;<span class="keyword">return</span> .<span class="type">List</span>([])&#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">List</span>(vars) = parameters[<span class="number">2</span>] <span class="keyword">else</span> &#123;<span class="keyword">return</span> .<span class="type">List</span>([])&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> lambda = parameters[<span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> f: (<span class="type">SExpr</span>, [<span class="type">SExpr</span>]?, [<span class="type">SExpr</span>]?)-&gt;<span class="type">SExpr</span> = &#123; params,locals,values <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">var</span> .<span class="type">List</span>(p) = params <span class="keyword">else</span> &#123;<span class="keyword">return</span> .<span class="type">List</span>([])&#125;</span><br><span class="line">        p = <span class="type">Array</span>(p.<span class="built_in">dropFirst</span>(<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Replace parameters in the lambda with values</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> result = lambda.eval(with:vars, <span class="keyword">for</span>:p)&#123;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">List</span>([])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    localContext[lname] = f</span><br><span class="line">    <span class="keyword">return</span> .<span class="type">List</span>([])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数需要一个包含四个符号表达式的列表，一个用于操作符名称，一个用于名称（这将是一个简单的原子），最后两个用于变量列表和 <code>lambda</code> 主体。 因此，一旦我们将每个组件存储在一个常量中（注意，空列表再次用作错误值），我们在 <code>localContext</code> 中定义和注册一个类型为 <code>(SExpr，[SExpr]?，[SExpr]?)-&gt; SExpr</code> 的函数，将会看到，当评估器在表达式中找到它时，会被 <code>eval()</code> 调用。</p>
<p>在调用期间，这个匿名函数将使用当前参数来评估 <code>lambda</code> 的主体，替换原始变量列表中包含的变量，并返回结果。</p>
<p>为了更好地理解这里发生了什么，让我们来看看 <code>eval()</code>函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SExpr</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Atom</span>(<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>([<span class="type">SExpr</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     Evaluates this SExpression with the given functions environment</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     - Parameter environment: A set of named functions or the default environment</span></span><br><span class="line"><span class="comment">     - Returns: the resulting SExpression after evaluation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(with locals: [SExpr]? = <span class="literal">nil</span>, <span class="keyword">for</span> values: [SExpr]? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">SExpr?</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="keyword">self</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> node &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Atom</span>:</span><br><span class="line">            <span class="keyword">return</span> evaluateVariable(node, with:locals, <span class="keyword">for</span>:values)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">var</span> .<span class="type">List</span>(elements):</span><br><span class="line">            <span class="keyword">var</span> skip = <span class="literal">false</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> elements.<span class="built_in">count</span> &gt; <span class="number">1</span>, <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Atom</span>(value) = elements[<span class="number">0</span>] &#123;</span><br><span class="line">                skip = <span class="type">Builtins</span>.mustSkip(value)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Evaluate all subexpressions</span></span><br><span class="line">            <span class="keyword">if</span> !skip &#123;</span><br><span class="line">                elements = elements.<span class="built_in">map</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> $<span class="number">0</span>.eval(with:locals, <span class="keyword">for</span>:values)!</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node = .<span class="type">List</span>(elements)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Obtain a a reference to the function represented by the first atom and apply it, local definitions shadow global ones</span></span><br><span class="line">            <span class="keyword">if</span> elements.<span class="built_in">count</span> &gt; <span class="number">0</span>, <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Atom</span>(value) = elements[<span class="number">0</span>], <span class="keyword">let</span> f = localContext[value] ?? defaultEnvironment[value] &#123;</span><br><span class="line">                <span class="keyword">let</span> r = f(node,locals,values)</span><br><span class="line">                <span class="keyword">return</span> r</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">evaluateVariable</span><span class="params">(<span class="number">_</span> v: SExpr, with locals: [SExpr]?, <span class="keyword">for</span> values: [SExpr]?)</span></span> -&gt; <span class="type">SExpr</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> locals = locals, <span class="keyword">let</span> values = values <span class="keyword">else</span> &#123;<span class="keyword">return</span> v&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> locals.<span class="built_in">contains</span>(v) &#123;</span><br><span class="line">            <span class="comment">// The current atom is a variable, replace it with its value</span></span><br><span class="line">            <span class="keyword">return</span> values[locals.index(of: v)!]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// Not a variable, just return it</span></span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>评估期遍历抽象语法树，根据可评估的类型形式执行不同的操作</p>
<p>当遇到一个原子时，可以试着把它当做具有局部变量的当前上下文的变量（最初由 <code>defun</code> 或 <code>lambda</code> 设置，并在调用之间传播）进行解析，但大多数时候它只是返回原子。</p>
<p>这是在执行用户定义lambda的变量替换的地方，我们简单地使用 <code>evaluateVariable</code> 验证每个原子的名称是否存在于变量的数组中，如果是，我们用具有相同索引的原子替换值数组中的原子。</p>
<p>在评估列表或复合形式时，我们需要更多的考虑。</p>
<p>我们将首先尝试递归地评估当前列表中的所有子表达式，但前提是当前运算符不需要处理此评估本身。如上所述，在这个简单的 LISP 解释器中只有 <code>quote</code>，特殊形式和 <code>lambda</code> 定义运算符这三类。</p>
<p>一旦子表达式求值完毕，就应该将运算符应用于其操作数，该操作符在 <code>localContext</code> 中执行查找于运算符原子具有相同名称的lambda，然后在 <code>defaultEnvironment</code> 中找。顺序很重要，因为我们希望能够使用那些手动定义的新函数来隐藏默认定义。</p>
<p>如果存在具有该名称的lambda，则调用该函数，并将结果返回到递归计算的上一步。</p>
<p>这就结束了对基本解释器的描述，整件事情需要大概400行代码。</p>
<h2 id="SwiftyLisp-REPL"><a href="#SwiftyLisp-REPL" class="headerlink" title="SwiftyLisp REPL"></a>SwiftyLisp REPL</h2><p>现在是时候实现 REPL 了，但是它花费不了太长时间，解释器具有我们需要的所有基本功能。</p>
<p>我们将从终端读取一行，将其转换为 <code>SExpr</code>，对其进行评估并打印结果，这要归功于 <code>CustomStringConvertible</code> 协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftyLisp</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exit = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!exit)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"&gt;&gt;&gt;"</span>, terminator:<span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">let</span> input = <span class="built_in">readLine</span>(strippingNewline: <span class="literal">true</span>)</span><br><span class="line">    exit = (input==<span class="string">"exit"</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> !exit &#123;</span><br><span class="line">        <span class="keyword">let</span> e = <span class="type">SExpr</span>.read(input!)</span><br><span class="line">        <span class="built_in">print</span>(e.eval()!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>REPL 已经上传到 GitHub 另外一个<a href="https://github.com/uraimo/SwiftyLISP-REPL" target="_blank" rel="noopener">仓库</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了一个最小 LISP 解释器，介绍普通解释器的基本构建块，而不考虑语言。</p>
<p>如果你以前从来没有这样做过，第一眼可能看起来令人畏惧，但我想要传达的意思是：这只不过是一个具有一定工作量的项目，但是每个人都能够完成。</p>
<p>查看 Github 上的<a href="https://github.com/uraimo/SwiftyLISP" target="_blank" rel="noopener">完整项目</a>，并在评论中告诉我，如果你想阅读更多关于解释器和编译器的话！</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/uraimo/">uraimo</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Swift-进阶/">Swift 进阶</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://swift.gg/2017/03/08/building-a-lisp-from-scratch-with-swift/" data-title="使用 Swift 从头构建 LISP 解释器 | SwiftGG" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/2017/03/09/structs-and-nscoding/" title="结构体与 NSCoding">
  <strong>上一篇</strong><br>
  <span>
  结构体与 NSCoding</span>
</a>
</div>


<div class="next">
<a href="/2017/03/06/why-is-string-characterview-not-a-mutablecollection/" title="为何 String.CharacterView 不是 MutableCollection">
 <strong>下一篇</strong><br> 
 <span>为何 String.CharacterView 不是 MutableCollection
</span>
</a>
</div>

</nav>

	


<section id="comments" class="comment">
  <div id="gitcomment">
  </div>
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
    var gitment = new Gitment({
      id: "2017/03/08/building-a-lisp-from-scratch-with-swift/",
      owner: "SwiftGGBot",
      repo: "gg-comment",
      oauth: {
        client_id: "8ed6aa0071e9d92f7ffc",
        client_secret: "29cc2c70290fad40a967780e5b49d86501348ddf",
      },
    })
    gitment.render('gitcomment')
    </script>
</section>



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#LISP-基础知识"><span class="toc-number">1.</span> <span class="toc-text">LISP 基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建解释器"><span class="toc-number">2.</span> <span class="toc-text">构建解释器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为符号表达式创建模型"><span class="toc-number">2.1.</span> <span class="toc-text">为符号表达式创建模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#词法分析器和语法分析器"><span class="toc-number">2.2.</span> <span class="toc-text">词法分析器和语法分析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评估和默认全局环境"><span class="toc-number">2.3.</span> <span class="toc-text">评估和默认全局环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SwiftyLisp-REPL"><span class="toc-number">3.</span> <span class="toc-text">SwiftyLisp REPL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/APPVENTURE/" title="APPVENTURE">APPVENTURE<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/Andyy-Hope/" title="Andyy Hope">Andyy Hope<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/AppCoda/" title="AppCoda">AppCoda<sup>44</sup></a></li>
		  
		
		  
			<li><a href="/categories/Arthur-Knopper/" title="Arthur Knopper">Arthur Knopper<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Big-O-Note-Taking/" title="Big O Note-Taking">Big O Note-Taking<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Coding-Explorer-Blog/" title="Coding Explorer Blog">Coding Explorer Blog<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Crunchy-Development/" title="Crunchy Development">Crunchy Development<sup>25</sup></a></li>
		  
		
		  
			<li><a href="/categories/Erica-Sadun/" title="Erica Sadun">Erica Sadun<sup>68</sup></a></li>
		  
		
		  
			<li><a href="/categories/IOSCREATOR/" title="IOSCREATOR">IOSCREATOR<sup>29</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jacob-Bandes-Storch/" title="Jacob Bandes-Storch">Jacob Bandes-Storch<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jameson-Quave/" title="Jameson Quave">Jameson Quave<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/JamesonQuave-com/" title="JamesonQuave.com">JamesonQuave.com<sup>18</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jesse-Squires/" title="Jesse Squires">Jesse Squires<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/KHANLOU/" title="KHANLOU">KHANLOU<sup>22</sup></a></li>
		  
		
		  
			<li><a href="/categories/Khanlou/" title="Khanlou">Khanlou<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mike-Ash/" title="Mike Ash">Mike Ash<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/NSHipster/" title="NSHipster">NSHipster<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift/NSHipster/" title="NSHipster">NSHipster<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/Natasha-The-Robot/" title="Natasha The Robot">Natasha The Robot<sup>48</sup></a></li>
		  
		
		  
			<li><a href="/categories/PhotoKit/Ole-Begemann/" title="Ole Begemann">Ole Begemann<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Ole-Begemann/" title="Ole Begemann">Ole Begemann<sup>37</sup></a></li>
		  
		
		  
			<li><a href="/categories/Ole-Begemannh/" title="Ole Begemannh">Ole Begemannh<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Olivier-Halligon/" title="Olivier Halligon">Olivier Halligon<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Open-Source-Swift/" title="Open Source Swift">Open Source Swift<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/PhotoKit/" title="PhotoKit">PhotoKit<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Raj-Kandathi/" title="Raj Kandathi">Raj Kandathi<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Reinder-de-Vries/" title="Reinder de Vries">Reinder de Vries<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Russ-Bishop/" title="Russ Bishop">Russ Bishop<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Soroush-Khanlou/" title="Soroush Khanlou">Soroush Khanlou<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Olivier-Halligon/Swift/" title="Swift">Swift<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift/" title="Swift">Swift<sup>13</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mike-Ash/Swift/" title="Swift">Swift<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift-and-Painless/" title="Swift and Painless">Swift and Painless<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/Swift-入门/" title="Swift 入门">Swift 入门<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift-进阶/" title="Swift 进阶">Swift 进阶<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Think-and-Build/" title="Think and Build">Think and Build<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Thomas-Hanning/" title="Thomas Hanning">Thomas Hanning<sup>22</sup></a></li>
		  
		
		  
			<li><a href="/categories/Thoughtbot/" title="Thoughtbot">Thoughtbot<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tomasz-Szulc/" title="Tomasz Szulc">Tomasz Szulc<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/Wooji-Juice/" title="Wooji Juice">Wooji Juice<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/alisoftware/" title="alisoftware">alisoftware<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/alloc-init/" title="alloc-init">alloc-init<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/appcoda/" title="appcoda">appcoda<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/codingexplorer/" title="codingexplorer">codingexplorer<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iAchieved-it/" title="iAchieved.it">iAchieved.it<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/AppCoda/iOS/" title="iOS">iOS<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/iOS-开发/" title="iOS 开发">iOS 开发<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开发/" title="iOS 开发">iOS 开发<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/khanlou-com/" title="khanlou.com">khanlou.com<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/machinethink/" title="machinethink">machinethink<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/medium-com/" title="medium.com">medium.com<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/mikeash-com/" title="mikeash.com">mikeash.com<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/radex-io/" title="radex.io">radex.io<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/swift-org/" title="swift.org">swift.org<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/swiftandpainless/" title="swiftandpainless">swiftandpainless<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/thomashanning/" title="thomashanning">thomashanning<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/uraimo/" title="uraimo">uraimo<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/原创文章/" title="原创文章">原创文章<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/投稿/" title="投稿">投稿<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播资源/" title="直播资源">直播资源<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/社区问答/" title="社区问答">社区问答<sup>19</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Swift-进阶/" title="Swift 进阶">Swift 进阶<sup>170</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-入门/" title="Swift 入门">Swift 入门<sup>130</sup></a></li>
			
		
			
				<li><a href="/tags/Swift/" title="Swift">Swift<sup>105</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-开发/" title="iOS 开发">iOS 开发<sup>85</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-跨平台/" title="Swift 跨平台">Swift 跨平台<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-开源信息/" title="Swift 开源信息">Swift 开源信息<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/NSHipster/" title="NSHipster">NSHipster<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-3/" title="Swift 3">Swift 3<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/WatchOS-2/" title="WatchOS 2">WatchOS 2<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-入门/" title="iOS 入门">iOS 入门<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/教程/" title="教程">教程<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Apple-TV-开发/" title="Apple TV 开发">Apple TV 开发<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Xcode/" title="Xcode">Xcode<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-9/" title="iOS 9">iOS 9<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/IOSCREATOR/" title="IOSCREATOR">IOSCREATOR<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/社区问答/" title="社区问答">社区问答<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C/" title="Objective-C">Objective-C<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Jesse-Squires/" title="Jesse Squires">Jesse Squires<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Design-Patterns/" title="Design Patterns">Design Patterns<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-2/" title="Swift 2">Swift 2<sup>3</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://c4ios.swift.gg" target="_blank" title="C4iOS 教程">C4iOS 教程</a>
            
          </li>
        
          <li>
            
            	<a href="http://swift.gg/2016/03/14/live-video/" target="_blank" title="SwiftGG直播">SwiftGG直播</a>
            
          </li>
        
          <li>
            
            	<a href="http://t.swift.gg/" target="_blank" title="T 沙龙">T 沙龙</a>
            
          </li>
        
          <li>
            
            	<a href="http://codebuild.me" target="_blank" title="Code Build Me">Code Build Me</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.saitjr.com" target="_blank" title="//TODO:">//TODO:</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.5isjyx.com/" target="_blank" title="chiba">chiba</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.cee.moe" target="_blank" title="Perfect Freeze">Perfect Freeze</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftyper.com" target="_blank" title="小锅的 swift 之路">小锅的 swift 之路</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.futantan.com/" target="_blank" title="Prayer 的博客">Prayer 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.csdn.net/mmoaay" target="_blank" title="画渣程序猿 mmoaay">画渣程序猿 mmoaay</a>
            
          </li>
        
          <li>
            
            	<a href="http://linusling.com" target="_blank" title="小铁匠的 swift 之路">小铁匠的 swift 之路</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" title="ppppppmst 的简书博客">ppppppmst 的简书博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://chenmingbiao.github.io/" target="_blank" title="CMB 的博客">CMB 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://wxgbridgeq.github.io/" target="_blank" title="BridgeQ">BridgeQ</a>
            
          </li>
        
          <li>
            
            	<a href="http://chengway.in" target="_blank" title="walkingway 的博客">walkingway 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.dianqk.org" target="_blank" title="靛青K">靛青K</a>
            
          </li>
        
          <li>
            
            	<a href="http://alanmelody.com/" target="_blank" title="JackAlan">JackAlan</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftconchina.com" target="_blank" title="SwiftConChina">SwiftConChina</a>
            
          </li>
        
          <li>
            
            	<a href="http://swiftcn.io" target="_blank" title="Swift 中国">Swift 中国</a>
            
          </li>
        
          <li>
            
            	<a href="https://boxueio.com/" target="_blank" title="泊学">泊学</a>
            
          </li>
        
          <li>
            
            	<a href="https://bearychat.com/" target="_blank" title="BearyChat">BearyChat</a>
            
          </li>
        
          <li>
            
            	<a href="http://bbs.php-z.com" target="_blank" title="PHP-Z 论坛">PHP-Z 论坛</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftguide.cn" target="_blank" title="官方文档">官方文档</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.upyun.com/" target="_blank" title="又拍云赞助图床">又拍云赞助图床</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="wechatpart">
	<p class="asidetitle">微信公众号</p>
	<img src="/img/wechat.jpg">
</div>

</aside>
</div>
    </div>
    <footer>


<div id="footer">
	
	<div class="social-font">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="SwiftGG">SwiftGG</a>
		
		 | 
		<a href="http://www.miitbeian.gov.cn" target="_blank">浙ICP备14022870号-3</a>
		</p>
</div>
<img src="/img/logo_new.jpg" style="position: fixed; top: -9999px;height: 500px;width: 500px;">
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.15.0/dist/av-min.js"></script>
<script src="/js/mm.js"></script>
<script src="/js/subscribe.js"></script>

<div id="swiftweekly" style="display:none;">
  <img id="closeme" src="/img/close.png">
  <span id="sw_slogan">SwiftUI 重磅教程专属优惠：<b><a style="color: white;text-decoration:underline;" target="_blank" href="https://j.youzan.com/H9aEpi">使用 SwiftGG 优惠码，半价基础上再减 20 元！</a></b>&nbsp;</span>
  <!-- <form id="content"> -->
    <!-- <input name="email" id="sw_email" placeholder="输入邮箱地址" type="email" /><a class="sw_sub">订阅</a> -->
  <!-- </form> -->
</div>

<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<script type="text/javascript">
$(document).ready(function(){

  

  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66150920-1', 'auto');
  ga('send', 'pageview');

</script>





<!-- Analytics End -->

<!-- Totop Begin -->
<!--
	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>
-->
<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
