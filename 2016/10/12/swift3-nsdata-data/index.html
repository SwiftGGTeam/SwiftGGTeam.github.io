
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="baidu-site-verification" content="vqJV77bZM6">
  
    <title>Data 解析 Doom 的 WAD 文件 | Swift 教程 - Swift 语言学习 - Swift code - SwiftGG 翻译组 - 高质量的 Swift 译文网站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="SwiftGG">
    

    <meta name="keywords" content="doom wad,swift3,swift语言,swift翻译,swift学习">
    <meta name="applicable-device" content="pc,mobile">
    <meta name="description" content="Swift 3 中有个变化是 Foundation 引用类型添加值类型的封装，本文就来讲解下作为值类型的 `Data` 怎么封装 `NSData`。">
<meta name="keywords" content="doom wad,swift3">
<meta property="og:type" content="article">
<meta property="og:title" content="Data 解析 Doom 的 WAD 文件">
<meta property="og:url" content="https://swift.gg/2016/10/12/swift3-nsdata-data/index.html">
<meta property="og:site_name" content="SwiftGG">
<meta property="og:description" content="Swift 3 中有个变化是 Foundation 引用类型添加值类型的封装，本文就来讲解下作为值类型的 `Data` 怎么封装 `NSData`。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://appventure.me/img-content/doom.png">
<meta property="og:image" content="http://appventure.me/img-content/doom-shot.png">
<meta property="og:updated_time" content="2019-08-14T12:15:52.076Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Data 解析 Doom 的 WAD 文件">
<meta name="twitter:description" content="Swift 3 中有个变化是 Foundation 引用类型添加值类型的封装，本文就来讲解下作为值类型的 `Data` 怎么封装 `NSData`。">
<meta name="twitter:image" content="http://appventure.me/img-content/doom.png">

    
    <link rel="alternative" href="/atom.xml" title="SwiftGG" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon_new.ico">
    
    
    <link rel="apple-touch-icon" href="/img/logo_new.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/logo_new.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/gitment.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo_new.png" alt="SwiftGG" title="SwiftGG"></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="SwiftGG">SwiftGG</a></h1>
				<h2 class="blog-motto">走心的 Swift 翻译组</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
						<li><a href="/stat">统计</a></li>
					
						<li><a href="https://swiftgg.gitbook.io/swift/">Swift 官方文档翻译</a></li>
					
					<li>
 					
						<form class="search" method="GET" action="http://search.swift.gg/cse/search" target="_blank">
							<label>搜索</label>
						<input name="s" type="hidden" value="4873498141517765035"><input type="search" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		
  <header class="article-info clearfix">
    <h1 itemprop="name">
      
        <a href="/2016/10/12/swift3-nsdata-data/" target="_blank" title="Data 解析 Doom 的 WAD 文件" itemprop="url">Data 解析 Doom 的 WAD 文件</a>
    </h1>
    <p class="article-time">
      <time datetime="2016-10-12T10:00:00.000Z" itemprop="datePublished">2016-10-12</time>
      <span style="margin-left: 0.5em;"><i class="icon-eye-open"></i> <span class="viewcount"></span></span>
    </p>
  </header>

	<div class="article-content">
		
		<blockquote>
<p>作者：Terhechte，<a href="http://appventure.me/2016/07/15/swift3-nsdata-data/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016/07/15<br>译者：<a href="https://github.com/chaiyixiao" target="_blank" rel="noopener">BigbigChai</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="noopener">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<h3 id="Swift-3-：-从-NSData-到-Data-的转变"><a href="#Swift-3-：-从-NSData-到-Data-的转变" class="headerlink" title="Swift 3 ： 从 NSData 到 Data 的转变"></a>Swift 3 ： 从 NSData 到 Data 的转变</h3><p>Swift 3 带来了许多大大小小的变化。其中一个是为常见的 Foundation 引用类型（例如将 NSData 封装成 <code>Data</code> ，将 NSDate 封装成 <code>Date</code>）添加值类型的封装。这些新类型除了改变了内存行为和名字以外，在方法上也与对应的引用类型有所区别 <sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>。 从更换新方法名这类小改动，到完全去掉某一功能这种大改动，我们需要一些时间去适应这些新的值类型。本文会重点介绍作为值类型的 <code>Data</code> 是如何封装 <code>NSData</code> 的。</p>
<a id="more"></a>
<p>不仅如此，在学习完基础知识之后，我们还会写一个简单的示例应用。这个应用会读取和解析一个 Doom 毁灭战士的 WAD 文件 <sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>。</p>
<p><img src="http://appventure.me/img-content/doom.png" alt></p>
<h3 id="基本区别"><a href="#基本区别" class="headerlink" title="基本区别"></a>基本区别</h3><p>对于 <code>NSData</code>，其中一个最常见的使用场景就是调用以下方法加载和写入数据：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeToURL</span><span class="params">(<span class="number">_</span> url: NSURL, atomically atomically: Bool)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeToURL</span><span class="params">(<span class="number">_</span> url: NSURL, options writeOptionsMask: NSDataWritingOptions)</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="comment">// ... (implementations for file: String instead of NSURL)</span></span><br><span class="line"><span class="keyword">init</span>?(contentsOfURL url: <span class="type">NSURL</span>)</span><br><span class="line"><span class="keyword">init</span>(contentsOfURL url: <span class="type">NSURL</span>, options readOptionsMask: <span class="type">NSDataReadingOptions</span>) <span class="keyword">throws</span></span><br><span class="line"><span class="comment">// ... (implementations for file: String instead of NSURL)</span></span><br></pre></td></tr></table></figure>
<p>基本的使用方法并没有什么改动。新的 <code>Data</code> 类型提供了以下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(contentsOf: <span class="type">URL</span>, options: <span class="type">ReadingOptions</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(to: URL, options: WritingOptions)</span></span></span><br></pre></td></tr></table></figure>
<p>留意到 <code>Data</code> 简化了从文件读写数据的方法，原本 <code>NSData</code> 提供了多种不同的方法，现在只精简到两个方法。</p>
<p>比较一下 <code>NSData</code> 和 <code>Data</code> 的方法，可以发现另一个变化。<code>NSData</code> 提供了三十个方法和属性，而 <code>Data</code> 提供了一百三十个。Swift 强大的协议扩展可以轻易地解释这个巨大的差异。<code>Data</code> 从以下协议里获得了许多方法：</p>
<ul>
<li>CustomStringConvertible</li>
<li>Equatable</li>
<li>Hashable</li>
<li>MutableCollection</li>
<li>RandomAccessCollection</li>
<li>RangeReplaceableCollection</li>
<li>ReferenceConvertible</li>
</ul>
<p>这给 <code>Data</code> 提供了许多 <code>NSData</code> 不具备的功能。这里列出部分例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distance</span><span class="params">(from: Int, to: Int)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dropFirst</span><span class="params">(Int)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dropLast</span><span class="params">(Int)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(<span class="params">(UInt8)</span></span></span> -&gt; <span class="type">Bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;ElementOfResult&gt;<span class="params">(<span class="params">(UInt8)</span></span></span> -&gt; <span class="type">ElementOfResult?</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forEach</span><span class="params">(<span class="params">(UInt8)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(Int, offsetBy: Int, limitedBy: Int)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="params">(UInt8)</span></span></span> -&gt; <span class="type">T</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prefix</span><span class="params">(Int)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sorted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(separator: UInt8, maxSplits: Int, omittingEmptySubsequences: Bool)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;Result&gt;<span class="params">(Result, <span class="params">(partialResult: Result, UInt8)</span></span></span> -&gt; <span class="type">Result</span>)</span><br></pre></td></tr></table></figure>
<p>如你所见，许多函数式方法，例如 mapping 和 filtering 现在都可以操作 <code>Data</code> 类型的字节内容了。我认为这是相对 <code>NSData</code> 的一大进步。优势在于，现在可以轻松地使用下标以及对数据内容进行比较了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="type">Data</span>(bytes: [<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>])  </span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">2</span>]) <span class="comment">// 2</span></span><br><span class="line">data[<span class="number">2</span>] = <span class="number">0x09</span></span><br><span class="line"><span class="built_in">print</span> (data == <span class="type">Data</span>(bytes: [<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x09</span>, <span class="number">0x03</span>])) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>Data</code> 还提供了一些新的初始化方法专门用于处理 Swift 里常见的数据类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(bytes: <span class="type">Array</span>&lt;<span class="type">UInt8</span>&gt;)</span><br><span class="line"><span class="keyword">init</span>&lt;<span class="type">SourceType</span>&gt;(buffer: <span class="type">UnsafeMutableBufferPointer</span>&lt;<span class="type">SourceType</span>&gt;)</span><br><span class="line"><span class="keyword">init</span>(repeating: <span class="type">UInt8</span>, <span class="built_in">count</span>: <span class="type">Int</span>)</span><br></pre></td></tr></table></figure>
<h3 id="获取字节"><a href="#获取字节" class="headerlink" title="获取字节"></a>获取字节</h3><p>如果你使用 <code>Data</code> 与底层代码（例如 <code>C</code>库）交互，你会发现另一个明显的区别：<code>Data</code> 缺少了 <code>NSData</code> 的 <code>getBytes</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBytes</span><span class="params">(<span class="number">_</span> buffer: UnsafeMutablePointer&lt;Void&gt;, length length: Int)</span></span></span><br></pre></td></tr></table></figure>
<p><code>getBytes</code> 方法有许多不同的应用场景。其中最常见的是，当你需要解析一个文件并按字节读取并存储到数据类型/变量里。例如说，你想读取一个包含项目列表的二进制文件。这个文件经过编码，而编码方式如下：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:right">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Char</td>
<td style="text-align:center">4</td>
<td style="text-align:right">头部 (ABCD)</td>
</tr>
<tr>
<td>UInt32</td>
<td style="text-align:center">4</td>
<td style="text-align:right">数据开始</td>
</tr>
<tr>
<td>UInt32</td>
<td style="text-align:center">4</td>
<td style="text-align:right">数量</td>
</tr>
</tbody>
</table>
<p>该文件包含了一个四字节字符串 <em>ABCD</em> 标签，用来表示正确的文件类型（做校验）。接着的四字节定义了实际数据（例如头部的结束和项目的开始），头部最后的四字节定义了该文件存储项目的数量。</p>
<p>用 <code>NSData</code> 解析这段数据非常简单：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = ...</span><br><span class="line"><span class="keyword">var</span> length: <span class="type">UInt32</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> start: <span class="type">UInt32</span> = <span class="number">0</span></span><br><span class="line">data.getBytes(&amp;start, range: <span class="type">NSRange</span>(location: <span class="number">4</span>, length: <span class="number">4</span>))</span><br><span class="line">data.getBytes(&amp;length, range: <span class="type">NSRange</span>(location: <span class="number">8</span>, length: <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>如此将返回正确结果<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup>。如果数据不包含 C 字符串，方法会更简单。你可以直接用正确的字段定义一个 <code>结构体</code>，然后把字节读到结构体里：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:right">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>UInt32</td>
<td style="text-align:center">4</td>
<td style="text-align:right">数据开始</td>
</tr>
<tr>
<td>UInt32</td>
<td style="text-align:center">4</td>
<td style="text-align:right">数量</td>
</tr>
</tbody>
</table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = ...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Header</span> </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> start: <span class="type">UInt32</span></span><br><span class="line">    <span class="keyword">let</span> length: <span class="type">UInt32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> header = <span class="type">Header</span>(start: <span class="number">0</span>, length: <span class="number">0</span>)</span><br><span class="line">data.getBytes(&amp;header, range: <span class="type">NSRange</span>(location: <span class="number">0</span>, length: <span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Data-中-getBytes-的替代方案"><a href="#Data-中-getBytes-的替代方案" class="headerlink" title="Data 中 getBytes 的替代方案"></a>Data 中 getBytes 的替代方案</h3><p>不过 <code>Data</code> 里 getBytes 这个功能不再可用，转而提供了一个新方法作替代：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数据里获得字节</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withUnsafeBytes</span>&lt;ResultType, ContentType&gt;<span class="params">(<span class="params">(UnsafePointer&lt;ContentType&gt;)</span></span></span> -&gt; <span class="type">ResultType</span>)</span><br></pre></td></tr></table></figure>
<p>通过这个方法，我们可以从闭包中直接读取数据的字节内容。来看一个简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="type">Data</span>(bytes: [<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>])</span><br><span class="line">data.withUnsafeBytes &#123; (pointer: <span class="type">UnsafePointer</span>&lt;<span class="type">UInt8</span>&gt;) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(pointer)</span><br><span class="line">    <span class="built_in">print</span>(pointer.pointee)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// : 0x00007f8dcb77cc50</span></span><br><span class="line"><span class="comment">// : 1</span></span><br></pre></td></tr></table></figure>
<p>好了，现在有一个指向数据的 unsafe UInt8 指针，那要怎样利用起来呢？首先，我们需要一个不同的数据类型，然后一定要确定该数据的类型。我们知道这段数据包含一个 Int32 类型，那该如何正确地解码呢？</p>
<p>既然已经有了一个 unsafe pointer（UInt8 类型），那么就能够轻松地转换成目标类型 unsafe pointer。<code>UnsafePointer</code> 有一个 <code>pointee</code> 属性，可以返回指针所指向数据的正确类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="type">Data</span>(bytes: [<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>])</span><br><span class="line"><span class="keyword">let</span> result = data.withUnsafeBytes &#123; (pointer: <span class="type">UnsafePointer</span>&lt;<span class="type">Int32</span>&gt;) -&gt; <span class="type">Int32</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> pointer.pointee</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment">//: 256</span></span><br></pre></td></tr></table></figure>
<p>如你所见，我们创建了一个字节的 <code>Data</code> 实例，通过在闭包里定义 <code>UnsafePointer&lt;Int32&gt;</code>，返回 <code>Int32</code> 类型的数据。可以把代码写得再精简一点，因为编译器能够根据上下文推断结果类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result: <span class="type">Int32</span> = data.withUnsafeBytes &#123; $<span class="number">0</span>.pointee &#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据的生命周期"><a href="#数据的生命周期" class="headerlink" title="数据的生命周期"></a>数据的生命周期</h3><p>使用 <code>withUnsafeBytes</code> 时，指针（你所访问的）的生命周期是一个很重要的考虑因素（除了整个操作都是不安全的之外）。指针的生命周期受制于闭包的生命周期。正如文档所说：</p>
<blockquote>
<p>留意：字节指针参数不应该被存储，或者在所调用闭包的生命周期以外被使用。</p>
</blockquote>
<h3 id="泛型解决方案"><a href="#泛型解决方案" class="headerlink" title="泛型解决方案"></a>泛型解决方案</h3><p>现在，我们已经可以读取原始字节数据，并把它们转换成正确的类型了。接下来创建一个通用的方法来更轻松地执行操作，而不用额外地关心语法。 另外，我们暂时还无法针对数据的子序列执行操作，而只能对整个 <code>Data</code> 实例执行操作。 泛型的解决方法大概是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">scanValue</span>&lt;T&gt;<span class="params">(start: Int, length: Int)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">self</span>.subdata(<span class="keyword">in</span>: start..&lt;start+length).withUnsafeBytes &#123; $<span class="number">0</span>.pointee &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data = <span class="type">Data</span>(bytes: [<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x01</span>, <span class="number">0x02</span>])</span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int16</span> = data.scanValue(start: <span class="number">0</span>, length: <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">// : 1</span></span><br></pre></td></tr></table></figure>
<p>与之前的代码相比，存在两个显著的不同点：</p>
<ul>
<li>我们使用了 <code>subdata</code> 把扫描的字节限定于所需的特定区域。</li>
<li>我们使用了泛型来支持提取不同的数据类型。</li>
</ul>
<h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>另一方面，从现有的变量内容里得到 <code>Data</code> 缓冲， 虽然与下面的 Doom 的例子不相关，但是非常容易实现，（因此也写在这里啦）</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable = <span class="number">256</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="type">Data</span>(buffer: <span class="type">UnsafeBufferPointer</span>(start: &amp;variable, <span class="built_in">count</span>: <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(data) <span class="comment">// : &lt;00010000 00000000&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="解析-Doom-WAD-文件"><a href="#解析-Doom-WAD-文件" class="headerlink" title="解析 Doom WAD 文件"></a>解析 Doom WAD 文件</h3><p>我小时候非常热爱 Doom（毁灭战士）这个游戏。也玩到了很高的等级，并修改  WAD 文件加入了新的精灵，纹理等。因此当我想给解析二进制文件找一个合适（和简单）的例子时，就想起了 WAD 文件的设计。因为它十分直观且容易实现。于是我写了一个简单的小程序，用于读取 WAD 文件，然后列出所有存储地板的纹理名称 <sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup>。</p>
<p>我把源代码<a href="https://github.com/terhechte/SwiftWadReader" target="_blank" rel="noopener"> 放在了 GitHub </a>。<br>以下两个文件解释了Doom WAD 文件的设计。</p>
<ul>
<li><a href="http://doom.wikia.com/wiki/WAD" target="_blank" rel="noopener">http://doom.wikia.com/wiki/WAD</a></li>
<li><a href="http://doomlegacy.sourceforge.net/hosted/doomspec1666.txt" target="_blank" rel="noopener">http://doomlegacy.sourceforge.net/hosted/doomspec1666.txt</a></li>
</ul>
<p>但是对于这个简单的示例，只需要了解部分的文件格式就够了。<br>首先，每个 WAD 文件都有头文件：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:right">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Char</td>
<td style="text-align:center">4</td>
<td style="text-align:right">字符串 IWAD 或者 PWAD</td>
</tr>
<tr>
<td>Int32</td>
<td style="text-align:center">4</td>
<td style="text-align:right">WAD 中区块的数目</td>
</tr>
<tr>
<td>Int32</td>
<td style="text-align:center">4</td>
<td style="text-align:right">指向目录位置的指针</td>
</tr>
</tbody>
</table>
<p>开头的 4 字节用来确定文件格式。 <code>IWAD</code> 表明是官方的 Doom WAD 文件，<code>PWAD</code> 表明是在运行时补充内容到主要 WAD 文件的补丁文件。我们的应用只会读取 <code>IWAD</code> 文件。接着的 4 字节确定了 WAD 文件中 <em>区块（lump）</em> 的数目。 区块（Lump）是与 Doom 引擎合作的个体项目，例如纹理材质、精灵帧（Sprite-Frames），文字内容，模型，等等。每个纹理都是不同类的区块。最后的 4 字节定义了<em>目录</em>的位置。我们开始解析目录的时候，会给出相关解释。首先，让我们来解析头文件。</p>
<h3 id="解析头文件"><a href="#解析头文件" class="headerlink" title="解析头文件"></a>解析头文件</h3><p>读取 WAD 文件的方法非常简单：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: wadFileURL, options: .alwaysMapped)</span><br></pre></td></tr></table></figure>
<p>我们获取到数据之后，首先需要解析头文件。这里多次使用了之前创建的 <code>scanValue</code>data<code></code> 扩展。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">validateWadFile</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// 一些 Wad 文件定义</span></span><br><span class="line">    <span class="keyword">let</span> wadMaxSize = <span class="number">12</span>, wadLumpsStart = <span class="number">4</span>, wadDirectoryStart = <span class="number">8</span>, wadDefSize = <span class="number">4</span></span><br><span class="line">    <span class="comment">// WAD 文件永远以 12 字节的头文件开始。</span></span><br><span class="line">    <span class="keyword">guard</span> data.<span class="built_in">count</span> &gt;= wadMaxSize <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">WadReaderError</span>.invalidWadFile(reason: <span class="string">"File is too small"</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 它包含了三个值:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ASCII 字符 "IWAD" 或 "PWAD" 定义了 WAD 是 IWAD 还是 PWAD。</span></span><br><span class="line">    <span class="keyword">let</span> validStart = <span class="string">"IWAD"</span>.data(using: <span class="type">String</span>.<span class="type">Encoding</span>.ascii)!</span><br><span class="line">    <span class="keyword">guard</span> data.subdata(<span class="keyword">in</span>: <span class="number">0</span>..&lt;wadDefSize) == validStart <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="keyword">throw</span> <span class="type">WadReaderError</span>.invalidWadFile(reason: <span class="string">"Not an IWAD"</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个声明了 WAD 中区块数目的整数。</span></span><br><span class="line">    <span class="keyword">let</span> lumpsInteger: <span class="type">Int32</span> = data.scanValue(start: wadLumpsStart, length: wadDefSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个整数，含有指向目录地址的指针。</span></span><br><span class="line">    <span class="keyword">let</span> directoryInteger: <span class="type">Int32</span> = data.scanValue(start: wadDirectoryStart, length: wadDefSize)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> lumpsInteger &gt; <span class="number">0</span> &amp;&amp; directoryInteger &gt; <span class="type">Int32</span>(wadMaxSize)</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="keyword">throw</span> <span class="type">WadReaderError</span>.invalidWadFile(reason: <span class="string">"Empty Wad File"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在 <a href="https://github.com/terhechte/SwiftWadReader" target="_blank" rel="noopener">GitHub</a> 找到其他的类型（例如 <code>WadReaderError</code> <code>enum</code>）。下一步就是解析目录来获取每个区块的地址和大小。</p>
<h3 id="解析目录"><a href="#解析目录" class="headerlink" title="解析目录"></a>解析目录</h3><p>目录与区块的名字、包含的数据相关联。它包括了一系列的项目，每个项目的长度为 16 字节。目录的长度取决于 WAD 头文件里给出的数字。</p>
<p>每个 16 字节的项目按照以下的格式：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:right">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int32</td>
<td style="text-align:center">4</td>
<td style="text-align:right">区块数据在文件中的开始</td>
</tr>
<tr>
<td>Int32</td>
<td style="text-align:center">4</td>
<td style="text-align:right">区块的字节大小</td>
</tr>
<tr>
<td>Char</td>
<td style="text-align:center">4</td>
<td style="text-align:right">定义了区块名字的 ASCII 字符串</td>
</tr>
</tbody>
</table>
<p>名字的字符定义得比较复杂。文档是这么说的：</p>
<blockquote>
<p>使用 ASCII 字符串定义区块的名字。区块的名字只能使用 A-Z（大写），0-9，[ ] - _（Arch-Vile 精灵除外，它们使用 \）。如果这串字符小于 8 字节长度，那么余下字节要被 null 填满。</p>
</blockquote>
<p>留意最后一句话。在 C 语言里，字符串由空字符（<code>\0</code>）结束。这向系统表明了该字符串的内存到这里结束。Doom 用可选的空字符来节约存储空间。当字符串小于 8 字节，它会包含一个空字符。如果它达到最大允许长度（ 8 字节），那么字符串以最后一个字节结束，而非由空字符结束。</p>
<table>
<thead>
<tr>
<th>&nbsp;</th>
<th style="text-align:center">0</th>
<th style="text-align:right">1</th>
<th style="text-align:right">2</th>
<th style="text-align:right">3</th>
<th style="text-align:right">4</th>
<th style="text-align:right">5</th>
<th style="text-align:right">6</th>
<th style="text-align:right">7</th>
<th style="text-align:right">&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td>短</td>
<td style="text-align:center">I</td>
<td style="text-align:right">M</td>
<td style="text-align:right">P</td>
<td style="text-align:right"><strong>\0</strong></td>
<td style="text-align:right"><strong>\0</strong></td>
<td style="text-align:right"><strong>\0</strong></td>
<td style="text-align:right"><strong>\0</strong></td>
<td style="text-align:right"><strong>\0</strong></td>
<td style="text-align:right">#</td>
</tr>
<tr>
<td>长</td>
<td style="text-align:center">F</td>
<td style="text-align:right">L</td>
<td style="text-align:right">O</td>
<td style="text-align:right">O</td>
<td style="text-align:right">R</td>
<td style="text-align:right">4</td>
<td style="text-align:right">_</td>
<td style="text-align:right">5</td>
<td style="text-align:right">#</td>
</tr>
</tbody>
</table>
<p>看看上面的表格， 短名字会在字符串最后补空字符（位置 3）。长名字则没有空字符，而是以 <strong>FLOOR4_5</strong> 的最后一个字符 <strong>5</strong> 作为结束。<code>#</code>表明了下一个项目/片段在内存中的开始。</p>
<p>在我们尝试支持区块的名字字符格式之前，首先处理一下简单的部分。那就是读取开头和大小。</p>
<p>在开始之前，我们应该定义一个数据结构，用于保存从目录里读取的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lump</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> filepos: <span class="type">Int32</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> size: <span class="type">Int32</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，从完整的数据实例里取出数据片段，这是这些数据构成我们的目录。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个目录项的默认大小。</span></span><br><span class="line"><span class="keyword">let</span> wadDirectoryEntrySize = <span class="number">16</span></span><br><span class="line"><span class="comment">// 从完整数据里提取目录片段。</span></span><br><span class="line"><span class="keyword">let</span> directory = data.subdata(<span class="keyword">in</span>: <span class="type">Int</span>(directoryLocation)..&lt;(<span class="type">Int</span>(directoryLocation) + <span class="type">Int</span>(numberOfLumps) * wadDirectoryEntrySize))</span><br></pre></td></tr></table></figure>
<p>接着，我们以每段 16 字节的长度在 <code>Data</code> 中迭代。 Swift 的 <code>stride</code> 方法能够很好地实现这个功能：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> currentIndex <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: directory.<span class="built_in">count</span>, by: wadDirectoryEntrySize) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentDirectoryEntry = directory.subdata(<span class="keyword">in</span>: currentIndex..&lt;currentIndex+wadDirectoryEntrySize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个整数表明区块数据的起始在文件中的位置。</span></span><br><span class="line">    <span class="keyword">let</span> lumpStart: <span class="type">Int32</span> = currentDirectoryEntry.scanValue(start: <span class="number">0</span>, length: <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个表示了区块字节大小的整数。</span></span><br><span class="line">    <span class="keyword">let</span> lumpSize: <span class="type">Int32</span> = currentDirectoryEntry.scanValue(start: <span class="number">4</span>, length: <span class="number">4</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的部分到此结束，下面我们要开始进入秋名山飙车了。</p>
<h3 id="解析-C-字符串"><a href="#解析-C-字符串" class="headerlink" title="解析 C 字符串"></a>解析 C 字符串</h3><p>要知道对于每个区块的名字，每当遇到空的结束字符<strong>或者</strong>达到 8 字节的时候，我们都要停止向 Swift 字符串的写入。首要任务是利用相关数据创建一个数据片段。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nameData = currentDirectoryEntry.subdata(<span class="keyword">in</span>: <span class="number">8</span>..&lt;<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>Swift 给 C 字符串提供了很好的互操作性。这意味着需要创建一个字符串的时候，我们只需要把数据交给 <code>String</code> 的初始化方法就行了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lumpName = <span class="type">String</span>(data: nameData, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.ascii)</span><br></pre></td></tr></table></figure>
<p>这个方法可以执行，但是结果并不正确。因为它忽略了空结束符，所以即使是短名字，也会跟长名字一样转换成 8 字节的字符串。例如，名字为 <strong>IMP</strong> 的区块会变成 <strong>IMP00000</strong>。但是由于 <code>String(data:encoding:)</code> 并不知道 Doom 把剩下的 5 字节都用空字符填满了，而是根据 <code>nameData</code> 创建了一个完整 8 字节的字符串。</p>
<p>如果我们想要支持空字符， Swift 提供了一个 <code>cString</code> 初始化方法，用来读取包含空结束符的有效 cString：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据所给的 C 数组创建字符串</span></span><br><span class="line"><span class="comment">// 根据所给的编码方式编码</span></span><br><span class="line"><span class="keyword">init</span>?(cString: <span class="type">UnsafePointer</span>&lt;<span class="type">CChar</span>&gt;, encoding enc: <span class="type">String</span>.<span class="type">Encoding</span>)</span><br></pre></td></tr></table></figure>
<p>留意这里的参数不需要传入 <code>data</code> 实例，而是要求一个指向 <code>CChars</code> 的 unsafePointer。我们已经熟悉这个方法了，来写一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lumpName2 = nameData.withUnsafeBytes(&#123; (pointer: <span class="type">UnsafePointer</span>&lt;<span class="type">UInt8</span>&gt;) -&gt; <span class="type">String?</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(cString: <span class="type">UnsafePointer</span>&lt;<span class="type">CChar</span>&gt;(pointer), encoding: <span class="type">String</span>.<span class="type">Encoding</span>.ascii)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上方法依然不能得到我们想要的结果。在 Doom 的名字长度小于 8 字符的情况下，这段代码都能完美运行。但是只要某个名字长度达到 8 字节而没有一个空结束符时，这会继续读取（变成一个 16 字节片段），直到找到下一个有效的空结束符。 这就带来一些不确定长度的长字符串。</p>
<p>这个逻辑是 Doom 自定义的，因此我们需要自己来实现相应的代码。<code>Data</code> 支持 Swift 的集合和序列操作，因此我们可以直接用 reduce 来解决。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lumpName3Bytes = <span class="keyword">try</span> nameData.<span class="built_in">reduce</span>([<span class="type">UInt8</span>](), &#123; (a: [<span class="type">UInt8</span>], b: <span class="type">UInt8</span>) <span class="keyword">throws</span> -&gt; [<span class="type">UInt8</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> b &gt; <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> a &#125;</span><br><span class="line">    <span class="keyword">guard</span> a.<span class="built_in">count</span> &lt;= <span class="number">8</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> a &#125;</span><br><span class="line">    <span class="keyword">return</span> a + [b]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> lumpName3 = <span class="type">String</span>(bytes: lumpName3Bytes, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.ascii)</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="type">WadReaderError</span>.invalidLup(reason: <span class="string">"Could not decode lump name for bytes \(lumpName3Bytes)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码把数据以 <code>UInt8</code> 字节 reduce，并检查数据是否含有提前的空结束符。一切工作正常，虽然数据需要进行几次抽象，执行速度并不是很快。</p>
<p>不过如果我们能以 Doom 引擎类似的方法来解决的话，效果会更好。Doom 仅移动了 <code>char*</code> 的指针，并根据字符是否为空结束符判断是否需要提前跳出。Doom 是用 C 语言写的，因此它能在裸指针层面上迭代。</p>
<p>那么我们要怎样在 Swift 里实现这个逻辑呢？事实上，可以再次借助 <code>withUnsafeBytes</code> 实现类似的效果。来看看代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> finalLumpName = nameData.withUnsafeBytes(&#123; (pointer: <span class="type">UnsafePointer</span>&lt;<span class="type">CChar</span>&gt;) -&gt; <span class="type">String?</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> localPointer = pointer</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">8</span> &#123;</span><br><span class="line">	<span class="keyword">guard</span> localPointer.pointee != <span class="type">CChar</span>(<span class="number">0</span>) <span class="keyword">else</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">	localPointer = localPointer.successor()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> position = pointer.<span class="built_in">distance</span>(to: localPointer)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(data: nameData.subdata(<span class="keyword">in</span>: <span class="number">0</span>..&lt;position),</span><br><span class="line">		  encoding: <span class="type">String</span>.<span class="type">Encoding</span>.ascii)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> lumpName4 = finalLumpName <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">WadReaderError</span>.invalidLup(reason: <span class="string">"Could not decode lump name for bytes \(lumpName3Bytes)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>withUnsafeBytes</code> 的用法与之前相似，我们接受一个指向原始内存的指针。 <code>指针</code> 是一个 <code>let</code> 常数，但是由于我们需要对它做修改，因此我们在第一行创建了一个可变的拷贝<sup><a id="fnr.5" name="fnr.5" class="footref" href="#fn.5">5</a></sup>。</p>
<p>接着，开始我们的主要工作。从 0 到 8 循环，每次循环都检测指针指向的字符（<code>pointee</code>）是否为空结束符（<code>CChar(0)</code>）。是空结束符的话就表明提前找到了空结束符，需要跳出循环。否则将 <code>localPointer</code> 重载为下一位，即就是，当前指针内存中的下一个位置。这样，我们就能逐字节地读取内存中的所有内容了。</p>
<p>完成之后 ，就计算一下我们原始<code>指针</code>和<code>本地指针</code>的距离。如果在找到空结束符之前我们仅前移了三次，那么两个指针之前的距离为 3。最后，这个距离能让我们通过实际 C 字符串的子数据创建一个新的 String 实例。</p>
<p>最后用得到的数据创建新的 <code>区块</code> 结构体：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lumps.append(<span class="type">Lump</span>(filepos: lumpStart, size: lumpSize, name: lumpName4))</span><br></pre></td></tr></table></figure>
<p>如果你观察源代码，会发现 <code>F_START</code> 和 <code>F_END</code> 这种显著的引用。对于特殊的 <em>区块区域</em> ，Doom 使用特殊名称的空区块标记了区域的开头和结尾。<code>F_START / F_END</code> 围起了所有地板纹理的区块。在本教程中，我们将忽略这额外的一步。</p>
<p>应用最终的截图：</p>
<p><img src="http://appventure.me/img-content/doom-shot.png" alt></p>
<p>我知道这看起来并不酷炫。之后可能会计划在博客里写写如何展示那些纹理。</p>
<h3 id="桥接-NSData"><a href="#桥接-NSData" class="headerlink" title="桥接 NSData"></a>桥接 NSData</h3><p>我发现新的 <code>Data</code> 比 <code>NSData</code> 使用起来更加方便。然而，如果你需要 <code>NSData</code> 或者 <code>getBytes</code> 方法的话，这有一个简单的方法能把 <code>Data</code> 转换成 <code>NSData</code>。Swift 文档是这么写的：</p>
<blockquote>
<p>Data 具有“写时拷贝”能力，也能与 Objective-C 的 NSData 类型桥接。 对于 NSData 的自定义子类，你可以使用 <code>myData as Data</code> 把它的一个实例转换成结构体 Data 。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Data 结构体</span></span><br><span class="line"><span class="keyword">let</span> aDataStruct = <span class="type">Data</span>()</span><br><span class="line"><span class="comment">// 获得底层的引用类型 NSData</span></span><br><span class="line"><span class="keyword">let</span> aDataReference = aDataStruct <span class="keyword">as</span> <span class="type">NSData</span></span><br></pre></td></tr></table></figure>
<p>无论何时，如果你觉得 <code>Data</code> 类型难以满足你的需求，都能轻松地回到 <code>NSData</code> 类型使用你熟悉的方法。不过总而言之你还是应该尽可能地使用新的 <code>Data</code> 类型（除非你需要引用类型的语法）。</p>
<p><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1:    有些类型（例如 <code>Date</code>） 并不是包裹类型，而是全新的实现。</a></sup></p>
<p><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2:    Doom1，Doom2，Hexen，Heretic，还有 Ultimate Doom。虽然我只在 Doom1 Shareware 验证过。</a>&lt;/sup</sup></p>
<p><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3:    留意，我们并没有验证最开头的 4 个字节，确保这的确是 ABCD 文件。但是要添加这个验证也很简单。</a>&lt;/sup</sup></p>
<p><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4:    其实我也想展示 texture 但是不够时间去实现。</a>&lt;/sup</sup></p>
<p><sup><a id="fn.5" name="fn.5" class="footnum" href="#fnr.5">5:    Swift 3 不再在闭包和函数体里支持有用的 <code>var</code> 标注。</a>&lt;/sup</sup></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/APPVENTURE/">APPVENTURE</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Swift-3/">Swift 3</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://swift.gg/2016/10/12/swift3-nsdata-data/" data-title="Data 解析 Doom 的 WAD 文件 | SwiftGG" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/2016/10/17/working-with-mysql-databases-using-swift-3-0/" title="使用 Swift 3.0 操作 MySQL 数据库">
  <strong>上一篇</strong><br>
  <span>
  使用 Swift 3.0 操作 MySQL 数据库</span>
</a>
</div>


<div class="next">
<a href="/2016/10/11/swift-extensions-can-add-stored-properties/" title="Swift 扩展「可以」添加存储属性">
 <strong>下一篇</strong><br> 
 <span>Swift 扩展「可以」添加存储属性
</span>
</a>
</div>

</nav>

	


<section id="comments" class="comment">
  <div id="gitcomment">
  </div>
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
    var gitment = new Gitment({
      id: "2016/10/12/swift3-nsdata-data/",
      owner: "SwiftGGBot",
      repo: "gg-comment",
      oauth: {
        client_id: "8ed6aa0071e9d92f7ffc",
        client_secret: "29cc2c70290fad40a967780e5b49d86501348ddf",
      },
    })
    gitment.render('gitcomment')
    </script>
</section>



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift-3-：-从-NSData-到-Data-的转变"><span class="toc-number">1.</span> <span class="toc-text">Swift 3 ： 从 NSData 到 Data 的转变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本区别"><span class="toc-number">2.</span> <span class="toc-text">基本区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取字节"><span class="toc-number">3.</span> <span class="toc-text">获取字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-中-getBytes-的替代方案"><span class="toc-number">4.</span> <span class="toc-text">Data 中 getBytes 的替代方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据的生命周期"><span class="toc-number">5.</span> <span class="toc-text">数据的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型解决方案"><span class="toc-number">6.</span> <span class="toc-text">泛型解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据转换"><span class="toc-number">7.</span> <span class="toc-text">数据转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析-Doom-WAD-文件"><span class="toc-number">8.</span> <span class="toc-text">解析 Doom WAD 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析头文件"><span class="toc-number">9.</span> <span class="toc-text">解析头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析目录"><span class="toc-number">10.</span> <span class="toc-text">解析目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析-C-字符串"><span class="toc-number">11.</span> <span class="toc-text">解析 C 字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#桥接-NSData"><span class="toc-number">12.</span> <span class="toc-text">桥接 NSData</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/APPVENTURE/" title="APPVENTURE">APPVENTURE<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/Andyy-Hope/" title="Andyy Hope">Andyy Hope<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/AppCoda/" title="AppCoda">AppCoda<sup>44</sup></a></li>
		  
		
		  
			<li><a href="/categories/Arthur-Knopper/" title="Arthur Knopper">Arthur Knopper<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Big-O-Note-Taking/" title="Big O Note-Taking">Big O Note-Taking<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Coding-Explorer-Blog/" title="Coding Explorer Blog">Coding Explorer Blog<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Crunchy-Development/" title="Crunchy Development">Crunchy Development<sup>25</sup></a></li>
		  
		
		  
			<li><a href="/categories/Erica-Sadun/" title="Erica Sadun">Erica Sadun<sup>68</sup></a></li>
		  
		
		  
			<li><a href="/categories/IOSCREATOR/" title="IOSCREATOR">IOSCREATOR<sup>29</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jacob-Bandes-Storch/" title="Jacob Bandes-Storch">Jacob Bandes-Storch<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jameson-Quave/" title="Jameson Quave">Jameson Quave<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/JamesonQuave-com/" title="JamesonQuave.com">JamesonQuave.com<sup>18</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jesse-Squires/" title="Jesse Squires">Jesse Squires<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/KHANLOU/" title="KHANLOU">KHANLOU<sup>22</sup></a></li>
		  
		
		  
			<li><a href="/categories/Khanlou/" title="Khanlou">Khanlou<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mike-Ash/" title="Mike Ash">Mike Ash<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift/NSHipster/" title="NSHipster">NSHipster<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/NSHipster/" title="NSHipster">NSHipster<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Natasha-The-Robot/" title="Natasha The Robot">Natasha The Robot<sup>48</sup></a></li>
		  
		
		  
			<li><a href="/categories/Ole-Begemann/" title="Ole Begemann">Ole Begemann<sup>37</sup></a></li>
		  
		
		  
			<li><a href="/categories/PhotoKit/Ole-Begemann/" title="Ole Begemann">Ole Begemann<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Ole-Begemannh/" title="Ole Begemannh">Ole Begemannh<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Olivier-Halligon/" title="Olivier Halligon">Olivier Halligon<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Open-Source-Swift/" title="Open Source Swift">Open Source Swift<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/PhotoKit/" title="PhotoKit">PhotoKit<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Raj-Kandathi/" title="Raj Kandathi">Raj Kandathi<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Reinder-de-Vries/" title="Reinder de Vries">Reinder de Vries<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Russ-Bishop/" title="Russ Bishop">Russ Bishop<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Soroush-Khanlou/" title="Soroush Khanlou">Soroush Khanlou<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift/" title="Swift">Swift<sup>13</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mike-Ash/Swift/" title="Swift">Swift<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Olivier-Halligon/Swift/" title="Swift">Swift<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift-and-Painless/" title="Swift and Painless">Swift and Painless<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/Swift-入门/" title="Swift 入门">Swift 入门<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift-进阶/" title="Swift 进阶">Swift 进阶<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Think-and-Build/" title="Think and Build">Think and Build<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Thomas-Hanning/" title="Thomas Hanning">Thomas Hanning<sup>22</sup></a></li>
		  
		
		  
			<li><a href="/categories/Thoughtbot/" title="Thoughtbot">Thoughtbot<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tomasz-Szulc/" title="Tomasz Szulc">Tomasz Szulc<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/Wooji-Juice/" title="Wooji Juice">Wooji Juice<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/alisoftware/" title="alisoftware">alisoftware<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/alloc-init/" title="alloc-init">alloc-init<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/appcoda/" title="appcoda">appcoda<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/codingexplorer/" title="codingexplorer">codingexplorer<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iAchieved-it/" title="iAchieved.it">iAchieved.it<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/AppCoda/iOS/" title="iOS">iOS<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/iOS-开发/" title="iOS 开发">iOS 开发<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开发/" title="iOS 开发">iOS 开发<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/khanlou-com/" title="khanlou.com">khanlou.com<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/machinethink/" title="machinethink">machinethink<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/medium-com/" title="medium.com">medium.com<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/mikeash-com/" title="mikeash.com">mikeash.com<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/radex-io/" title="radex.io">radex.io<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/swift-org/" title="swift.org">swift.org<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/swiftandpainless/" title="swiftandpainless">swiftandpainless<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/thomashanning/" title="thomashanning">thomashanning<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/uraimo/" title="uraimo">uraimo<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/原创文章/" title="原创文章">原创文章<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/投稿/" title="投稿">投稿<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播资源/" title="直播资源">直播资源<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/社区问答/" title="社区问答">社区问答<sup>19</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Swift-进阶/" title="Swift 进阶">Swift 进阶<sup>170</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-入门/" title="Swift 入门">Swift 入门<sup>130</sup></a></li>
			
		
			
				<li><a href="/tags/Swift/" title="Swift">Swift<sup>105</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-开发/" title="iOS 开发">iOS 开发<sup>85</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-跨平台/" title="Swift 跨平台">Swift 跨平台<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-开源信息/" title="Swift 开源信息">Swift 开源信息<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/NSHipster/" title="NSHipster">NSHipster<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-3/" title="Swift 3">Swift 3<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/WatchOS-2/" title="WatchOS 2">WatchOS 2<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-入门/" title="iOS 入门">iOS 入门<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/教程/" title="教程">教程<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Apple-TV-开发/" title="Apple TV 开发">Apple TV 开发<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Xcode/" title="Xcode">Xcode<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-9/" title="iOS 9">iOS 9<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/IOSCREATOR/" title="IOSCREATOR">IOSCREATOR<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/社区问答/" title="社区问答">社区问答<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C/" title="Objective-C">Objective-C<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Jesse-Squires/" title="Jesse Squires">Jesse Squires<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Design-Patterns/" title="Design Patterns">Design Patterns<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-2/" title="Swift 2">Swift 2<sup>3</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://c4ios.swift.gg" target="_blank" title="C4iOS 教程">C4iOS 教程</a>
            
          </li>
        
          <li>
            
            	<a href="http://swift.gg/2016/03/14/live-video/" target="_blank" title="SwiftGG直播">SwiftGG直播</a>
            
          </li>
        
          <li>
            
            	<a href="http://t.swift.gg/" target="_blank" title="T 沙龙">T 沙龙</a>
            
          </li>
        
          <li>
            
            	<a href="http://codebuild.me" target="_blank" title="Code Build Me">Code Build Me</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.saitjr.com" target="_blank" title="//TODO:">//TODO:</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.5isjyx.com/" target="_blank" title="chiba">chiba</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.cee.moe" target="_blank" title="Perfect Freeze">Perfect Freeze</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftyper.com" target="_blank" title="小锅的 swift 之路">小锅的 swift 之路</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.futantan.com/" target="_blank" title="Prayer 的博客">Prayer 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.csdn.net/mmoaay" target="_blank" title="画渣程序猿 mmoaay">画渣程序猿 mmoaay</a>
            
          </li>
        
          <li>
            
            	<a href="http://linusling.com" target="_blank" title="小铁匠的 swift 之路">小铁匠的 swift 之路</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" title="ppppppmst 的简书博客">ppppppmst 的简书博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://chenmingbiao.github.io/" target="_blank" title="CMB 的博客">CMB 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://wxgbridgeq.github.io/" target="_blank" title="BridgeQ">BridgeQ</a>
            
          </li>
        
          <li>
            
            	<a href="http://chengway.in" target="_blank" title="walkingway 的博客">walkingway 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.dianqk.org" target="_blank" title="靛青K">靛青K</a>
            
          </li>
        
          <li>
            
            	<a href="http://alanmelody.com/" target="_blank" title="JackAlan">JackAlan</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftconchina.com" target="_blank" title="SwiftConChina">SwiftConChina</a>
            
          </li>
        
          <li>
            
            	<a href="http://swiftcn.io" target="_blank" title="Swift 中国">Swift 中国</a>
            
          </li>
        
          <li>
            
            	<a href="https://boxueio.com/" target="_blank" title="泊学">泊学</a>
            
          </li>
        
          <li>
            
            	<a href="https://bearychat.com/" target="_blank" title="BearyChat">BearyChat</a>
            
          </li>
        
          <li>
            
            	<a href="http://bbs.php-z.com" target="_blank" title="PHP-Z 论坛">PHP-Z 论坛</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftguide.cn" target="_blank" title="官方文档">官方文档</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.upyun.com/" target="_blank" title="又拍云赞助图床">又拍云赞助图床</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="wechatpart">
	<p class="asidetitle">微信公众号</p>
	<img src="/img/wechat.jpg">
</div>

</aside>
</div>
    </div>
    <footer>


<div id="footer">
	
	<div class="social-font">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="SwiftGG">SwiftGG</a>
		
		 | 
		<a href="http://www.miitbeian.gov.cn" target="_blank">浙ICP备14022870号-3</a>
		</p>
</div>
<img src="/img/logo_new.jpg" style="position: fixed; top: -9999px;height: 500px;width: 500px;">
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script src="/js/mm.js"></script>
<script src="/js/subscribe.js"></script>

<div id="swiftweekly" style="display:none;">
  <img id="closeme" src="/img/close.png">
  <span id="sw_slogan">SwiftUI 重磅教程专属优惠：<b><a style="color: white;text-decoration:underline;" target="_blank" href="https://j.youzan.com/H9aEpi">使用 SwiftGG 优惠码，半价基础上再减 20 元！</a></b>&nbsp;</span>
  <!-- <form id="content"> -->
    <!-- <input name="email" id="sw_email" placeholder="输入邮箱地址" type="email" /><a class="sw_sub">订阅</a> -->
  <!-- </form> -->
</div>

<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<script type="text/javascript">
$(document).ready(function(){

  

  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66150920-1', 'auto');
  ga('send', 'pageview');

</script>





<!-- Analytics End -->

<!-- Totop Begin -->
<!--
	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>
-->
<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
