
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="baidu-site-verification" content="vqJV77bZM6">
  
    <title>Friday Q&amp;A 2015-11-06：为什么 Swift 中的 String API 如此难用？ | Swift 教程 - Swift 语言学习 - Swift code - SwiftGG 翻译组 - 高质量的 Swift 译文网站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="SwiftGG">
    

    <meta name="keywords" content="swift语言,swift翻译,swift学习">
    <meta name="applicable-device" content="pc,mobile">
    <meta name="description" content="作者：Mike Ash，原文链接，原文日期：2015-11-06译者：Cee；校对：numbbbbb；定稿：numbbbbb    译者注：可以结合 WWDC 2015 Session 227 - What’s New in Internationalization 一起学习  欢迎来到本期因修改了很多次稿而推迟发布的周五问答。我发现很多人在使用 Swift 时，都会抱怨 String API">
<meta name="keywords" content="Swift 进阶">
<meta property="og:type" content="article">
<meta property="og:title" content="Friday Q&amp;A 2015-11-06：为什么 Swift 中的 String API 如此难用？">
<meta property="og:url" content="https://swift.gg/2016/01/25/friday-qa-2015-11-06-why-is-swifts-string-api-so-hard/index.html">
<meta property="og:site_name" content="SwiftGG">
<meta property="og:description" content="作者：Mike Ash，原文链接，原文日期：2015-11-06译者：Cee；校对：numbbbbb；定稿：numbbbbb    译者注：可以结合 WWDC 2015 Session 227 - What’s New in Internationalization 一起学习  欢迎来到本期因修改了很多次稿而推迟发布的周五问答。我发现很多人在使用 Swift 时，都会抱怨 String API">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-10-29T04:13:48.722Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Friday Q&amp;A 2015-11-06：为什么 Swift 中的 String API 如此难用？">
<meta name="twitter:description" content="作者：Mike Ash，原文链接，原文日期：2015-11-06译者：Cee；校对：numbbbbb；定稿：numbbbbb    译者注：可以结合 WWDC 2015 Session 227 - What’s New in Internationalization 一起学习  欢迎来到本期因修改了很多次稿而推迟发布的周五问答。我发现很多人在使用 Swift 时，都会抱怨 String API">

    
    <link rel="alternative" href="/atom.xml" title="SwiftGG" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon_new.ico">
    
    
    <link rel="apple-touch-icon" href="/img/logo_new.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/logo_new.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/gitment.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo_new.png" alt="SwiftGG" title="SwiftGG"></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="SwiftGG">SwiftGG</a></h1>
				<h2 class="blog-motto">走心的 Swift 翻译组</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
						<li><a href="/stat">统计</a></li>
					
						<li><a href="https://swiftgg.gitbook.io/swift/">Swift 官方文档翻译</a></li>
					
					<li>
 					
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		
  <header class="article-info clearfix">
    <h1 itemprop="name">
      
        <a href="/2016/01/25/friday-qa-2015-11-06-why-is-swifts-string-api-so-hard/" target="_blank" title="Friday Q&amp;A 2015-11-06：为什么 Swift 中的 String API 如此难用？" itemprop="url">Friday Q&amp;A 2015-11-06：为什么 Swift 中的 String API 如此难用？</a>
    </h1>
    <p class="article-time">
      <time datetime="2016-01-25T00:00:00.000Z" itemprop="datePublished">2016-01-25</time>
      <span style="margin-left: 0.5em;"><i class="icon-eye-open"></i> <span class="viewcount"></span></span>
    </p>
  </header>

	<div class="article-content">
		
		<blockquote>
<p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-11-06-why-is-swifts-string-api-so-hard.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-11-06<br>译者：<a href="https://github.com/Cee" target="_blank" rel="noopener">Cee</a>；校对：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a>；定稿：<a href="http://numbbbbb.com/" target="_blank" rel="noopener">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>译者注：可以结合 WWDC 2015 Session 227 - What’s New in Internationalization 一起学习</p>
</blockquote>
<p>欢迎来到本期因修改了很多次稿而推迟发布的周五问答。我发现很多人在使用 Swift 时，都会抱怨 <code>String</code> API 很难用。它很难学习并且设计得晦涩难懂，大多数人希望它能采用其他语言的字符串（String） API 设计风格。今天我就要来讲一下为什么 Swift 中的 <code>String</code> API 会被设计成现在这样（最起码要解释清楚我的看法），以及为什么我最终会认为，就其基础设计而言 Swift 中的 <code>String</code> API 是字符串 API 中设计得最好的。</p>
<a id="more"></a>
<h3 id="什么是字符串？"><a href="#什么是字符串？" class="headerlink" title="什么是字符串？"></a>什么是字符串？</h3><p>在我们讨论这点之前，首先需要建立一个基本的概念。我们总是把字符串想得很肤浅，很少有人能够深入思考它的本质。深思熟虑才能有助于我们理解接下来的内容。</p>
<p>从概念上来说，什么<em>是</em>字符串呢？从表面上看，字符串就是一段文本。<code>&quot;Hello, World&quot;</code> 是字符串；<code>&quot;/Users/mikeash&quot;</code> 和 <code>&quot;Robert&#39;); DROP TABLE Students;--&quot;</code> 也是字符串。</p>
<p>（顺道讲一下，我认为不应该把这些不同的文本表述概念看作是同样的字符串类型。人类可读的文本、文件路径、SQL 查询语句，以及其他所有在概念上讲并不相同的东西，在语言表示层面上都应该被表示成不同的类型。我觉得这些概念上不同的字符串应当有不同的类型，这也能大幅减少 bug 数量。尽管我并没有发现有哪个语言或者标准库做到了这点。）</p>
<p>那么在底层，这些常见的「文本」概念又是怎么被表示的呢？唔，得看情况。有很多不同的解决方法。</p>
<p>在很多语言中，字符串是用于存放字节（bytes）的数组（array）。程序所要做的就是为这些字节赋值。这种字符串的表示方法在 C++ 中是 <code>std::string</code> 类型，Python 2、Go 和其他语言也是这样。</p>
<p>C 语言对于字符串的表示就比较古怪和特殊。在 C 语言中，字符串是指向一串非零字节序列（sequence of non-zero bytes）的指针，以零字节位表示字符串的结束。基本的使其实和数组一样，但是 C 语言中的字符串不能包含零字节位，并且诸如查询字符串长度这样的操作需要扫描内存。</p>
<p>很多新语言把字符串定义成了一串 UCS-2 或者 UTF-16 码元（code unit）的集合。Java、C# 还有 JavaScript 是其中的代表。同样，在 Objective-C 中也使用了 Cocoa 和 <code>NSString</code>。这可能是一个历史遗留问题。Unicode 在 1991 年被提出时（译者注：1991 年 10 月发布 Unicode 1.0.0），当时的系统都是 16 位。很多流行的编程语言在那个时代被设计出来，并且将 Unicode 作为字符串的构成基础。在 1996 年，Unicode 在 16 位系统上经历了爆发性的增长（译者注：1996 年 7 月发布了 Unicode 2.0，字库从 7161 个字元变成了 38950 个），这些语言再要改变字符串的编码方式已为时已晚。这时，由于 UTF-16 的编码方式能够将更大的数字编码为一组 16 位码元的集合，因此将字符串视为 16 位码元序列的基本想法就这样延续了下来。</p>
<p>这种想法的一个变体就是将字符串定义成 UTF-8 码元序列，其中组成的码元是 8 位的。总体上来说和 UTF-16 的表示方法很接近，但是对于 ASCII 字符串来说，能够有更加紧凑的表示空间，而且避免了在传递字符串进入函数时，由于这些函数只接受 C 语言风格类型（也就是 UTF-8 字符串）而导致的转换。</p>
<p>也有些语言将字符串表示为 Unicode 码位（code point）指向的一段字符序列。Python 3 中就是这么实现的，在很多 C 语言实现中也提供了内置的 <code>wchar_t</code> 类型。</p>
<p>简短概括一下，一个字符串通常情况下会被当做某些特定<em>字符（character）</em>的序列，其中字符通常是一个字节，或者是一个 UTF-16 码元，又或者是一个 Unicode 码位。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>将字符串表示成一段连续「字符」的序列的确很方便。你可以把字符串看作是数组（array）（通常情况下就<em>是</em>个数组），这样就很容易获得字符串的子串、从字符串头部或者尾部取出部分元素、删除字符串的某部分、获取字符总数，等等。</p>
<p>问题是我们身边遍布着 Unicode，而 Unicode 会让事情变得很复杂。简单看一个字符串的例子，看一下它是怎么工作的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aé∞𝄞</span><br></pre></td></tr></table></figure>
<p>每一个 Unicode 码位都有一串数字（写作 U+nnnn）和一个供我们看得懂的命名（某种原因使用全大写的英文字母表示），这样我们更容易讨论单个字符所表示的内容。对于上面这个特定的字符串，它包括了：</p>
<ul>
<li>U+0061 LATIN SMALL LETTER A</li>
<li>U+0065 LATIN SMALL LETTER E</li>
<li>U+0301 COMBINING ACUTE ACCENT</li>
<li>U+221E INFINITY</li>
<li>U+1D11E MUSICAL SYMBOL G CLEF</li>
</ul>
<p>让我们从字符串的中间移除一个「字符」。对于这个「字符」，我们尝试用 UTF-8、UTF-16 和 Unicode 三种不同的字符编码方式来讲解。</p>
<p>首先将这个「字符」看作是一个 UTF-8 字符单元。这个字符串在 UTF-8 下看上去长这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">61 65 cc 81 e2 88 9e f0 9d 84 9e</span><br><span class="line">-- -- ----- -------- -----------</span><br><span class="line">a  e    ´      ∞          𝄞</span><br></pre></td></tr></table></figure>
<p>我们来移除第 3 个「字符」，即第三个字节（cc）。结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">61 65 81 e2 88 9e f0 9d 84 9e</span><br></pre></td></tr></table></figure>
<p>这个字符串已经不再是个合法的 UTF-8 字符串。UTF-8 的字符编码有三类。对于那些 <code>0xxxxxxx</code> 表示的，即由 0 开头的，会被表示为 ASCII 字符，单独归为第一类。那些看上去形如 <code>11xxxxxx</code> 的，表示一个多位序列，长度由第一个 0 的位置决定。第三类表示成 <code>10xxxxxx</code>，说明一个多位序列的剩余部分。<code>cc</code>（译者注：即 <code>11001100</code>，划分在第二类。其中第一个 0 出现在从 0 开始计数的第 2 位，故整个多位序列由两个字节组成）表示了一个多位序列的开始，长度是两个字节，<code>81</code>（译者注：即 <code>10000001</code>，划分在第三类）表示了这个多位序列的尾部。如果移除了 <code>cc</code>，那么剩下的 <code>81</code> 将会被留在字符串中。所有 UTF-8 校验器都会拒绝识别这个字符串（译者注：因为 <code>81</code> 并不是合法的 UTF-8 头部字符，只有第一类和第二类的字符是合法的）。如果我们移除了从第三位之后的任意一个字符，这个问题依旧会发生。</p>
<p>那么如果是第二位呢？如果我们移除了这个字符，我们会得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">61 cc 81 e2 88 9e f0 9d 84 9e</span><br><span class="line">-- ----- -------- -----------</span><br><span class="line">a    ´      ∞          𝄞</span><br></pre></td></tr></table></figure>
<p>看上去这依然是个合法的 UTF-8 字符串，但是结果并不是我们所期待的那样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">á∞𝄞</span><br></pre></td></tr></table></figure>
<p>对于人类来说，在这个字符串中的「第二个字符」应该是「é」。但是第二位上的字符仅仅是不带语调标记的「e」。这个语调标记被看作是一个「连接字符（combining character）」，被单独添加到前面的字符上。移除第二个字符仅仅是移去了「e」，导致这个语调标记连接到了「a」字符上。</p>
<p>那么如果移去首个字符呢？最终结果是我们所想要的那样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">65 cc 81 e2 88 9e f0 9d 84 9e</span><br><span class="line">-- ----- -------- -----------</span><br><span class="line">e    ´      ∞          𝄞</span><br></pre></td></tr></table></figure>
<p>让我们再把这个字符串当做 UTF-16 编码来看。在 UTF-16 编码下，这个字符串看上去长这个样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0061 0065 0301 221e d834 dd1e</span><br><span class="line">---- ---- ---- ---- ---------</span><br><span class="line"> a    e    ´    ∞       𝄞</span><br></pre></td></tr></table></figure>
<p>我们尝试着移除第二个「字符」：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0061 0301 221e d834 dd1e</span><br><span class="line">---- ---- ---- ---------</span><br><span class="line"> a    ´    ∞       𝄞</span><br></pre></td></tr></table></figure>
<p>和上面在 UTF-8 中出现的问题一样，删除了「e」，但是没有删除语调标记，导致这个标记附在了「a」上面。</p>
<p>那么如果删除第五个字符呢？我们得到了如下的序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0061 0065 0301 221e dd1e</span><br></pre></td></tr></table></figure>
<p>和不合法的 UTF-8 编码是类似的问题，这个序列也不再是一个合法的 UTF-16 字符串。序列 <code>d834 dd1e</code> 形成了一组代理对（surrogate pair），指两个 16 位的单元用于表示一个超过 16 位的码位（译者注：具体计算参考 <a href="http://www.wikiwand.com/zh/UTF-16#.E4.BB.8EU.2B10000.E5.88.B0U.2B10FFFF.E7.9A.84.E7.A0.81.E4.BD.8D" target="_blank" rel="noopener">Wiki</a>）。而让代理对中的一部分单独出现在字符串中是非法的。在 UTF-8 中通常会出错，而在 UTF-16 中这种状态会被忽略。例如，Cocoa 会将这个字符串渲染成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aé∞�</span><br></pre></td></tr></table></figure>
<p>（译者注：即平时出现的乱码现象。）</p>
<p>那么如果一个字符串被表示成一串 Unicode 码位序列呢？字符串看上去是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00061 00065 00301 0221E 1D11E</span><br><span class="line">----- ----- ----- ----- -----</span><br><span class="line">  a     e     ´     ∞     𝄞</span><br></pre></td></tr></table></figure>
<p>对于这种表示方式，我们可以移除任意一个「字符」而不会导致产生一个非法的字符串。但是连接语调标记的问题<em>依然</em>存在。移除第二个字符将会是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00061 00301 0221E 1D11E</span><br><span class="line">----- ----- ----- -----</span><br><span class="line">  a     ´     ∞     𝄞</span><br></pre></td></tr></table></figure>
<p>即使使用这种表示方法，我们也无法确保结果的正确。</p>
<p>这些通常不是我们能够简单想到的问题。英语是鲜有的几种仅使用 ASCII 字符就能表示的语言。你肯定不想把求职时的简历（Résumé）改成「Resume」吧！一旦超出 ASCII 字符集，这些荒谬的错误就开始出现了。</p>
<h3 id="字素簇（Grapheme-Clusters）"><a href="#字素簇（Grapheme-Clusters）" class="headerlink" title="字素簇（Grapheme Clusters）"></a>字素簇（Grapheme Clusters）</h3><p>Unicode 中有个概念叫做<em>字素簇（Grapheme Clusters）</em>，本质上就是阅读时会被考虑成单个「字符」的最小单元。在大多数表示方法中，一个字素簇就等价于一个单独的码位，但是也有可能会表示成包括语调标记的一部分内容。如果我们将上面的例子表示成字素簇的方式，那么很显然会是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a é ∞ 𝄞</span><br></pre></td></tr></table></figure>
<p>移除任意一个作为字素簇的单元，留下的内容都会被认为是合情合理的。</p>
<p>注意到在这个例子中，并没有任何的数字等值 (numeric equivalents) 存在。这是因为与 UTF-8、UTF-16 或者普通的 Unicode 码位不同，单个数字无法在一般情况下表示字素簇 (grapheme cluster) 。所谓字素簇，指的是一个或多个码位的序列集合。一个字素簇通常会包含一个或两个码位，但是某些情况下（比如 <a href="http://www.eeemo.net/" target="_blank" rel="noopener">Zalgo</a> 中）字素簇中也可能会包含大量的码位。例如下面这个字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e⃝⃞⃟⃠⃣⃤⃥⃦⃪⃧꙰꙲꙱</span><br></pre></td></tr></table></figure>
<p>这一团乱七八糟的字符串包括了 14 个不同的码位：</p>
<pre><code>+ U+0065
+ U+20DD
+ U+20DE
+ U+20DF
+ U+20E0
+ U+20E3
+ U+20E4
+ U+20E5
+ U+20E6
+ U+20E7
+ U+20EA
+ U+A670
+ U+A672
+ U+A671
</code></pre><p>所有的这些码位单元都表示一个单独的字素簇。</p>
<p>下面有个有趣的例子。有这样一个包含瑞士国旗的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">🇨🇭</span><br></pre></td></tr></table></figure>
<p>这个标记实际上包括两个码位：<code>U+1F1E8 U+1F1ED</code>。这两个码位又表示什么意思呢？</p>
<pre><code>+ U+1F1E8 REGIONAL INDICATOR SYMBOL LETTER C
+ U+1F1ED REGIONAL INDICATOR SYMBOL LETTER H
</code></pre><p>Unicode 包含了 26 个「Regional indicator symbol」而不是将地球上的所有国家的国旗作为单独的码位。将 C 和 H 的两个标识符合起来你就能得到瑞士的国旗。将 M 和 X 合起来会得到墨西哥国旗。每个国旗都是一个单独的字符簇，但是由两个码位组成，即四个 UTF-16 码元或者八个 UTF-8 字节。</p>
<h3 id="字符串-API-实现方式"><a href="#字符串-API-实现方式" class="headerlink" title="字符串 API 实现方式"></a>字符串 API 实现方式</h3><p>我们发现字符串有多种理解方法，也有多种表示「字符」的方式。将「字符」当做一个字素簇可能最接近人们对于「字符」的理解，但是在代码中操作字符串时，要依据语言环境来判断所谓「字符」的含义。当在文本中移动插入光标时，光标经过的字符就是指字素簇。当为了保证文本满足 140 字限制的推文时，这里的字符就是 Unicode 码位。当字符串想要保存在限定长度是 80 个字符的数据库表中时，这里的字符就是个 UTF-8 字节。</p>
<p>那么当你在实现字符串时，如何来平衡性能、内存使用和简洁代码三者呢？</p>
<p>通常的回答是选择一种标准化表示（canonical representation），之后在需要其他表示方法时进行转换。例如，<code>NSString</code> 使用 UTF-16 作为其标准化表示法。整个 API 基于 UTF-16 建立。如果你想要处理 UTF-8 或者 Unicode 码位，你需要将原始字符串转化成 UTF-8 或者 UTF-32 表示然后再对结果进行操作。这种处理方式更多是将字符串视为数据对象，而不是视为字符串本身，所以在转换时并不是很方便。如果你要对字符簇进行操作，还需要使用 <code>rangeOfComposedCharacterSequencesForRange:</code> 方法找到它们和其他字符的分界位置，这是一项非常枯燥的任务。</p>
<p>Swift 的 <code>String</code> 类型则采用了另外一种方法。在这里面没有标准化的表示，而是为字符串的不同表示方式提供了<em>视图（view）</em>。这样无论处理哪种表示方式，你都能够灵活自如地操作。</p>
<h3 id="简述-Swift-中的-String-API"><a href="#简述-Swift-中的-String-API" class="headerlink" title="简述 Swift 中的 String API"></a>简述 Swift 中的 String API</h3><p>在旧版本中的 Swift 中，<code>String</code> 类遵循了 <code>CollectionType</code> 接口，将自己看做是 <code>Character</code> 元素的集合。在 Swift 2 中，这种表示已经不复存在，<code>String</code> 类会根据使用的不同情况，展现出不同的表现方式。</p>
<p>这种表示方式还不是很完善，<code>String</code> 仍然有点倾向于 <code>Character</code> 集合的表示方式，它依旧提供了有点类似集合处理的接口：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">String</span>.<span class="type">CharacterView</span>.<span class="type">Index</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">subscript</span> (i: <span class="type">Index</span>) -&gt; <span class="type">Character</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过 <code>String</code> 的索引获得单独的 <code>Character</code>。注意，你并不能通过标准的 <code>for in</code> 语法遍历整个字符串。</p>
<p>在 Swift 看来，一个「字符」究竟是什么？正如我们所见，有太多的可能性。Swift 中 String API 的实现基础是将一个字素簇看作一个「字符」。这看上去是一个非常不错的选择，因为正如我们所见，这种方式符合人类在字符串中对于一个「字符」的定义。</p>
<p>不同的视图在 <code>String</code> 类中作为属性展现。例如，<code>characters</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> characters: <span class="type">String</span>.<span class="type">CharacterView</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>CharacterView</code> 是 <code>Character</code> 的一个集合：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>.<span class="title">CharacterView</span> : <span class="title">CollectionType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Index</span> ...</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">var</span> <span class="title">startIndex</span>: <span class="title">String</span>.<span class="title">CharacterView</span>.<span class="title">Index</span> </span>&#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">String</span>.<span class="type">CharacterView</span>.<span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">subscript</span> (i: <span class="type">String</span>.<span class="type">CharacterView</span>.<span class="type">Index</span>) -&gt; <span class="type">Character</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这看上去有点像 <code>String</code> 接口本身，除了它遵循 <code>CollectionType</code> 协议并且拥有所有 <code>CollectionType</code> 提供的方法外，它实现了划分（slice）、遍历（iterate）、映射（map）或者计数（count）方法。所以尽管下面的方法是不被允许的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">"abc"</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但是这是行得通的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">"abc"</span>.characters &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用构造函数从 <code>CharacterView</code> 中获得一个字符串：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> characters: <span class="type">String</span>.<span class="type">CharacterView</span>)</span><br></pre></td></tr></table></figure>
<p>你甚至可以从随机序列中获取 <code>Character</code> 作为一个字符串：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">S</span> : <span class="type">SequenceType</span> <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Generator</span>.<span class="type">Element</span> == <span class="type">Character</span>&gt;(<span class="number">_</span> characters: <span class="type">S</span>)</span><br><span class="line"><span class="comment">// 译者注：现在是 public init(_ characters: String.CharacterView)</span></span><br></pre></td></tr></table></figure>
<p>继续我们的旅程，下一个是 UTF-32 字符视图。Swift 把 UTF-32 码元叫做「Unicode 标量（unicode scalars）」（译者注：参看 <a href="http://www.unicode.org/glossary/#unicode_scalar_value" target="_blank" rel="noopener">Unicode scalar values</a>），因为 UTF-32 码元与 Unicode 码位是等同的。这个（简化的）接口看上去是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> unicodeScalars: <span class="type">String</span>.<span class="type">UnicodeScalarView</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnicodeScalarView</span> : <span class="title">CollectionType</span>, <span class="title">_Reflectable</span>, <span class="title">CustomStringConvertible</span>, <span class="title">CustomDebugStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Index</span> ...</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">var</span> <span class="title">startIndex</span>: <span class="title">String</span>.<span class="title">UnicodeScalarView</span>.<span class="title">Index</span> </span>&#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">String</span>.<span class="type">UnicodeScalarView</span>.<span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">subscript</span> (position: <span class="type">String</span>.<span class="type">UnicodeScalarView</span>.<span class="type">Index</span>) -&gt; <span class="type">UnicodeScalar</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于 <code>CharacterView</code>，在 <code>UnicodeScalarView</code> 内部也有个 <code>String</code> 的构造函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> unicodeScalars: <span class="type">String</span>.<span class="type">UnicodeScalarView</span>)</span><br></pre></td></tr></table></figure>
<p>不幸的是，<code>UnicodeScalar</code> 序列没有实例化方法，所以在操作时需要做一点额外工作，例如，需要将这些字符转换成数组，然后再将数组转化成字符串。同时，在 <code>UnicodeScalarView</code> 中也没有接受 <code>UnicodeScalar</code> 序列作为参数的实例化方法。然而，Swift 提供了一个在尾部添加元素的函数，所以你可以通过下面三步建立一个 <code>String</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unicodeScalarsView = <span class="type">String</span>.<span class="type">UnicodeScalarView</span>()</span><br><span class="line">unicodeScalarsView.appendContentsOf(unicodeScalarsArray)</span><br><span class="line"><span class="keyword">let</span> unicodeScalarsString = <span class="type">String</span>(unicodeScalarsView)</span><br></pre></td></tr></table></figure>
<p>接下来是 UTF-16 字符视图，看上去和其他的也很类似：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> utf16: <span class="type">String</span>.<span class="type">UTF16View</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">UTF16View</span> : <span class="title">CollectionType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Index</span> ...</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">var</span> <span class="title">startIndex</span>: <span class="title">String</span>.<span class="title">UTF16View</span>.<span class="title">Index</span> </span>&#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">String</span>.<span class="type">UTF16View</span>.<span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">subscript</span> (i: <span class="type">String</span>.<span class="type">UTF16View</span>.<span class="type">Index</span>) -&gt; <span class="type">CodeUnit</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个视图中，<code>String</code> 的实例化方法又有细微的差别：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>?(<span class="number">_</span> utf16: <span class="type">String</span>.<span class="type">UTF16View</span>)</span><br></pre></td></tr></table></figure>
<p>与其他的方法不同，这是一个可能会构造失败的构造方法（译者注：注意 <code>init?</code>）。任何 <code>Character</code> 或者 <code>UnicodeScalar</code> 的序列都是一个合法的 <code>String</code>，但是对于以 UTF-16 作为码元的序列，可能无法将其转化成一个合法的字符串。当内容非法时，构造方法将返回 <code>nil</code>。</p>
<p>将任意一个 UTF-16 码元序列转换成一个 <code>String</code> 类型的字符串非常困难。<code>UTF16View</code> 没有公共的构造方法，并且只有很少几个转换方法。这个问题的解决方法就是使用全局 <code>transcode</code> 函数，它已经遵循 <code>UnicodeCodecType</code> 协议。<code>UTF8</code>、<code>UTF16</code> 和 <code>UTF32</code> 这三个类中分别实现了这个协议，通过 <code>transcode</code> 函数可以实现三者的互相转化，虽然很不优雅。对于输入，函数接受一个 <code>GeneratorType</code> 类型的参数，中间通过一个用于产生输出结果每一位的函数进行转化。这可将一个 <code>UTF16</code> 字符串一点一点地转化成 <code>UTF32</code> 类型字符串，接着再将每个 <code>UTF-32</code> 码元转化成对应的 <code>UnicodeScalar</code>，拼接到 <code>String</code> 中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> utf16String = <span class="string">""</span></span><br><span class="line"><span class="built_in">transcode</span>(<span class="type">UTF16</span>.<span class="keyword">self</span>, <span class="type">UTF32</span>.<span class="keyword">self</span>, utf16Array.generate(), &#123; utf16String.append(<span class="type">UnicodeScalar</span>($<span class="number">0</span>)) &#125;, stopOnError: <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 译者注：transcode 方法的几个参数：</span></span><br><span class="line"><span class="comment">// 1. inputEncoding: InputEncoding.Type</span></span><br><span class="line"><span class="comment">// 2. _ outputEncoding: OutputEncoding.Type</span></span><br><span class="line"><span class="comment">// 3. _ input: Input</span></span><br><span class="line"><span class="comment">// 4. _ output: (OutputEncoding.CodeUnit) -&gt; ()</span></span><br><span class="line"><span class="comment">// 5. stopOnError: Bool</span></span><br><span class="line"><span class="comment">// 这里缺少 utf16Array，可以尝试在第二行代码前加入</span></span><br><span class="line"><span class="comment">// let utf16Array = Array(String(count: 9999, repeatedValue: Character("X")).utf16)</span></span><br><span class="line"><span class="comment">// 来测试结果</span></span><br></pre></td></tr></table></figure>
<p>最后我们来看一下 UTF-8 字符视图。实现方式和我们之前介绍的一样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> utf8: <span class="type">String</span>.<span class="type">UTF8View</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">UTF8View</span> : <span class="title">CollectionType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// A position in a `String.UTF8View`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Index</span> ...</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">var</span> <span class="title">startIndex</span>: <span class="title">String</span>.<span class="title">UTF8View</span>.<span class="title">Index</span> </span>&#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">String</span>.<span class="type">UTF8View</span>.<span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">subscript</span> (position: <span class="type">String</span>.<span class="type">UTF8View</span>.<span class="type">Index</span>) -&gt; <span class="type">CodeUnit</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外在定义中也有一个构造函数。和 <code>UTF16View</code> 一样，这也是一个可能失败的构造方法，因为由 UTF-8 码元组成的序列也有可能是不合法的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>?(<span class="number">_</span> utf8: <span class="type">String</span>.<span class="type">UTF8View</span>)</span><br></pre></td></tr></table></figure>
<p>和前者类似，这儿也没有一种简便的方法将任意一个 UTF-8 码元组成的序列转换成 <code>String</code> 类型。仍然可以使用 transcode 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> utf8String = <span class="string">""</span></span><br><span class="line"><span class="built_in">transcode</span>(<span class="type">UTF8</span>.<span class="keyword">self</span>, <span class="type">UTF32</span>.<span class="keyword">self</span>, utf8Array.generate(), &#123; utf8String.append(<span class="type">UnicodeScalar</span>($<span class="number">0</span>)) &#125;, stopOnError: <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 译者注：自行补充 utf8Array</span></span><br></pre></td></tr></table></figure>
<p>因为每次调用 <code>transcode</code> 方法实在是太痛苦了，我将它们用在了这一对可能会构造失败的构造函数中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>?&lt;<span class="type">Seq</span>: <span class="type">SequenceType</span> <span class="keyword">where</span> <span class="type">Seq</span>.<span class="type">Generator</span>.<span class="type">Element</span> == <span class="type">UInt16</span>&gt;(utf16: <span class="type">Seq</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="built_in">transcode</span>(<span class="type">UTF16</span>.<span class="keyword">self</span>,</span><br><span class="line">                        <span class="type">UTF32</span>.<span class="keyword">self</span>,</span><br><span class="line">                        utf16.generate(),</span><br><span class="line">                        &#123; <span class="keyword">self</span>.append(<span class="type">UnicodeScalar</span>($<span class="number">0</span>)) &#125;,</span><br><span class="line">                        stopOnError: <span class="literal">true</span>)</span><br><span class="line">                        == <span class="literal">false</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>?&lt;<span class="type">Seq</span>: <span class="type">SequenceType</span> <span class="keyword">where</span> <span class="type">Seq</span>.<span class="type">Generator</span>.<span class="type">Element</span> == <span class="type">UInt8</span>&gt;(utf8: <span class="type">Seq</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="built_in">transcode</span>(<span class="type">UTF8</span>.<span class="keyword">self</span>,</span><br><span class="line">                        <span class="type">UTF32</span>.<span class="keyword">self</span>,</span><br><span class="line">                        utf8.generate(),</span><br><span class="line">                        &#123; <span class="keyword">self</span>.append(<span class="type">UnicodeScalar</span>($<span class="number">0</span>)) &#125;,</span><br><span class="line">                        stopOnError: <span class="literal">true</span>)</span><br><span class="line">                        == <span class="literal">false</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个构造函数，我们能将任意一个 UTF-8 或 UTF-16 码元组成的序列转化成 <code>String</code> 类型的字符串：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span>(utf16: utf16Array)</span><br><span class="line"><span class="type">String</span>(utf8: utf8Array)</span><br></pre></td></tr></table></figure>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>上面介绍的不同视图都可用于索引 （Indexes）集合，但是它们并<em>不</em>是数组。索引类型是一种非常诡异的自定义<code>结构体（struct）</code>。这意味着你不能通过数字来读取不同视图中的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// all errors</span></span><br><span class="line">string[<span class="number">2</span>]</span><br><span class="line">string.characters[<span class="number">2</span>]</span><br><span class="line">string.unicodeScalars[<span class="number">2</span>]</span><br><span class="line">string.utf16[<span class="number">2</span>]</span><br><span class="line">string.utf8[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>不过你可以使用集合类型的 <code>startIndex</code> 或者是 <code>endIndex</code> 属性，并且使用 <code>successor()</code> 或者 <code>advancedBy()</code> 方法来移动到合适的位置：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// these work</span></span><br><span class="line">string[string.startIndex.advancedBy(<span class="number">2</span>)]</span><br><span class="line">string.characters[string.characters.startIndex.advancedBy(<span class="number">2</span>)]</span><br><span class="line">string.unicodeScalars[string.unicodeScalars.startIndex.advancedBy(<span class="number">2</span>)]</span><br><span class="line">string.utf16[string.utf16.startIndex.advancedBy(<span class="number">2</span>)]</span><br><span class="line">string.utf8[string.utf8.startIndex.advancedBy(<span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<p>这并不是件有趣的事，我们想知道到底发生了什么？</p>
<p>还记得这些以标准化表示保存在字符串对象的视图吗？当你使用了一个不符合标准化表示形式的视图时，存储的数据并不能自动转化成你想要的形式。</p>
<p>回想一下上面所提到的，不同的编码方式有不同的大小和长度。这也意味着无法简单地判断字符在不同视图中对应的位置，因为所映射到的位置是根据保存的数据不同而不同的。考虑下面这个字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AƎ工🄞</span><br></pre></td></tr></table></figure>
<p>这个 <code>String</code> 类型的字符串在 UTF-32 编码下的标准化表示是几个 32 位整型元素的集合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00041 0x0018e 0x05de5 0x1f11e</span><br></pre></td></tr></table></figure>
<p>我们再站在 UTF-8 编码的视角上来看这些数据。理论上说，这些数据就是一组 8 位整型元素的序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x41 0xc6 0x8e 0xe5 0xb7 0xa5 0xf0 0x9f 0x84 0x9e</span><br></pre></td></tr></table></figure>
<p>下面是两者的映射关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 0x00041 |  0x0018e  |     0x05de5    |       0x1f11e       |</span><br><span class="line">|         |           |                |                     |</span><br><span class="line">|  0x41   | 0xc6 0x8e | 0xe5 0xb7 0xa5 | 0xf0 0x9f 0x84 0x9e |</span><br></pre></td></tr></table></figure>
<p>如果需要获取在 UTF-8 视图下索引为 6 的值，那么必须去从 UTF-32 的序列中从头开始去扫描，然后获取所在位置所对应的值。</p>
<p>显然，这是可以做到的。Swift 提供了这种底层方法，但是长得并不好看：<code>string.utf8[string.utf8.startIndex.advancedBy(6)]</code>。为什么不能简化这种表示，直接用一个整数来访问索引呢？实际上 Swift 为了加强这种表示牺牲了简洁性。在一个 <code>UTF8View</code> 能提供 <code>subscript(Int)（译者注：即下标索引）</code> 方法的世界里，我们希望下面两段代码是等价的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> string.utf8 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;string.utf8.<span class="built_in">count</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">c</span> = string.utf8[i]</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这看上去很相似，但是第二个会意外地更慢一些。第一个循环是一个线性时间的扫描，然而第二个循环需要对每次迭代做一次线性扫描，即需要用二次方项的时间来做迭代遍历。对于一个长度为一百万的字符串，第一个循环只需要 0.1 秒，而第二个循环需要 3 个小时（在我的 2013 年 MacBook Pro 上进行的测试）。</p>
<p>我们再来看另外一个例子，从字符串中获得最后一个字符：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lastCharacter = string.characters[string.characters.endIndex.predecessor()]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lastCharacter = string.characters[string.characters.<span class="built_in">count</span> - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>第一个版本会更快一些。因为它直接从字符串的最后开始，从最后一个 <code>Character</code> 开始的地方从后往前搜索，然后获取字符。第二个版本会扫描整个字符串……<em>两次！</em>它首先得扫描整个字符串来获取有多少个 <code>Character</code>，接着<em>再一次</em>扫描特定序号的字符是什么。</p>
<p>类似这样的 API 在 Swift 中只是有点不同、有点难写。这些不同之处让程序员们知道了视图并不是数组，它们也没有数组的行为。当我们使用下标索引时，我们事实上假设了这种操作是一种效率很高的行为。如果 <code>String</code> 的视图提供了这种索引，那其实和我们的主观假设相反，只能写出效率很低的代码。</p>
<h3 id="使用-String-类来写代码吧"><a href="#使用-String-类来写代码吧" class="headerlink" title="使用 String 类来写代码吧"></a>使用 <code>String</code> 类来写代码吧</h3><p>在应用层面上使用 <code>String</code> 类写代码意味着什么呢？</p>
<p>你可以使用顶层 API。举个例子，如果你需要判断一个字符串是否是以某个字符开头的，那不需要对字符串索引然后获取第一个字符并做比较。直接使用 <code>hasPrefix</code> 方法，它已经为你准备好了一切。不要害怕导入 Foundation 库和使用 <code>NSString</code> 中的方法。当你想移除 <code>String</code> 开头和结尾多余的空格时，不必手动遍历获取这些字符，可以直接使用 <code>stringByTrimmingCharactersInSet</code> 方法。</p>
<p>如果你需要做一些字符层面的事情，那么就要想象一下，对于特定情况一个「字符」意味着什么。通常，正确答案是指一个字素簇，这在 Swift 中表示成 <code>Character</code> 类型，展现在 <code>characters</code> 视图中。</p>
<p>无论你需要对文本做些什么事情，都要思考一下对文本从头到尾线性扫描的事情。诸如计算有多少个字符、查找中间的字符这类操作会消耗线性的时间，所以你最好整理一下代码，更加干净利落地做这些线性时间扫描的操作。对于特定的视图，取得开始和结束的下标索引，在必要的时候使用 <code>advancedBy()</code> 或者其他类似的方法来移动索引的位置。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Swift 中的 <code>String</code> 类型采取了一种与众不同的方法来处理字符串。其他很多语言会选择一种标准化表示法，然后将转换等操作留给程序员自己去处理。通常它们在「到底什么才是字符？」这种重要的问题上做出了妥协，它们在处理字符串的时候，直接在编码中加入一些「语法糖」来让代码更加易写，然而这本质上就会导致各种困难的发生。Swift 语法可能没那么「甜」，相反则是在告诉你实际上会发生什么。对于程序员来说，这会比较困难，但其实也就只有这些困难。</p>
<p><code>String</code> 的 API 中也有一些坑，但是我们可以使用一些其他的方法来让操作稍微简单一些。特别地，从 UTF-8 或 UTF-16 转换成一个 <code>String</code> 类型的数据是一件困难而又烦人的事。如果我们有一些能够将任意一串码元序列转换成字符串的 <code>UTF8View</code> 和 <code>UTF16View</code> 构造方法，以及另外一些直接建立在这些视图上的转换方法，那么 Swift 中的 <code>String</code> 类型将变得更加友好。</p>
<p>今天就到这里了。希望下次还能给大家带来更多惊喜。周五问答的主题是根据大家的想法产生的，所以记得<a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">给我们写信来提出你想要听的话题</a>。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/mikeash-com/">mikeash.com</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Swift-进阶/">Swift 进阶</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://swift.gg/2016/01/25/friday-qa-2015-11-06-why-is-swifts-string-api-so-hard/" data-title="Friday Q&amp;A 2015-11-06：为什么 Swift 中的 String API 如此难用？ | SwiftGG" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/2016/01/26/lazy-properties-in-structs-swift/" title="结构体中的 Lazy 属性探究">
  <strong>上一篇</strong><br>
  <span>
  结构体中的 Lazy 属性探究</span>
</a>
</div>


<div class="next">
<a href="/2016/01/22/an-easy-way-to-stub-nsurlsession/" title="如何简单地模拟 NSURLSession 的返回数据">
 <strong>下一篇</strong><br> 
 <span>如何简单地模拟 NSURLSession 的返回数据
</span>
</a>
</div>

</nav>

	


<section id="comments" class="comment">
  <div id="gitcomment">
  </div>
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
    var gitment = new Gitment({
      id: "2016/01/25/friday-qa-2015-11-06-why-is-swifts-string-api-so-hard/",
      owner: "SwiftGGBot",
      repo: "gg-comment",
      oauth: {
        client_id: "8ed6aa0071e9d92f7ffc",
        client_secret: "29cc2c70290fad40a967780e5b49d86501348ddf",
      },
    })
    gitment.render('gitcomment')
    </script>
</section>



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是字符串？"><span class="toc-number">1.</span> <span class="toc-text">什么是字符串？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题"><span class="toc-number">2.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字素簇（Grapheme-Clusters）"><span class="toc-number">3.</span> <span class="toc-text">字素簇（Grapheme Clusters）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串-API-实现方式"><span class="toc-number">4.</span> <span class="toc-text">字符串 API 实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简述-Swift-中的-String-API"><span class="toc-number">5.</span> <span class="toc-text">简述 Swift 中的 String API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引"><span class="toc-number">6.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-String-类来写代码吧"><span class="toc-number">7.</span> <span class="toc-text">使用 String 类来写代码吧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/APPVENTURE/" title="APPVENTURE">APPVENTURE<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/Andyy-Hope/" title="Andyy Hope">Andyy Hope<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/AppCoda/" title="AppCoda">AppCoda<sup>44</sup></a></li>
		  
		
		  
			<li><a href="/categories/Arthur-Knopper/" title="Arthur Knopper">Arthur Knopper<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Big-O-Note-Taking/" title="Big O Note-Taking">Big O Note-Taking<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Coding-Explorer-Blog/" title="Coding Explorer Blog">Coding Explorer Blog<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Crunchy-Development/" title="Crunchy Development">Crunchy Development<sup>26</sup></a></li>
		  
		
		  
			<li><a href="/categories/Erica-Sadun/" title="Erica Sadun">Erica Sadun<sup>68</sup></a></li>
		  
		
		  
			<li><a href="/categories/IOSCREATOR/" title="IOSCREATOR">IOSCREATOR<sup>29</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jacob-Bandes-Storch/" title="Jacob Bandes-Storch">Jacob Bandes-Storch<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jameson-Quave/" title="Jameson Quave">Jameson Quave<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/JamesonQuave-com/" title="JamesonQuave.com">JamesonQuave.com<sup>18</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jesse-Squires/" title="Jesse Squires">Jesse Squires<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/KHANLOU/" title="KHANLOU">KHANLOU<sup>22</sup></a></li>
		  
		
		  
			<li><a href="/categories/Khanlou/" title="Khanlou">Khanlou<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mike-Ash/" title="Mike Ash">Mike Ash<sup>16</sup></a></li>
		  
		
		  
			<li><a href="/categories/NSHipster/" title="NSHipster">NSHipster<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift/NSHipster/" title="NSHipster">NSHipster<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/Natasha-The-Robot/" title="Natasha The Robot">Natasha The Robot<sup>48</sup></a></li>
		  
		
		  
			<li><a href="/categories/Ole-Begemann/" title="Ole Begemann">Ole Begemann<sup>38</sup></a></li>
		  
		
		  
			<li><a href="/categories/PhotoKit/Ole-Begemann/" title="Ole Begemann">Ole Begemann<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Ole-Begemannh/" title="Ole Begemannh">Ole Begemannh<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Olivier-Halligon/" title="Olivier Halligon">Olivier Halligon<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Open-Source-Swift/" title="Open Source Swift">Open Source Swift<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/POP/" title="POP">POP<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/PhotoKit/" title="PhotoKit">PhotoKit<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Raj-Kandathi/" title="Raj Kandathi">Raj Kandathi<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Reinder-de-Vries/" title="Reinder de Vries">Reinder de Vries<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Russ-Bishop/" title="Russ Bishop">Russ Bishop<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/POP/SWIFT/" title="SWIFT">SWIFT<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Soroush-Khanlou/" title="Soroush Khanlou">Soroush Khanlou<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift/" title="Swift">Swift<sup>16</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mike-Ash/Swift/" title="Swift">Swift<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Ole-Begemann/Swift/" title="Swift">Swift<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Olivier-Halligon/Swift/" title="Swift">Swift<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift-and-Painless/" title="Swift and Painless">Swift and Painless<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/Swift-入门/" title="Swift 入门">Swift 入门<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift-进阶/" title="Swift 进阶">Swift 进阶<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/The-Always-Right-Institute/" title="The Always Right Institute">The Always Right Institute<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Think-and-Build/" title="Think and Build">Think and Build<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Thomas-Hanning/" title="Thomas Hanning">Thomas Hanning<sup>22</sup></a></li>
		  
		
		  
			<li><a href="/categories/Thoughtbot/" title="Thoughtbot">Thoughtbot<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tomasz-Szulc/" title="Tomasz Szulc">Tomasz Szulc<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/Wooji-Juice/" title="Wooji Juice">Wooji Juice<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/alisoftware/" title="alisoftware">alisoftware<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/alloc-init/" title="alloc-init">alloc-init<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/appcoda/" title="appcoda">appcoda<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/codingexplorer/" title="codingexplorer">codingexplorer<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iAchieved-it/" title="iAchieved.it">iAchieved.it<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/AppCoda/iOS/" title="iOS">iOS<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/iOS-开发/" title="iOS 开发">iOS 开发<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开发/" title="iOS 开发">iOS 开发<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/khanlou-com/" title="khanlou.com">khanlou.com<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/machinethink/" title="machinethink">machinethink<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/medium-com/" title="medium.com">medium.com<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/mikeash-com/" title="mikeash.com">mikeash.com<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/radex-io/" title="radex.io">radex.io<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/swift-org/" title="swift.org">swift.org<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/swiftandpainless/" title="swiftandpainless">swiftandpainless<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/swiftjectivec/" title="swiftjectivec">swiftjectivec<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/thomashanning/" title="thomashanning">thomashanning<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/uraimo/" title="uraimo">uraimo<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/原创文章/" title="原创文章">原创文章<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/投稿/" title="投稿">投稿<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播资源/" title="直播资源">直播资源<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/社区问答/" title="社区问答">社区问答<sup>19</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Swift-进阶/" title="Swift 进阶">Swift 进阶<sup>170</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-入门/" title="Swift 入门">Swift 入门<sup>130</sup></a></li>
			
		
			
				<li><a href="/tags/Swift/" title="Swift">Swift<sup>110</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-开发/" title="iOS 开发">iOS 开发<sup>85</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-跨平台/" title="Swift 跨平台">Swift 跨平台<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-开源信息/" title="Swift 开源信息">Swift 开源信息<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/NSHipster/" title="NSHipster">NSHipster<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-3/" title="Swift 3">Swift 3<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/WatchOS-2/" title="WatchOS 2">WatchOS 2<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/教程/" title="教程">教程<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-入门/" title="iOS 入门">iOS 入门<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Apple-TV-开发/" title="Apple TV 开发">Apple TV 开发<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Xcode/" title="Xcode">Xcode<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/IOSCREATOR/" title="IOSCREATOR">IOSCREATOR<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-9/" title="iOS 9">iOS 9<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/社区问答/" title="社区问答">社区问答<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-2/" title="Swift 2">Swift 2<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C/" title="Objective-C">Objective-C<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Jesse-Squires/" title="Jesse Squires">Jesse Squires<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Design-Patterns/" title="Design Patterns">Design Patterns<sup>3</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://c4ios.swift.gg" target="_blank" title="C4iOS 教程">C4iOS 教程</a>
            
          </li>
        
          <li>
            
            	<a href="http://swift.gg/2016/03/14/live-video/" target="_blank" title="SwiftGG直播">SwiftGG直播</a>
            
          </li>
        
          <li>
            
            	<a href="http://t.swift.gg/" target="_blank" title="T 沙龙">T 沙龙</a>
            
          </li>
        
          <li>
            
            	<a href="http://codebuild.me" target="_blank" title="Code Build Me">Code Build Me</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.saitjr.com" target="_blank" title="//TODO:">//TODO:</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.5isjyx.com/" target="_blank" title="chiba">chiba</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.cee.moe" target="_blank" title="Perfect Freeze">Perfect Freeze</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftyper.com" target="_blank" title="小锅的 swift 之路">小锅的 swift 之路</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.futantan.com/" target="_blank" title="Prayer 的博客">Prayer 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.csdn.net/mmoaay" target="_blank" title="画渣程序猿 mmoaay">画渣程序猿 mmoaay</a>
            
          </li>
        
          <li>
            
            	<a href="http://linusling.com" target="_blank" title="小铁匠的 swift 之路">小铁匠的 swift 之路</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" title="ppppppmst 的简书博客">ppppppmst 的简书博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://chenmingbiao.github.io/" target="_blank" title="CMB 的博客">CMB 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://wxgbridgeq.github.io/" target="_blank" title="BridgeQ">BridgeQ</a>
            
          </li>
        
          <li>
            
            	<a href="http://chengway.in" target="_blank" title="walkingway 的博客">walkingway 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.dianqk.org" target="_blank" title="靛青K">靛青K</a>
            
          </li>
        
          <li>
            
            	<a href="http://alanmelody.com/" target="_blank" title="JackAlan">JackAlan</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftconchina.com" target="_blank" title="SwiftConChina">SwiftConChina</a>
            
          </li>
        
          <li>
            
            	<a href="http://swiftcn.io" target="_blank" title="Swift 中国">Swift 中国</a>
            
          </li>
        
          <li>
            
            	<a href="https://boxueio.com/" target="_blank" title="泊学">泊学</a>
            
          </li>
        
          <li>
            
            	<a href="https://bearychat.com/" target="_blank" title="BearyChat">BearyChat</a>
            
          </li>
        
          <li>
            
            	<a href="http://bbs.php-z.com" target="_blank" title="PHP-Z 论坛">PHP-Z 论坛</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftguide.cn" target="_blank" title="官方文档">官方文档</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.upyun.com/" target="_blank" title="又拍云赞助图床">又拍云赞助图床</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="wechatpart">
	<p class="asidetitle">微信公众号</p>
	<img src="/img/wechat.jpg">
</div>

</aside>
</div>
    </div>
    <footer>


<div id="footer">
	
	<div class="social-font">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="SwiftGG">SwiftGG</a>
		
		 | 
		<a href="http://www.miitbeian.gov.cn" target="_blank">浙ICP备14022870号-3</a>
		</p>
</div>
<img src="/img/logo_new.jpg" style="position: fixed; top: -9999px;height: 500px;width: 500px;">
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.15.0/dist/av-min.js"></script>
<script src="/js/mm.js"></script>
<script src="/js/subscribe.js"></script>

<div id="swiftweekly" style="display:none;">
  <img id="closeme" src="/img/close.png">
  <span id="sw_slogan">SwiftUI 重磅教程专属优惠：<b><a style="color: white;text-decoration:underline;" target="_blank" href="https://j.youzan.com/H9aEpi">使用 SwiftGG 优惠码，半价基础上再减 20 元！</a></b>&nbsp;</span>
  <!-- <form id="content"> -->
    <!-- <input name="email" id="sw_email" placeholder="输入邮箱地址" type="email" /><a class="sw_sub">订阅</a> -->
  <!-- </form> -->
</div>

<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<script type="text/javascript">
$(document).ready(function(){

  

  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66150920-1', 'auto');
  ga('send', 'pageview');

</script>





<!-- Analytics End -->

<!-- Totop Begin -->
<!--
	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>
-->
<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
