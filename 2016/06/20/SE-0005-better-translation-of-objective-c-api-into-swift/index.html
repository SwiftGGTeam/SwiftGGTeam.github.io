
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="baidu-site-verification" content="vqJV77bZM6" />
  
    <title>SE-0005 更好的把 Objective-C APIs 转换成 Swift 版本 | Swift 教程 - Swift 语言学习 - Swift code - SwiftGG 翻译组 - 高质量的 Swift 译文网站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="SwiftGG">
    

    <meta name="keywords" content="objective c 转 swift,swift语言,swift翻译,swift学习">
    <meta name="applicable-device" content="pc,mobile">
    <meta name="description" content="怎么把 Objective-C APIs 转成 Swift 呢，本文就来深入的探讨这个问题。">
<meta name="keywords" content="objective c 转 swift">
<meta property="og:type" content="article">
<meta property="og:title" content="SE-0005 更好的把 Objective-C APIs 转换成 Swift 版本">
<meta property="og:url" content="https://swift.gg/2016/06/20/SE-0005-better-translation-of-objective-c-api-into-swift/index.html">
<meta property="og:site_name" content="SwiftGG">
<meta property="og:description" content="怎么把 Objective-C APIs 转成 Swift 呢，本文就来深入的探讨这个问题。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-11-15T03:28:34.764Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SE-0005 更好的把 Objective-C APIs 转换成 Swift 版本">
<meta name="twitter:description" content="怎么把 Objective-C APIs 转成 Swift 呢，本文就来深入的探讨这个问题。">

    
    <link rel="alternative" href="/atom.xml" title="SwiftGG" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon_new.ico">
    
    
    <link rel="apple-touch-icon" href="/img/logo_new.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/logo_new.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/gitment.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo_new.png" alt="SwiftGG" title="SwiftGG"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="SwiftGG">SwiftGG</a></h1>
				<h2 class="blog-motto">走心的 Swift 翻译组</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
						<li><a href="/stat">统计</a></li>
					
					<li>
 					
						<form class="search" method="GET" action="http://search.swift.gg/cse/search" target="_blank">
							<label>搜索</label>
						<input name="s" type="hidden" value= 4873498141517765035 ><input type="search" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		
  <header class="article-info clearfix">
    <h1 itemprop="name">
      
        <a href="/2016/06/20/SE-0005-better-translation-of-objective-c-api-into-swift/" target="_blank" title="SE-0005 更好的把 Objective-C APIs 转换成 Swift 版本" itemprop="url">SE-0005 更好的把 Objective-C APIs 转换成 Swift 版本</a>
    </h1>
    <p class="article-time">
      <time datetime="2016-06-20T00:00:00.000Z" itemprop="datePublished">2016-06-20</time>
      <span style="margin-left: 0.5em;"><i class="icon-eye-open"></i> <span class="viewcount"></span></span>
    </p>
  </header>

	<div class="article-content">
		
		<blockquote>
<p>译者：<a href="https://www.boxueio.com" target="_blank" rel="noopener">泊学</a></p>
</blockquote>
<h2 id="提交-review-前必读"><a href="#提交-review-前必读" class="headerlink" title="提交 review 前必读"></a>提交 review 前必读</h2><p>做为下面三份文档的一部分，它们的内容是彼此关联的：</p>
<ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md" target="_blank" rel="noopener">SE-0023 API设计指南</a></li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md" target="_blank" rel="noopener">SE-0006 在标准库中应用设计指南</a></li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md" target="_blank" rel="noopener">SE-0005 更好的把Objective-C APIs转换成Swift版本</a></li>
</ul>
<p>这三份文档的内容是相互关联的（例如：标准库中一个 API 的调整和某个 API guideline 是对应的，或根据某条设计指南制定的 Clang importer 规则，等等）。正因为存在这些内容交叉，为了保证讨论是可维护的，我们希望你：</p>
<ul>
<li><strong>在提交 review 之前，对以上三份文档中的全部内容，有一个基本的了解</strong>；</li>
<li><strong>在提交以上三个文档的 review 时，请参照每个文档的 review 声明</strong>。在你提交 review 时，如果文档间交叉引用有助于帮你阐述观点，你应该包含它们（这也是被提倡的做法）。</li>
</ul>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这份提议描述了我们如何改进 Swift 的 <code>Clang Importer</code>，它有两个功能：首先，把 C 和 Objective-C 的 APIs 映射成 Swift 版本；其次，翻译 Objective-C 中的函数、类型、方法和属性等的名字，让它们满足 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md" target="_blank" rel="noopener">API设计指南</a> 中的要求，这些要求，是我们在设计Swift 3时，建立的原则。</p>
<p>我们的方法专注于 Objective-C 版本的 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="noopener">Cocoa 编码指南</a> 和 Swift 版本的 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md" target="_blank" rel="noopener">API 设计指南</a> 之间的差异。使用一些简单的语言学分析方法，协助我们把 Objective-C 中的名字自动转换成更加 Swift “原汁原味”的名字。</p>
<p>转换的结果，可以在 <a href="https://github.com/apple/swift-3-api-guidelines-review" target="_blank" rel="noopener">Swift 3 API Guidelines Review</a> 这个 repository 中查看。这个 repository 中包含了用 <a href="https://github.com/apple/swift-3-api-guidelines-review/tree/swift-2" target="_blank" rel="noopener">Swift 2</a> 和 <a href="https://github.com/apple/swift-3-api-guidelines-review/tree/swift-3" target="_blank" rel="noopener">Swift 3</a> 编写的 Objective-C APIs 项目，以及一些已经迁移到 Swift 3 版本的示例代码。你也可以通过 <a href="https://github.com/apple/swift-3-api-guidelines-review/compare/swift-2...swift-3" target="_blank" rel="noopener">对比这两个分支</a> 来查看所有的改动。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>Objective-C 版本的 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="noopener">Cocoa 编码指南</a> 为使用 Objective-C 创建简单、一致的 API 提供了完整的框架。但是 Swift 是一门不同的编程语言，特别是，它是一门支持类型推导、泛型编程和重载等语言特性的强类型语言。于是，基于 Objective-C 编写的 APIs 搭配上Swift就有点儿水土不服，这些 API 在 Swift 里用起来显得很啰嗦。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> content = </span><br><span class="line">    listItemView.text.stringByTrimmingCharactersInSet(</span><br><span class="line">        <span class="type">NSCharacterSet</span>.whitespaceAndNewlineCharacterSet())</span><br></pre></td></tr></table></figure>
<p>这明显是一个 Objective-C 风格的函数调用。如果我们用 Swift 编写，结果看上去应该是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> content = </span><br><span class="line">    listItemView.text.trimming(.whitespaceAndNewlines)</span><br></pre></td></tr></table></figure>
<p>这显然是更遵循 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md" target="_blank" rel="noopener">Swift API 设计指南</a> 中的用法，特别是，我们忽略掉了那些编译器已经能强制约束我们使用的类型名称（例如：view，string, character set等）。这份提议的目的，就是让从 Objective-C 引入 API 更加 “Swift原汁原味” ，让 Swift 开发者在使用 Objective API 时，有和使用 Swift “原生代码”更为一致的开发体验。</p>
<p>这份提议中的解决方案对 Objective-C 框架（例如：Cocoa 和 Cocoa Touch）和任何可以在“Swift 混合项目”中使用的 Objective-C API 是相同的。要说明的是， <a href="https://swift.org/core-libraries/" target="_blank" rel="noopener">Swift 核心库</a> 重新实现了 Objective-C 框架中的 API，所以，对这些 API（名称的）的改动都会在 Swift 3 核心库的实现中体现出来。</p>
<h2 id="提议的解决方案"><a href="#提议的解决方案" class="headerlink" title="提议的解决方案"></a>提议的解决方案</h2><p>提议的解决方案引入了一种定义 Objective-C <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="noopener">Cocoa 编码指南</a> 和 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md" target="_blank" rel="noopener"> Swift API设计指南</a> 区别的方式，这种方式可以帮助我们通过设置一系列规则，参照 Cocoa 编码指南以及 Objective-C 中既定的习俗，把前者变换成后者。这是对用Clang importer进行名称翻译的一种启发式扩展。例如：把 Objective-C 中的全局 <code>enum</code> 常量变成 Swift 中的 cases（这要去掉 Objective-C 为全局enum常量名设置的前缀）以及把 Objective-C 中的工厂方法（例如：<code>+[NSNumber numberWithBool:]</code>）映射成 Swift 中的初始化方法（<code>NSNumber(bool: true)</code>）。</p>
<p>这份提议中描述的启发式方法需要通过覆盖大量的 Objective-C API 进行迭代、调校和试验，以确保它最终可以正常工作。但是，它仍旧是不可能完美工作的，一定会有一些 API ，经过 “翻译” 之后，会导致其不如原来表意清晰。因此，我们的目标是确保绝大多数的Objective C API都可以在翻译之后更加的 Swift 原汁原味。并且允许 Objective-C API 的作者对于那些不满意的翻译，在 Objective-C 头文件中，通过 API 注释说明问题。</p>
<p>这份提议的解决方案对 Clang importer 引入了以下这些改变：</p>
<ol>
<li><strong>泛化 <code>swift_name</code> 属性的应用范围</strong>：Clang 的 <code>swift_name</code> 现在只能用于重命名 <code>enum</code> 的 cases 以及工厂方法。当它被引入到Swift后，它应该被泛化成允许重命名任意的 C 或 Objective-C 的语言元素，以方便 C 或 Objective-C API 的作者更好的调校重命名的过程。</li>
<li><strong>去掉冗余的类型名称</strong>：Objective-C Cocoa 编码指南要求方法声明中要带有每一个参数的描述。当这个描述重申了参数的类型时，方法的名字就违背了 Swift 编码指南中关于“忽略不需要的字符”的设计要求。因此，执行翻译时，我们应该去掉那些描述类型的部分。</li>
<li><strong>添加默认参数</strong>：如果 Objective-C API 的声明强烈暗示参数需要参数默认值，应该为这样的 API 在引入 Swift 时，添加参数默认值。例如，一个表示选项集合的参数，可以被设置成[]。</li>
<li><strong>为第一个参数添加label</strong>：如果方法的第一个参数有默认值， <a href="https://swift.org/documentation/api-design-guidelines#first-argument-label" target="_blank" rel="noopener">应该为这个参数设置一个参数label</a> 。</li>
<li><strong>给Bool语义的属性添加“is”前缀</strong>：<a href="https://swift.org/documentation/api-design-guidelines#boolean-assertions" target="_blank" rel="noopener">Bool属性应该在读取的时候，表达断言的语义</a> ，但是 Objective-C Cocoa 编码指南中，<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE" target="_blank" rel="noopener">禁止在属性名中使用单词“is”</a> 。因此，当引入这样的属性时，为它们添加“is”前缀。</li>
<li><strong>表达值语义的名字，首字母小写</strong>：在 Swift API 设计指南中，要求对 “非类型声明（non-type declarations）” 使用小写字母。包括，<code>enum</code> 中的 <code>case</code> 以及属性或函数的声明。因此，引入Objective-C中没有前缀的值时，让这些名字的首字母小写（例如：一个叫做<code>URLHandler</code>的属性应该变成<code>urlHandler</code>）。</li>
<li><strong>让实现<code>compare(_:) -&gt; NSComparisonResult</code>的类遵从Comparable protocol</strong>：在 Objective-C 中，类对象的比较结果，都是通过“排序”的方式判断的（注：例如 <code>NSOrderedDescending</code> 和 <code>NSOrderedAscending</code> ）。导入过程中，通过让这些类遵从 <code>Comparable</code> protocol，可以让比较操作的实现更正规（注：通过<code>Comparable</code>提供的运算符方法）。</li>
</ol>
<p>为了感受下这些转换规则带来的实际效果，看下 <code>UIBezierPath</code> 从 Swift 2：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIBezierPath</span> : <span class="title">NSObject</span>, <span class="title">NSCopying</span>, <span class="title">NSCoding</span> </span>&#123;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(ovalInRect: <span class="type">CGRect</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">moveToPoint</span><span class="params">(<span class="number">_</span>: CGPoint)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addLineToPoint</span><span class="params">(<span class="number">_</span>: CGPoint)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addCurveToPoint</span><span class="params">(<span class="number">_</span>: CGPoint, </span></span></span><br><span class="line"><span class="function"><span class="params">        controlPoint1: CGPoint, controlPoint2: CGPoint)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addQuadCurveToPoint</span><span class="params">(<span class="number">_</span>: CGPoint, </span></span></span><br><span class="line"><span class="function"><span class="params">        controlPoint: CGPoint)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">appendPath</span><span class="params">(<span class="number">_</span>: UIBezierPath)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bezierPathByReversingPath</span><span class="params">()</span></span> -&gt; <span class="type">UIBezierPath</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">applyTransform</span><span class="params">(<span class="number">_</span>: CGAffineTransform)</span></span></span><br><span class="line">    <span class="keyword">var</span> empty: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">containsPoint</span><span class="params">(<span class="number">_</span>: CGPoint)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fillWithBlendMode</span><span class="params">(<span class="number">_</span>: CGBlendMode, alpha: CGFloat)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">strokeWithBlendMode</span><span class="params">(<span class="number">_</span>: CGBlendMode, alpha: CGFloat)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copyWithZone</span><span class="params">(<span class="number">_</span>: NSZone)</span></span> -&gt; <span class="type">AnyObject</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encodeWithCoder</span><span class="params">(<span class="number">_</span>: NSCoder)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移植到 Swift 3 后的变化：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIBezierPath</span> : <span class="title">NSObject</span>, <span class="title">NSCopying</span>, <span class="title">NSCoding</span> </span>&#123;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(ovalIn rect: <span class="type">CGRect</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(to point: CGPoint)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addLine</span><span class="params">(to point: CGPoint)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addCurve</span><span class="params">(to endPoint: CGPoint, </span></span></span><br><span class="line"><span class="function"><span class="params">        controlPoint1 controlPoint1: CGPoint, </span></span></span><br><span class="line"><span class="function"><span class="params">        controlPoint2 controlPoint2: CGPoint)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addQuadCurve</span><span class="params">(to endPoint: CGPoint, </span></span></span><br><span class="line"><span class="function"><span class="params">          controlPoint controlPoint: CGPoint)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> bezierPath: UIBezierPath)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reversing</span><span class="params">()</span></span> -&gt; <span class="type">UIBezierPath</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(<span class="number">_</span> transform: CGAffineTransform)</span></span></span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(<span class="number">_</span> point: CGPoint)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fill</span><span class="params">(<span class="number">_</span> blendMode: CGBlendMode, alpha alpha: CGFloat)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stroke</span><span class="params">(<span class="number">_</span> blendMode: CGBlendMode, alpha alpha: CGFloat)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(with zone: NSZone = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">AnyObject</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(with aCoder: NSCoder)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在 Swift 3 版本里，原来 API 里很多描述类型信息的部分都被去掉了。转换后的结果，更接近 Swift API 设计指南中的要求。现在，Swift 开发者可以通过类似 <code>foo.copy()</code> 这样的方式，拷贝任何遵从 <code>NSCopying</code> 的对象，而不用再像原来 <code>foo.copyWithZone(nil)</code> 这样的方式。</p>
<p><a name="implementation-experience"></a></p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>这份提议的一个试验性实现在 Swift main repository 中。Swift 编译器提供了一些开关帮助我们查看按照这份提议中的描述，被引入的 Objective-C API 以及 Swift 代码自身的转换结果（例如，通过 utils/omit-needless-words.py 脚本）。这些开关是：</p>
<ul>
<li><code>--enable-omit-needless-words</code>：这个开关启用了对 Clang importer 绝大多数的改动（上一节中提到的 1，2，4，5）。它主要适合用来打印在 Master 和 <a href="https://github.com/apple/swift/tree/swift-2.2-branch" target="_blank" rel="noopener">Swift 2.2 分支</a> 上，Swift 对Objective-C 模块提供的接口。在 <a href="https://github.com/apple/swift/tree/swift-3-api-guidelines" target="_blank" rel="noopener">Swift 3 API Guidelines分支</a> 上，它默认是开启的；</li>
<li><code>--enable-infer-default-arguments</code>：这个开关启用了 Clang importer 中，对参数默认值的干涉（上一节的 3）；</li>
<li><code>--swift-migration</code>：仅在 <a href="https://github.com/apple/swift/tree/swift-2.2-branch" target="_blank" rel="noopener">Swift 2.2 分支</a>上才有的开关，这个选项通过添加 “Fix-Its”，执行把名称从 Swift 2 迁移到 Swift 3 的基本转换。通过和其它编译器开关（例如：-fixit-code，-fixit-all）以及一个收集和应用 “Fix-Its” 的脚本（utils/apply-fixit-edits.py）一起使用，这个开关为我们提供的基础迁移工作可以帮助我们了解 Swift 代码在各种声明和调用场景里，按照这份提议被转换后的样子；</li>
</ul>
<p>为了使用转换后的名称，真正编译 Swift 3 代码，可以使用 <a href="https://github.com/apple/swift/tree/swift-3-api-guidelines" target="_blank" rel="noopener">Swift 3 API Guidelines</a> 分支。编译器默认启用了上述功能并带有随之一起改动的标准库。</p>
<h2 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h2><p>这部分描述了上述改变规则中第 2-5 条的试验性实现细节。真正的实现在 Swift 代码树中，主要是 <a href="https://github.com/apple/swift/blob/master/lib/Basic/StringExtras.cpp" target="_blank" rel="noopener">lib/Basic/StringExtras.cpp</a> 中的 <code>omitNeedlessWords</code> 函数。</p>
<p>接下来的描述，和参与名称翻译的 Objective-C API 紧密相关。例如：<code>startWithQueue:compeltionHandler:</code> 是个有两个selector 片段的方法，<code>startWithQueue</code> 和 <code>completionHandler</code>。这个 selector 翻译成 Swift 版本应该是<code>startWithQueue(_:completionHandler:)</code>。</p>
<h3 id="去掉冗余的名称"><a href="#去掉冗余的名称" class="headerlink" title="去掉冗余的名称"></a>去掉冗余的名称</h3><p>Objective-C API 中经常会包含参数或返回值的类型名称，它们应该在 Swift API 中统统被去掉。下面的这些规则，用于识别并且去掉这些表示类型名称的单词。[[详见 API 设计原则之忽略不需要的单词]]。</p>
<h4 id="定义类型名称"><a href="#定义类型名称" class="headerlink" title="定义类型名称"></a>定义类型名称</h4><p>匹配的过程是在老版本 Swift API 的 selector 片段里，搜索特定的<strong>类型名称</strong>后缀，这些类型名称定义如下：</p>
<ul>
<li>对于绝大部分 Objective-C 类型来说，类型名称就是忽略 <code>nullable</code> 之后，Swift 引入的名称，例如：</li>
</ul>
<table>
<thead>
<tr>
<th>Objective-C type</th>
<th>Type name</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>nullable NSString</td>
<td>String</td>
</tr>
<tr>
<td>UIDocument</td>
<td>UIDocument</td>
</tr>
<tr>
<td>nullable UIDocument</td>
<td>UIDocument</td>
</tr>
<tr>
<td>NSInteger</td>
<td>NSInteger</td>
</tr>
<tr>
<td>UIUInteger</td>
<td>NSUInteger</td>
</tr>
<tr>
<td>CGFloat</td>
<td>CGFloat</td>
</tr>
</tbody>
</table>
<ul>
<li>当 Objective-C 类型是一个 block 时，Swift 中的类型名称是 <code>Block</code>；</li>
<li>当 Objective-C 的类型是一个函数指针或引用时，Swift中的类型名称是 <code>Function</code>；</li>
<li>当 Objective-C 的类型是一个除 <code>NSInteger</code>、<code>NSUInteger</code> 或 <code>CGFloat</code> 之外的 typedef 时，Swift 中的类型名称则是这些typedef实际代表的类型的名称。例如，Objective-C 中的类型是 <code>UILayoutPriority</code>，实际上它是一个 <code>float</code> 类型的 typedef，我们将（在老版本的 Swift API 里）尝试匹配字符串 <code>Float</code>。[详见 API 设计原则之为弱类型提供信息补偿]。</li>
</ul>
<h4 id="匹配类型名称"><a href="#匹配类型名称" class="headerlink" title="匹配类型名称"></a>匹配类型名称</h4><p>为了在 selector 片段中删除冗余的类型信息，我们需要在 selector 中匹配包含上述类型信息的字符串。</p>
<p>全部匹配都是由以下两个基本规则来管理的：</p>
<ul>
<li><strong>在单词开始和结束的边界进行匹配</strong>：无论是 selector 片段内部，还是类型名称，单词边界位置都是一个字符串的开始或结束，以及每一个大写字母前面。把每一个大写字母作为单词边界可以让我们匹配到“大写字母缩略词”，而无需单独维护一个特殊的缩略词或前缀列表；</li>
</ul>
<p>例如，下面的 <code>URL</code> 是匹配的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">documentForURL</span><span class="params">(<span class="number">_</span>: NSURL)</span></span> -&gt; <span class="type">NSDocument</span>?</span><br></pre></td></tr></table></figure>
<p>但是，下面的 View，由于在单词中间，它是不能被匹配的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> thumbnailPreview : <span class="type">UIView</span>  <span class="comment">// not matched</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>匹配的字符扩展到类型名称的结尾</strong>：因为我们支持匹配一个类型名称的后缀，因此：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constraintEqualToAnchor</span><span class="params">(anchor: NSLayoutAnchor)</span></span> -&gt; <span class="type">NSLayoutConstraint</span>?</span><br></pre></td></tr></table></figure>
<p>可以被简化成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constraintEqualTo</span><span class="params">(anchor: NSLayoutAnchor)</span></span> -&gt; <span class="type">NSLayoutConstraint</span>?</span><br></pre></td></tr></table></figure>
<p>基于以上两个原则，我们可以执行以下一系列的匹配过程：</p>
<ul>
<li><p><strong>基本匹配</strong>：</p>
<ul>
<li>selector 片段中的字串匹配类型名称的字串，例如：<code>appendString</code> 中的 <code>String</code> 匹配 <code>NSString</code> 中的 <code>String</code>：<code>func appendString(_:  NSString)</code>；</li>
<li>Selector 片段中的 <code>Index</code> 匹配类型名称中的 <code>Int</code>，例如：<code>func characterAtIndex(_: Int) -&gt; unichar</code>；</li>
</ul>
</li>
<li><p><strong>集合相关匹配（Collection matches）</strong>：</p>
<ul>
<li>Selector 片段中的 <code>Indexes</code> 或 <code>Indices</code> 匹配类型名称中的 <code>IndexSet</code>，例如：<code>func removeObjectsAtIndexes(_: NSIndexSet)</code>；</li>
<li>如果 selector 片段中的复数名词的单数形式匹配集合中元素的类型，那么 selector 中的复数名词匹配集合类型名称，例如：<code>func arrangeObjects(_: [AnyObject]) -&gt; [AnyObject]</code></li>
</ul>
</li>
</ul>
<p><strong>特殊后缀匹配</strong>：</p>
<ul>
<li>在 selector 片段中，用一个空字符串后缀匹配类型名称中的 <code>Type</code> 或 <code>_t</code>，例如：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注：用一个空字符串匹配到了Type，因此SaveOperation加上</span></span><br><span class="line"><span class="comment">// 空字符串就匹配了SaveOperationType，</span></span><br><span class="line"><span class="comment">// 于是Selector中的SaveOperation的部分就可以删除了。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writableTypesForSaveOperation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span>: NSSaveOperationType)</span></span> -&gt; [<span class="type">String</span>]</span><br><span class="line"><span class="comment">// 注：用一个空字符串匹配到了Type。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">objectForKey</span><span class="params">(<span class="number">_</span>: KeyType)</span></span> -&gt; <span class="type">AnyObject</span></span><br><span class="line"><span class="comment">// 注：用一个空字符串匹配到了_t。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startWithQueue</span><span class="params">(<span class="number">_</span>: dispatch_queue_t, </span></span></span><br><span class="line"><span class="function"><span class="params">    completionHandler: MKMapSnapshotCompletionhandler)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>selector片段中的空字符串可以匹配类型名称中“数字+D”形式的后缀，例如：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Coordinate+空字符串匹配到了2D</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pointForCoordinate</span><span class="params">(<span class="number">_</span>: CLLocationCoordinate2D)</span></span> -&gt; <span class="type">NSPoint</span></span><br></pre></td></tr></table></figure>
<p><a name="pruning-restrictions"></a></p>
<h4 id="名称限制约束"><a href="#名称限制约束" class="headerlink" title="名称限制约束"></a>名称限制约束</h4><p><strong>(译者注：删除类型名称时的限制)</strong></p>
<p>如果在删除 selector 名称时违背了以下任何限制，那么删除行为将不会进行：</p>
<ul>
<li><strong>不要删光所有的 selector</strong>；</li>
<li><strong>不要把 selector 的第一个片段转换成 Swift 关键字</strong>：</li>
</ul>
<p>在 Swift 里，Objective-C 方法中的第一个 selector 片段会变成<strong>构建一个方法名称的基础</strong>或者<strong>一个属性的名字</strong>。</p>
<p>它们之中的任何一种，都不能是 Swift 关键字，否则，用户就需要使用反引号来使用它们。</p>
<p>例如，下面的用法是合理的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSParagraphStyle</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultParagraphStyle</span>() -&gt; <span class="title">NSParagraphStyle</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"><span class="title">let</span> <span class="title">defaultStyle</span> = </span></span><br><span class="line"><span class="class">    <span class="title">NSParagraphStyle</span>.<span class="title">defaultParagraphStyle</span>()  // <span class="title">OK</span></span></span><br></pre></td></tr></table></figure>
<p>如果我们删掉 <code>ParagraphStyle</code>，用起来就会很糟糕：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSParagraphStyle</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> `<span class="title">default</span>`() -&gt; <span class="title">NSParagraphStyle</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"><span class="title">let</span> <span class="title">defaultStyle</span> = </span></span><br><span class="line"><span class="class">    <span class="title">NSParagraphStyle</span>.`<span class="title">default</span>`()    // <span class="title">Awkward</span></span></span><br></pre></td></tr></table></figure>
<p>Objective-C方法名中的其它selector片段，会变成Swift方法的参数label，这个label是允许使用Swift关键字的，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">receiver.handle(someMessage, <span class="keyword">for</span>: somebody)  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>不要把方法名称转换成 “get”，“Set”，“with”, “for” 或 “using”</strong>，用这些单词形成的方法名称表意非常空洞；</li>
<li><strong>不要删除方法名称中那些介绍参数的后缀，除非这个后缀前面直接连接一个介词、动词或动名词</strong>：</li>
</ul>
<p>这种启发式转换帮助我们避免破坏那些介绍参数的名词短语。直接删掉名词短语后缀通常不会带来我们预期的表意结果。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setTextColor</span><span class="params">(<span class="number">_</span>: UIColor)</span></span></span><br><span class="line">...</span><br><span class="line">button.setTextColor(.red())  <span class="comment">// clear</span></span><br></pre></td></tr></table></figure>
<p>如果我们删掉方法名中的<code>Color</code>，只剩下<code>Text</code>，调用方法时表达的语意就会让人困惑：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setText</span><span class="params">(<span class="number">_</span>: UIColor)</span></span></span><br><span class="line">...</span><br><span class="line">button.setText(.red())      <span class="comment">// appears to be setting the text!</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>如果方法的名字匹配它所在的类型中的一个属性，不要转换方法名</strong>：</li>
</ul>
<p>这种启发式转换使我们可以避免让那些修改类属性的方法转换出过于泛泛的名字，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gestureRecognizers: [<span class="type">UIGestureRecognizer</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addGestureRecognizer</span><span class="params">(<span class="number">_</span>: UIGestureRecognizer)</span></span></span><br></pre></td></tr></table></figure>
<p>如果我们删掉方法中的 <code>GestureRecognizer</code>，只留下 <code>add</code>，对于一个实际上是在修改 <code>gesturerecognizers</code> 属性的方法来说，这个名字明显太泛泛了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gestureRecognizers: [<span class="type">UIGestureRecognizer</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span>: UIGestureRecognizer)</span></span> <span class="comment">// should indicate that we're adding to the property</span></span><br></pre></td></tr></table></figure>
<h4 id="删除类型名称的步骤"><a href="#删除类型名称的步骤" class="headerlink" title="删除类型名称的步骤"></a>删除类型名称的步骤</h4><p>我们按照下面的步骤删除冗余的名字：</p>
<ol>
<li><p><strong>删除头部的结果类型信息</strong>。特别是，当以下情形的时候：</p>
<ul>
<li>当方法返回一个自身所在的类型时；</li>
<li>并且这个类型的名称匹配方法中第一个 selector 片段；</li>
<li>匹配到的名词后面，紧跟一个介词；</li>
</ul>
</li>
</ol>
<p>就可以删除掉这个匹配。</p>
<p>通常，匹配以上这些条件的属性和方法，它们都用于把自身类型变成其它某种等价形式的值。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSColor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">colorWithAlphaComponent</span><span class="params">(<span class="number">_</span>: CGFloat)</span></span> -&gt; <span class="type">NSColor</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> translucentForeground = </span><br><span class="line">    foregroundColor.colorWithAlphaComponent(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>可以被简化成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSColor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">withAlphaComponent</span><span class="params">(<span class="number">_</span>: CGFloat)</span></span> -&gt; <span class="type">NSColor</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> translucentForeground = </span><br><span class="line">    foregroundColor.withAlphaComponent(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p><strong>删掉多余的介词By</strong>。特别是，当以下情形的时候：</p>
<ul>
<li>在第一步中删掉了开始的名词之后；</li>
<li>方法名称中，剩余的部分用 <code>By</code> +动名词的形式；</li>
</ul>
</li>
</ol>
<p>就可以删掉多余的 <code>By</code> 了。</p>
<p>这种启发式方法可以让我们使用类似<code>a = b.frobnicating(c)</code>的方法调用形式。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stringByApplyingTransform</span><span class="params">(<span class="number">_</span>: NSString, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">reverse</span>: Bool)</span></span> -&gt; <span class="type">NSString</span>?</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sanitizedInput = </span><br><span class="line">    rawInput.stringByApplyingTransform(</span><br><span class="line">        <span class="type">NSStringTransformToXMLHex</span>, <span class="built_in">reverse</span>: <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>就可以通过第一步和第二步，被简化成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">applyingTransform</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span>: NSString, <span class="built_in">reverse</span>: Bool</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> -&gt; <span class="type">NString</span>?</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> sanitizedInput = </span><br><span class="line">    rawInput.applyingTransform(<span class="type">NSStringTransformToXMLHex</span>, </span><br><span class="line">        <span class="built_in">reverse</span>: <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>在方法签名的最后一个 selector 片段中，删除任何匹配到的类型名称</strong>。特别是以下类型：</li>
</ol>
<table>
<thead>
<tr>
<th>方法名称的尾部是</th>
<th>删除匹配到的</th>
</tr>
</thead>
<tbody>
<tr>
<td>用于介绍参数的selector片段</td>
<td>参数类型名称</td>
</tr>
<tr>
<td>一个属性名称</td>
<td>属性的类型名称</td>
</tr>
<tr>
<td>一个不带参数的方法</td>
<td>返回值的类型名称</td>
</tr>
</tbody>
</table>
<p>例如，下面这些情况：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSDocumentController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentForURL</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span> url: NSURL)</span></span> -&gt; <span class="type">NSDocument</span>? <span class="comment">// parameter introducer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSManagedObjectContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parentContext: <span class="type">NSManagedObjectContext</span>?  <span class="comment">// property</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">darkGrayColor</span>() -&gt; <span class="title">UIColor</span>  // <span class="title">zero</span>-<span class="title">argument</span> <span class="title">method</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">...</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">myDocument</span> = <span class="title">self</span>.<span class="title">documentForURL</span>(<span class="title">locationOfFile</span>)</span></span><br><span class="line"><span class="class"><span class="title">if</span> <span class="title">self</span>.<span class="title">managedObjectContext</span>.<span class="title">parentContext</span> != <span class="title">changedContext</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">foregroundColor = .darkGrayColor()</span><br></pre></td></tr></table></figure>
<p>可以被简化成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSDocumentController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">documentFor</span><span class="params">(<span class="number">_</span> url: NSURL)</span></span> -&gt; <span class="type">NSDocument</span>?</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSManagedObjectContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parent : <span class="type">NSManagedObjectContext</span>?</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">darkGray</span>() -&gt; <span class="title">UIColor</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">...</span></span><br><span class="line"><span class="class"><span class="title">myDocument</span> = <span class="title">self</span>.<span class="title">documentFor</span>(<span class="title">locationOfFile</span>)</span></span><br><span class="line"><span class="class"><span class="title">if</span> <span class="title">self</span>.<span class="title">managedObjectContext</span>.<span class="title">parent</span> != <span class="title">changedContext</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line">foregroundColor = .darkGray()</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>只要匹配到的类型名称前面直接连接动词，即便这个类型名称在方法名中间也可以删掉它</strong>，例如：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dismissViewControllerAnimated</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        flag: Bool, </span></span></span><br><span class="line"><span class="function"><span class="params">        completion: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以被简化成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dismissAnimated</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        flag: Bool, </span></span></span><br><span class="line"><span class="function"><span class="params">        completion: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="为什么删除一定要按照顺序执行呢？"><a href="#为什么删除一定要按照顺序执行呢？" class="headerlink" title="为什么删除一定要按照顺序执行呢？"></a>为什么删除一定要按照顺序执行呢？</h5><p>下面的简化过程有些在方法名称的第一个selector片段中匹配，有些在方法名称的结尾匹配。当<a href="#pruning-restrictions">名称限制约束</a>阻止我们从开始和结尾进行删除时，从头部开始删除名称可以保持方法家族的一致性，例如，对于 <code>NSFontDescriptor</code> 来说：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fontDescriptorWithSymbolicTraits</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span>: NSFontSymbolicTraits)</span></span> -&gt; <span class="type">NSFontDescriptor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fontDescriptorWithSize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span>: CGFloat)</span></span> -&gt; <span class="type">UIFontDescriptor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fontDescriptorWithMatrix</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span>: CGAffineTransform)</span></span> -&gt;  <span class="type">UIFontDescriptor</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>按照头部匹配规则，它们可以变成这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withSymbolicTraits</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span>: UIFontDescriptorSymbolicTraits)</span></span> -&gt;  <span class="type">UIFontDescriptor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withSize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span>: CGFloat)</span></span> -&gt; <span class="type">UIFontDescriptor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withMatrix</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span>: CGAffineTransform)</span></span> -&gt; <span class="type">UIFontDescriptor</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果我们坚持从尾部进行删除，删掉第一个方法中的 <code>SymbolicTraits</code> 之后，我们就无法再继续删除头部的 <code>fontDescriptor</code> 了，因为这违背了我们在<a href="#pruning-restrictions">名称限制约束</a>中定义的原则，只留下一个 <code>with</code> 表意是不够的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fontDescriptorWith</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span>: NSFontSymbolicTraits)</span></span> -&gt; <span class="type">NSFontDescriptor</span> <span class="comment">// inconsistent</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withSize</span><span class="params">(<span class="number">_</span>: CGFloat)</span></span> -&gt; <span class="type">UIFontDescriptor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withMatrix</span><span class="params">(<span class="number">_</span>: CGAffineTransform)</span></span> -&gt; <span class="type">UIFontDescriptor</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：这样一来，我们就破坏了原来家族方法的名称一致性。</p>
</blockquote>
<h4 id="添加参数默认值"><a href="#添加参数默认值" class="headerlink" title="添加参数默认值"></a>添加参数默认值</h4><p>除了那些只有一个参数的 setter 方法之外，在以下情况时，应该给参数添加默认值：</p>
<ul>
<li>让<strong>可以为空的 trailing closure 参数</strong>值为<code>nil</code>；</li>
<li>让<strong>可以为空的 <code>NSZone</code> 参数</strong>默认为 <code>nil</code>。Zones几乎不在Swift中使用，它们应该总是为 <code>nil</code> 的；</li>
<li>让<strong>参数名中带有 “Options” 字样的参数</strong>值默认为 <code>[]</code>，表示空的选项集合；</li>
<li>和选项、属性或信息有关的 NSDictionary 参数，默认值为<code>[:]</code>；</li>
</ul>
<p>把这些规则集合起来，这个启发式方法可以把下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">rootViewController.presentViewController(</span><br><span class="line">     alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.2</span>, delay: <span class="number">0.0</span>, </span><br><span class="line">    options: [], </span><br><span class="line">    animations: &#123; <span class="keyword">self</span>.logo.alpha = <span class="number">0.0</span> &#125;) &#123;</span><br><span class="line">    <span class="number">_</span> <span class="keyword">in</span> <span class="keyword">self</span>.logo.hidden = <span class="literal">true</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变成这个样子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">rootViewController.present(alert, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.2</span>, delay: <span class="number">0.0</span>, </span><br><span class="line">    animations: &#123; <span class="keyword">self</span>.logo.alpha = <span class="number">0.0</span> &#125;) &#123; </span><br><span class="line">    <span class="number">_</span> <span class="keyword">in</span> <span class="keyword">self</span>.logo.hidden = <span class="literal">true</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为第一个参数添加label"><a href="#为第一个参数添加label" class="headerlink" title="为第一个参数添加label"></a>为第一个参数添加label</h4><p>如果方法名称中第一个 selector 片段中包含一个介词，<strong>就把这个 selector 片段从最后一个介词处分开</strong>，把这个 selector 中，这个介词后面的部分变成第一个参数的 label。</p>
<p>除了为大量 API 的第一个参数添加 label 之外，当第一个参数有默认值时，这种启发式方法还能消除方法被调用时，方法名称表达的模糊语义。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIBezierPath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">enumerateObjectsWith</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span>: NSEnumerationOptions = [], </span></span></span><br><span class="line"><span class="function"><span class="params">        using: <span class="params">(AnyObject, UnsafeMutablePointer)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array.enumerateObjectsWith(.<span class="type">Reverse</span>) &#123; <span class="comment">// OK</span></span><br><span class="line">   <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array.enumerateObjectsWith() &#123; <span class="comment">// ?? With what?</span></span><br><span class="line">   <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">enumerateObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      options <span class="number">_</span>: NSEnumerationOptions = [], </span></span></span><br><span class="line"><span class="function"><span class="params">      using: <span class="params">(AnyObject, UnsafeMutablePointer)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array.enumerateObjects(options: .<span class="type">Reverse</span>) &#123; <span class="comment">// OK</span></span><br><span class="line">   <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array.enumerateObjects() &#123; <span class="comment">// OK</span></span><br><span class="line">   <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为-Bool-语义的属性添加-“is”-前缀"><a href="#为-Bool-语义的属性添加-“is”-前缀" class="headerlink" title="为 Bool 语义的属性添加 “is” 前缀"></a>为 Bool 语义的属性添加 “is” 前缀</h4><p>在 Objective-C 里，表达 Bool 语义的属性，使用对应的 getter 方法作为这个属性在 Swift 中的名字。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface NSBezierPath : NSObject</span><br><span class="line">@property (readonly,getter=isEmpty) BOOL empty;</span><br></pre></td></tr></table></figure>
<p>会变成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSBezierPath</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isEmpty: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> path.isEmpty &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现比较方法时遵从的准则"><a href="#实现比较方法时遵从的准则" class="headerlink" title="实现比较方法时遵从的准则"></a>实现比较方法时遵从的准则</h3><p>现如今，为了实现对象比较，例如对 <code>NSDate</code> 来说，开发者经常会扩展 <code>NSDate</code> 让它遵从 <code>Comparable</code> 或使用 <code>NSDate</code> 的<code>compare(_:) -&gt; NSComparisonResult</code> 方法。在这些场景里，对 <code>NSDate</code> 使用表操作符会有效提高代码可读性，例如 <code>someDate &lt; today</code> 要比 <code>someDate.comare(today) == .OrderedAscending</code> 要清晰的多。由于转换过程可以确定一个类是否实现了 Objective-C 中的比较方法，所有实现了这个方法的类都可以按照遵从 <code>Comparable</code> protocol 的方式引入。</p>
<p>不仅仅是 <code>NSDate</code>，Foundation 中的一些其它类也会被这个改变影响，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(other: NSDate)</span></span> -&gt; <span class="type">NSComparisonResult</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(decimalNumber: NSNumber)</span></span> -&gt; <span class="type">NSComparisonResult</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(otherObject: NSIndexPath)</span></span> -&gt; <span class="type">NSComparisonResult</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(string: String)</span></span> -&gt; <span class="type">NSComparisonResult</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(otherNumber: NSNumber)</span></span> -&gt; <span class="type">NSComparisonResult</span></span><br></pre></td></tr></table></figure>
<h3 id="对已有代码的影响"><a href="#对已有代码的影响" class="headerlink" title="对已有代码的影响"></a>对已有代码的影响</h3><p>这份提议中的改变为使用 Objective-C 框架的已有的 Swift 代码引入了大量破坏性改变（breaking change）。以至于，我们需要一个迁移工具把 Swift 2 代码迁移到 Swift 3。在<a href="#implementation-experience">实现过程</a>中描述的 <code>-swift3-migration</code> 开关为这样的转换工具提供了基本信息。另外，编译器需要为那些引用了旧版本 Objective-C 名称的Swift代码提供良好的错误信息（带有修改建议），除此之外，还应该提供一个辅助的通过旧版本名称进行查询的机制。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>为了最终形成 <a href="https://swift.org/documentation/api-design-guidelines" target="_blank" rel="noopener">Swift API 设计指南</a> ，这份自动名称转换提议由Dmitri Hrybenko, Ted Kremenek, Chris Lattner, Alex Migicovsky, Max Moiseev, Ali Ozer和Tony Parker开发。</p>
<p>补充添加进来的comparable部分之前由 <a href="https://github.com/chrisamanse" target="_blank" rel="noopener">Chris Amanse</a> 提交到了 <a href="https://swift.org/core-libraries/" target="_blank" rel="noopener">core-libraries</a> 邮件列表中。Philippe Hausler 进行 review 之后，添加到了这份提议中。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/投稿/">投稿</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Swift-进化/">Swift 进化</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://swift.gg/2016/06/20/SE-0005-better-translation-of-objective-c-api-into-swift/" data-title="SE-0005 更好的把 Objective-C APIs 转换成 Swift 版本 | SwiftGG" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/06/21/dear-erica-whats-the-biggest-and-best-swift-3-change/" title="亲爱的 Erica：Swift 3 有哪些最重大最出色的改变？">
  <strong>上一篇</strong><br/>
  <span>
  亲爱的 Erica：Swift 3 有哪些最重大最出色的改变？</span>
</a>
</div>


<div class="next">
<a href="/2016/06/17/when-to-use-mutating-functions-in-swift-structs/"  title="Swift 结构体何时使用 mutating 函数">
 <strong>下一篇</strong><br/> 
 <span>Swift 结构体何时使用 mutating 函数
</span>
</a>
</div>

</nav>

	


<section id="comments" class="comment">
  <div id="gitcomment">
  </div>
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
    var gitment = new Gitment({
      id: "2016/06/20/SE-0005-better-translation-of-objective-c-api-into-swift/",
      owner: "SwiftGGBot",
      repo: "gg-comment",
      oauth: {
        client_id: "8ed6aa0071e9d92f7ffc",
        client_secret: "29cc2c70290fad40a967780e5b49d86501348ddf",
      },
    })
    gitment.render('gitcomment')
    </script>
</section>



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#提交-review-前必读"><span class="toc-number">1.</span> <span class="toc-text">提交 review 前必读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动机"><span class="toc-number">3.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提议的解决方案"><span class="toc-number">4.</span> <span class="toc-text">提议的解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现过程"><span class="toc-number">5.</span> <span class="toc-text">实现过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计细节"><span class="toc-number">6.</span> <span class="toc-text">设计细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#去掉冗余的名称"><span class="toc-number">6.1.</span> <span class="toc-text">去掉冗余的名称</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义类型名称"><span class="toc-number">6.1.1.</span> <span class="toc-text">定义类型名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#匹配类型名称"><span class="toc-number">6.1.2.</span> <span class="toc-text">匹配类型名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#名称限制约束"><span class="toc-number">6.1.3.</span> <span class="toc-text">名称限制约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除类型名称的步骤"><span class="toc-number">6.1.4.</span> <span class="toc-text">删除类型名称的步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么删除一定要按照顺序执行呢？"><span class="toc-number">6.1.4.1.</span> <span class="toc-text">为什么删除一定要按照顺序执行呢？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#添加参数默认值"><span class="toc-number">6.1.5.</span> <span class="toc-text">添加参数默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为第一个参数添加label"><span class="toc-number">6.1.6.</span> <span class="toc-text">为第一个参数添加label</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为-Bool-语义的属性添加-“is”-前缀"><span class="toc-number">6.1.7.</span> <span class="toc-text">为 Bool 语义的属性添加 “is” 前缀</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现比较方法时遵从的准则"><span class="toc-number">6.2.</span> <span class="toc-text">实现比较方法时遵从的准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对已有代码的影响"><span class="toc-number">6.3.</span> <span class="toc-text">对已有代码的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#声明"><span class="toc-number">6.4.</span> <span class="toc-text">声明</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/APPVENTURE/" title="APPVENTURE">APPVENTURE<sup>13</sup></a></li>
		  
		
		  
			<li><a href="/categories/Andyy-Hope/" title="Andyy Hope">Andyy Hope<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/AppCoda/" title="AppCoda">AppCoda<sup>43</sup></a></li>
		  
		
		  
			<li><a href="/categories/Arthur-Knopper/" title="Arthur Knopper">Arthur Knopper<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Big-O-Note-Taking/" title="Big O Note-Taking">Big O Note-Taking<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Coding-Explorer-Blog/" title="Coding Explorer Blog">Coding Explorer Blog<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Crunchy-Development/" title="Crunchy Development">Crunchy Development<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/Erica-Sadun/" title="Erica Sadun">Erica Sadun<sup>67</sup></a></li>
		  
		
		  
			<li><a href="/categories/IOSCREATOR/" title="IOSCREATOR">IOSCREATOR<sup>29</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jacob-Bandes-Storch/" title="Jacob Bandes-Storch">Jacob Bandes-Storch<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jameson-Quave/" title="Jameson Quave">Jameson Quave<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/JamesonQuave-com/" title="JamesonQuave.com">JamesonQuave.com<sup>18</sup></a></li>
		  
		
		  
			<li><a href="/categories/Jesse-Squires/" title="Jesse Squires">Jesse Squires<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/KHANLOU/" title="KHANLOU">KHANLOU<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mike-Ash/" title="Mike Ash">Mike Ash<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift/NSHipster/" title="NSHipster">NSHipster<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/NSHipster/" title="NSHipster">NSHipster<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Natasha-The-Robot/" title="Natasha The Robot">Natasha The Robot<sup>48</sup></a></li>
		  
		
		  
			<li><a href="/categories/Ole-Begemann/" title="Ole Begemann">Ole Begemann<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/Ole-Begemannh/" title="Ole Begemannh">Ole Begemannh<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Open-Source-Swift/" title="Open Source Swift">Open Source Swift<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/Raj-Kandathi/" title="Raj Kandathi">Raj Kandathi<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Reinder-de-Vries/" title="Reinder de Vries">Reinder de Vries<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Russ-Bishop/" title="Russ Bishop">Russ Bishop<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Soroush-Khanlou/" title="Soroush Khanlou">Soroush Khanlou<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mike-Ash/Swift/" title="Swift">Swift<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift/" title="Swift">Swift<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift-and-Painless/" title="Swift and Painless">Swift and Painless<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/Swift-入门/" title="Swift 入门">Swift 入门<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Swift-进阶/" title="Swift 进阶">Swift 进阶<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Think-and-Build/" title="Think and Build">Think and Build<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Thomas-Hanning/" title="Thomas Hanning">Thomas Hanning<sup>22</sup></a></li>
		  
		
		  
			<li><a href="/categories/Thoughtbot/" title="Thoughtbot">Thoughtbot<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tomasz-Szulc/" title="Tomasz Szulc">Tomasz Szulc<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/Wooji-Juice/" title="Wooji Juice">Wooji Juice<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/alisoftware/" title="alisoftware">alisoftware<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/alloc-init/" title="alloc-init">alloc-init<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/codingexplorer/" title="codingexplorer">codingexplorer<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iAchieved-it/" title="iAchieved.it">iAchieved.it<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开发/" title="iOS 开发">iOS 开发<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/iOS-开发/" title="iOS 开发">iOS 开发<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/khanlou-com/" title="khanlou.com">khanlou.com<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/machinethink/" title="machinethink">machinethink<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/medium-com/" title="medium.com">medium.com<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/mikeash-com/" title="mikeash.com">mikeash.com<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/radex-io/" title="radex.io">radex.io<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/swift-org/" title="swift.org">swift.org<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/swiftandpainless/" title="swiftandpainless">swiftandpainless<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/uraimo/" title="uraimo">uraimo<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/原创文章/" title="原创文章">原创文章<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/投稿/" title="投稿">投稿<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播资源/" title="直播资源">直播资源<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/社区问答/" title="社区问答">社区问答<sup>19</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Swift-进阶/" title="Swift 进阶">Swift 进阶<sup>169</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-入门/" title="Swift 入门">Swift 入门<sup>130</sup></a></li>
			
		
			
				<li><a href="/tags/Swift/" title="Swift">Swift<sup>90</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-开发/" title="iOS 开发">iOS 开发<sup>83</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-跨平台/" title="Swift 跨平台">Swift 跨平台<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-开源信息/" title="Swift 开源信息">Swift 开源信息<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/WatchOS-2/" title="WatchOS 2">WatchOS 2<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-3/" title="Swift 3">Swift 3<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-入门/" title="iOS 入门">iOS 入门<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Apple-TV-开发/" title="Apple TV 开发">Apple TV 开发<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Xcode/" title="Xcode">Xcode<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-9/" title="iOS 9">iOS 9<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/IOSCREATOR/" title="IOSCREATOR">IOSCREATOR<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/社区问答/" title="社区问答">社区问答<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/NSHipster/" title="NSHipster">NSHipster<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/教程/" title="教程">教程<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Jesse-Squires/" title="Jesse Squires">Jesse Squires<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-2/" title="Swift 2">Swift 2<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Swift-进化/" title="Swift 进化">Swift 进化<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/机器学习/" title="机器学习">机器学习<sup>2</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://c4ios.swift.gg" target="_blank" title="C4iOS 教程">C4iOS 教程</a>
            
          </li>
        
          <li>
            
            	<a href="http://swift.gg/2016/03/14/live-video/" target="_blank" title="SwiftGG直播">SwiftGG直播</a>
            
          </li>
        
          <li>
            
            	<a href="http://t.swift.gg/" target="_blank" title="T 沙龙">T 沙龙</a>
            
          </li>
        
          <li>
            
            	<a href="http://codebuild.me" target="_blank" title="Code Build Me">Code Build Me</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.saitjr.com" target="_blank" title="//TODO:">//TODO:</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.5isjyx.com/" target="_blank" title="chiba">chiba</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.cee.moe" target="_blank" title="Perfect Freeze">Perfect Freeze</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftyper.com" target="_blank" title="小锅的 swift 之路">小锅的 swift 之路</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.futantan.com/" target="_blank" title="Prayer 的博客">Prayer 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.csdn.net/mmoaay" target="_blank" title="画渣程序猿 mmoaay">画渣程序猿 mmoaay</a>
            
          </li>
        
          <li>
            
            	<a href="http://linusling.com" target="_blank" title="小铁匠的 swift 之路">小铁匠的 swift 之路</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" title="ppppppmst 的简书博客">ppppppmst 的简书博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://chenmingbiao.github.io/" target="_blank" title="CMB 的博客">CMB 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://wxgbridgeq.github.io/" target="_blank" title="BridgeQ">BridgeQ</a>
            
          </li>
        
          <li>
            
            	<a href="http://chengway.in" target="_blank" title="walkingway 的博客">walkingway 的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.dianqk.org" target="_blank" title="靛青K">靛青K</a>
            
          </li>
        
          <li>
            
            	<a href="http://ijack.pw/" target="_blank" title="JackAlan">JackAlan</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftconchina.com" target="_blank" title="SwiftConChina">SwiftConChina</a>
            
          </li>
        
          <li>
            
            	<a href="http://swiftcn.io" target="_blank" title="Swift 中国">Swift 中国</a>
            
          </li>
        
          <li>
            
            	<a href="https://boxueio.com/" target="_blank" title="泊学">泊学</a>
            
          </li>
        
          <li>
            
            	<a href="https://bearychat.com/" target="_blank" title="BearyChat">BearyChat</a>
            
          </li>
        
          <li>
            
            	<a href="http://bbs.php-z.com" target="_blank" title="PHP-Z 论坛">PHP-Z 论坛</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.swiftguide.cn" target="_blank" title="官方文档">官方文档</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.upyun.com/" target="_blank" title="又拍云赞助图床">又拍云赞助图床</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="wechatpart">
	<p class="asidetitle">微信公众号</p>
	<img src="/img/wechat.jpg" />
</div>

</aside>
</div>
    </div>
    <footer>


<div id="footer" >
	
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="SwiftGG">SwiftGG</a>
		
		 | 
		<a href="http://www.miitbeian.gov.cn" target="_blank">浙ICP备14022870号-3</a>
		</p>
</div>
<img src="/img/logo_new.jpg" style="position: fixed; top: -9999px;height: 500px;width: 500px;">
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script src="/js/mm.js"></script>
<script src="/js/subscribe.js"></script>

<div id="swiftweekly" style="display:none;">
  <img id="closeme" src="/img/close.png">
  <span id="sw_slogan">SwiftGG 专属 Reveal 优惠：<b><a style="color: white;text-decoration:underline;" target="_blank" href="https://j.youzan.com/XzKhGY">领取立减 143 元！</a></b>&nbsp;</span>
  <!-- <form id="content"> -->
    <!-- <input name="email" id="sw_email" placeholder="输入邮箱地址" type="email" /><a class="sw_sub">订阅</a> -->
  <!-- </form> -->
</div>

<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<script type="text/javascript">
$(document).ready(function(){

  

  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66150920-1', 'auto');
  ga('send', 'pageview');

</script>





<!-- Analytics End -->

<!-- Totop Begin -->
<!--
	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>
-->
<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
